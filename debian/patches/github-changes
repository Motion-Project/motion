Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 motion (3.2.12-4ppa01) trusty; urgency=low
 .
    * Nonmaintainer upload
    * Due to conficts, removed patches (Mr Dave)
    * Revise motion.postinst to put motion.conf at 0644 instead of 0640(Mr Dave)
    * Many many changes from github repos of many many developers since 3.2.12 was released.
    *
    * Features
    * Insert Blanking frames http://www.lavrsen.dk/twiki/bin/view/Motion/FeatureRequest2007x12x16x132522 (Dag Erlandsson)
    * IPV6 for http-control and webcam stream not netcam yet http://www.lavrsen.dk/twiki/bin/view/Motion/IPv6
      (Jeroen Massar & Angel Carpintero)
    * Experimental approach for MJPEG streams (Motion JPEG) for network cameras
      http://www.lavrsen.dk/twiki/bin/view/Motion/LinksysWVC200SupportPatch ( ... )
    * Add draw a RED box around the movement as default (Joerg Weber)
    * Add write/read nonblock functions in webhttpd( timeout on read/write). (Angel Carpintero)
    * More changes in option names from http://www.lavrsen.dk/twiki/bin/view/Motion/IntuitiveOptionNamesDiscussion
      (Angel Carpintero)
    * motion_locate new parameter names : red , center , redcross  instead of only on, off. (Angel Carpintero)
    * External pipe to allow external video encoders
      http://www.lavrsen.dk/twiki/bin/view/Motion/DarkwindHackeronMotionPatching (Bill Payne, Angel Carpintero)
    * Split locate_motion into separate 'mode' and 'style' option to allow all
      possible combinations. (Joerg Weber)
    * Implement 'gapless' event mode to allow for recording of movies without 'holes'. (Joerg Weber)
    * Limit detection rate to 3fps at framerates above 5fps, to reduce CPU load. (Joerg Weber)
    * Fix warning for syslog() , Added support for some new bayer palettes introduced in kernel 2.6.27.
      http://www.lavrsen.dk/twiki/bin/view/Motion/FeatureRequest2008x10x15x130110
      Increased buffer in ffmpeg to allow encoding at 1600x1200 (Angel Carpintero)
    * Sqlite3 support http://www.lavrsen.dk/twiki/bin/view/Motion/SQLite3Patch (Giacomo Graziosi)
    * New RPM SPEC file and startup scripts compliant with Fedora 10 guidelines and above (Steven Moix)
    * Increase write buffer size for writing image files and ffmpegs
      http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionWriteBuffersPatch (Craig West)
    * Fixed mask overlay in setup mode is now green instead of white (Joerg Weber)
    * Add new config option 'ipv6_enabled' to enable/disable IPV6 (Angel Carpintero)
    * Remove VIDIOC_S_JPEGCOMP support is deprecated. (Angel Carpintero)
    * Use static memory allocation in ffmpeg_deinterlace() (Peter Holik)
      http://www.lavrsen.dk/foswiki/bin/view/Motion/FfmpegDeinterlaceStatic
    * Atom optimizacion in configure.in (Peter Holik)
      http://www.lavrsen.dk/foswiki/bin/view/Motion/AtomOptimizations
    * Allow to change Standard method ( PAL / NECAM / SECAM ) (Angel Carpintero)
    * Add authentication  methods 'Basic Authentication' and 'Digest Authentication'
      to the "Live Stream Server". (Michael Finsterbusch)
      http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionStreamAuthPatch
    * Implemented new logging system
      http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionLog (Angel Carpintero)
    * Added a macro MOTION_LOG , no need to add __FUNCTION__ anymore. (Angel Carpintero)
    * Added EXIF feature for jpeg images , http://www.lavrsen.dk/foswiki/bin/view/Motion/ExifTaggingPatch (Wim Lewis)
    * Improve detection of av_register_protocol() for ffmpeg (Angel Carpintero).
    * Added support for libjpeg-turbo
      http://www.lavrsen.dk/foswiki/bin/view/Motion/FeatureRequest2010x04x14x082244 (Angel Carpintero)
    * Added new log type COR , to filter messages from CORE. (Angel Carpintero)
    * Added a new starting option -m to disable motion detection. (Angel Carpintero)
    * Allow image dimension not 4:3 changing a check of modulo 16 by modulo 8. (Jeroen Massar)
    * Added codec Ogg/Theora as new output format for regular movies.
      http://www.lavrsen.dk/foswiki/bin/view/Motion/OggTimelapse (Michael Luich)
    * Added support for ffmpeg 0.11 new API.
    * Added RSTP support for netcam ( merge https://github.com/hyperbolic2346/motion )
    * Merge tosiara/rtsp branch (commit 46cfcf31d, 2014/05/21) (Mr-Dave)
      * 3fps bugfix from SVN rev559 (tosiara, Joerg Weber)
      * Buffer overflow vulnerabilities (hyperbolic2346)
      * Redundand -- boundary prefix (torao)
    * Removed compiler warnings:  (Mr-Dave)
        logger.c,jpegutils.c,netcam_ftp.c,track.c,
        picture.c,webhttpd.c,stream.c,ffmpeg.c
    * Bug fix as part of warnings in webhttpd.c fixed(Mr-Dave)
    * Removed compiler warning regarding ffmpeg being newer than 0.4 version(Mr-Dave)
    * New configure script and identification of ffmpeg version and additional libs. (Mr-Dave)
    * Resolve additional compiler warnings in ffmpeg (Mr-Dave)
    * Revised INSTALL with samples(Mr-Dave)
    * Revisions for RTSP and code standard.(Mr-Dave)
    * Plugged most memory leaks in RTSP. (Mr-Dave)
    * Undo changes caused by code editor and other unnecessary changes (Mr-Dave)
    * Moved call to netcam_shutdown_rtsp into netcam_cleanup where it belongs. (Mr-Dave)
    * Regession fix for memory leaks and reconnection (Mr-Dave)
    * Eliminated requirement to manually build FFMPEG for RTSP support. (Mr-Dave)
    * Revised RTSP to support version 53 of libavformat (Mr-Dave)
    * Revised FFMPEG.c to eliminate warnings and functions no longer supported by Libav/FFMPEG(Mr-Dave)
    * Revised INSTALL to have sample PI configure option.(Mr-Dave)
    * Revised configure.ac to generate compiler flag AVFMT_V53.(Mr-Dave)
    * Revised INSTALL to indicate standard APT packages for RTSP (Mr-Dave)
    * Revised configure.ac to recognize libavformat version 54 RTSP (Mr-Dave)
    * Clean up the messaging for RTSP.
    * Additional validations for RTSP connection and corrected free sequences
    * Removed seg fault on failure to open first image, comments, isolation of RTSP
    * Add AC_GNU_SOURCE macro to check for GNU C Library, fix compile when no FFMpeg.
    * Implement inits of AV functions from bcl fork
    * Add gray image upon disconnection
    * Added tcp/udp transport config option from hyperbolic2346(commit 423ef7bb3)
    * Revised comments to be in line with application standard.
    * Restructure rtsp to handle rescaling and non YUV420 format, rotate, MJPEG input format
    * Revise version.sh to put out the git commit.
    * Rollback revision to allow for a formal pull request.
    * Reimplement changes not to be included in pull request from tosiara commit 9ebee031
    * Implement requirement of modulo 16 to avoid seg fault when opening stream
    * Add debian build files from trusty(14.04)
    * Revise default values for motion.conf
    * Revise CHANGELOG to conform with debian format
 .
    * Bugfixes
    * Avoid segfault detecting strerror_r() version GNU or SUSv3. (Angel Carpintero)
    * Fix Segfault on reload or quit for vloopback (maybe other v4l1 devices too) (Peter Holik)
      http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2009x06x17x090603
    * Allow compile with NetBSD and make LP64 compliant video_freebsd.c (Andreas Wrede)
    * Avoid compile vloopback in BSD (Angel Carpintero)
    * V4L2 fourcc GRBG not supported, updated default value for v4l2_palette 17. (Isaac Richter)
      http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2009x10x29x222753
    * Exit when image dimension are not modulo 16. (Angel Carpintero)
    * Avoid logs flooding using some options of netcam_keepalive and try to discard images with
      weird header Content-Lenght 0. (Angel Carpintero)
    * Only use post capture when we setup to record videos with external pipe or ffmpeg. (Angel Carpintero)
    * Fix introduced bug for Content-Lenght = 0 in svn r476. (Angel Carpintero)
    * Avoid segfault when motion cannot create a logfile. (Angel Carpintero)
    * No mysql_close
      http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2010x11x22x033859
    * No PQfinish() (Angel Carpintero)
    * Input for webcams has to be set to -1
      http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2011x01x21x162309
    * Added a conditional check for avformat_alloc_context , av_avformat_alloc_context to fix
      http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2011x10x05x071936 (Angel Carpintero)
    * Fix issue with JPEG , adding dinfo.do_fancy_upsampling = FALSE;
      http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2011x08x20x194659
    * Made micro-lightswitch optional (see lightwitch option in motion.conf)
    * Fixed help text for options event_gap and area_detect
    * Fixed motion.conf-dist , adding text according with config options.
    * Fixed a bug in post_capture. It was missed under certain conditions.
    * Fixed configure for SDL.
    * Replace malloc() by calloc(). (Jeroen Massar)
    * Free file descriptor buffers on exit.
    * Avoid segfault when text_left or text_right uses non supported chars.
    * Fixed leak in vloopback.
    * Fixed a build of motion for some kernel version with not good videodev.h
    * Netcam Modulo 8
Author: Mr Dave <motionmrdave@gmail.com>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: http://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: <YYYY-MM-DD>

--- motion-3.2.12.orig/CHANGELOG
+++ motion-3.2.12/CHANGELOG
@@ -1,3 +1,129 @@
+   * 
+   * Features
+   * Insert Blanking frames http://www.lavrsen.dk/twiki/bin/view/Motion/FeatureRequest2007x12x16x132522 (Dag Erlandsson)
+   * IPV6 for http-control and webcam stream not netcam yet http://www.lavrsen.dk/twiki/bin/view/Motion/IPv6 
+     (Jeroen Massar & Angel Carpintero) 
+   * Experimental approach for MJPEG streams (Motion JPEG) for network cameras 
+     http://www.lavrsen.dk/twiki/bin/view/Motion/LinksysWVC200SupportPatch ( ... )  
+   * Add draw a RED box around the movement as default (Joerg Weber)
+   * Add write/read nonblock functions in webhttpd( timeout on read/write). (Angel Carpintero) 
+   * More changes in option names from http://www.lavrsen.dk/twiki/bin/view/Motion/IntuitiveOptionNamesDiscussion
+     (Angel Carpintero)
+   * motion_locate new parameter names : red , center , redcross  instead of only on, off. (Angel Carpintero)
+   * External pipe to allow external video encoders 
+     http://www.lavrsen.dk/twiki/bin/view/Motion/DarkwindHackeronMotionPatching (Bill Payne, Angel Carpintero)
+   * Split locate_motion into separate 'mode' and 'style' option to allow all
+     possible combinations. (Joerg Weber)
+   * Implement 'gapless' event mode to allow for recording of movies without 'holes'. (Joerg Weber)
+   * Limit detection rate to 3fps at framerates above 5fps, to reduce CPU load. (Joerg Weber)
+   * Fix warning for syslog() , Added support for some new bayer palettes introduced in kernel 2.6.27. 
+     http://www.lavrsen.dk/twiki/bin/view/Motion/FeatureRequest2008x10x15x130110
+     Increased buffer in ffmpeg to allow encoding at 1600x1200 (Angel Carpintero)
+   * Sqlite3 support http://www.lavrsen.dk/twiki/bin/view/Motion/SQLite3Patch (Giacomo Graziosi)
+   * New RPM SPEC file and startup scripts compliant with Fedora 10 guidelines and above (Steven Moix)
+   * Increase write buffer size for writing image files and ffmpegs 
+     http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionWriteBuffersPatch (Craig West)
+   * Fixed mask overlay in setup mode is now green instead of white (Joerg Weber)
+   * Add new config option 'ipv6_enabled' to enable/disable IPV6 (Angel Carpintero)
+   * Remove VIDIOC_S_JPEGCOMP support is deprecated. (Angel Carpintero) 
+   * Use static memory allocation in ffmpeg_deinterlace() (Peter Holik)
+     http://www.lavrsen.dk/foswiki/bin/view/Motion/FfmpegDeinterlaceStatic 
+   * Atom optimizacion in configure.in (Peter Holik)
+     http://www.lavrsen.dk/foswiki/bin/view/Motion/AtomOptimizations
+   * Allow to change Standard method ( PAL / NECAM / SECAM ) (Angel Carpintero)
+   * Add authentication  methods 'Basic Authentication' and 'Digest Authentication' 
+     to the "Live Stream Server". (Michael Finsterbusch)
+     http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionStreamAuthPatch
+   * Implemented new logging system 
+     http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionLog (Angel Carpintero)
+   * Added a macro MOTION_LOG , no need to add __FUNCTION__ anymore. (Angel Carpintero)
+   * Added EXIF feature for jpeg images , http://www.lavrsen.dk/foswiki/bin/view/Motion/ExifTaggingPatch (Wim Lewis)
+   * Improve detection of av_register_protocol() for ffmpeg (Angel Carpintero).
+   * Added support for libjpeg-turbo 
+     http://www.lavrsen.dk/foswiki/bin/view/Motion/FeatureRequest2010x04x14x082244 (Angel Carpintero)     
+   * Added new log type COR , to filter messages from CORE. (Angel Carpintero)
+   * Added a new starting option -m to disable motion detection. (Angel Carpintero)
+   * Allow image dimension not 4:3 changing a check of modulo 16 by modulo 8. (Jeroen Massar)
+   * Added codec Ogg/Theora as new output format for regular movies.
+     http://www.lavrsen.dk/foswiki/bin/view/Motion/OggTimelapse (Michael Luich)
+   * Added support for ffmpeg 0.11 new API.
+   * Added RSTP support for netcam ( merge https://github.com/hyperbolic2346/motion )
+   * Merge tosiara/rtsp branch (commit 46cfcf31d, 2014/05/21) (Mr-Dave)
+     * 3fps bugfix from SVN rev559 (tosiara, Joerg Weber)
+     * Buffer overflow vulnerabilities (hyperbolic2346)
+     * Redundand -- boundary prefix (torao)
+   * Removed compiler warnings:  (Mr-Dave)
+       logger.c,jpegutils.c,netcam_ftp.c,track.c,
+       picture.c,webhttpd.c,stream.c,ffmpeg.c
+   * Bug fix as part of warnings in webhttpd.c fixed(Mr-Dave)
+   * Removed compiler warning regarding ffmpeg being newer than 0.4 version(Mr-Dave)
+   * New configure script and identification of ffmpeg version and additional libs. (Mr-Dave)
+   * Resolve additional compiler warnings in ffmpeg (Mr-Dave)
+   * Revised INSTALL with samples(Mr-Dave)
+   * Revisions for RTSP and code standard.(Mr-Dave)
+   * Plugged most memory leaks in RTSP. (Mr-Dave)
+   * Undo changes caused by code editor and other unnecessary changes (Mr-Dave)
+   * Moved call to netcam_shutdown_rtsp into netcam_cleanup where it belongs. (Mr-Dave)
+   * Regession fix for memory leaks and reconnection (Mr-Dave)
+   * Eliminated requirement to manually build FFMPEG for RTSP support. (Mr-Dave)
+   * Revised RTSP to support version 53 of libavformat (Mr-Dave)
+   * Revised FFMPEG.c to eliminate warnings and functions no longer supported by Libav/FFMPEG(Mr-Dave)
+   * Revised INSTALL to have sample PI configure option.(Mr-Dave)
+   * Revised configure.ac to generate compiler flag AVFMT_V53.(Mr-Dave)
+   * Revised INSTALL to indicate standard APT packages for RTSP (Mr-Dave)
+   * Revised configure.ac to recognize libavformat version 54 RTSP (Mr-Dave)
+   * Clean up the messaging for RTSP.
+   * Additional validations for RTSP connection and corrected free sequences
+   * Removed seg fault on failure to open first image, comments, isolation of RTSP
+   * Add AC_GNU_SOURCE macro to check for GNU C Library, fix compile when no FFMpeg.
+   * Implement inits of AV functions from bcl fork
+   * Add gray image upon disconnection
+   * Added tcp/udp transport config option from hyperbolic2346(commit 423ef7bb3)
+   * Revised comments to be in line with application standard.
+   * Restructure rtsp to handle rescaling and non YUV420 format, rotate, MJPEG input format
+   * Revise version.sh to put out the git commit.
+   * Rollback revision to allow for a formal pull request.
+   * Reimplement changes not to be included in pull request from tosiara commit 9ebee031
+   * Implement requirement of modulo 16 to avoid seg fault when opening stream
+   * Add debian build files from trusty(14.04)
+   * Revise default values for motion.conf
+   * Revise CHANGELOG to conform with debian format
+
+   * Bugfixes
+   * Avoid segfault detecting strerror_r() version GNU or SUSv3. (Angel Carpintero)
+   * Fix Segfault on reload or quit for vloopback (maybe other v4l1 devices too) (Peter Holik)
+     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2009x06x17x090603
+   * Allow compile with NetBSD and make LP64 compliant video_freebsd.c (Andreas Wrede)
+   * Avoid compile vloopback in BSD (Angel Carpintero)
+   * V4L2 fourcc GRBG not supported, updated default value for v4l2_palette 17. (Isaac Richter)
+     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2009x10x29x222753
+   * Exit when image dimension are not modulo 16. (Angel Carpintero)
+   * Avoid logs flooding using some options of netcam_keepalive and try to discard images with 
+     weird header Content-Lenght 0. (Angel Carpintero)
+   * Only use post capture when we setup to record videos with external pipe or ffmpeg. (Angel Carpintero)   
+   * Fix introduced bug for Content-Lenght = 0 in svn r476. (Angel Carpintero)
+   * Avoid segfault when motion cannot create a logfile. (Angel Carpintero)
+   * No mysql_close
+     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2010x11x22x033859
+   * No PQfinish() (Angel Carpintero)
+   * Input for webcams has to be set to -1
+     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2011x01x21x162309
+   * Added a conditional check for avformat_alloc_context , av_avformat_alloc_context to fix 
+     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2011x10x05x071936 (Angel Carpintero)
+   * Fix issue with JPEG , adding dinfo.do_fancy_upsampling = FALSE;
+     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2011x08x20x194659
+   * Made micro-lightswitch optional (see lightwitch option in motion.conf)
+   * Fixed help text for options event_gap and area_detect
+   * Fixed motion.conf-dist , adding text according with config options.
+   * Fixed a bug in post_capture. It was missed under certain conditions.
+   * Fixed configure for SDL.
+   * Replace malloc() by calloc(). (Jeroen Massar)
+   * Free file descriptor buffers on exit.
+   * Avoid segfault when text_left or text_right uses non supported chars.
+   * Fixed leak in vloopback.
+   * Fixed a build of motion for some kernel version with not good videodev.h 
+   * Netcam Modulo 8
+
 3.2.12 Summary of Changes
 
 Bugfixes
@@ -6,10 +132,11 @@ Bugfixes
    * Fixed FFV1 codec encode with ffmpeg (Angel Carpintero)
      http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2010x04x13x032553 
    * Fix conv_uyvyto420p segfault ( William M Brack )
-   * Enhancing the palette selection ( William M Brack ) 
+   * Enhancing the palette selection ( William M Brack )  
    * Fix zombies on OpenBSD. (Mark Feenstra)
      http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2010x04x28x054348
 
+
 3.2.11.1 Sumary of Changes
 
 Bugfixes
@@ -18,16 +145,15 @@ Bugfixes
    * Fix fd leaks in external pipe. (Angel Carpintero)
    * Avoid possible stack smashing in v4l_open_vidpipe(). (Angel Carpintero)
    * Allow compile with OpenSuse ffmpeg package (15594svn-20081010)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/SupportQuestion2008x10x25x070400 (Angel Carpintero)
+     http://www.lavrsen.dk/twiki/bin/view/Motion/SupportQuestion2008x10x25x070400 (Angel Carpintero)
    * Fix warning for syslog().  (Angel Carpintero)
-   * Better detection of ffmpeg  
-     http://www.lavrsen.dk/foswiki/pub/Motion/ReleaseNoteMotion3x2x11/ffmpeg-detection.diff.gz 
-     (Angel Carpintero) 
-   * Fix warning for __USE_GNU redefined (Peter Holik) 
+   * Better detection of ffmpeg
+     http://www.lavrsen.dk/foswiki/pub/Motion/ReleaseNoteMotion3x2x11/ffmpeg-detection.diff.gz
+     (Angel Carpintero)
+   * Fix warning for __USE_GNU redefined (Peter Holik)
      http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2009x06x17x122137 (Peter Holik)
    * Allow compile with NetBSD and make LP64 compliant video_freebsd.c (Andreas Wrede)
    * Fix segfault for new libjpeg v7. (Angel Carpintero)
-   
 
 3.2.11 Summary of Changes
 
@@ -39,29 +165,31 @@ Features
 
 
 Bugfixes
-   * Fix Problem Encoding 1280x1024 resolution videos  
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/SupportQuestion2008x06x11x183727 (Angel Carpintero)
+   * Fix Problem Encoding 1280x1024 resolution videos
+     http://www.lavrsen.dk/twiki/bin/view/Motion/SupportQuestion2008x06x11x183727 (Angel Carpintero)
    * Add a new parameter netcam_tolerant_check, to be less strict with some buggy network cameras firmwares.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2008x06x19x123218 (Angel Carpintero)
-   * Fix round robin in BSD switching to METEOR_CAP_SINGLE. (Angel Carpintero)   
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2008x06x19x123218 (Angel Carpintero)
+   * Fix round robin in BSD switching to METEOR_CAP_SINGLE. (Angel Carpintero)
    * Fix rotate for v4l2 devices using JPEG / MJPEG palettes. (Angel Carpintero)
-   * Fix v4l2_palette http://www.lavrsen.dk/foswiki/bin/view/Motion/UvcvideoMjpegPatch (Gerrit Hannaert)
+   * Fix v4l2_palette http://www.lavrsen.dk/twiki/bin/view/Motion/UvcvideoMjpegPatch (Gerrit Hannaert)
    * Fix warning for x86_64 in conf.c using pointers LP64 compliant ( Angel Carpintero ).
+   * Fix Segfault on reload or quit for vloopback (maybe other v4l1 devices too) ( Peter Holik )
+     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2009x06x17x090603
+
 
 3.2.10.1 Summary of Changes
 
 Bugfixes
     * Fix a security issue in web control interface http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=484572
-      (Angel Carpintero) 
-
+      (Angel Carpintero)
 
 3.2.10 Summary of Changes
 
 Features
    * Added the pre_capture buffer redesign to throttle load and enhance pre_capture feature.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/PreCaptureRedesign (Dag Erlandsson).
+     http://www.lavrsen.dk/twiki/bin/view/Motion/PreCaptureRedesign (Dag Erlandsson).
    * Added preview center feature.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/PreviewCenter (Dag Erlandsson).	
+     http://www.lavrsen.dk/twiki/bin/view/Motion/PreviewCenter (Dag Erlandsson).	
    * Removed low_cpu feature, as it is not really compatible with pre_capture and a lot of other
      features rely on the pre_capture buffer behind the scenes. (Joerg Weber)
    * Removed night_compensate feature. This functionality is covered by noise_tune. (Joerg Weber)
@@ -69,8 +197,8 @@ Features
    * Improved smartmask feature: real moving objects don't trigger the mask anymore. (Joerg Weber)
    * Added area_detect feature. New config options: area_detect, on_area_detected. (Joerg Weber)
    * Added help in http control 
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/FeatureRequest2007x11x19x181541 (Angel Carpintero)
-   * Added Choose V4L2 palette http://www.lavrsen.dk/foswiki/bin/view/Motion/FeatureRequest2007x11x19x032318
+     http://www.lavrsen.dk/twiki/bin/view/Motion/FeatureRequest2007x11x19x181541 (Angel Carpintero)
+   * Added Choose V4L2 palette http://www.lavrsen.dk/twiki/bin/view/Motion/FeatureRequest2007x11x19x032318
      (Angel Carpintero)  
    * Improved http control ( 'back' link, select box, show current values when are going to be changed ). 
      (Angel Carpintero)
@@ -78,7 +206,7 @@ Features
    * Watchdog, restart hang threads (Dag Erlandsson)
    * Added ON_CAMERA_LOST event (Dag Erlandsson)
    * Motion start if a camera isn't there at start, retries to connect if lost (Dag Erlandsson)
-   * Netcam Keepalive and HTTP/1.1 http://www.lavrsen.dk/foswiki/bin/view/Motion/FeatureRequest2007x01x22x231542 
+   * Netcam Keepalive and HTTP/1.1 http://www.lavrsen.dk/twiki/bin/view/Motion/FeatureRequest2007x01x22x231542 
     (Simon Walls)
    * Added mov , Quicktime file format (Andrew Hamilton).
    * Added to configure.in --with-pwcbsd to allow compile motion in freebsd with webcam support instead of bktr
@@ -87,25 +215,25 @@ Features
 Bugfixes
    * Fixed a problem with locate and fixed mask overlay (Dag Erlandsson).
    * Preview pictures get the timestamp of moment they were captured (Dag Erlandsson).
-   * Fixed http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2007x10x23x093651 (Angel Carpintero)
+   * Fixed http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2007x10x23x093651 (Angel Carpintero)
    * Fix process_id_file when is passed from command line (Angel Carpintero)
-   * Fix http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2007x10x27x150419 (Angel Carpintero)
-   * Fix http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2007x11x25x102808 (Angel Carpintero)
+   * Fix http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2007x10x27x150419 (Angel Carpintero)
+   * Fix http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2007x11x25x102808 (Angel Carpintero)
    * Avoid random errors , initialising some structs for V4L1 
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2007x11x26x010755 (Jason Sharpee & Angel Carpintero)
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2007x11x26x010755 (Jason Sharpee & Angel Carpintero)
    * Fix motion segfault because ffmpeg API change 
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/SupportQuestion2007x12x29x175530 (Angel Carpintero)
+     http://www.lavrsen.dk/twiki/bin/view/Motion/SupportQuestion2007x12x29x175530 (Angel Carpintero)
    * Little fix in ffmpeg.c comparing version of LIBAVFORMAT_BUILD, since ffmpeg svn -r4486 LIBAVFORMAT_BUILD and
      LIBAVCODEC_BUILD uses LIBAVFORMAT_VERSION_INT ((49<<16)+(0<<8)+0) and LIBAVCODEC_VERSION_INT ((49<<16)+(0<<8)+0)
      (Angel Carpintero)	
-   * Fix choose v4l2 palette , http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2008x01x21x043812   (Onakra)
+   * Fix choose v4l2 palette , http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2008x01x21x043812	(Onakra)
    * Get current directory to allow write motion.conf properly 
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2008x02x25x013419 (John Bray) 
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2008x02x25x013419 (John Bray) 
    * Fix broken PostgreSQL detection for custom location, 
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2008x02x25x025134 ( Angel Carpintero )
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2008x02x25x025134 ( Angel Carpintero )
    * Fixed stepper when is used track_auto on ( Angel Carpintero ).
    * Better debug in netcam for "Error reading image header" 
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2008x02x27x092849 (Simon Walls)
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2008x02x27x092849 (Simon Walls)
 
 
 3.2.9 Formal Release - Summary of Changes
@@ -115,20 +243,20 @@ Features
      ( no needed to deploy BSD port here ) directories. ( Angel Carpintero )
    * Added --chuid motion to debian init.d script. ( Angel Carpintero )
    * Added Flash video format (FLV) to ffmpeg.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/FeatureRequest2007x07x19x131921 (Timo Taskinen).
+     http://www.lavrsen.dk/twiki/bin/view/Motion/FeatureRequest2007x07x19x131921 (Timo Taskinen).
    * Added FFV1 ( FF video codec 1 ) codec , Lossless encoding
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/LosslessEncoding (Andrew Hamilton).
+     http://www.lavrsen.dk/twiki/bin/view/Motion/LosslessEncoding (Andrew Hamilton).
 
 
 Bugfixes
    * Fix segfault in webhttpd.c on motion restart (Angel Carpintero)
-   * Fix segfault in debian http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2007x09x24x175945
+   * Fix segfault in debian http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2007x09x24x175945
      (Angel Carpintero)
    * Fix http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=391055 , change
      motion man page , -d requires level. (Angel Carpintero)
    * Handle mjpeg decoding and fix colour issue adding mjpegtools dependency
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/MjpegColorIssue
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/MjpegToYUV420pPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/MjpegColorIssue
+     http://www.lavrsen.dk/twiki/bin/view/Motion/MjpegToYUV420pPatch
      (Marius Rieder, Angel Carpintero).
    * Add debug level > 5 to get logs from v4l2_select_input, v4l2_set_control and v4l2_set_input.
      (Angel Carpintero)
@@ -139,17 +267,17 @@ Bugfixes
 Features
    * Added connection status for all devices available from http web interface.
      (Angel Carpintero).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/FeatureRequest2006x11x09x050638
+     http://www.lavrsen.dk/twiki/bin/view/Motion/FeatureRequest2006x11x09x050638
    * Improved deb packaging, install the init.d script. (Angel Carpintero).
    * Added swf codec to video creation (Bowser Pete, Andy Brown).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/FFmpegSWFcreation
+     http://www.lavrsen.dk/twiki/bin/view/Motion/FFmpegSWFcreation
    * Added V4L2 support (Krzysztof Blaszkowski, Angel Carpintero).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/VideoForLinuxTwoDiscussion,
+     http://www.lavrsen.dk/twiki/bin/view/Motion/VideoForLinuxTwoDiscussion,
    * Added support for V4L2_PIX_FMT_SBGGR8 ( bayer ), V4L2_PIX_FMT_SN9C10X,
      V4L2_PIX_FMT_MJPEG and V4L2_PIX_FMT_UYVY (Angel Carpintero).
    * ucvideo track pan/tilt support ( Michal Licko ,Dirk Wesenberg and
      Angel Carpintero )
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/LinuxUvcTrackingPatch 
+     http://www.lavrsen.dk/twiki/bin/view/Motion/LinuxUvcTrackingPatch 
    * Added a FreeBSD directory to allow people from BSD to get a daily version
      and create a port. (Angel Carpintero).
    * Removed mysql dependency from debian package and added a note to setup
@@ -164,18 +292,18 @@ Features
 Bugfixes
    * Removed a duplicate call to jpeg_destroy_decompress already is called from
      netcam_image_conv (Krzysztof Blaszkowski).
-   * Fix http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2006x10x10x081903,
+   * Fix http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2006x10x10x081903,
      reconnect to mysql if connection dropped (Angel Carpintero).
    * Fix memory management in ffmpeg.c  (Rafis Khayrullin).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2006x12x19x062432	
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2006x12x19x062432	
    * Fix of ffmpeg_avcodec_log code (Alain Guidez).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2007x03x25x074612
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2007x03x25x074612
    * Fix a segfault adding correct size to be used for bayer2rgb24()
      (Damian Wrobel)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2007x03x30x175913
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2007x03x30x175913
    * Fix an error in FreeBSD, the use of capture even fields depends on height
      value. (Angel Carpintero)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2006x12x03x073610	
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2006x12x03x073610	
    * Fixed autodetection for VIA cpu, no needed to use --without-optimizecpu.
      Added many others (Angel Carpintero)
    * Fix, don't remove pid file when motion reload config file( HUP signal )
@@ -184,12 +312,12 @@ Bugfixes
    * Fixed the thread number assignment which could goof up if netcams started
      very quickly before all thread were created at startup. (Kenneth Lavrsen)
    * Fix RoundRobin v4l2 buffers in driver when switching input,
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2007x07x07x182605 
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2007x07x07x182605 
      (Dag Erlandsson and Angel Carpintero).
    * Check EIO for VIDIOC_DQBUF to workaround saa7134 problem. 
      (Dag Erlandsson and Angel Carpintero).
    * Change bayer2rgb24() to fix a problem with sn9c102 driver
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2007x06x05x012249 
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2007x06x05x012249 
      (Jared D and Angel Carpintero).	
 	
 3.2.7 Formal Release - Summary of Changes
@@ -200,30 +328,30 @@ Features
      than 2 frames per second (Kenneth Lavrsen and Angel Carpintero)
    * Made the creation of reference frame and the decay mechanism depending
      on how much motion was detected relative to threshold setting (Joerg Weber)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/ReferenceFramePatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/ReferenceFramePatch
    * Added process_id_file feature (Angel Carpintero)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/FeatureRequest2006x06x06x123003
+     http://www.lavrsen.dk/twiki/bin/view/Motion/FeatureRequest2006x06x06x123003
 
 Bugfixes
    * Fixed problem related to fetching images from Network camera and error
      handling when it fails. Motion would end in infinite loops (Bill Brack).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2006x03x10x000151
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2006x03x10x000151
    * Improved reporting of thread numbers during startup in setup mode.
      (Peter Smith and Kenneth Lavrsen)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/SlightlyImprovedThreadCreationLogging
+     http://www.lavrsen.dk/twiki/bin/view/Motion/SlightlyImprovedThreadCreationLogging
    * Ffmpeg code mutex locking fix (Peter Smith)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2006x04x07x164654
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2006x04x07x164654
    * Ffmpeg avicodec logging improved (Peter Smith and Kenneth Lavrsen)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/FfmpegAvicodecLogging
+     http://www.lavrsen.dk/twiki/bin/view/Motion/FfmpegAvicodecLogging
    * Improved upon a few ambiguous log messages which may be emitted by the Event
      handling code with regards to Ffmpeg (Peter Smith)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/LoggingEventFix
+     http://www.lavrsen.dk/twiki/bin/view/Motion/LoggingEventFix
    * Implemented a fix for the rare problem where some experienced that the
      move file names would only consist of the extension .mpg or .avi with no
      name in front. The root cause was the use of sprintf for appending to
      strings. (Mike Kenney and Kenneth Lavrsen)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/SupportQuestion2005x09x05x133031
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/SupportQuestion2006x06x19x174238
+     http://www.lavrsen.dk/twiki/bin/view/Motion/SupportQuestion2005x09x05x133031
+     http://www.lavrsen.dk/twiki/bin/view/Motion/SupportQuestion2006x06x19x174238
    * Altered the risky use of sprintf to snprintf in all places related to
      use with config strings that can become very long (Kenneth Lavrsen)
    * Removed annoying debug messages (v4l_set_input really needed ?) in the FreeBSD
@@ -236,20 +364,20 @@ Bugfixes
    * Fixed interlace issue with METEOR_GEO_EVEN_ONLY in FreeBSD (Angel Carpintero)
    * Fixed possible syntax error in configure related to MySQL (Angel Carpintero)
    * Avoid open file descriptor when connecting to network cameras fails (Peter Holik) 
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/AvoidOpenfiledescriptors
+     http://www.lavrsen.dk/twiki/bin/view/Motion/AvoidOpenfiledescriptors
    * Fixed http pause feature so that pausing thread 0 now pauses all threads.
      (GunnarSkjold)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2006x07x10x111239
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2006x07x10x111239
    * Put a new global mutex around avcodec_close to avoid problems with not thread
      safe functions in ffmpeg (Angel Carpintero)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2006x04x07x164654
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2006x04x07x164654
    * On FreeBSD configure defines a redundant freebsd for motion. Fixed by replacing
      -D__freebsd_ by BSD macro  included in sys/param.h for BSD platforms.
      (JukkaUkkonen and Angel Carpintero)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2006x07x08x070417
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2006x07x08x070417
    * For BSD platforms changed to using native pthreads as default and adding
      linuxthreads as a optional parameter from configure. (Angel Carpintero)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2006x07x08x071646
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2006x07x08x071646
    * Smartmask overlay feature did not set intensity correctly. (Kenneth Lavrsen)
 
 
@@ -257,14 +385,14 @@ Bugfixes
    * Fixed bug where variables time_last_frame and time_current_frame had been
      extended to also be used for snapshot feature but declaration was hidden
      between #ifdef HAVE_FFMPEG. (Kenneth Lavrsen)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2006x03x09x012244
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2006x03x09x012244
    * Fixed a bug that only allowed remote control of max 9 cameras. Now
      Motion can present up to 99 cameras in its http remote control interface
      (Angel Carpintero based on idea by Chuck Sheehan)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/WebHttpManyThreads
+     http://www.lavrsen.dk/twiki/bin/view/Motion/WebHttpManyThreads
    * text_changes now shows a '-' when motion detection is paused instead of
      just showing 0 (Kenneth Lavrsen)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/FeatureRequest2006x03x16x095713
+     http://www.lavrsen.dk/twiki/bin/view/Motion/FeatureRequest2006x03x16x095713
 
 3.2.5.1  Doc and man page correction
    * ffmpeg_filename has changed name to movie_filename to prepare for
@@ -285,30 +413,30 @@ Bugfixes
       * Remove cpu optimization (is broken)
    * Fixed memory leak in ffmpeg code. (Andrew Hamilton)
    * Fixed http control of pan and tilt (Angel Carpintero)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x12x22x122649
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x12x22x122649
    * Fixed netcamera bug related to separating frames in an mjpeg stream.
      (Peter Holik). From mailing list 23 Dec 2005.
    * Fix related to connecting to the netcam (William Black)
      From mailing list 23 Dec 2005.
-   * Changed CHANGELOG to same bullet format as used by Foswiki to make it easier
+   * Changed CHANGELOG to same bullet format as used by TWiki to make it easier
      to write release notes (Kenneth Lavrsen)
    * Changed CREDITS to same bullet format as CHANGELOG (Kenneth Lavrsen)
    * Fixed sql_mask not initialised correctly (Angel Carpintero)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2006x01x09x175603 
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2006x01x09x175603 
    * Fixed the management of strings from http remote control , setting to NULL 
      when they are set to "blank" and fixes a problem with despeckle , that didn't 
      allow to remove labeling action from http remote control. (Angel Carpintero)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/FixStringsAndDisableLabeling
+     http://www.lavrsen.dk/twiki/bin/view/Motion/FixStringsAndDisableLabeling
    * Fix many typos in comments ( i ran aspell against the code ). Also there's a 
      fix to free cnt->eventtime_tm when motion exits. (Angel Carpintero)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/FixTypoInComments
+     http://www.lavrsen.dk/twiki/bin/view/Motion/FixTypoInComments
    * Fix the problem that happens in FreeBSD and Debian Sarge because 
      version of ffmpeg is LIBAVFORMAT_BUILD < 4629. ( Pete Shipley and Angel Carpintero)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2006x01x12x120335
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2006x01x12x120335
    * Updated motion.spec. Changing D_FORTIFY_SOURCE=2 by D_FORTIFY_SOURCE=1 to fix
      problem related to building with ffmpeg. (Angel Carpintero)
    * Implemented fix for missed snapshots with slow network cameras (Kenneth Lavrsen)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2006x02x07x162149
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2006x02x07x162149
    * Added some constants in video.c function v4l_picture_controls() which can help
      people hack an optimal set of values for controlling auto brightness for their
      particular camera. For now I am do not want to add all of these to the already
@@ -316,19 +444,19 @@ Bugfixes
      permanently change the constants and add an additional auto brightness option.
      Or maybe a combined option that sets more constant based on an algorithm.
      (Kenneth Lavrsen)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2006x02x07x212816
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2006x02x07x212816
    * Fixed a syntax error in picture.c get_pgm() which caused the program to segfault 
      when a mask file size did not match the picture size. Now the program
      correctly gives an error message and continues without the mask. (Kenneth
      Lavrsen).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x10x08x150720
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x10x08x150720
    * Added Tilt support to stepper track. ( Angel Carpintero ).
    * CPU VIA Ezra C3 autodetection support added. (James Van Vleet)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/VIAEzraC3Patch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/VIAEzraC3Patch
    * Fixed mysql configure auto-detection for x64 systems. ( Angel Carpintero)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/SupportQuestion2006x03x02x152208
+     http://www.lavrsen.dk/twiki/bin/view/Motion/SupportQuestion2006x03x02x152208
    * Added the ffmpeg_deinterlace feature (Andrew Hamilton)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionffmpegDeinterlace 	
+     http://www.lavrsen.dk/twiki/bin/view/Motion/MotionffmpegDeinterlace 	
 
 3.2.4   Formal Release. Summary of changes
 
@@ -353,7 +481,7 @@ Features
      after the camera has moved (auto or manual) during which motion detection
      is disabled. This option should be set so low that the motion detection
      is re-enabled the minute the camera is standing still again.
-   * Added new sql_query option. This in combination with conversion
+   * Added new sql_query option. This in combination with convertion
      specifiers incl the two new %f and %n enables the user to use any database
      structure they please. Adding fields is now a simple matter of modifying
      the sql query.
@@ -380,7 +508,7 @@ Features
      and brightness, support large resolutions.
    * RPM specs file changed as suggested for use in the Livna repository.
    * Changed the sequence of events connected with creating files. Data is
-     now written to the databases (if used) before an external commends is
+     now written to the databases (if used) before an external comments is
      on (on_xxxx options) allowing the external program to use the new data
      in the database.
    * Motion is now also works on MaxOSX with similar feature set as FreeBSD.
@@ -427,21 +555,21 @@ snap1
      We now encourage developers to ensure that new code is checked with
      --with-developer-flags and code made so that no new warnings shows originating
      from the motion sources.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/ReduceWarningsPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/ReduceWarningsPatch
    * Fixed error message with unknown config option (Bill Brack)
    * Fixed small mistake in allocating memory for cnt->imgs.common_buffer
      (Angel Carpintero).
    * Implemented a speed-up patch of the draw text feature (Peter Holik).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/DrawTextspeedup
+     http://www.lavrsen.dk/twiki/bin/view/Motion/DrawTextspeedup
    * http control updated: (null) messages replaced by "disabled", last parameter
      in conf/list are displayed correctly and only in Main thread. When motion runs
      with only one thread, it displays "No threads". (Angel Carpintero)
    * Enhanced compatibility with Lumenera (Bill Brack)
    * http control: selectbox instead of a textfield for changing boolean configs
      (Peter Holik and Angel Carpintero).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/WebhttpEnhancements.
+     http://www.lavrsen.dk/twiki/bin/view/Motion/WebhttpEnhancements.
    * Introduced check for device image size being a multiple of 16 (Peter Holik).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/NetcamModulo16Patch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/NetcamModulo16Patch
    * Added the debian sub directory so that people can build the deb package
      (Angel Carpintero).
    * Sync configure.in.freebsd (adding support for jpeg-mmx, developer-flags and
@@ -452,8 +580,8 @@ snap1
      cnt struct around just to be able to print the thread number in the log and
      on the console. (Per Jönsson with additional removal of unused cnt by
      Kenneth Lavrsen).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/ThreadNrTlsPatch
-   * Moved the motion_loop initialisation into a new function motion_init
+     http://www.lavrsen.dk/twiki/bin/view/Motion/ThreadNrTlsPatch
+   * Moved the motion_loop initialization into a new function motion_init
      (Bill Brack).
    * Removed old unused code related to read mode (not mmap) from V4L devices
      (Kenneth Lavrsen).
@@ -481,7 +609,7 @@ snap1
 snap2
    * Simplified rotation code based on the fact that images must have dimensions
      that are a multiple of 16 (Per Jönsson)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/RotateSimplificationPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/RotateSimplificationPatch
    * Switchfilter feature repaired. It was called inside motion_detected()
      after overlays on cnt->img.out were added which meant that the feature also
      detected all the overlays, smartmasks, fixed mask and text. It is now moved
@@ -499,7 +627,7 @@ snap2
      and minimum_motion_frames images are time stamped before the event happens
      so %C in text_left/right does not have any effect on those images (Kenneth
      Lavrsen).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/EventConvertionSpecifierDiscussion
+     http://www.lavrsen.dk/twiki/bin/view/Motion/EventConvertionSpecifierDiscussion
    * Renamed some variables related to time to be better descriptive of function
      and type (Kenneth Lavrsen).
    * Added new option 'sql_user_text'. This can be defined with the same
@@ -511,10 +639,10 @@ snap2
 
 snap3
    * Enhancement to Netcam Code for Connection to Pixord Cameras (Bill Brack).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/NetcamFixPixordBug
+     http://www.lavrsen.dk/twiki/bin/view/Motion/NetcamFixPixordBug
    * Implemented fix to configure so that LDFLAGS from the environment are used
      when making the Makefile (Angel Carpintero).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x09x15x185558
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x09x15x185558
    * Changed configure so that --with-jpeg-mmx is default off as a reaction to
      known problems seen when using the jpeg-mmx library (Angel Carpintero).
    * RPM specs file changed as suggested for use in the Livna repository.
@@ -523,35 +651,35 @@ snap3
      despeckle features are run. This should ensure that both algorithms work on
      raw unfiltered motion pixels which they both were designed for. (Kenneth
      Lavrsen)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x10x05x212444
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x10x05x212444
 
 snap4
    * Integrated NetcamWithFtp patch. To use ftp simply use a URL starting with
      ftp:// (Bill Brack). Code was additionally cleaned up by Kenneth Lavrsen.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/NetcamWithFTP
+     http://www.lavrsen.dk/twiki/bin/view/Motion/NetcamWithFTP
    * Changed error handling in vid_start so that failing to open the video
      device no longer causes an exit but a return with error code -1. (Kenneth
      Lavrsen)
    * Added the %t conversion specifier to show the thread number. (Angel
      Carpintero).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/ThreadConversionSpecifierPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/ThreadConversionSpecifierPatch
    * Added help texts in conf.c and motion-dist.conf describing the %t
      specifier. Added a good example of use in motion-dist.conf. (Kenneth
      Lavrsen).
    * Fixed bug related to init of mutex in netcam code (Angel Carpintero).
    * Improved fix for netcam mutex init (Bill Brack).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/NetcamFixPthreadInit
+     http://www.lavrsen.dk/twiki/bin/view/Motion/NetcamFixPthreadInit
    * Netcam_ftp code fixes (Angel Carpintero and Asbjørn Pettersen)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/NetcamWithFtpEnhancements
+     http://www.lavrsen.dk/twiki/bin/view/Motion/NetcamWithFtpEnhancements
    * Enhanced ffmpeg detection (Angel Carpintero).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BetterFFmpegDetection
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BetterFFmpegDetection
    * Added two new conversion specifiers: %f which is filename (full path)
      and %n which is filetype (sqltype) valid in on_picture_save, on_movie_start,
      on_movie_end and sql_query. This also means that filename is no longer
      appended at the end of the 3 on_xxxx commands. (Kenneth Lavrsen)
    * Removed the sql_user_text option that was added in snap 2 (Kenneth
      Lavrsen)
-   * Added new sql_query option. This in combination with conversion
+   * Added new sql_query option. This in combination with convertion
      specifiers incl the two new %f and %n enables the user to use any database
      structure they please. Added fields is now a simple matter of modifying
      the sql query. The default is the same as the default in snap1.
@@ -569,7 +697,7 @@ snap4
      a good idea to setup width and height so it is the same as the netcam.
      If the dimensions are the same Motion will switch over to the netcam
      seemlessly. If the dimensions are different Motion will perform a quick
-     restart so all the many internal buffers can be initialised properly
+     restart so all the many internal buffers can be initialized properly
      (Kenneth Lavrsen).
    * Added a better error handling of a netcam that changes dimensions
      while Motion is running. Instead of just writing error messages Motion
@@ -584,7 +712,7 @@ snap5
    * Restored the function sigchild_handler so it contains the same code
      as before motion-3.2.1_snap9. They is done in an attempt to fix an old
      problem with zombie child processes that has shown up again.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x11x13x115016
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x11x13x115016
      (Kenneth Lavrsen).
    * Move the declaration of sig_handler_action and sigchild_action from
      the setup_signals function where they are local and will be destroyed
@@ -608,11 +736,11 @@ Release
      is re-enabled the minute the camera is standing still again. Feature
      originally made by Moshe Van Der Sterre. Kenneth Lavrsen extended it to
      be more generic.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/PwcConfiguration
+     http://www.lavrsen.dk/twiki/bin/view/Motion/PwcConfiguration
    * New Feature: Motion is now also supported on MaxOSX with similar
      feature set as for Free BSD. See README.MacOSX for details how to install
      it. (Angel Carpintero)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/MacOSXPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/MacOSXPatch
    * Added a work-around so people in FreeBSD that uses a capture card
      where input 1 is not tuner can use motion if frequency is set -1 in
      motion.conf or thread#.conf (Angel Carpintero).
@@ -629,11 +757,11 @@ Release
      not changed so that the ring buffer is used for timestamped images
      and the image used for detection is in a buffer cnt->imgs.image_virgin.
      (Kenneth Lavrsen).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x08x15x140701
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x08x15x140701
    * Auto brightness used the first image in ring buffer instead of the
      latest image and it used an image with time stamping. It now uses the new
      cnt->imgs.image_virgin buffer.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x08x15x160208
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x08x15x160208
    * Cleaned out unused code from httpd control (Angel Carpintero).
    * Option switch_filter used print_int instead of print_bool when motion.conf
      was saved (Kenneth Lavrsen).
@@ -704,15 +832,15 @@ Bug Fixes
 3.2.2   Detailed changes for 3.2.2
 snap1
    * Pthread deadlock in motion 3.2.1 fixed (Angel Carpintero)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x05x26x125712
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x05x26x125712
    * http lockup bugfixes and ConvertSignalToSigaction only for webhttpd
      (Angel Carpintero)
    * alg_draw_location: Use temporary variables to store the values used in
      for() loops instead of compute them in each loop (Angel Carpintero).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/ImproveAlgDrawLocation
+     http://www.lavrsen.dk/twiki/bin/view/Motion/ImproveAlgDrawLocation
    * Small speed boost to the function draw_textn (Andrew Hamilton and
      Angel Carpintero).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/DrawTextnImprovement
+     http://www.lavrsen.dk/twiki/bin/view/Motion/DrawTextnImprovement
    * Added two new convertion specifiers: %o for threshold and %Q for number
      of labels. (Kenneth Lavrsen)
    * Improved the config file description for pre_capture to get people to
@@ -723,7 +851,7 @@ snap2
      strdup to avoid segfault is target_dir parameter is not supplied in
      motion.conf. Moves out from signal handler the cleanup for pipe and mpipe.
      (Angel Carpintero)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/AvoidCleanupSegfault
+     http://www.lavrsen.dk/twiki/bin/view/Motion/AvoidCleanupSegfault
    * Major code cleanup concerning signedness of chars all over the code to
      allow compilation with gcc4.0 (like in Fedora Core 4) without any
      errors or warnings. This will probably require that some of the not yet
@@ -752,27 +880,27 @@ snap4
    * Netcam First Header patch. If an error with jpeg decompression occurred at
      connecting to a mjpeg streaming webcam, this patch skips this jpeg and tries
      to decompress next jpeg up to MAX_HEADER_RETRIES (20) (Peter Holik).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/NetcamFirstHeader
+     http://www.lavrsen.dk/twiki/bin/view/Motion/NetcamFirstHeader
 
 snap5
    * Small improvement in framerate accuracy (Peter Holik).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/FramerateAdjust
+     http://www.lavrsen.dk/twiki/bin/view/Motion/FramerateAdjust
    * Fixed a bug in the autobrightness algorithm (Per Johnsson)
    * Fixed a bug in the webhttpd code related to pan/tilt. Bug was introduced in
      snap4 (Angel Carpintero, Kenneth Lavrsen).
    * Improved the labelling algorithm so that locate feature and tracking features
      includes all labelled areas above threshold (Joerg Weber).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/ImprovedLabellingPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/ImprovedLabellingPatch
    * Fixed bug reporting errors when creating symlink to last snap (Bill Maidment)
    * Changed all use of localtime to localtime_r which is threadsafe
      (Kenneth Lavrsen).
    * Implemented a modified version of the WebcamCompressInMemory so that Motion
      no longer uses the tmpfile() function for buffering the frames of the mjpeg
      stream (Peter Holik).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/WebcamCompressInMemory
+     http://www.lavrsen.dk/twiki/bin/view/Motion/WebcamCompressInMemory
    * Modified the WebcamCompressInMemory patch so that Motion now supports the
      mjpeg webcam stream while being setup for saving PPM images (Kenneth Lavrsen).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/WebcamCompressInMemory
+     http://www.lavrsen.dk/twiki/bin/view/Motion/WebcamCompressInMemory
    * Major clean-up of code in picture.c and webcam.c so that function names and
      variable names are less confusing. Also added many comments in picture.c.
      (Kenneth Lavrsen).
@@ -787,13 +915,13 @@ snap6
 
 snap7
    * Implemented WebcamShortWriteHandling patch (Bill Brack)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/WebcamShortWriteHandlingPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/WebcamShortWriteHandlingPatch
    * Implemented the libjpeg-mmx patch. Installing the MMX version of libjpeg
      can increase performance. Especially for machines with very little CPU power.
      It only modifies the configure script. If you do not have the libjpeg-mmx
      the configure script with ignore this and use the standard libjpeg.
      Note that RPMS will be built without this (Peter Holik and Angel Carpintero).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/LibJpegMmx
+     http://www.lavrsen.dk/twiki/bin/view/Motion/LibJpegMmx
 
 snap8
    * Small code cleanup in webcam.c and picture.c and .h for the webcam code
@@ -803,19 +931,19 @@ snap8
      overflow every 71 minutes. (Bill Brack and Kenneth Lavrsen)
    * Implemented a fix/work around to a bug related to building and installing
      RPMs on Suse. (Paul Beltrani)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x07x14x212356
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x07x14x212356
    * Small speed optimization in the creation of reference frame (Peter Holik).
    * Complete rewrite of the Netcam code. Should fix many of the reported and
      still open netcam bugs. This is first release in a snapshot. Expect to find
      bugs. Testing is important. If you have a netcam please test this and report
      bugs.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/NetcamCodeRewritePatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/NetcamCodeRewritePatch
 
 snap9
    * Fixed bug related to disabled webcam or duplicate webcam port. Error log
      accept(): Socket operation on non-socket continuously written to syslog.
      (Kenneth Lavrsen)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x08x01x150922
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x08x01x150922
    * Fixed memory leak in webhttpd related to use of strdup (Angel Carpintero).
    * Improved the error reporting in the Netcam code and did a few minor
      corrections and code cleanups (Bill Brack).
@@ -823,21 +951,21 @@ snap9
      calls to printf and syslog. The implementation to actually use this has been
      implemented in video.c and the Netcam code files. Rest will be in next snap.
      This code change as no impact to the user (Bill Brack).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/ErrorLoggingEnhancementPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/ErrorLoggingEnhancementPatch
    * Fixed a bug in video.c so that VIDEO_PALETTE_GREY cameras now actually work
      (Bill Brack).
    * Implemented the conversion of signal to sigaction which should be more
      thread safe. Hopefully this still keeps Motion from making Zombies.
      (Christophe Grenier).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/ConvertSignalToSigaction
+     http://www.lavrsen.dk/twiki/bin/view/Motion/ConvertSignalToSigaction
    * Added new feature: Double size text. A new config option 'text_double' can
      be set 'on' and this scales the text to double size. Default is off.
      (Andrew Hamilton).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/TextScalingPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/TextScalingPatch
 
 snap10
    * Error Logging Enhancement Patch v 1.3 (Angel Carpintero) including:
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/ErrorLoggingEnhancementPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/ErrorLoggingEnhancementPatch
       * Populate the motion_log to the whole motion source code.
       * Fixed FreeBSD compilation.
       * Added the possibility to pass NULL as struct context *
@@ -853,9 +981,9 @@ snap10
       * fixed bug where initialization would be incomplete for invalid degrees
         of rotation
       * now uses motion_log for error reporting
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/RotateBswapFix
+     http://www.lavrsen.dk/twiki/bin/view/Motion/RotateBswapFix
    * Re-mplementation of optional Proxy Server for Network Cameras (Bill Brack).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/NetcamProxyServerPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/NetcamProxyServerPatch
    * Included a CODE_STANDARD text file to help new developers make patches
      that are easier to integrate without too much manual editing. (Kenneth
      Lavrsen)
@@ -864,7 +992,7 @@ snap10
 snap11
    * Updated the ffmpeg.c code so that Motion can now be built with ffmpeg CVS
      release from the June/July 2005 timeframe (Per Jönsson).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/FfmpegCodecPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/FfmpegCodecPatch
    * Improved error handling of missing picture frames from camera. Especially
      network cameras will often not be able to provide a picture frame from time
      to time. Motion would retry before and eventually and rather quickly exit
@@ -884,12 +1012,12 @@ snap11
         "Without Locking" portion of his proposal).
      Version 2 however does not seems to recover when an mjpeg stream resumes
      after a period of not being available. (Bill Brack)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/NetcamErrorImprovementPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/NetcamErrorImprovementPatch
    * Note: Snap11 release as a developer sync release. Bug reports welcome.
      FreeBSD code changes not tested yet.
 
 Release
-   * Netcam error handling improvements and cleanup from Walgrind analysis
+   * Netcam error handling improvements and cleanup from Valgrind analysis
      (Bill Brack).
    * Added a configure option --with-developer-flags which enables many compiler
      warnings that can be used by developers to make code more robust. Not
@@ -897,12 +1025,12 @@ Release
    * http-control: Fixed segfault when motion is restarted from command line
      ( kill -s 1 pid_motion ). Improved control code so Motion can Restart and
      Finish 'smoothly'. (Angel Carpintero).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionHttpControl
+     http://www.lavrsen.dk/twiki/bin/view/Motion/MotionHttpControl
    * Changed the 5 second missed camera signal timeout to 30 seconds. (Kenneth
      Lavrsen)
    * Fixed bug where an extra jpeg is saved if you have output_normal=best
      and you stop motion after an event has ended. (Kenneth Lavrsen)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x08x05x173526
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x08x05x173526
 
 
 
@@ -910,19 +1038,19 @@ Release
 snap1
    * Major new feature. XMLRPC is replaced by a simpler http remote control
      interface (implemented by Angel Carpintero)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionHttpControl
+     http://www.lavrsen.dk/twiki/bin/view/Motion/MotionHttpControl
 
 snap2
    * Fixed netcam->userpass problem (Angel Carpintero)
    * Added support in configure for athlon64 from
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x01x30x190907
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x01x30x190907
      (Angel Carpintero and William M Brack)
    * Fixed some gcc warnings (William M Brack)
    * Code cleanup from a valgrind analysis (William M. Brack).
 
 snap3
    * Added Best Preview Patch (Joerg Weber)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BestPreviewShot
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BestPreviewShot
 
 snap4
    * Fix for tracking control with http control (Angel Carpintero)
@@ -932,7 +1060,7 @@ snap4
      for daemon mode debugging.
      The patch is still being worked on and is not finished.
      Changes in the FreeBSD code are not yet tested.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/SetupModePatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/SetupModePatch
      Remove most command line options and replace them by an option to specify
      location to motion.conf and a few options related to setting up motion.
      (Joerg Weber). This is also included in SetupModePatch.
@@ -948,7 +1076,7 @@ snap5
 
 snap6
    * Netcam fixes and debug code by Christopher Price
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/NetcamStabilityPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/NetcamStabilityPatch
      snap5_post1_video.c and snap5-post1 patches
    * Fixed netcam startup race condition.
    * Refactored image handling back to single unified function
@@ -1017,20 +1145,20 @@ snap9
 snap10
    * Fixed a problem when compiling with --without-v4l configuration.
      (Philip Marien)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x03x27x112843
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x03x27x112843
    * Threw away the file descriptor leak fix from snap 9 because it caused
      more trouble than it fixed. Removed the close_anything_open() and the
      cnt_list.control_socket_server field. Replaced it all with a simple
      piece of code that all server daemons call when started: setsid() followed
      by for (i=getdtablesize(); i>2; --i) close(i). Dirty and simple.
      (Kenneth Lavrsen)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x03x21x070534
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x03x21x070534
    * Fixed a bug where rate of fetching picture frames was disturned by
      the signal SIG_CHLD from exec_command programs terminating. The symptom
      was that the number of post_capture frames became inaccurate and motion
      in mpegs did not have constant time between frames. (Kenneth Lavrsen)
    * Fixed a bug where motion did not work with gap=1 (Kenneth Lavrsen).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x01x30x073616
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x01x30x073616
    * Added the feature gap=0 which now also works. It disables gap completely
      so that one single mpeg file is created. You can end the event from the
      remote control interface make movie feature using for example cron.
@@ -1058,11 +1186,11 @@ snap11
      Movie starts (mpeg file opened) --- onmpeg --- on_movie_start
      Movie ends (mpeg file closed) --- onffmpegclose --- on_movie_end
      Motion detected  --- New! --- on_motion_detected
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/OnXxxCommandsPatch and
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/OnXxxxFeatureDiscussion
+     http://www.lavrsen.dk/twiki/bin/view/Motion/OnXxxCommandsPatch and
+     http://www.lavrsen.dk/twiki/bin/view/Motion/OnXxxxFeatureDiscussion
      (Joerg Weber)
    * More Netcam Stability Fixes (snap10-post1-6) (Christopher Price)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/NetcamStabilityPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/NetcamStabilityPatch
       * Destroy mutexes in netcam_cleanup().
       * Add reconnection for netcam_start() - this may block other cameras
          from starting up!.
@@ -1093,11 +1221,11 @@ snap11
 
 snap12
    * Fixed a bug in the rgb2yuv420p function. (Daniel Ladd)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x03x30x011107
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x03x30x011107
    * Fixed a bug of locate feature for movement images combined with the
      new output_normal best feature (Joerg Weber)
    * More Netcam Stability Fixes (snap11-post1-4) (Christopher Price)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/NetcamStabilityPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/NetcamStabilityPatch
       * Reworked thread signal/wait conditions, should fix some race conditions.
       * Use gettimeofday() to determine thread timeouts, results in better accuracy.
       * Adjusted condition timeouts to smaller values due to usage of gettimeofday()
@@ -1112,7 +1240,7 @@ snap12
       * Fix bug in streaming camera without content-length, recent mod broke.
       * Fix bug in startup of single image reads without content-length.
    * Motion Guide refactored completely for 3.2.1 with better web navigation and
-     auto generation of pages. Makefile updated so that the Motion Foswiki topic
+     auto generation of pages. Makefile updated so that the Motion TWiki topic
      MotionGuideOneLargeDocument is fetched when updating the guide and making
      releases. (Kenneth Lavrsen).
 
@@ -1135,7 +1263,7 @@ snap13
       * Userpass now allowed in url (http://user:pass@example.com/).
        Netcam_userpass has precedence, it will override a userpass embedded in
        the url.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/NetcamStabilityPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/NetcamStabilityPatch
 
 snap14
    * Added basic authentication to the http control interface introducing new
@@ -1150,30 +1278,30 @@ snap14
 snap15
    * Added new feature which shows the fixed mask (in addition to the smart mask)
      in bright red on the Motion type images (Joerg Weber).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/FixedMaskFileOnMotionImagesPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/FixedMaskFileOnMotionImagesPatch
    * Added new feature. When you specify a mask file in the config file and start
      Motion, and the mask file does not exist, Motion will create a new clear
      (white) mask file for you in the right size. Then it is easy to simply
      open the file in your favourite paint program and add the masking in black
      (Joerg Weber).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/FixedMaskFileOnMotionImagesPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/FixedMaskFileOnMotionImagesPatch
    * Fixed a bug in the low_cpu feature where cpu load increased instead of
      decreasing because the framerate calculations were completely wrong. This was
      an old bug introduced in 3.0.1 (Kenneth Lavrsen).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x04x24x205933
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x04x24x205933
    * Improved the auto-brightness algorithm. When auto-brightness is enabled
      the brightness option becomes a target value for the brightness level.
      This should also close a bug report (Kenneth Lavrsen).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x02x26x195358
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x02x26x195358
    * http interface small fixes (motion-3.2.1_snap14-small-fixes 1.1) incl
      Add 'back' link to response_client errors (Angel Carpintero).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionHttpControl
+     http://www.lavrsen.dk/twiki/bin/view/Motion/MotionHttpControl
    * Started adding tuner_number as option. This is not fully implemented. First
      code is added and rest will be done in next snap. (Kenneth Lavrsen)
 
 snap16
    * Made the http control interface more RFC compliant (Angel Carpintero).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x05x02x180550
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x05x02x180550
    * Made the http control HTML responses nicer to look at as sources and
      therefore easier to debug errors (Kenneth Lavrsen).
    * Code style cleanup of webhttpd.c (Kenneth Lavrsen).
@@ -1182,23 +1310,23 @@ snap16
      Carpintero. However this fix made Firefox flicker even more than it normally
      does. Final fix which works in both Palantir client, Firefox and Cambozola
      was made by Kenneth Lavrsen. This closes the following bugs:
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x05x02x205307,
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x05x07x042849
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x05x02x205307,
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x05x07x042849
 
 snap17
    * Fixed small bug when pre_capture buffer is resized during operation.
      (Joerg Weber).
    * In httpd control code: Fixed RAW syntax following API specs. (Angel
      Carpintero).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionHttpControl
+     http://www.lavrsen.dk/twiki/bin/view/Motion/MotionHttpControl
    * Added new conversion specifiers: %D (diffs), (noise) %K (motion center x),
      %L (motion center y), %i (locate width x) and %J (locate width y). These
      changes also required a refactoring of the alg_locate code. This change
      is part of the implementation of a generic tracking feature and it enables
      implementing external programs that can perform simple prediction features.
      (Kenneth Lavrsen)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/ExtendReplaceConversionSpecifiersDiscussion
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/GenericTrackingPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/ExtendReplaceConversionSpecifiersDiscussion
+     http://www.lavrsen.dk/twiki/bin/view/Motion/GenericTrackingPatch
    * Fixed a bug in switchfilter which caused motion detection to not work
      when the feature was enabled (Kenneth Lavrsen).
 
@@ -1206,26 +1334,26 @@ Release
    * Change the working directory to / in daemon mode. This way you don't have
      to kill motion to umount the partition from where you start it. (Christophe
      Grenier)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/ChdirNetCamWgetPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/ChdirNetCamWgetPatch
    * In netcam-wget header_get() didn't always in add a \0 string terminator.
      This was fixed by Christophe Grenier
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/ChdirNetCamWgetPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/ChdirNetCamWgetPatch
    * Fix for Unknown content type with lumenera cameras (Kenneth Lavrsen)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x05x06x174416
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x05x06x174416
    * MotionHttpControl Patch motion-3.2.1_snap18-pre1 v,1.0 19 May 2005.
      Fixed some HTTP response codes and added header copyrights. (Angel Carpintero).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionHttpControl
+     http://www.lavrsen.dk/twiki/bin/view/Motion/MotionHttpControl
    * Implemented pthread fix by Christophe Grenier.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/PthreadFixPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/PthreadFixPatch
    * Fixed problem compiling "ffmpeg reports only YUV420 is supported" when
      ffmpeg is a recent CVS version.     (Angel Carpintero)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x05x22x213229
-   * Man page updated. It is now semi-autogenerated in the Motion Foswiki
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x05x22x213229
+   * Man page updated. It is now semi-autogenerated in the Motion TWiki
      (Kenneth Lavrsen)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionOptionsAlphabeticalManpage
+     http://www.lavrsen.dk/twiki/bin/view/Motion/MotionOptionsAlphabeticalManpage
    * Bug fix in netcam code: Sometimes motion try to free an invalid memory area
      (Angel Carpintero)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x05x21x105335
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x05x21x105335
    * Small configure fix related to --without-v4l (Angel Carpintero)
    * Fixes for http control HTML code (Angel Carpintero)
    * Added init script to RPM (Angel Carpintero)
@@ -1235,15 +1363,15 @@ Release
 snap1
    * Fixed bug which caused Motion 3.1.18 fail to save timelapse mpegs when
      setting ffmpeg_timelapse = 1 (fixed by Michael Reuschling)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x01x31x211756
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x01x31x211756
    * Fixed several bugs in new netcam code introduced in 3.1.18
      (Angel Carpintero)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x01x16x030209
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x02x01x071546
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x02x03x035918
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x01x16x030209
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x02x01x071546
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x02x03x035918
    * Added patch that enables Motion to work with vloopback version 0.94
      and kernel 2.6.10+. (patch by William M Brack).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionAndVloopbackVideoDotCPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/MotionAndVloopbackVideoDotCPatch
 
 snap2
    * Following bugfixes all by Angel Carpintero
@@ -1307,17 +1435,17 @@ Detailed changes for all 3.1.18 snapshot
 snap1
    * Removed the Berkeley mpeg feature (code commented out)
    * Implemented a bugfixed version of
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BrightnessContrastPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BrightnessContrastPatch
      Released as snapshot for developers to merge other patches.
      The snap1 is not recommended for normal use.
 
 snap2
    * Improved the Makefile with automatic check of dependencies and
      nicer output for the user.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/MakefileWithAutoDependencies
+     http://www.lavrsen.dk/twiki/bin/view/Motion/MakefileWithAutoDependencies
    * Implemented first phase of the rotate patch. Need to fix the storage
      method for image height and width
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/RotatePatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/RotatePatch
 
 snap3
    * Implemented phase 2 of the rotate patch
@@ -1327,7 +1455,7 @@ snap4
    * Added the new smart mask feature. It is working but it is still under
      development. It currently outputs an extra smart mask timelapse movie
      when the normal timelapse is enabled. This will be removed in the final
-     version. http://www.lavrsen.dk/foswiki/bin/view/Motion/PatchSmartMask
+     version. http://www.lavrsen.dk/twiki/bin/view/Motion/PatchSmartMask
    * Added a new config option --without-optimizecpu which disables the
      CPU specific compiler optimizations introduced with the rotate phase 2
      patch. The purpose of the new option is to enable a packager to build
@@ -1344,7 +1472,7 @@ snap4
      getting lost when saving with xmlrpc. For text_left and text_right
      Motion now puts the string in quotation marks if the value starts with
      a leading space.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2004x10x24x135840
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2004x10x24x135840
 
 snap5
    * Implemented the November 10 update for smartmask
@@ -1353,7 +1481,7 @@ snap5
 
 snap6
    * Merged in the DilateNineSpeedPatch
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/DilateNineSpeedPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/DilateNineSpeedPatch
    * Changed a few image char definitions to unsigned char. Still many to fix.
 
 snap7
@@ -1364,10 +1492,10 @@ snap7
      The patch is now in ReleasedScheduled state for 3.1.18.
    * Implemented Angel Carpintero's FreeBSD auto-detection CPU/ARCH fix.
    * Merged in Per Johnsson's DilateFiveSpeedPatch
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/DilateFiveSpeedPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/DilateFiveSpeedPatch
    * Removed the prediction feature from the code (commented out for now).
    * Included fix by Jan X.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2004x11x13x202132
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2004x11x13x202132
 
 snap8
    * Implemented an improvement of Smartmask so that the mask is cleared when
@@ -1377,40 +1505,40 @@ snap8
    * Improved the picture control function so that cameras are only probed
      when needed to avoid USB errors. (Kenneth Lavrsen)
    * Implemented new ffmpeg patch (Per Jönsson)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/FfmpegPatch049
+     http://www.lavrsen.dk/twiki/bin/view/Motion/FfmpegPatch049
    * Implemented new preview patch (Joerg Weber)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/PreviewShotsPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/PreviewShotsPatch
    * Removed commented code from obsolete Berkeley and Prediction features
    * Implemented labelling speed patch (Per Jönsson)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/LabelingSpeedPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/LabelingSpeedPatch
 
 snap9
    * Implemented Streaming Netcam Without Curl which enables connecting to
      network cameras both with single jpeg frame mode and streaming mjpeg
      mode. This enables much higher framerates with Netcams. (by Christopher
      Price and Angel Carpintero).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/StreamingNetcamWithoutCurl
+     http://www.lavrsen.dk/twiki/bin/view/Motion/StreamingNetcamWithoutCurl
    * Implemented a significant speed improvement in the motion detection
      algorithm (by Per Jönsson).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/AlgDiffStandardMmxPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/AlgDiffStandardMmxPatch
    * Fixed a small bug which caused in jumpy mpeg1 videos with ffmpeg 0.4.8.
 
 snap10
    * Corrected a small error in the usage help text
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x01x05x174139
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x01x05x174139
    * Improved the help text for config option night_compensate in docs,
      conf.c, motion man pages and config file.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x01x06x103939
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x01x06x103939
    * Improved the Netcam patch (Angel Carpintero)
-     http://www.lavrsen.dk/foswiki/pub/Motion/StreamingNetcamWithoutCurl/
+     http://www.lavrsen.dk/twiki/pub/Motion/StreamingNetcamWithoutCurl/
      (pre2 patch fixes problem with not detecting Content-length and segfaults
      in netcam)
    * Improved the signal handling of ctrl-C as suggested by Per Jonsson
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x01x06x181426
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x01x06x181426
    * Implemented a POSIX compliant SIGCHLD signal handler as replacement for
      the traditional signal(SIGCHLD, SIG_IGN) which can cause floods of
      warnings in some RedHat versions. (Angel Carpintero and Kenneth Lavrsen)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2004x10x26x134906
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2004x10x26x134906
    * Changed the reporting of the changes of noise detection level so that
      it is only displayed in the console (daemon off) when the always_changes
      option is enabled. (Kenneth Lavrsen)
@@ -1423,7 +1551,7 @@ snap11
    * The noise tune value displayed in the upper left corner along with
      number of changed pixels is no longer displayed (was there for debugging).
    * Improved the Netcam patch (Angel Carpintero)
-     http://www.lavrsen.dk/foswiki/pub/Motion/StreamingNetcamWithoutCurl/
+     http://www.lavrsen.dk/twiki/pub/Motion/StreamingNetcamWithoutCurl/
      (pre3 reconnection feature added)
    * Changed the SIGCHLD handler introduced in snap10 so that it is a shorter
      and faster function. Disabled this handler in the xmlrpc thread as this
@@ -1434,7 +1562,7 @@ snap11
      very high or the time was changes by ntp. Motion will now catch up a few
      seconds later if this happens. Also fixed the code for monthly rollover
      (Kenneth Lavrsen).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x01x23x133554
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x01x23x133554
 
 Release
    * Fixed a bug in the timelapse feature. Both the rollover events of the
@@ -1442,7 +1570,7 @@ Release
      very high or the time was changes by ntp. Motion will now catch up a few
      seconds later if this happens. Also fixed the code for monthly rollover
      (Kenneth Lavrsen).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x01x23x133554
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x01x23x133554
    * Small improvement in timelapse feature so that an image is added when
      the new mpeg is created and not waiting till the following timelapse
      (Kenneth Lavrsen).
@@ -1456,15 +1584,15 @@ snap1
      when Motion receives SIGTERM or SIGHUB.
    * Implemented fix for compiling errors when building the FreeBSD version
      without bktr support.
-     (http://www.lavrsen.dk/foswiki/bin/view/Motion/FreeBSDFixCompile)
+     (http://www.lavrsen.dk/twiki/bin/view/Motion/FreeBSDFixCompile)
    * Commented out many unnecessary syslog debug only messages. The commented
      out code was first patched by Mike Lees patch related to syslog causing
      instability and hanging motion processes.
-     (http://www.lavrsen.dk/foswiki/bin/view/Motion/SyslogEventPatch).
+     (http://www.lavrsen.dk/twiki/bin/view/Motion/SyslogEventPatch).
    * Included Kalle Andersson's patch that ensures that Motion detaches from
      the stdin and stout devices so that a secure shell that was used to start
      Motion in daemon mode does not hang when you exit the shell.
-     (http://www.lavrsen.dk/foswiki/bin/view/Motion/DaemonDetachFromSTDIO)
+     (http://www.lavrsen.dk/twiki/bin/view/Motion/DaemonDetachFromSTDIO)
 
 snap2
    * Implemented a new lightswitch feature so that is now triggers lightswitch
@@ -1797,7 +1925,7 @@ rc1
      is in "idle" mode.
    * added Kenneth's patch: motion with ffmpeg-0.4.8 now compiles
      again!
-   * small optimalisation: if a file is created, the path is now
+   * small optimisation: if a file is created, the path is now
      only recreated when it did not already exist.
 
 
@@ -2083,7 +2211,7 @@ van Heusden (http://www.vanheusden.com/)
       -locate is on by default (-l function now works reversed)
       -night_compensate is on by default
      Added mpeg framerate adjustment.
-     Added night_compenstate for dark pictures.
+     Added night_compensate for dark pictures.
 
 2.0     froze 2.0
      Integrated motion tracking.
--- motion-3.2.12.orig/CODE_STANDARD
+++ motion-3.2.12/CODE_STANDARD
@@ -17,7 +17,8 @@ void * mymalloc(size_t nbytes)
     void *dummy = malloc(nbytes);
     if (!dummy) {
         printf("Could not allocate %llu bytes of memory!\n", (unsigned long long) nbytes);
-        syslog(LOG_EMERG, "Could not allocate %llu bytes of memory!", (unsigned long long) nbytes);
+        syslog(EMERG, TYPE_ALL, "%s: Could not allocate %llu bytes of memory!", 
+               __FUNCTION__, (unsigned long long) nbytes);
         exit(1);
     }
     
@@ -41,8 +42,8 @@ void * mymalloc(size_t nbytes)
     if (!dummy) {
         printf("Could not allocate %llu bytes of memory!\n",
                (unsigned long long) nbytes);
-        syslog(LOG_EMERG, "Could not allocate %llu bytes of memory!",
-               (unsigned long long) nbytes);
+        syslog(EMERG, TYPE_ALL,"Could not allocate %llu bytes of memory!",
+               __FUNCTION__, (unsigned long long) nbytes);
         exit(1);
     }
     
--- motion-3.2.12.orig/CREDITS
+++ motion-3.2.12/CREDITS
@@ -32,14 +32,14 @@ Ryan Ayers
 Paul Beltrani
    * Implemented a fix/work around to a bug related to building and installing
      RPMs on Suse.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x07x14x212356
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x07x14x212356
 
 Michael Newlyn Blake
    * For setting up the motion mailinglist and the onsave command.
 
 Krzysztof Blaszkowski
    * Removed a duplicate call to jpeg_destroy_decompress already is called from netcam_image_conv. 
-   * Added V4L2 support http://www.lavrsen.dk/foswiki/bin/view/Motion/VideoForLinuxTwoDiscussion, (Krzysztof Blaszkowski, Angel Carpintero).
+   * Added V4L2 support http://www.lavrsen.dk/twiki/bin/view/Motion/VideoForLinuxTwoDiscussion, (Krzysztof Blaszkowski, Angel Carpintero).
 
 Mathias Bogaert
    * Lots of good ideas and the motion logos
@@ -47,30 +47,30 @@ Mathias Bogaert
 William M Brack
    * Added patch that enables Motion to work with vloopback version 0.94
      and kernel 2.6.10+.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionAndVloopbackVideoDotCPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/MotionAndVloopbackVideoDotCPatch
    * Added support in configure for athlon64 from
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x01x30x190907
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x01x30x190907
      (Angel Carpintero and William M Brack)
    * Fixed some gcc warnings
    * Code cleanup from a valgrind analysis.
    * Implemented WebcamShortWriteHandling patch
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/WebcamShortWriteHandlingPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/WebcamShortWriteHandlingPatch
    * Small code cleanup in motion.c for the variable holding the number of
      microseconds since epoch. The old code worked fine but relied on an integer
      overflow every 71 minutes. (Bill Brack and Kenneth Lavrsen)
    * Complete rewrite of the Netcam code. Should fix many of the reported and
      still open netcam bugs.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/NetcamCodeRewritePatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/NetcamCodeRewritePatch
    * Improved the error reporting in the Netcam code and did a few minor
      corrections and code cleanups.
    * Implemented a much easier to use motion_log function which replaces the
      calls to printf and syslog. The implementation to actually use this has been
      implemented in video.c and the Netcam code files. Rest will be in next snap.
      This code change as no impact to the user.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/ErrorLoggingEnhancementPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/ErrorLoggingEnhancementPatch
    * Fixed a buf in video.c so that VIDEO_PALETTE_GREY cameras now actually work.
    * Re-mplementation of optional Proxy Server for Network Cameras.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/NetcamProxyServerPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/NetcamProxyServerPatch
    * Added the missing rotate feature in the new netcam code (Billl Brack)
    * Netcam error handling improvements and cleanup from Valgrind analysis.
    * Added a configure option --with-developer-flags which enables many compiler
@@ -80,7 +80,7 @@ William M Brack
      ./configure --with-developer-flags.
      The modifications were done by the following people: Peter Holik, Bill Brack,
      Angel Carpintero and Kenneth Lavrsen.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/ReduceWarningsPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/ReduceWarningsPatch
    * Fixed error message with unknown config option.
    * Enhanced compatibility with Lumenera.
    * Moved the motion_loop initialization into a new function motion_init.
@@ -89,17 +89,17 @@ William M Brack
    * Last --with-developer-flags warnings eliminated simply by swapping the
      order of the #include statements in the sources (Bill Brack and Kenneth Lavrsen).
    * Enhancement to Netcam Code for Connection to Pixord Cameras.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/NetcamFixPixordBug
+     http://www.lavrsen.dk/twiki/bin/view/Motion/NetcamFixPixordBug
    * Fix related to connecting to the netcam. From mailing list 23 Dec 2005.
    * Fixed problem related to fetching images from Network camera and error
      handling when it fails. Motion would end in infinite loops.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2006x03x10x000151
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2006x03x10x000151
    * Fix conv_uyvyto420p segfault.
    * Enhancing the palette selection.
 
 John Bray
    * Get current directory to allow write motion.conf properly 
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2008x02x25x013419
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2008x02x25x013419
 
 Andy Brown 
    * Add swf codec to video creation (on behalf of Bowser Pete).
@@ -130,21 +130,21 @@ Angel Carpintero
      mode. This enables much higher framerates with Netcams. (with
      Christopher Price).
    * Improved the Netcam patch (Angel Carpintero)
-     http://www.lavrsen.dk/foswiki/pub/Motion/StreamingNetcamWithoutCurl/
+     http://www.lavrsen.dk/twiki/pub/Motion/StreamingNetcamWithoutCurl/
      (pre2 patch fixes problem with not detecting Content-length and segfaults
      in netcam)
    * Implemented a POSIX compliant SIGCHLD signal handler as replacement for
      the traditional signal(SIGCHLD, SIG_IGN) which can cause floods of
      warnings in some RedHat versions. (with Kenneth Lavrsen)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2004x10x26x134906
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2004x10x26x134906
    * Improved the Netcam patch (Angel Carpintero)
-     http://www.lavrsen.dk/foswiki/pub/Motion/StreamingNetcamWithoutCurl/
+     http://www.lavrsen.dk/twiki/pub/Motion/StreamingNetcamWithoutCurl/
      (pre3 reconnection feature added)
    * Fixed several bugs in new netcam code introduced in 3.1.18
      (Angel Carpintero)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x01x16x030209
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x02x01x071546
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x02x03x035918
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x01x16x030209
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x02x01x071546
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x02x03x035918
    * Netcam code: Change printf() to fprintf().
    * Netcam code: Cleanup memory netcam (netcam.c , motion.c ).
    * Netcam code: Redesign of reconnection feature.
@@ -154,10 +154,10 @@ Angel Carpintero
    * Added fix to BugReport2005x02x11x150802
    * Major new feature. XMLRPC is replaced by a simpler http remote control
      interface.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionHttpControl
+     http://www.lavrsen.dk/twiki/bin/view/Motion/MotionHttpControl
    * Fixed netcam->userpass problem
    * Added support in configure for athlon64 from
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x01x30x190907
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x01x30x190907
      (Angel Carpintero and William M Brack)
    * Updated code so Motion again runs on FreeBSD.
    * Removed check for memmem from configure.
@@ -174,42 +174,42 @@ Angel Carpintero
      (string) by submitting blank entry field in the http control interface.
    * http interface small fixes (motion-3.2.1_snap14-small-fixes 1.1) incl
      Add 'back' link to response_client errors.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionHttpControl
+     http://www.lavrsen.dk/twiki/bin/view/Motion/MotionHttpControl
    * Made the http control interface more RFC compliant.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x05x02x180550
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x05x02x180550
    * Fixed compatibility problem with Palantir. Fixed by making output more
      compatible with RFC (\r\n). Original fixes by Roberto Spadim and Angel
      Carpintero. However this fix made Firefox flicker even more than it normally
      does. Final fix which works in both Palantir client, Firefox and Cambozola
      was made by Kenneth Lavrsen. This closes the following bugs:
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x05x02x205307,
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x05x07x042849
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x05x02x205307,
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x05x07x042849
    * In httpd control code: Fixed RAW syntax following API specs.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionHttpControl
+     http://www.lavrsen.dk/twiki/bin/view/Motion/MotionHttpControl
    * MotionHttpControl Patch motion-3.2.1_snap18-pre1 v,1.0 19 May 2005.
      Fixed some HTTP response codes and added header copyrights.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionHttpControl
+     http://www.lavrsen.dk/twiki/bin/view/Motion/MotionHttpControl
    * Fixed problem compiling "ffmpeg reports only YUV420 is supported" when
      ffmpeg is a recent CVS version.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x05x22x213229
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x05x22x213229
    * Bug fix in netcam code: Sometimes motion try to free an invalid memory area
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x05x21x105335
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x05x21x105335
    * Small configure fix related to --without-v4l.
    * Fixes for http control HTML code.
    * Added init script to RPM.
    * Pthread deadlock in motion 3.2.1 fixed.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x05x26x125712
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x05x26x125712
    * http lockup bugfixes and ConvertSignalToSigaction only for webhttpd
    * alg_draw_location: Use temporary variables to store the values used in
      for() loops instead of compute them in each loop
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/ImproveAlgDrawLocation.
+     http://www.lavrsen.dk/twiki/bin/view/Motion/ImproveAlgDrawLocation.
    * Small speed boost to the function draw_textn (Andrew Hamilton and
      Angel Carpintero).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/DrawTextnImprovement
+     http://www.lavrsen.dk/twiki/bin/view/Motion/DrawTextnImprovement
    * Avoid Cleanup Segfault. Avoid Cleanup Segfault. Allocates filepath using
      strdup to avoid segfault is target_dir parameter is not supplied in
      motion.conf. Moves out from signal handler the cleanup for pipe and mpipe.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/AvoidCleanupSegfault
+     http://www.lavrsen.dk/twiki/bin/view/Motion/AvoidCleanupSegfault
    * Changed the configure script so that rpms can be made by normal non-root
      users.
    * Above change in configure script for 64 bit ffmpeg support also implemented
@@ -222,7 +222,7 @@ Angel Carpintero
      It only modifies the configure script. If you do not have the libjpeg-mmx
      the configure script with ignore this and use the standard libjpeg.
      Note that RPMS will be built without this (Peter Holik and Angel Carpintero).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/LibJpegMmx
+     http://www.lavrsen.dk/twiki/bin/view/Motion/LibJpegMmx
    * Fixed memory leak in webhttpd related to use of strdup.
    * Error Logging Enhancement Patch v 1.3 including:
       * Populate the motion_log to the whole motion source code.
@@ -234,25 +234,25 @@ Angel Carpintero
       * Fixed a bug when not motion.conf is found
       * Removed printf from all files
       * Fixed the conf_list[] index in motion.c
-      * http://www.lavrsen.dk/foswiki/bin/view/Motion/ErrorLoggingEnhancementPatch
+      * http://www.lavrsen.dk/twiki/bin/view/Motion/ErrorLoggingEnhancementPatch
    * http-control: Fixed segfault when motion is restarted from command line
      ( kill -s 1 pid_motion ). Improved control code so Motion can Restart and
      Finish 'smoothly'. 
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionHttpControl.
+     http://www.lavrsen.dk/twiki/bin/view/Motion/MotionHttpControl.
    * Fixed a bug in the http control code that failed to accept a client
      connecting in some systems
    * Removed all warnings originating from the motion sources when running
      ./configure --with-developer-flags.
      The modifications were done by the following people: Peter Holik, Bill Brack,
      Angel Carpintero and Kenneth Lavrsen.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/ReduceWarningsPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/ReduceWarningsPatch
    * Fixed small mistake in allocating memory for cnt->imgs.common_buffer.
    * http control updated: (null) messages replaced by "disabled", last parameter
      in conf/list are displayed correctly and only in Main thread. When motion runs
      with only one thread, it displays "No threads".
    * http control: selectbox instead of a textfield for changing boolean configs
      (Peter Holik and Angel Carpintero)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/WebhttpEnhancements.
+     http://www.lavrsen.dk/twiki/bin/view/Motion/WebhttpEnhancements.
    * Added the debian sub directory so that people can build the deb package.
    * Sync configure.in.freebsd (adding support for jpeg-mmx, developer-flags and
      some cosmetic changes ).
@@ -271,20 +271,20 @@ Angel Carpintero
       * Cleanup code and fix warnings.
    * Implemented fix to configure so that LDFLAGS from the environment are used
      when making the Makefile.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x09x15x185558
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x09x15x185558
    * Changed configure so that --with-jpeg-mmx is default off as a reaction to
      known problems seen when using the jpeg-mmx library.
    * Added the %t conversion specifier to show the thread number.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/ThreadConversionSpecifierPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/ThreadConversionSpecifierPatch
    * Fixed bug related to init of mutex in netcam code.
    * Netcam_ftp code fixes (Angel Carpintero and Asbjørn Pettersen)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/NetcamWithFtpEnhancements
+     http://www.lavrsen.dk/twiki/bin/view/Motion/NetcamWithFtpEnhancements
    * Enhanced ffmpeg detection.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BetterFFmpegDetection
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BetterFFmpegDetection
    * New Feature: Motion is now also supported on MaxOSX with similar
      feature set as for Free BSD. See README.MacOSX for details how to install
      it. (Angel Carpintero)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/MacOSXPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/MacOSXPatch
    * Added a work-around so people in FreeBSD that uses a capture card
      where input 1 is not tuner can use motion if frequency is set -1 in
      motion.conf or thread#.conf.
@@ -298,28 +298,28 @@ Angel Carpintero
       * Remove a warning when used --without-bktr
       * Remove cpu optimization (is broken)
    * Fixed http control of pan and tilt.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x12x22x122649
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x12x22x122649
    * Fixed sql_mask not initialised correctly
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2006x01x09x175603 
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2006x01x09x175603 
    * Fixed the management of strings from http remote control , setting to NULL
      when they are set to "blank" and fixes a problem with despeckle , that didn't
      allow to remove labeling action from http remote control. 
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/FixStringsAndDisableLabeling
+     http://www.lavrsen.dk/twiki/bin/view/Motion/FixStringsAndDisableLabeling
    * Fix many typos in comments ( i ran aspell against the code ). Also there's a
      fix to free cnt->eventtime_tm when motion exits.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/FixTypoInComments
+     http://www.lavrsen.dk/twiki/bin/view/Motion/FixTypoInComments
    * Fix the problem that happens in FreeBSD and Debian Sarge because
      version of ffmpeg is LIBAVFORMAT_BUILD < 4629. ( Pete Shipley and Angel Carpintero)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2006x01x12x120335
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2006x01x12x120335
    * Updated motion.spec. Changing D_FORTIFY_SOURCE=2 by D_FORTIFY_SOURCE=1 to fix
      problem related to building with ffmpeg. (Angel Carpintero) 
    * Added Tilt support to stepper track.
    * Fixed mysql configure auto-detection for x64 systems.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/SupportQuestion2006x03x02x152208
+     http://www.lavrsen.dk/twiki/bin/view/Motion/SupportQuestion2006x03x02x152208
    * Fixed a bug that only allowed remote control of max 9 cameras. Now
      Motion can present up to 99 cameras in its http remote control interface
      (Angel Carpintero based on idea by Chuck Sheehan)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/WebHttpManyThreads
+     http://www.lavrsen.dk/twiki/bin/view/Motion/WebHttpManyThreads
    * Removed annoying debug messages (v4l_set_input really needed ?) in the FreeBSD
      version.
    * Added new feature: minimum_frame_time which enables capturing at a lower rate
@@ -331,97 +331,112 @@ Angel Carpintero
      safe functions in ffmpeg
    * Put a new global mutex around avcodec_close to avoid problems with not thread
      safe functions in ffmpeg.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2006x04x07x164654
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2006x04x07x164654
    * On FreeBSD configure defines a redundant freebsd for motion. Fixed by replacing
      -D__freebsd_ by BSD macro  included in sys/param.h for BSD platforms.
      (JukkaUkkonen and Angel Carpintero)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2006x07x08x070417
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2006x07x08x070417
    * For BSD platforms changed to using native pthreads as default and adding
      linuxthreads as a optional parameter from configure.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2006x07x08x071646
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2006x07x08x071646
    * Added process_id_file feature
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/FeatureRequest2006x06x06x123003
+     http://www.lavrsen.dk/twiki/bin/view/Motion/FeatureRequest2006x06x06x123003
    * Add connection status for all devices available from http web interface.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/FeatureRequest2006x11x09x050638
+     http://www.lavrsen.dk/twiki/bin/view/Motion/FeatureRequest2006x11x09x050638
    * Improved deb packaging , install the init.d script.
    * Reconnect to mysql if connection dropped.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2006x10x10x081903	
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2006x10x10x081903	
    * Track pan/tilt support for uvcvideo ( Michal Licko ,Dirk Wesenberg and Angel Carpintero )
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/LinuxUvcTrackingPatch
-   * Added V4L2 support http://www.lavrsen.dk/foswiki/bin/view/Motion/VideoForLinuxTwoDiscussion, (Krzysztof Blaszkowski, Angel Carpintero).
+     http://www.lavrsen.dk/twiki/bin/view/Motion/LinuxUvcTrackingPatch
+   * Added V4L2 support http://www.lavrsen.dk/twiki/bin/view/Motion/VideoForLinuxTwoDiscussion, (Krzysztof Blaszkowski, Angel Carpintero).
    * Added support for V4L2_PIX_FMT_SBGGR8 ( bayer ), V4L2_PIX_FMT_SN9C10X, V4L2_PIX_FMT_MJPEG and V4L2_PIX_FMT_UYVY. 
    * Added a FreeBSD directory to allow people from BSD to get a daily version and create a port. 
    * Removed mysql dependency from debian package and added a note to setup motion to run as daemon to create the pid file.
-   * Changed the way configure search mysql headers and libs, added 3 parameters to configure --without-mysql to disable support, --with-  mysql-include directory of mysql.h and --with-mysql-lib directory of libmysqlclient.a or libmysqlclient.so
+   * Changed the way configure search mysql headers and libs, added 3 parameters to configure --without-mysql to disable support, 
+     --with-mysql-include directory of mysql.h and --with-mysql-lib directory of libmysqlclient.a or libmysqlclient.so
    * Fix an error in FreeBSD , the use of capture even fields depends on height value.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2006x12x03x073610
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2006x12x03x073610
    * Fixed autodetection for VIA cpu , no needed to use --without-optimizecpu. Added many others.
    * Fix , don't remove pid file when motion reload config file( HUP signal ).
    * Fix compilation broken by uvc track type.
    * Fix RoundRobin v4l2 buffers in driver when switching input,
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2007x07x07x182605
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2007x07x07x182605
      (Dag Erlandsson and Angel Carpintero).
    * Check EIO for VIDIOC_DQBUF to workaround saa7134 problem.
      (Dag Erlandsson and Angel Carpintero).
    * Change bayer2rgb24() to fix a problem with sn9c102 driver
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2007x06x05x012249
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2007x06x05x012249
      (Jared D and Angel Carpintero).  
    * Added MYSQL_OPT_RECONNECT flag for mysql connection (MYSQL 5.x only) and 
      changed default value for mysql_host.
    * Fix http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=391055 , change
      motion man page , -d requires level.
    * Handle mjpeg decoding and fix colour issue adding mjpegtools dependency
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/MjpegColorIssue
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/MjpegToYUV420pPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/MjpegColorIssue
+     http://www.lavrsen.dk/twiki/bin/view/Motion/MjpegToYUV420pPatch
      (Marius Rieder, Angel Carpintero).
    * Fix segfault in webhttpd.c on motion restart.
-   * Fix segfault in debian http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2007x09x24x175945  
+   * Fix segfault in debian http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2007x09x24x175945  
    * Add debug level > 5 to get logs from v4l2_select_input, v4l2_set_control and v4l2_set_input.
    * Removed debian ( to avoid conflicts with debian package) and FreeBSD
      ( no needed to deploy BSD port here ) directories.
    * Improve debian package, create user/group motion and added --chuid motion to init script.
-   * Added help in http control http://www.lavrsen.dk/foswiki/bin/view/Motion/FeatureRequest2007x11x19x181541
-   * Fixed http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2007x10x23x093651
+   * Added help in http control http://www.lavrsen.dk/twiki/bin/view/Motion/FeatureRequest2007x11x19x181541
+   * Fixed http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2007x10x23x093651
    * Fix process_id_file when is passed from command line 
-   * Fix http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2007x10x27x150419
-   * Added Choose V4L2 palette http://www.lavrsen.dk/foswiki/bin/view/Motion/FeatureRequest2007x11x19x032318
+   * Fix http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2007x10x27x150419
+   * Added Choose V4L2 palette http://www.lavrsen.dk/twiki/bin/view/Motion/FeatureRequest2007x11x19x032318
    * Improved in http control ( 'back' link, select box, show current values when are going to be changed ). 
-   * Fix http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2007x11x25x102808
+   * Fix http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2007x11x25x102808
    * Avoid random errors , initialising some structs for V4L1 
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2007x11x26x010755 (Jason Sharpee & Angel Carpintero)
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2007x11x26x010755 (Jason Sharpee & Angel Carpintero)
    * Fix motion segfault because ffmpeg API change
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/SupportQuestion2007x12x29x17553
+     http://www.lavrsen.dk/twiki/bin/view/Motion/SupportQuestion2007x12x29x17553
    * Little fix in ffmpeg.c comparing version of LIBAVFORMAT_BUILD, since ffmpeg svn -r4486 LIBAVFORMAT_BUILD and 
      LIBAVCODEC_BUILD uses LIBAVFORMAT_VERSION_INT ((49<<16)+(0<<8)+0) and LIBAVCODEC_VERSION_INT ((49<<16)+(0<<8)+0)
    * Fix broken PostgreSQL detection for custom location,
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2008x02x25x025134
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2008x02x25x025134
    * Fixed stepper when is used track_auto on.
    * Added to configure.in --with-pwcbsd to allow compile motion in freebsd with webcam support instead of bktr.
+   * IPV6 for http-control and webcam stream not netcam yet http://www.lavrsen.dk/twiki/bin/view/Motion/IPv6
+     (Jeroen Massar & Angel Carpintero)
    * Fix a security issue in web control interface http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=484572
    * Fix Problem Encoding 1280x1024 resolution videos
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/SupportQuestion2008x06x11x183727
-   * Remove mjpegtools dependencies and integrate only needed functions from library.
-   * Fix rotate for v4l2 devices using JPEG / MJPEG palettes.
-   * Allow change/setup framerate in FreeBSD using pwcbsd.
+     http://www.lavrsen.dk/twiki/bin/view/Motion/SupportQuestion2008x06x11x183727
+   * Add write/read nonblock functions in webhttpd( timeout on read/write).
    * Add a new parameter netcam_tolerant_check, to be less strict with some buggy network cameras firmwares.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2008x06x19x123218
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2008x06x19x123218
+   * Remove mjpegtools dependencies and integrate only needed functions from library.  
+   * Fix rotate for v4l2 devices using JPEG / MJPEG palettes.
+   * External pipe to allow external video encoders 
+     http://www.lavrsen.dk/twiki/bin/view/Motion/DarkwindHackeronMotionPatching (Bill Payne, Angel Carpintero)
+   * Allow change/setup framerate in FreeBSD using pwcbsd
    * Get rid of ffmpeg-config in configure.in for debian.
    * Fix warning for x86_64 in conf.c using pointers LP64 compliant.
-   * Fix fd leaks in external pipe. 
-   * Avoid possible stack smashing in v4l_open_vidpipe(). 
+   * Fix warning for syslog() , Added support for some new bayer palettes introduced in kernel 2.6.27.
+     http://www.lavrsen.dk/twiki/bin/view/Motion/FeatureRequest2008x10x15x130110
+     Increased buffer in ffmpeg to allow encoding at 1600x1200
+   * Avoid possible stack smashing in v4l_open_vidpipe().
    * Allow compile with OpenSuse ffmpeg package (15594svn-20081010)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/SupportQuestion2008x10x25x070400
-   * Better detection of ffmpeg  
-     http://www.lavrsen.dk/foswiki/pub/Motion/ReleaseNoteMotion3x2x11/ffmpeg-detection.diff.gz 
-     (Angel Carpintero) 
-   * Fix warning for syslog().
+     http://www.lavrsen.dk/twiki/bin/view/Motion/SupportQuestion2008x10x25x070400
+   * Avoid segfault detecting strerror_r() version GNU or SUSv3.
+   * Fix fd leaks in external pipe. 
    * Fix segfault for new libjpeg v7.
+   * Allow to change Standard method ( PAL / NECAM / SECAM ).
+   * Exit when image dimension are not modulo 16.
+   * Avoid logs flooding using some options of netcam_keepalive and try to discard images with
+     weird header Content-Lenght 0.
+   * Only use post capture when we setup to record videos with external pipe or ffmpeg.
    * Fixed FFV1 codec encode with ffmpeg.
      http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2010x04x13x032553
+   * No PQfinish().
+   * Added a conditional check for avformat_alloc_context , av_avformat_alloc_context to fix
+     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2011x10x05x071936
+   * Added a new starting option -m to disable motion detection.
  
 Jared D
    * Change bayer2rgb24() to fix a problem with sn9c102 driver
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2007x06x05x012249
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2007x06x05x012249
      (Jared D and Angel Carpintero).
 
 John Edwards
@@ -429,23 +444,30 @@ John Edwards
 
 Dag Erlandsson
    * Fix RoundRobin v4l2 buffers in driver when switching input,
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2007x07x07x182605
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2007x07x07x182605
      (Dag Erlandsson and Angel Carpintero).
    * Check EIO for VIDIOC_DQBUF to workaround saa7134 problem.
      (Dag Erlandsson and Angel Carpintero). 
    * Added the pre_capture buffer redesign to throttle load and enhance pre_capture feature.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/PreCaptureRedesign
+     http://www.lavrsen.dk/twiki/bin/view/Motion/PreCaptureRedesign
    * Fixed a problem with locate and fixed mask overlay
    * Added preview center feature.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/PreviewCenter
+     http://www.lavrsen.dk/twiki/bin/view/Motion/PreviewCenter
    * Fixed timestamp for preview pictures.
+   * Insert Blanking frames http://www.lavrsen.dk/twiki/bin/view/Motion/FeatureRequest2007x12x16x132522
      
 Stephen Farrugia
    * Fixing the division by zero problem.
      This makes motion a lot more stable.
 
+Michael Finsterbusch
+
+   * Add authentication  methods 'Basic Authentication' and 'Digest Authentication' 
+     to the "Live Stream Server". 
+     http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionStreamAuthPatch
+
 Mark Feenstra
-   * Fix zombies on OpenBSD. 
+   * Fix zombies on OpenBSD.
      http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2010x04x28x054348
 
 Miguel Freitas
@@ -455,6 +477,9 @@ Aaron Gage
    * Pointed me to the vid_mmap/int problem when calling SYNC in
      video.c
 
+Giacomo Graziosi
+   * Sqlite3 support http://www.lavrsen.dk/twiki/bin/view/Motion/SQLite3Patch
+
 Christophe Grenier
    * Fixed some file descriptor leaks in webcam.c and netcam.c.
    * Renamed the top level global context structure to cnt_list so it can be
@@ -467,15 +492,15 @@ Christophe Grenier
      Kenneth Lavrsen.
    * Change the working directory to / in daemon mode. This way you don't have
      to kill motion to umount the partition from where you start it.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/ChdirNetCamWgetPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/ChdirNetCamWgetPatch
    * In netcam-wget header_get() didn't always in add a \0 string terminator.
      This was fixed.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/ChdirNetCamWgetPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/ChdirNetCamWgetPatch
    * Made a pthread fix.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/PthreadFixPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/PthreadFixPatch
    * Implemented the conversion of signal to sigaction which should be more
      thread safe. Hopefully this still keeps Motion from making Zombies.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/ConvertSignalToSigaction
+     http://www.lavrsen.dk/twiki/bin/view/Motion/ConvertSignalToSigaction
 
 Mihnea-Costin Grigore
    * Fixed the oldlayout behaviour of snapshots.
@@ -485,7 +510,7 @@ Mihnea-Costin Grigore
 
 Alain Guidez
    * Fix of ffmpeg_avcodec_log code.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2007x03x25x074612
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2007x03x25x074612
 
 Jan Gyselinck
    * Original time/date-stamp code.
@@ -502,37 +527,38 @@ Steffen Haas
 Andrew Hamilton
    * Small speed boost to the function draw_textn (Andrew Hamilton and
      Angel Carpintero).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/DrawTextnImprovement
+     http://www.lavrsen.dk/twiki/bin/view/Motion/DrawTextnImprovement
    * Added new feature: Double size text. A new config option 'text_double' can
      be set 'on' and this scales the text to double size. Default is off.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/TextScalingPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/TextScalingPatch
    * Fixed memory leak in ffmpeg code.
    * Added the ffmpeg_deinterlace feature
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionffmpegDeinterlace 
+     http://www.lavrsen.dk/twiki/bin/view/Motion/MotionffmpegDeinterlace 
    * Added FFV1 ( FF video codec 1 ) codec , Lossless encoding
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/LosslessEncoding 
+     http://www.lavrsen.dk/twiki/bin/view/Motion/LosslessEncoding 
    * Added mov , Quicktime file format (Andrew Hamilton).
 
 Gerrit Hannaert
-    * Fix v4l2_palette http://www.lavrsen.dk/foswiki/bin/view/Motion/UvcvideoMjpegPatch
+
+   * Fix v4l2_palette http://www.lavrsen.dk/twiki/bin/view/Motion/UvcvideoMjpegPatch
 
 Peter Holik
    * Netcam First Header patch. If an error with jpeg decompression occurred at
      connecting to a mjpeg streaming webcam, this patch skips this jpeg and tries
      to decompress next jpeg up to MAX_HEADER_RETRIES (20).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/NetcamFirstHeader
+     http://www.lavrsen.dk/twiki/bin/view/Motion/NetcamFirstHeader
    * Small improvement in framerate accuracy.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/FramerateAdjust
+     http://www.lavrsen.dk/twiki/bin/view/Motion/FramerateAdjust
    * Implemented a modified version of the WebcamCompressInMemory so that Motion
      no longer uses the tmpfile() function for buffering the frames of the mjpeg
      stream.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/WebcamCompressInMemory
+     http://www.lavrsen.dk/twiki/bin/view/Motion/WebcamCompressInMemory
    * Implemented the libjpeg-mmx patch. Installing the MMX version of libjpeg
      can increase performance. Especially for machines with very little CPU power.
      It only modifies the configure script. If you do not have the libjpeg-mmx
      the configure script with ignore this and use the standard libjpeg.
      Note that RPMS will be built without this (Peter Holik and Angel Carpintero).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/LibJpegMmx
+     http://www.lavrsen.dk/twiki/bin/view/Motion/LibJpegMmx
    * Small code cleanup in webcam.c and picture.c and .h for the webcam code
      (Peter Holik and Kenneth Lavrsen).
    * Small speed optimization in the creation of reference frame.
@@ -540,22 +566,27 @@ Peter Holik
      ./configure --with-developer-flags.
      The modifications were done by the following people: Peter Holik, Bill Brack,
      Angel Carpintero and Kenneth Lavrsen.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/ReduceWarningsPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/ReduceWarningsPatch
    * Implemented a speed-up patch of the draw text feature.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/DrawTextspeedup
+     http://www.lavrsen.dk/twiki/bin/view/Motion/DrawTextspeedup
    * http control: selectbox instead of a textfield for changing boolean configs
      (Peter Holik and Angel Carpintero).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/WebhttpEnhancements.
+     http://www.lavrsen.dk/twiki/bin/view/Motion/WebhttpEnhancements.
    * Introduced check for device image size being a multiple of 16.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/NetcamModulo16Patch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/NetcamModulo16Patch
    * Fixed netcamera bug related to separating frames in an mjpeg stream.
      From mailing list 23 Dec 2005.
    * Avoid open file descriptor when connecting to network cameras fails 
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/AvoidOpenfiledescriptors
+     http://www.lavrsen.dk/twiki/bin/view/Motion/AvoidOpenfiledescriptors
    * Fix Segfault on reload or quit for vloopback (maybe other v4l1 devices too)
      http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2009x06x17x090603
    * Fix warning for __USE_GNU redefined
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2009x06x17x122137
+     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2009x06x17x122137  
+   * Use static memory allocation in ffmpeg_deinterlace()
+     http://www.lavrsen.dk/foswiki/bin/view/Motion/FfmpegDeinterlaceStatic
+   * Atom optimizacion in configure.in 
+     http://www.lavrsen.dk/foswiki/bin/view/Motion/AtomOptimizations
+
 
 Wesley Hosking
    * For pointing me to the absence of a frame length check using
@@ -569,15 +600,15 @@ Per Jönsson
    * Added the rotate feature.
    * Improved the Makefile with automatic check of dependencies and
      nicer output for the user.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/MakefileWithAutoDependencies
+     http://www.lavrsen.dk/twiki/bin/view/Motion/MakefileWithAutoDependencies
    * Improved rotate feature (speed)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/RotatePatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/RotatePatch
    * Implemented new ffmpeg patch
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/FfmpegPatch049
+     http://www.lavrsen.dk/twiki/bin/view/Motion/FfmpegPatch049
    * Implemented labelling speed patch
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/LabelingSpeedPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/LabelingSpeedPatch
    * Improved the signal handling of ctrl-C
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x01x06x181426
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x01x06x181426
    * Fixed the ffmpeg code so that Motion also compiles against libavcodec
      build 4754 or later.
    * Fixed a bug in the autobrightness algorithm.
@@ -587,28 +618,28 @@ Per Jönsson
       * fixed bug where initialization would be incomplete for invalid degrees
         of rotation
       * now uses motion_log for error reporting
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/RotateBswapFix
+     http://www.lavrsen.dk/twiki/bin/view/Motion/RotateBswapFix
    * Implemented Threadnr in TLS (thread-local storage)patch. It puts the thread
      number into TLS and modifies motion_log() so that we do not have to drag the
      cnt struct around just to be able to print the thread number in the log and
      on the console. (Per Jönsson with additional removal of unused cnt by
      Kenneth Lavrsen).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/ThreadNrTlsPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/ThreadNrTlsPatch
    * Simplified rotation code based on the fact that images must have dimensions
      that are a multiple of 16.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/RotateSimplificationPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/RotateSimplificationPatch
 
 Mike Kenney
    * Implemented a fix for the rare problem where some experienced that the
      move file names would only consist of the extension .mpg or .avi with no
      name in front. The root cause was the use of sprintf for appending to
      strings. (Mike Kenney and Kenneth Lavrsen)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/SupportQuestion2005x09x05x133031
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/SupportQuestion2006x06x19x174238
+     http://www.lavrsen.dk/twiki/bin/view/Motion/SupportQuestion2005x09x05x133031
+     http://www.lavrsen.dk/twiki/bin/view/Motion/SupportQuestion2006x06x19x174238
 
 Rafis Khayrullin
    * Fix memory management in ffmpeg.c 
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2006x12x19x062432
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2006x12x19x062432
 
 Matthias Kilian
    * Configure patch which enables configure to find and use a
@@ -616,7 +647,7 @@ Matthias Kilian
 
 Daniel Ladd
    * Fixed a bug in the rgb2yuv420p function.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x03x30x011107
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x03x30x011107
 
 Kenneth Lavrsen (Currently project managing Motion)
    * Wrote the excellent Motion Guide. (Jeroen wrote this :-) )
@@ -720,14 +751,14 @@ Kenneth Lavrsen (Currently project manag
    * Fixed a bug in netcam_start() - wrong imgs.size calculation.
    * Removed the obsolete Berkeley mpeg feature.
    * Corrected a small error in the usage help text
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x01x05x174139
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x01x05x174139
    * Improved the help text for config option night_compensate in docs,
      conf.c, motion man pages and config file.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x01x06x103939
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x01x06x103939
    * Implemented a POSIX compliant SIGCHLD signal handler as replacement for
      the traditional signal(SIGCHLD, SIG_IGN) which can cause floods of
      warnings in some RedHat versions. (with Angel Carpintero)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2004x10x26x134906
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2004x10x26x134906
    * Changed the reporting of the changes of noise detection level so that
      it is only displayed in the console (daemon off) when the always_changes
      option is enabled. (Kenneth Lavrsen)
@@ -746,7 +777,7 @@ Kenneth Lavrsen (Currently project manag
      very high or the time was changes by ntp. Motion will now catch up a few
      seconds later if this happens. Also fixed the code for monthly rollover.
      (Kenneth Lavrsen)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x01x23x133554
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x01x23x133554
    * Small improvement in timelapse feature so that an image is added when
      the new mpeg is created and not waiting till the following timelapse
      (Kenneth Lavrsen).
@@ -786,13 +817,13 @@ Kenneth Lavrsen (Currently project manag
      cnt_list.control_socket_server field. Replaced it all with a simple
      piece of code that all server daemons call when started: setsid() followed
      by for (i=getdtablesize(); i>2; --i) close(i). Dirty and simple.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x03x21x070534
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x03x21x070534
    * Fixed a bug where rate of fetching picture frames was disturned by
      the signal SIG_CHLD from exec_command programs terminating. The symptom
      was that the number of post_capture frames became inaccurate and motion
      in mpegs did not have constant time between frames.
    * Fixed a bug where motion did not work with gap=1.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x01x30x073616
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x01x30x073616
    * Added the feature gap=0 which now also works. It disables gap completely
      so that one single mpeg file is created. You can end the event from the
      remote control interface make movie feature using for example cron.
@@ -806,7 +837,7 @@ Kenneth Lavrsen (Currently project manag
    * Improvements of motion.conf help comments including improvements in new
      onxxxx options.
    * Motion Guide refactored completely for 3.2.1 with better web navigation and
-     auto generation of pages. Makefile updated so that the Motion Foswiki topic
+     auto generation of pages. Makefile updated so that the Motion TWiki topic
      MotionGuideOneLargeDocument is fetched when updating the guide and making
      releases.
    * Removed the debug_parameter option which had no use. Programmers can still
@@ -822,11 +853,11 @@ Kenneth Lavrsen (Currently project manag
    * Fixed a bug in the low_cpu feature where cpu load increased instead of
      decreasing because the framerate calculations were completely wrong. This was
      an old bug introduced in 3.0.1.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x04x24x205933
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x04x24x205933
    * Improved the auto-brightness algorithm. When auto-brightness is enabled
      the brightness option becomes a target value for the brightness level.
      This should also close a bug report.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x02x26x195358.
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x02x26x195358.
    * Made the http control HTML responses nicer to look at as sources and
      therefore easier to debug errors.
    * Code style cleanup of webhttpd.c.
@@ -835,22 +866,22 @@ Kenneth Lavrsen (Currently project manag
      Carpintero. However this fix made Firefox flicker even more than it normally
      does. Final fix which works in both Palantir client, Firefox and Cambozola
      was made by Kenneth Lavrsen. This closes the following bugs:
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x05x02x205307,
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x05x07x042849
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x05x02x205307,
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x05x07x042849
    * Added new conversion specifiers: %D (diffs), (noise) %K (motion center x),
      %L (motion center y), %i (locate width x) and %J (locate width y). These
      changes also required a refactoring of the alg_locate code. This change
      is part of the implementation of a generic tracking feature and it enables
      implementing external programs that can perform simple prediction features.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/ExtendReplaceConversionSpecifiersDiscussion
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/GenericTrackingPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/ExtendReplaceConversionSpecifiersDiscussion
+     http://www.lavrsen.dk/twiki/bin/view/Motion/GenericTrackingPatch
    * Fixed a bug in switchfilter which caused motion detection to not work
      when the feature was enabled.
    * Fix for Unknown content type with lumenera cameras
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x05x06x174416
-   * Man page updated. It is now semi-autogenerated in the Motion Foswiki
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionOptionsAlphabeticalManpage
-   * Added two new conversion specifiers: %o for threshold and %Q for number
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x05x06x174416
+   * Man page updated. It is now semi-autogenerated in the Motion TWiki
+     http://www.lavrsen.dk/twiki/bin/view/Motion/MotionOptionsAlphabeticalManpage
+   * Added two new convertion specifiers: %o for threshold and %Q for number
      of labels.
    * Improved the config file description for pre_capture to get people to
      use small values.
@@ -868,7 +899,7 @@ Kenneth Lavrsen (Currently project manag
    * Changed all use of localtime to localtime_r which is threadsafe.
    * Modified the WebcamCompressInMemory patch so that Motion now supports the
      mjpeg webcam stream while being setup for saving PPM images.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/WebcamCompressInMemory
+     http://www.lavrsen.dk/twiki/bin/view/Motion/WebcamCompressInMemory
    * Major clean-up of code in picture.c and webcam.c so that function names and
      variable names are less confusing. Also added many comments in picture.c.
    * Webcam code commented more.
@@ -884,26 +915,26 @@ Kenneth Lavrsen (Currently project manag
      overflow every 71 minutes. (Bill Brack and Kenneth Lavrsen)
    * Fixed bug related to disabled webcam or duplicate webcam port. Error log
      accept(): Socket operation on non-socket continuously written to syslog.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x08x01x150922
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x08x01x150922
    * Included a CODE_STANDARD text file to help new developers make patches
      that are easier to integrate without too much manual editing.
    * Changed the 5 second missed camera signal timeout to 30 seconds.
    * Fixed bug where an extra jpeg is saved if you have output_normal=best
      and you stop motion after an event has ended. (Kenneth Lavrsen).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x08x05x173526
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x08x05x173526
    * Option switch filter used print_int instead of print_bool when motion.conf
      was saved.
    * Removed all warnings originating from the motion sources when running
      ./configure --with-developer-flags.
      The modifications were done by the following people: Peter Holik, Bill Brack,
      Angel Carpintero and Kenneth Lavrsen.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/ReduceWarningsPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/ReduceWarningsPatch
    * Implemented Threadnr in TLS (thread-local storage)patch. It puts the thread
      number into TLS and modifies motion_log() so that we do not have to drag the
      cnt struct around just to be able to print the thread number in the log and
      on the console. (Per Jönsson with additional removal of unused cnt by
      Kenneth Lavrsen).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/ThreadNrTlsPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/ThreadNrTlsPatch
    * Removed old unused code related to read mode (not mmap) from V4L devices.
    * Motion loop resets its frame timer when the image received is from a netcam.
      This lowers the actual framerate of Motion to the rate the netcam can actually
@@ -925,7 +956,7 @@ Kenneth Lavrsen (Currently project manag
      string when no event is in progress (gap period expired). Pre_captured
      and minimum_motion_frames images are time stamped before the event happens
      so %C in text_left/right does not have any effect on those images.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/EventConvertionSpecifierDiscussion
+     http://www.lavrsen.dk/twiki/bin/view/Motion/EventConvertionSpecifierDiscussion
    * Renamed some variables related to time to be better descriptive of function
      and type.
    * Added new option 'sql_user_text'. This can be defined with the same
@@ -937,7 +968,7 @@ Kenneth Lavrsen (Currently project manag
    * The lightswitch and switchfilter features have been moved up before the
      despeckle features are run. This should ensure that both algorithms work on
      raw unfiltered motion pixels which they both were designed for.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x10x05x212444
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x10x05x212444
    * Added help texts in conf.c and motion-dist.conf describing the %t
      specifier. Added a good example of use in motion-dist.conf.
    * Added two new conversion specifiers: %f which is filename (full path)
@@ -973,7 +1004,7 @@ Kenneth Lavrsen (Currently project manag
    * Restored the function sigchild_handler so it contains the same code
      as before motion-3.2.1_snap9. They is done in an attempt to fix an old
      problem with zombie child processes that has shown up again.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x11x13x115016
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x11x13x115016
    * Move the declaration of sig_handler_action and sigchild_action from
      the setup_signals function where they are local and will be destroyed
      and out in main just before setup_signals is called. Changed the
@@ -993,39 +1024,39 @@ Kenneth Lavrsen (Currently project manag
      is re-enabled the minute the camera is standing still again. Feature
      originally made by Moshe Van Der Sterre. Kenneth Lavrsen extended it to
      be more generic.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/PwcConfiguration
+     http://www.lavrsen.dk/twiki/bin/view/Motion/PwcConfiguration
    * Implemented fix for missed snapshots with slow network cameras
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2006x02x07x162149
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2006x02x07x162149
    * Added some constants in video.c function v4l_picture_controls() which can help
      people hack an optimal set of values for controlling auto brightness for their
      particular camera. For now I am do not want to add all of these to the already
      too large number of motion config options. Maybe based on feedback we can
      permanently change the constants and add an additional auto brightness option.
      Or maybe a combined option that sets more constant based on an algorithm.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2006x02x07x212816
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2006x02x07x212816
    * Fixed a syntax error in picture.c get_pgm() which caused the program to segfault 
      when a mask file size did not match the picture size. Now the program
      correctly gives an error message and continues without the mask.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x10x08x150720
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x10x08x150720
    * ffmpeg_filename has changed name to movie_filename to prepare for
      alternative movie encoding to the current ffmpeg based implementation
      and ffmpeg_filename will then be a bad name.
    * Fixed bug where variables time_last_frame and time_current_frame had been
      extended to also be used for snapshot feature but declaration was hidden
      between #ifdef HAVE_FFMPEG.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2006x03x09x012244
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2006x03x09x012244
    * text_changes now shows a '-' when motion detection is paused instead of
      just showing 0
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/FeatureRequest2006x03x16x095713
+     http://www.lavrsen.dk/twiki/bin/view/Motion/FeatureRequest2006x03x16x095713
    * Improved reporting of thread numbers during startup in setup mode.
      (Peter Smith and Kenneth Lavrsen)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/SlightlyImprovedThreadCreationLogging
+     http://www.lavrsen.dk/twiki/bin/view/Motion/SlightlyImprovedThreadCreationLogging
    * Implemented a fix for the rare problem where some experienced that the
      move file names would only consist of the extension .mpg or .avi with no
      name in front. The root cause was the use of sprintf for appending to
      strings. (Mike Kenney and Kenneth Lavrsen)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/SupportQuestion2005x09x05x133031
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/SupportQuestion2006x06x19x174238
+     http://www.lavrsen.dk/twiki/bin/view/Motion/SupportQuestion2005x09x05x133031
+     http://www.lavrsen.dk/twiki/bin/view/Motion/SupportQuestion2006x06x19x174238
    * Altered the risky use of sprintf to snprintf in all places related to
      use with config strings that can become very long.
    * Removed the minimum_gap feature which was utterly useless
@@ -1045,11 +1076,20 @@ Mike Lees
    * Fixed a serious stability issue related to syslog not being a fully
      re-entrant function.
    * Implemented the new brightness, contrast, hue, saturation features
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BrightnessContrastPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BrightnessContrastPatch
+
+Wim Lewis
+
+   * Added EXIF feature for jpeg images , http://www.lavrsen.dk/foswiki/bin/view/Motion/ExifTaggingPatch
 
 Michal Licko
    * Track pan/tilt support for uvcvideo ( Michal Licko ,Dirk Wesenberg and Angel Carpintero )
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/LinuxUvcTrackingPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/LinuxUvcTrackingPatch
+
+Michael Luich
+
+   * Added codec Ogg/Theora as new output format for regular movies.
+     http://www.lavrsen.dk/foswiki/bin/view/Motion/OggTimelapse
 
 Bill Maidment
    * Fixed bug reporting errors when creating symlink to last snap.
@@ -1057,6 +1097,10 @@ Bill Maidment
 Philip Marien
    * Fixed a problem when compiling with --without-v4l configuration.
 
+Jeroen Massar
+   * IPV6 for http-control and webcam stream not netcam yet http://www.lavrsen.dk/twiki/bin/view/Motion/IPv6
+     (Jeroen Massar & Angel Carpintero)
+
 Lionnel Maugis
    * ffmpeg code
 
@@ -1091,17 +1135,21 @@ nullset?
    * For the ir script to turn motion and lights on and of
 
 Onakra
-   * Fix choose v4l2 palette , http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2008x01x21x043812
+   * Fix choose v4l2 palette , http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2008x01x21x043812
 
 Mikko Paananen
    * Changed netcam open to use pipes and fixed authentication.
 
+Bill Payne,
+   * External pipe to allow external video encoders 
+     http://www.lavrsen.dk/twiki/bin/view/Motion/DarkwindHackeronMotionPatching (Angel Carpintero, Bill Payne)
+
 Bowser Pete
    * Add swf codec to video creation.
 
 Asbjørn Pettersen
    * Netcam_ftp code fixes (Angel Carpintero and Asbjørn Pettersen)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/NetcamWithFtpEnhancements
+     http://www.lavrsen.dk/twiki/bin/view/Motion/NetcamWithFtpEnhancements
 
 Pawel Pierscionek
    * Signal blocking during ioctls.
@@ -1120,9 +1168,9 @@ Christopher Price
      network cameras both with single jpeg frame mode and streaming mjpeg
      mode. This enables much higher framerates with Netcams. (with Angel
      Carpintero).
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/StreamingNetcamWithoutCurl
+     http://www.lavrsen.dk/twiki/bin/view/Motion/StreamingNetcamWithoutCurl
    * Netcam fixes and debug code by Christopher Price
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/NetcamStabilityPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/NetcamStabilityPatch
    * snap5_post1_video.c and snap5-post1 patches
       * Fixed netcam startup race condition.
       * Refactored image handling back to single unified function
@@ -1137,7 +1185,7 @@ Christopher Price
       * Added support for netcams without content-length header (streaming only)
       * Remove memmem from netcam_wget.[c|h] (no longer used)
       * Several miscellaneous code cosmetic changes
-   * Netcam Stabilty Patch version 3.2.1-snap7-post1
+   * Netcam Stability Patch version 3.2.1-snap7-post1
       * Added support for non-streaming (image based) netcams without
         content-lengthheader.
    * Contributed code for new function in event.c close_anything_open()
@@ -1146,7 +1194,7 @@ Christopher Price
      causing freezing and instability. Code contributed by Christophe Grenier,
      Christopher Price and Kenneth Lavrsen.
    * More Netcam Stability Fixes (snap10-post1-6)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/NetcamStabilityPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/NetcamStabilityPatch
       * Destroy mutexes in netcam_cleanup().
       * Add reconnection for netcam_start() - this may block other cameras
         from starting up!.
@@ -1173,7 +1221,7 @@ Christopher Price
       * Rearranged timeout assignments for pthread_cond_timedwait() calls.
       * Adjusted TIMEOUT_COND_WHICH to 4 seconds.
    * More Netcam Stability Fixes (snap11-post1-4) (Christopher Price)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/NetcamStabilityPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/NetcamStabilityPatch
       * Reworked thread signal/wait conditions, should fix some race conditions.
       * Use gettimeofday() to determine thread timeouts, results in better accuracy.
       * Adjusted condition timeouts to smaller values due to usage of gettimeofday()
@@ -1188,7 +1236,7 @@ Christopher Price
       * Fix bug in streaming camera without content-length, recent mod broke.
       * Fix bug in startup of single image reads without content-length.
    * More Netcam Stability Fixes (snap12-post1) (Christopher Price)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/NetcamStabilityPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/NetcamStabilityPatch
       * Newrote url parser, better syntax checking and error handling of urls.
       * Userpass now allowed in url (http://user:pass@example.com/).
         Netcam_userpass has precedence, it will override a userpass embedded in
@@ -1206,15 +1254,19 @@ rasca
 Michael Reuschling
    * Fixed bug which caused Motion 3.1.18 fail to save timelapse mpegs when
      setting ffmpeg_timelapse = 1 (fixed by Michael Reuschling)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x01x31x211756
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x01x31x211756
 
 Petter Reinholdtsen
    * Adding the install option to the makefile.
 
+Isaac Richte
+   * V4L2 fourcc GRBG not supported, updated default value for v4l2_palette 17.
+     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2009x10x29x222753
+
 Marius Rieder
    * Handle mjpeg decoding and fix colour issue adding mjpegtools dependency
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/MjpegColorIssue
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/MjpegToYUV420pPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/MjpegColorIssue
+     http://www.lavrsen.dk/twiki/bin/view/Motion/MjpegToYUV420pPatch
      (Marius Rieder, Angel Carpintero).
 
 James A. Russo.
@@ -1227,29 +1279,29 @@ James A. Russo.
 
 Jason Sharpee
    * Avoid random errors , initialising some structs for V4L1
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2007x11x26x010755 (Jason Sharpee & Angel Carpintero)   
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2007x11x26x010755 (Jason Sharpee & Angel Carpintero)   
 
 
 Pete Shipley
    * Fix the problem that happens in FreeBSD and Debian Sarge because
      version of ffmpeg is LIBAVFORMAT_BUILD < 4629. ( Angel Carpintero and Pete Shipley)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2006x01x12x120335
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2006x01x12x120335
 
 Gunnar Skjold     
    * Fixed http pause feature so that pausing thread 0 now pauses all threads.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2006x07x10x111239
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2006x07x10x111239
 
 Peter Smith
    * Improved reporting of thread numbers during startup in setup mode.
      (Peter Smith and Kenneth Lavrsen)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/SlightlyImprovedThreadCreationLogging
+     http://www.lavrsen.dk/twiki/bin/view/Motion/SlightlyImprovedThreadCreationLogging
    * Ffmpeg code mutex locking fix
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2006x04x07x164654
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2006x04x07x164654
    * Ffmpeg avicodec logging improved (Peter Smith and Kenneth Lavrsen)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/FfmpegAvicodecLogging
+     http://www.lavrsen.dk/twiki/bin/view/Motion/FfmpegAvicodecLogging
    * Improved upon a few ambiguous log messages which may be emitted by the Event
      handling code with regards to Ffmpeg (Peter Smith)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/LoggingEventFix
+     http://www.lavrsen.dk/twiki/bin/view/Motion/LoggingEventFix
 
 Roberto Spadim
    * Fixed compatibility problem with Palantir. Fixed by making output more
@@ -1257,8 +1309,8 @@ Roberto Spadim
      Carpintero. However this fix made Firefox flicker even more than it normally
      does. Final fix which works in both Palantir client, Firefox and Cambozola
      was made by Kenneth Lavrsen. This closes the following bugs:
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x05x02x205307,
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2005x05x07x042849
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x05x02x205307,
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2005x05x07x042849
 
 Daniel Sterling
    * Studies of the performance of Motion.
@@ -1284,7 +1336,7 @@ Tommy Svensson
 
 Timo Taskinen
    * Added Flash video format (FLV) to ffmpeg.   
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/FeatureRequest2007x07x19x131921
+     http://www.lavrsen.dk/twiki/bin/view/Motion/FeatureRequest2007x07x19x131921
 
 technolust.cx
    * For hosting motion.technolust.cx
@@ -1302,7 +1354,7 @@ Jukka Ukkonen
    * On FreeBSD configure defines a redundant freebsd for motion. Fixed by replacing
      -D__freebsd_ by BSD macro  included in sys/param.h for BSD platforms.
      (JukkaUkkonen and Angel Carpintero)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2006x07x08x070417
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2006x07x08x070417
 
 Moshe Van Der Sterre
    * Added 3 new tracking options: track_step_angle_x, track_step_angle_y,
@@ -1315,14 +1367,14 @@ Moshe Van Der Sterre
      is re-enabled the minute the camera is standing still again. Feature
      originally made by Moshe Van Der Sterre. Kenneth Lavrsen extended it to
      be more generic.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/PwcConfiguration
+     http://www.lavrsen.dk/twiki/bin/view/Motion/PwcConfiguration
 
 Folkert Van Heusden
    * Maintained the code from version 3.1.9 till 3.1.12-rc1
      Including features like..
    * Error reporting to syslog.
    * Better memory allocation.
-     low_cpu feature extention to configurable frame rate.
+     low_cpu feature extension to configurable frame rate.
    * First work on Logitech Sphere/Orbit tracking.
    * Implemented original pre-record feature.
      Misc code optimisations
@@ -1331,13 +1383,12 @@ Folkert Van Heusden
 
 James Van Vleet
    * CPU VIA Ezra C3 autodetection support added.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/VIAEzraC3Patch	
+     http://www.lavrsen.dk/twiki/bin/view/Motion/VIAEzraC3Patch	
 
 Simon Walls
-   * Netcam Keepalive and HTTP/1.1 http://www.lavrsen.dk/foswiki/bin/view/Motion/FeatureRequest2007x01x22x231542 
+   * Netcam Keepalive and HTTP/1.1 http://www.lavrsen.dk/twiki/bin/view/Motion/FeatureRequest2007x01x22x231542 
    * Better debug in netcam for "Error reading image header" 
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2008x02x27x092849
-
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2008x02x27x092849 (Simon Walls)
 
 Sean Watkins
    * Created a centralized logging function that became event()
@@ -1346,18 +1397,18 @@ Joerg Weber
    * Added the new labeling motion detection feature.
    * Added the new Smartmask feature.
    * Implemented new preview patch (Joerg Weber)
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/PreviewShotsPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/PreviewShotsPatch
    * Implemented an improvement of Smartmask so that the mask is cleared when
      the smart_mask_speed is set from a non-zero to zero
    * Implemented an improvement of noise_tune with smart mask (and probably
      also in general)
    * Added Best Preview Patch
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BestPreviewShot
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BestPreviewShot
    * Added the new feature Setup Mode (Joerg Weber). This also enables
      much more error messages given to the console when in non-daemon mode
      while still preserving the messages in syslog which are important
      for daemon mode debugging.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/SetupModePatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/SetupModePatch
    * Fixed a bug in noise tune which was most visible at very low light.
    * Improved console output in setup mode. Now also outputs threshold.
    * Improvement in the noise-tune algorithm.
@@ -1369,8 +1420,8 @@ Joerg Weber
      Movie starts (mpeg file opened) --- onmpeg --- on_movie_start
      Movie ends (mpeg file closed) --- onffmpegclose --- on_movie_end
      Motion detected  --- New! --- on_motion_detected
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/OnXxxCommandsPatch and
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/OnXxxxFeatureDiscussion
+     http://www.lavrsen.dk/twiki/bin/view/Motion/OnXxxCommandsPatch and
+     http://www.lavrsen.dk/twiki/bin/view/Motion/OnXxxxFeatureDiscussion
    * Fixed small bug when pre_capture buffer is resized during operation.
    * Changed the order of drawing the red mask in setup mode so that the
      smartmask is drawn after the fixed mask.
@@ -1379,19 +1430,25 @@ Joerg Weber
      a fixed mask.
    * Improved the labelling algorithm so that locate feature and tracking
      features includes all labelled areas above threshold.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/ImprovedLabellingPatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/ImprovedLabellingPatch
    * Make the creation of reference frame and the decay mechanism depending
      on how much motion was detected relative to threshold setting.
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/ReferenceFramePatch
+     http://www.lavrsen.dk/twiki/bin/view/Motion/ReferenceFramePatch
    * Removed low_cpu feature.
    * Removed night_compensate feature
    * Implemented a new reference frame algorithm to improve object recognition and location.
    * Improved smartmask feature: real moving objects don't trigger the mask anymore.
    * Added area_detect feature.
-
+   * Add draw a RED box around the movement as default.
+   * Split locate_motion into separate 'mode' and 'style' option to allow all
+     possible combinations.
+   * Gapless_event mode.
+   * Limit detection rate to 3fps at framerates above 5fps, to reduce CPU load.
+   * Fixed mask overlay in setup mode is now green instead of white.
+   
 Dirk Wesenberg
    * Track pan/tilt support for uvcvideo ( Michal Licko ,Dirk Wesenberg and Angel Carpintero )
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/LinuxUvcTrackingPatch	
+     http://www.lavrsen.dk/twiki/bin/view/Motion/LinuxUvcTrackingPatch	
 
 Tristan Willy
    * Wrote Axis 2100 support and added the check for ~/.motion/motion.conf
@@ -1404,7 +1461,7 @@ Andreas Wrede
 
 Damian Wrobel
    * Fix a segfault adding correct size to be used for bayer2rgb24(). 
-     http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReport2007x03x30x175913
+     http://www.lavrsen.dk/twiki/bin/view/Motion/BugReport2007x03x30x175913
 
 Yieldtech
    * These guys are making a complete linux based security system
--- motion-3.2.12.orig/FAQ
+++ motion-3.2.12/FAQ
@@ -1,6 +1,6 @@
 This FAQ is no longer kept up to date
 Look at this URL for a more up to date wiki based FAQ
-http://www.lavrsen.dk/foswiki/bin/view/Motion/FrequentlyAskedQuestions
+http://www.lavrsen.dk/twiki/bin/view/Motion/FrequentlyAskedQuestions
 
 Q: motion crashes while parsing the config file.
 
--- motion-3.2.12.orig/INSTALL
+++ motion-3.2.12/INSTALL
@@ -1,16 +1,61 @@
-Very simple:
+NOTE:  Versions come, versions go, packages change, etc.  These instructions are intended as a starting point
+       and may need modification by the time you read this.
 
-type:
+**********************************
+***    DEBIAN BASED SYSTEMS    ***
 
+Required Packages:
+    sudo apt-get install autoconf automake build-essential libtool libjpeg8-dev libzip-dev
+
+Obtain source code (via git)
+    sudo apt-get install git
+    cd ~
+    git clone {https://github.com/your favorite fork}
+
+To rebuild the motion configure file use
+    autoreconf
+
+Optional: With FFMPEG support:
+    Build FFMPEG via their instructions
+    Configure with manually built ffmpeg which currently installs to ~/bin and ~/ffmpeg_build
+        Basic
+            ./configure --with-ffmpeg=$HOME/ffmpeg_build --with-ffmpeg-headers=$HOME/ffmpeg_build/include
+
+        With extra libraries for ffmpeg  IMPORTANT NOTE:  Your libraries will vary depending upon your build of FFMPEG
+            ./configure --with-ffmpeg=$HOME/ffmpeg_build --with-ffmpeg-headers=$HOME/ffmpeg_build/include --with-ffmpeg-libs=" -lavformat -lswscale -lavcodec -lavutil -lfdk-aac -lswresample -lm -lopus -lz -lva -lvpx -lx264 -lmp3lame -lbz2 -ldl -lvorbisenc -lvorbis -ltheoraenc -ltheoradec "
+
+        With extra libraries for ffmpeg and install to ~/motion_build
+            ./configure --prefix=$HOME/motion_build --with-ffmpeg=$HOME/ffmpeg_build --with-ffmpeg-headers=$HOME/ffmpeg_build/include --with-ffmpeg-libs=" -lavformat -lswscale -lavcodec -lavutil -lfdk-aac -lswresample -lm -lopus -lz -lva -lvpx -lx264 -lmp3lame -lbz2 -ldl -lvorbisenc -lvorbis -ltheoraenc -ltheoradec "
+
+With LIBAV APT versions of libraries
+    sudo apt-get install libavformat-dev libavcodec-dev libavutil-dev libav-tools libswscale-dev
+
+Without any LIBAV/FFMPEG support or the installed version of libavcodec/libavformat
     ./configure
 
-followed by:
+Sample PI configuration with LIBAV
+    ./configure --with-ffmpeg=/usr/lib/arm-linux-gnueabihf --with-ffmpeg-headers=/usr/include
+
 
+Once configured type:
     make
+    make install
 
-And
+*****************************
+***    OpenSUSE SYSTEM    ***
 
+sudo zypper install autoconf automake libtool git
+sudo zypper install --type pattern devel_basis
+sudo zypper install libjpeg8-devel
+sudo zypper install -t pattern devel_C_C++
+
+Optional:  FFmpeg files
+sudo zypper ar -f -n packman-essentials http://packman.inode.at/suse/openSUSE_13.1/Essentials/ packman-essentials
+sudo zypper ar -f -n packman-multimedia http://packman.inode.at/suse/openSUSE_13.1/Multimedia/ packman-multimedia
+sudo zypper install libffmpeg-devel
+
+./configure
+    make
     make install
 
-    
-Next read the README
+*************************
--- /dev/null
+++ motion-3.2.12/Makefile
@@ -0,0 +1,279 @@
+################################################################################
+# Makefile for Motion                                                          #
+################################################################################
+# Copyright 2000 by Jeroen Vreeken                                             #
+#                                                                              #
+# This program is published under the GNU public license version 2.0 or later. #
+# Please read the file COPYING for more info.                                  #
+################################################################################
+# Please visit the Motion home page:                                           #
+# http://www.lavrsen.dk/twiki/bin/view/Motion                                  #
+################################################################################
+
+CC      = gcc
+INSTALL = install
+
+################################################################################
+# Install locations, controlled by setting configure flags.                    #
+################################################################################
+prefix      = /home/dave/motion_build
+exec_prefix = ${prefix}
+bindir      = ${exec_prefix}/bin
+mandir      = ${datarootdir}/man
+sysconfdir  = ${prefix}/etc
+datadir     = ${datarootdir}
+datarootdir = ${prefix}/share
+docdir      = $(datadir)/doc/motion-3.2.12-4ppa01 
+examplesdir = $(datadir)/motion-3.2.12-4ppa01/examples
+
+################################################################################
+# These variables contain compiler flags, object files to build and files to   #
+# install.                                                                     #
+################################################################################
+CFLAGS       =  -g -O2 -D_REENTRANT -DHAVE_FFMPEG -I/usr/include -DFFMPEG_NEW_INCLUDES -DHAVE_FFMPEG_NEW -DMOTION_V4L2 -DMOTION_V4L2_OLD -DTYPE_32BIT="int" -DHAVE_BSWAP   -march=native -mtune=native -Wall -DVERSION=\"3.2.12-4ppa01\" -Dsysconfdir=\"$(sysconfdir)\" 
+LDFLAGS      =   -L/usr/lib/x86_64-linux-gnu
+LIBS         = -lm  -lpthread -ljpeg -L/usr/lib/x86_64-linux-gnu  -lavformat -lavcodec -lavutil -lm -lz -lswscale  
+VIDEO_OBJ    = video.o video2.o video_common.o
+OBJ          = motion.o logger.o conf.o draw.o jpegutils.o vloopback_motion.o $(VIDEO_OBJ) \
+			   netcam.o netcam_ftp.o netcam_jpeg.o netcam_wget.o track.o \
+			   alg.o event.o picture.o rotate.o webhttpd.o \
+			   stream.o md5.o ffmpeg.o  netcam_rtsp.o
+SRC          = $(OBJ:.o=.c)
+DOC          = CHANGELOG COPYING CREDITS INSTALL README motion_guide.html
+EXAMPLES     = *.conf motion.init-Debian motion.init-Fedora motion.init-FreeBSD.sh
+PROGS        = motion
+DEPEND_FILE  = .depend
+
+################################################################################
+# ALL and PROGS build Motion and, possibly, Motion-control.                    #
+################################################################################
+all: progs
+ifneq (,$(findstring freebsd,$(VIDEO_OBJ)))
+	@echo "Build complete, run \"gmake install\" to install Motion!"
+else
+	@echo "Build complete, run \"make install\" to install Motion!"
+endif
+	@echo
+
+progs: pre-build-info $(PROGS)
+
+################################################################################
+# PRE-BUILD-INFO outputs some general info before the build process starts.    #
+################################################################################
+pre-build-info: 
+	@echo "Welcome to the setup procedure for Motion, the motion detection daemon! If you get"
+	@echo "error messages during this procedure, please report them to the mailing list. The"
+	@echo "Motion Guide contains all information you should need to get Motion up and running."
+	@echo "Run \"make updateguide\" to download the latest version of the Motion Guide."
+	@echo
+	@echo "Version: 3.2.12-4ppa01"
+ifneq (,$(findstring freebsd,$(VIDEO_OBJ)))
+	@echo "Platform: FreeBSD"
+else
+	@echo "Platform: Linux (if this is incorrect, please read README.FreeBSD)"
+endif
+	@echo
+
+################################################################################
+# MOTION builds motion. MOTION-OBJECTS and PRE-MOBJECT-INFO are helpers.       #
+################################################################################
+motion: motion-objects
+	@echo "Linking Motion..."
+	@echo "--------------------------------------------------------------------------------"
+	$(CC) $(LDFLAGS) -o $@ $(OBJ) $(LIBS)
+	@echo "--------------------------------------------------------------------------------"
+	@echo "Motion has been linked."
+	@echo
+
+motion-objects: dep pre-mobject-info $(OBJ)
+	@echo "--------------------------------------------------------------------------------"
+	@echo "Motion object files compiled."
+	@echo
+	
+pre-mobject-info:
+	@echo "Compiling Motion object files..."
+	@echo "--------------------------------------------------------------------------------"
+
+################################################################################
+# Define the compile command for C files.                                      #
+################################################################################
+#%.o: %.c
+#	@echo -e "\tCompiling $< into $@..."
+#	@$(CC) -c $(CFLAGS) $< -o $@
+
+################################################################################
+# Include the dependency file if it exists.                                    #
+################################################################################
+ifeq ($(DEPEND_FILE), $(wildcard $(DEPEND_FILE)))
+ifeq (,$(findstring clean,$(MAKECMDGOALS)))
+-include $(DEPEND_FILE)
+endif
+endif
+
+################################################################################
+# Make the dependency file depend on all header files and all relevant source  #
+# files. This forces the file to be re-generated if the source/header files    #
+# change. Note, however, that the existing version will be included before     #
+# re-generation.                                                               #
+################################################################################
+$(DEPEND_FILE): *.h $(SRC)
+	@echo "Generating dependencies, please wait..."
+	@$(CC) $(CFLAGS) -M $(SRC) > .tmp
+	@mv -f .tmp $(DEPEND_FILE)
+	@echo
+
+################################################################################
+# DEP, DEPEND and FASTDEP generate the dependency file.                        #
+################################################################################
+dep depend fastdep: $(DEPEND_FILE)
+
+
+################################################################################
+# DEV, BUILD with developer flags                                              #
+################################################################################
+dev: distclean autotools all
+
+################################################################################
+# DEV-GIT, BUILD with developer flags                                          #
+################################################################################
+dev-git: distclean autotools-git all
+
+
+################################################################################
+# GIT, BUILD with developer flags                                              #
+################################################################################
+build-commit-git: distclean set-version-git all
+
+################################################################################
+# CURRENT, BUILD current svn trunk.                                            #
+################################################################################
+current: distclean svn autotools all
+
+svn:
+	svn update
+
+autotools:
+	@sed -i 's/.\/commit-version.sh/.\/version.sh/g' configure.in
+	autoconf
+	./configure --with-developer-flags 
+
+autotools-git:
+	@sed -i 's/.\/git-commit-version.sh/.\/version.sh/g' configure.in
+	autoconf
+	./configure --with-developer-flags 
+
+
+build-commit: distclean svn set-version all
+
+set-version:
+	@sed -i 's/.\/version.sh/.\/commit-version.sh/g' configure.in
+	autoconf
+	@sed -i 's/.\/commit-version.sh/.\/version.sh/g' configure.in
+	./configure --with-developer-flags
+
+set-version-git:
+	@sed -i 's/.\/version.sh/.\/git-commit-version.sh/g' configure.in
+	autoconf
+	@sed -i 's/.\/git-commit-version.sh/.\/version.sh/g' configure.in
+	./configure --with-developer-flags
+
+
+help:
+	@echo "--------------------------------------------------------------------------------"
+	@echo "make                   Build motion from local copy in your computer"	
+	@echo "make current           Build last version of motion from svn"
+	@echo "make dev               Build motion with dev flags"
+	@echo "make dev-git           Build motion with dev flags for git"
+	@echo "make build-commit      Build last version of motion and prepare to commit to svn"
+	@echo "make build-commit-git  Build last version of motion and prepare to commit to git"
+	@echo "make clean             Clean objects" 
+	@echo "make distclean         Clean everything"	
+	@echo "make install           Install binary , examples , docs and config files"
+	@echo "make uninstall         Uninstall all installed files"
+	@echo "--------------------------------------------------------------------------------"
+	@echo
+
+################################################################################
+# INSTALL installs all relevant files.                                         #
+################################################################################
+install:
+	@echo "Installing files..."
+	@echo "--------------------------------------------------------------------------------"
+	mkdir -p $(DESTDIR)$(bindir)
+	mkdir -p $(DESTDIR)$(mandir)/man1
+	mkdir -p $(DESTDIR)$(sysconfdir)
+	mkdir -p $(DESTDIR)$(docdir)
+	mkdir -p $(DESTDIR)$(examplesdir)
+	$(INSTALL) motion.1 $(DESTDIR)$(mandir)/man1
+	$(INSTALL) $(DOC) $(DESTDIR)$(docdir)
+	$(INSTALL) $(EXAMPLES) $(DESTDIR)$(examplesdir)
+	$(INSTALL) motion-dist.conf $(DESTDIR)$(sysconfdir)
+	for prog in $(PROGS); \
+	do \
+	($(INSTALL) $$prog $(DESTDIR)$(bindir) ); \
+	done
+	@echo "--------------------------------------------------------------------------------"
+	@echo "Install complete! The default configuration file, motion-dist.conf, has been"
+	@echo "installed to $(sysconfdir). You need to rename/copy it to $(sysconfdir)/motion.conf"
+	@echo "for Motion to find it. More configuration examples as well as init scripts"
+	@echo "can be found in $(examplesdir)."
+	@echo
+
+################################################################################
+# UNINSTALL and REMOVE uninstall already installed files.                      #
+################################################################################
+uninstall remove: pre-build-info
+	@echo "Uninstalling files..."
+	@echo "--------------------------------------------------------------------------------"
+	for prog in $(PROGS); \
+	do \
+		($ rm -f $(bindir)/$$prog ); \
+	done
+	rm -f $(mandir)/man1/motion.1
+	rm -f $(sysconfdir)/motion-dist.conf
+	rm -rf $(docdir)
+	rm -rf $(examplesdir)
+	@echo "--------------------------------------------------------------------------------"
+	@echo "Uninstall complete!"
+	@echo
+
+################################################################################
+# CLEAN is basic cleaning; removes object files and executables, but does not  #
+# remove files generated from the configure step.                              #
+################################################################################
+clean: pre-build-info
+	@echo "Removing compiled files and binaries..."
+	@rm -f *~ *.jpg *.o $(PROGS) combine $(DEPEND_FILE)
+
+################################################################################
+# DIST restores the directory to distribution state.                           #
+################################################################################
+dist: distclean updateguide
+	@chmod -R 644 *
+	@chmod 755 configure
+	@chmod 755 version.sh
+
+################################################################################
+# DISTCLEAN removes all files generated during the configure step in addition  #
+# to basic cleaning.                                                           #
+################################################################################
+distclean: clean
+	@echo "Removing files generated by configure..."
+	@rm -f config.status config.log config.cache Makefile motion.init-Fedora motion.init-Debian motion.init-FreeBSD.sh
+	@rm -f thread1.conf thread2.conf thread3.conf thread4.conf motion-dist.conf motion-help.conf motion.spec
+	@rm -rf autom4te.cache config.h
+	@echo "You will need to re-run configure if you want to build Motion."
+	@echo
+
+################################################################################
+# UPDATEGUIDE downloads the Motion Guide from TWiki.                           #
+################################################################################
+updateguide: pre-build-info
+	@echo "Downloading Motion Guide. If it fails, please check your Internet connection."
+	@echo
+	wget www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideOneLargeDocument?skin=text -O motion_guide.tmp
+	@echo "Cleaning up and fixing links..."
+	@cat motion_guide.tmp | sed -e 's/\?skin=text//g;s,"/twiki/,"http://www.lavrsen.dk/twiki/,g' > motion_guide.html
+	@rm -f motion_guide.tmp
+	@echo "All done, you should now have an up-to-date local copy of the Motion guide."
+	@echo
--- motion-3.2.12.orig/Makefile.in
+++ motion-3.2.12/Makefile.in
@@ -7,7 +7,7 @@
 # Please read the file COPYING for more info.                                  #
 ################################################################################
 # Please visit the Motion home page:                                           #
-# http://www.lavrsen.dk/foswiki/bin/view/Motion                                  #
+# http://www.lavrsen.dk/twiki/bin/view/Motion                                  #
 ################################################################################
 
 CC      = @CC@
@@ -23,7 +23,7 @@ mandir      = @mandir@
 sysconfdir  = @sysconfdir@
 datadir     = @datadir@
 datarootdir = @datarootdir@
-docdir      = $(datadir)/doc/@PACKAGE_NAME@-@PACKAGE_VERSION@
+docdir      = $(datadir)/doc/@PACKAGE_NAME@-@PACKAGE_VERSION@ 
 examplesdir = $(datadir)/@PACKAGE_NAME@-@PACKAGE_VERSION@/examples
 
 ################################################################################
@@ -34,10 +34,10 @@ CFLAGS       = @CFLAGS@ -Wall -DVERSION=
 LDFLAGS      = @LDFLAGS@
 LIBS         = @LIBS@ 
 VIDEO_OBJ    = @VIDEO@
-OBJ          = motion.o conf.o draw.o jpegutils.o $(VIDEO_OBJ) netcam.o \
-			   netcam_ftp.o netcam_jpeg.o netcam_wget.o track.o \
+OBJ          = motion.o logger.o conf.o draw.o jpegutils.o vloopback_motion.o $(VIDEO_OBJ) \
+			   netcam.o netcam_ftp.o netcam_jpeg.o netcam_wget.o track.o \
 			   alg.o event.o picture.o rotate.o webhttpd.o \
-			   webcam.o @FFMPEG_OBJ@
+			   stream.o md5.o @FFMPEG_OBJ@ @SDL_OBJ@ @RTPS_OBJ@
 SRC          = $(OBJ:.o=.c)
 DOC          = CHANGELOG COPYING CREDITS INSTALL README motion_guide.html
 EXAMPLES     = *.conf motion.init-Debian motion.init-Fedora motion.init-FreeBSD.sh
@@ -127,6 +127,72 @@ $(DEPEND_FILE): *.h $(SRC)
 ################################################################################
 dep depend fastdep: $(DEPEND_FILE)
 
+
+################################################################################
+# DEV, BUILD with developer flags                                              #
+################################################################################
+dev: distclean autotools all
+
+################################################################################
+# DEV-GIT, BUILD with developer flags                                          #
+################################################################################
+dev-git: distclean autotools-git all
+
+
+################################################################################
+# GIT, BUILD with developer flags                                              #
+################################################################################
+build-commit-git: distclean set-version-git all
+
+################################################################################
+# CURRENT, BUILD current svn trunk.                                            #
+################################################################################
+current: distclean svn autotools all
+
+svn:
+	svn update
+
+autotools:
+	@sed -i 's/.\/commit-version.sh/.\/version.sh/g' configure.in
+	autoconf
+	./configure --with-developer-flags 
+
+autotools-git:
+	@sed -i 's/.\/git-commit-version.sh/.\/version.sh/g' configure.in
+	autoconf
+	./configure --with-developer-flags 
+
+
+build-commit: distclean svn set-version all
+
+set-version:
+	@sed -i 's/.\/version.sh/.\/commit-version.sh/g' configure.in
+	autoconf
+	@sed -i 's/.\/commit-version.sh/.\/version.sh/g' configure.in
+	./configure --with-developer-flags
+
+set-version-git:
+	@sed -i 's/.\/version.sh/.\/git-commit-version.sh/g' configure.in
+	autoconf
+	@sed -i 's/.\/git-commit-version.sh/.\/version.sh/g' configure.in
+	./configure --with-developer-flags
+
+
+help:
+	@echo "--------------------------------------------------------------------------------"
+	@echo "make                   Build motion from local copy in your computer"	
+	@echo "make current           Build last version of motion from svn"
+	@echo "make dev               Build motion with dev flags"
+	@echo "make dev-git           Build motion with dev flags for git"
+	@echo "make build-commit      Build last version of motion and prepare to commit to svn"
+	@echo "make build-commit-git  Build last version of motion and prepare to commit to git"
+	@echo "make clean             Clean objects" 
+	@echo "make distclean         Clean everything"	
+	@echo "make install           Install binary , examples , docs and config files"
+	@echo "make uninstall         Uninstall all installed files"
+	@echo "--------------------------------------------------------------------------------"
+	@echo
+
 ################################################################################
 # INSTALL installs all relevant files.                                         #
 ################################################################################
@@ -185,6 +251,7 @@ clean: pre-build-info
 dist: distclean updateguide
 	@chmod -R 644 *
 	@chmod 755 configure
+	@chmod 755 version.sh
 
 ################################################################################
 # DISTCLEAN removes all files generated during the configure step in addition  #
@@ -199,14 +266,14 @@ distclean: clean
 	@echo
 
 ################################################################################
-# UPDATEGUIDE downloads the Motion Guide from the Motion Foswiki.              #
+# UPDATEGUIDE downloads the Motion Guide from TWiki.                           #
 ################################################################################
 updateguide: pre-build-info
 	@echo "Downloading Motion Guide. If it fails, please check your Internet connection."
 	@echo
-	wget www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument?skin=text -O motion_guide.tmp
+	wget www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideOneLargeDocument?skin=text -O motion_guide.tmp
 	@echo "Cleaning up and fixing links..."
-	@cat motion_guide.tmp | sed -e 's/\?skin=text//g;s,"/foswiki/,"http://www.lavrsen.dk/foswiki/,g' > motion_guide.html
+	@cat motion_guide.tmp | sed -e 's/\?skin=text//g;s,"/twiki/,"http://www.lavrsen.dk/twiki/,g' > motion_guide.html
 	@rm -f motion_guide.tmp
 	@echo "All done, you should now have an up-to-date local copy of the Motion guide."
 	@echo
--- motion-3.2.12.orig/README
+++ motion-3.2.12/README
@@ -44,17 +44,17 @@ installation and use.
 The Motion Guide is part of the distribution (motion_guide.htm).
 You are encouraged to look up an up to date version by visiting the Motion
 homepage at
-http://www.lavrsen.dk/foswiki/bin/view/Motion/WebHome
+http://www.lavrsen.dk/twiki/bin/view/Motion/WebHome
 and specifically the Motion Guide at
-http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuide
+http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuide
 
 
 Support:
 
-Lots of resources at http://www.lavrsen.dk/foswiki/bin/view/Motion/WebHome
+Lots of resources at http://www.lavrsen.dk/twiki/bin/view/Motion/WebHome
 
 Please join the mailing list
-http://www.lavrsen.dk/foswiki/bin/view/Motion/MailingList
+http://www.lavrsen.dk/twiki/bin/view/Motion/MailingList
 Newbies and silly questions are welcome. We prefer support through the mailing
 list because more will have benefit from the answers.
 
--- motion-3.2.12.orig/README.FreeBSD
+++ motion-3.2.12/README.FreeBSD
@@ -78,11 +78,11 @@ Packages needed (dependencies for 6.x):
  Any question / fix / suggestion  please send it to motion mailing list.
 
 
- http://www.lavrsen.dk/foswiki/bin/view/Motion/FreeBSD
+ http://www.lavrsen.dk/twiki/bin/view/Motion/FreeBSD
 
  * WEBCAMS
  ----------
- http://www.lavrsen.dk/foswiki/bin/view/Motion/HowtoMotionPwcFreeBSD
+ http://www.lavrsen.dk/twiki/bin/view/Motion/HowtoMotionPwcFreeBSD
 
  Angel Carpintero
  ack@telefonica.net
--- motion-3.2.12.orig/alg.c
+++ motion-3.2.12/alg.c
@@ -17,7 +17,10 @@
 #define MAX2(x, y) ((x) > (y) ? (x) : (y))
 #define MAX3(x, y, z) ((x) > (y) ? ((x) > (z) ? (x) : (z)) : ((y) > (z) ? (y) : (z)))
 
-/* locate the center and size of the movement. */
+/** 
+ * alg_locate_center_size 
+ *      Locates the center and size of the movement. 
+ */
 void alg_locate_center_size(struct images *imgs, int width, int height, struct coord *cent)
 {
     unsigned char *out = imgs->out;
@@ -31,18 +34,19 @@ void alg_locate_center_size(struct image
     cent->minx = width;
     cent->miny = height;
 
-    /* If Labeling enabled - locate center of largest labelgroup */
+    /* If Labeling enabled - locate center of largest labelgroup. */
     if (imgs->labelsize_max) {
         /* Locate largest labelgroup */
         for (y = 0; y < height; y++) {
             for (x = 0; x < width; x++) {
-                if (*(labels++)&32768) {
+                if (*(labels++) & 32768) {
                     cent->x += x;
                     cent->y += y;
                     centc++;
                 }
             }
         }
+
     } else {
         /* Locate movement */
         for (y = 0; y < height; y++) {
@@ -54,6 +58,7 @@ void alg_locate_center_size(struct image
                 }
             }
         }
+
     }
 
     if (centc) {
@@ -61,18 +66,18 @@ void alg_locate_center_size(struct image
         cent->y = cent->y / centc;
     }
     
-    /* Now we find the size of the Motion */
+    /* Now we find the size of the Motion. */
 
-    /* First reset pointers back to initial value */
+    /* First reset pointers back to initial value. */
     centc = 0;
     labels = imgs->labels;
     out = imgs->out;
 
-    /* If Labeling then we find the area around largest labelgroup instead */
+    /* If Labeling then we find the area around largest labelgroup instead. */
     if (imgs->labelsize_max) {
         for (y = 0; y < height; y++) {
             for (x = 0; x < width; x++) {
-                if (*(labels++)&32768) {
+                if (*(labels++) & 32768) {
                     if (x > cent->x)
                         xdist += x - cent->x;
                     else if (x < cent->x)
@@ -87,6 +92,7 @@ void alg_locate_center_size(struct image
                 }
             }    
         }
+
     } else {
         for (y = 0; y < height; y++) {
             for (x = 0; x < width; x++) {
@@ -105,14 +111,17 @@ void alg_locate_center_size(struct image
                 }
             }    
         }
+
     }
     
     if (centc) {
         cent->minx = cent->x - xdist / centc * 2;
         cent->maxx = cent->x + xdist / centc * 2;
-        /* Make the box a little bigger in y direction to make sure the
-           heads fit in so we multiply by 3 instead of 2 which seems to
-           to work well in practical */
+        /* 
+         * Make the box a little bigger in y direction to make sure the
+         * heads fit in so we multiply by 3 instead of 2 which seems to
+         * to work well in practical. 
+         */
         cent->miny = cent->y - ydist / centc * 3;
         cent->maxy = cent->y + ydist / centc * 2;
     }
@@ -126,85 +135,227 @@ void alg_locate_center_size(struct image
         cent->maxy = height - 1;
     else if (cent->maxy < 0)
         cent->maxy = 0;
-    
+
     if (cent->minx > width - 1)
         cent->minx = width - 1;
     else if (cent->minx < 0)
         cent->minx = 0;
-    
+
     if (cent->miny > height - 1)
         cent->miny = height - 1;
     else if (cent->miny < 0)
         cent->miny = 0;
+
+    /* Align for better locate box handling */
+    cent->minx += cent->minx % 2;
+    cent->miny += cent->miny % 2;
+    cent->maxx -= cent->maxx % 2;
+    cent->maxy -= cent->maxy % 2;
     
     cent->width = cent->maxx - cent->minx;
     cent->height = cent->maxy - cent->miny;
     
-    /* We want to center Y coordinate to be the center of the action.
-       The head of a person is important so we correct the cent.y coordinate
-       to match the correction to include a persons head that we just did above */
+    /*
+     * We want to center Y coordinate to be the center of the action.
+     * The head of a person is important so we correct the cent.y coordinate
+     * to match the correction to include a persons head that we just did above. 
+     */
     cent->y = (cent->miny + cent->maxy) / 2;
     
 }
 
 
-/* draw a box around the movement */
-void alg_draw_location(struct coord *cent, struct images *imgs, int width, unsigned char *new, int mode)
+/** 
+ * alg_draw_location 
+ *      Draws a box around the movement. 
+ */
+void alg_draw_location(struct coord *cent, struct images *imgs, int width, unsigned char *new,
+                       int style, int mode, int process_thisframe)
 {
     unsigned char *out = imgs->out;
     int x, y;
 
     out = imgs->out;
 
-    /* Draw a box around the movement */
-    if (mode == LOCATE_BOTH){ /* both normal and motion image gets a box */
+    /* Debug image always gets a 'normal' box. */
+    if ((mode == LOCATE_BOTH) && process_thisframe) {
         int width_miny = width * cent->miny;
         int width_maxy = width * cent->maxy;
 
         for (x = cent->minx; x <= cent->maxx; x++) {
             int width_miny_x = x + width_miny;
             int width_maxy_x = x + width_maxy;
-            new[width_miny_x]=~new[width_miny_x];
-            new[width_maxy_x]=~new[width_maxy_x];
-            out[width_miny_x]=~out[width_miny_x];
-            out[width_maxy_x]=~out[width_maxy_x];
+
+            out[width_miny_x] =~out[width_miny_x];
+            out[width_maxy_x] =~out[width_maxy_x];
         }
 
         for (y = cent->miny; y <= cent->maxy; y++) {
             int width_minx_y = cent->minx + y * width; 
             int width_maxx_y = cent->maxx + y * width;
-            new[width_minx_y]=~new[width_minx_y];
-            new[width_maxx_y]=~new[width_maxx_y];
-            out[width_minx_y]=~out[width_minx_y];
-            out[width_maxx_y]=~out[width_maxx_y];
+
+            out[width_minx_y] =~out[width_minx_y];
+            out[width_maxx_y] =~out[width_maxx_y];
         }
-    } else { /* normal image only (e.g. preview shot) */
+    }
+    if (style == LOCATE_BOX) { /* Draw a box on normal images. */
         int width_miny = width * cent->miny;
         int width_maxy = width * cent->maxy;
+
         for (x = cent->minx; x <= cent->maxx; x++) {
-            int width_miny_x = width_miny + x;
-            int width_maxy_x = width_maxy + x;
-            new[width_miny_x]=~new[width_miny_x];
-            new[width_maxy_x]=~new[width_maxy_x];
+            int width_miny_x = x + width_miny;
+            int width_maxy_x = x + width_maxy;
+
+            new[width_miny_x] =~new[width_miny_x];
+            new[width_maxy_x] =~new[width_maxy_x];
         }
 
         for (y = cent->miny; y <= cent->maxy; y++) {
-            int minx_y = cent->minx + y * width;
-            int maxx_y = cent->maxx + y * width;
-            new[minx_y]=~new[minx_y];
-            new[maxx_y]=~new[maxx_y];
+            int width_minx_y = cent->minx + y * width; 
+            int width_maxx_y = cent->maxx + y * width;
+
+            new[width_minx_y] =~new[width_minx_y];
+            new[width_maxx_y] =~new[width_maxx_y];
+        }
+    } else if (style == LOCATE_CROSS) { /* Draw a cross on normal images. */
+        int centy = cent->y * width;
+
+        for (x = cent->x - 10;  x <= cent->x + 10; x++) {
+            new[centy + x] =~new[centy + x];
+            out[centy + x] =~out[centy + x];
         }
+
+        for (y = cent->y - 10; y <= cent->y + 10; y++) {
+            new[cent->x + y * width] =~new[cent->x + y * width];
+            out[cent->x + y * width] =~out[cent->x + y * width];
+        }       
     }
 }
 
 
+/** 
+ * alg_draw_red_location 
+ *          Draws a RED box around the movement.
+ */
+void alg_draw_red_location(struct coord *cent, struct images *imgs, int width, unsigned char *new,
+                           int style, int mode, int process_thisframe)
+{
+    unsigned char *out = imgs->out;
+    unsigned char *new_u, *new_v;
+    int x, y, v, cwidth, cblock;
+
+    cwidth = width / 2;
+    cblock = imgs->motionsize / 4;
+    x = imgs->motionsize;
+    v = x + cblock;
+    out = imgs->out;
+    new_u = new + x;
+    new_v = new + v;
+
+    /* Debug image always gets a 'normal' box. */
+    if ((mode == LOCATE_BOTH) && process_thisframe) {
+        int width_miny = width * cent->miny;
+        int width_maxy = width * cent->maxy;
+
+        for (x = cent->minx; x <= cent->maxx; x++) {
+            int width_miny_x = x + width_miny;
+            int width_maxy_x = x + width_maxy;
+
+            out[width_miny_x] =~out[width_miny_x];
+            out[width_maxy_x] =~out[width_maxy_x];
+        }
+
+        for (y = cent->miny; y <= cent->maxy; y++) {
+            int width_minx_y = cent->minx + y * width; 
+            int width_maxx_y = cent->maxx + y * width;
+
+            out[width_minx_y] =~out[width_minx_y];
+            out[width_maxx_y] =~out[width_maxx_y];
+        }
+    }
+
+    if (style == LOCATE_REDBOX) { /* Draw a red box on normal images. */
+        int width_miny = width * cent->miny;
+        int width_maxy = width * cent->maxy;
+        int cwidth_miny = cwidth * (cent->miny / 2);
+        int cwidth_maxy = cwidth * (cent->maxy / 2);
+        
+        for (x = cent->minx + 2; x <= cent->maxx - 2; x += 2) {
+            int width_miny_x = x + width_miny;
+            int width_maxy_x = x + width_maxy;
+            int cwidth_miny_x = x / 2 + cwidth_miny;
+            int cwidth_maxy_x = x / 2 + cwidth_maxy;
+
+            new_u[cwidth_miny_x] = 128;
+            new_u[cwidth_maxy_x] = 128;
+            new_v[cwidth_miny_x] = 255;
+            new_v[cwidth_maxy_x] = 255;
+
+            new[width_miny_x] = 128;
+            new[width_maxy_x] = 128;
+
+            new[width_miny_x + 1] = 128;
+            new[width_maxy_x + 1] = 128;
+
+            new[width_miny_x + width] = 128;
+            new[width_maxy_x + width] = 128;
+
+            new[width_miny_x + 1 + width] = 128;
+            new[width_maxy_x + 1 + width] = 128;
+        }
+
+        for (y = cent->miny; y <= cent->maxy; y += 2) {
+            int width_minx_y = cent->minx + y * width; 
+            int width_maxx_y = cent->maxx + y * width;
+            int cwidth_minx_y = (cent->minx / 2) + (y / 2) * cwidth; 
+            int cwidth_maxx_y = (cent->maxx / 2) + (y / 2) * cwidth;
+
+            new_u[cwidth_minx_y] = 128;
+            new_u[cwidth_maxx_y] = 128;
+            new_v[cwidth_minx_y] = 255;
+            new_v[cwidth_maxx_y] = 255;
+
+            new[width_minx_y] = 128;
+            new[width_maxx_y] = 128;
+
+            new[width_minx_y + width] = 128;
+            new[width_maxx_y + width] = 128;
+
+            new[width_minx_y + 1] = 128;
+            new[width_maxx_y + 1] = 128;
+
+            new[width_minx_y + width + 1] = 128;
+            new[width_maxx_y + width + 1] = 128;
+        }
+    } else if (style == LOCATE_REDCROSS) { /* Draw a red cross on normal images. */
+        int cwidth_maxy = cwidth * (cent->y / 2);
+        
+        for (x = cent->x - 10; x <= cent->x + 10; x += 2) {
+            int cwidth_maxy_x = x / 2 + cwidth_maxy;
+
+            new_u[cwidth_maxy_x] = 128;
+            new_v[cwidth_maxy_x] = 255;
+        }
+
+        for (y = cent->y - 10; y <= cent->y + 10; y += 2) {
+            int cwidth_minx_y = (cent->x / 2) + (y / 2) * cwidth; 
+            
+            new_u[cwidth_minx_y] = 128;
+            new_v[cwidth_minx_y] = 255;
+        }
+    }
+}
+
 
 #define NORM               100
 #define ABS(x)             ((x) < 0 ? -(x) : (x))
-#define DIFF(x, y)         (ABS((x) - (y)))
-#define NDIFF(x, y)        (ABS(x) * NORM/(ABS(x) + 2 * DIFF(x,y)))
-
+#define DIFF(x, y)         (ABS((x)-(y)))
+#define NDIFF(x, y)        (ABS(x) * NORM / (ABS(x) + 2 * DIFF(x, y)))
 
+/**
+ * alg_noise_tune
+ *
+ */
 void alg_noise_tune(struct context *cnt, unsigned char *new)
 {
     struct images *imgs = &cnt->imgs;
@@ -216,25 +367,33 @@ void alg_noise_tune(struct context *cnt,
 
     i = imgs->motionsize;
             
-    for (; i>0; i--) {
+    for (; i > 0; i--) {
         diff = ABS(*ref - *new);
+
         if (mask)
-            diff = ((diff * *mask++)/255);
-        if (*smartmask){
+            diff = ((diff * *mask++) / 255);
+
+        if (*smartmask) {
             sum += diff + 1;
             count++;
         }
+
         ref++;
         new++;
         smartmask++;
     }
 
-    if (count > 3) /* avoid divide by zero */
+    if (count > 3)  /* Avoid divide by zero. */
         sum /= count / 3;
     
-    cnt->noise = 4 + (cnt->noise + sum) / 2;  /* 5: safe, 4: regular, 3: more sensitive */
+    /* 5: safe, 4: regular, 3: more sensitive */
+    cnt->noise = 4 + (cnt->noise + sum) / 2;
 }
 
+/**
+ * alg_threshold_tune
+ *
+ */
 void alg_threshold_tune(struct context *cnt, int diffs, int motion)
 {
     int i;
@@ -248,6 +407,7 @@ void alg_threshold_tune(struct context *
 
     for (i = 0; i < THRESHOLD_TUNE_LENGTH - 1; i++) {
         sum += cnt->diffs_last[i];
+        
         if (cnt->diffs_last[i + 1] && !motion)
             cnt->diffs_last[i] = cnt->diffs_last[i + 1];
         else
@@ -256,10 +416,12 @@ void alg_threshold_tune(struct context *
         if (cnt->diffs_last[i] > top)
             top = cnt->diffs_last[i];
     }
+
     sum += cnt->diffs_last[i];
     cnt->diffs_last[i] = diffs;
 
     sum /= THRESHOLD_TUNE_LENGTH / 4;
+
     if (sum < top * 2)
         sum = top * 2;
 
@@ -268,47 +430,50 @@ void alg_threshold_tune(struct context *
 }
 
 /*
-Labeling by Joerg Weber. Based on an idea from Hubert Mara.
-Floodfill enhanced by Ian McConnel based on code from
-http://www.acm.org/pubs/tog/GraphicsGems/
-http://www.codeproject.com/gdi/QuickFill.asp
-*/
+ * Labeling by Joerg Weber. Based on an idea from Hubert Mara.
+ * Floodfill enhanced by Ian McConnel based on code from
+ * http://www.acm.org/pubs/tog/GraphicsGems/
+ * http://www.codeproject.com/gdi/QuickFill.asp
 
-/*
- * Filled horizontal segment of scanline y for xl<=x<=xr.
- * Parent segment was on line y-dy.  dy=1 or -1
+ * Filled horizontal segment of scanline y for xl <= x <= xr.
+ * Parent segment was on line y - dy.  dy = 1 or -1
  */
 
 #define MAXS 10000               /* max depth of stack */
 
-#define PUSH(Y, XL, XR, DY)     /* push new segment on stack */ \
-        if (sp<stack+MAXS && Y+(DY) >= 0 && Y+(DY) < height) \
+#define PUSH(Y, XL, XR, DY)     /* push new segment on stack */  \
+        if (sp<stack+MAXS && Y+(DY) >= 0 && Y+(DY) < height)     \
         {sp->y = Y; sp->xl = XL; sp->xr = XR; sp->dy = DY; sp++;}
 
-#define POP(Y, XL, XR, DY)      /* pop segment off stack */ \
+#define POP(Y, XL, XR, DY)      /* pop segment off stack */      \
         {sp--; Y = sp->y+(DY = sp->dy); XL = sp->xl; XR = sp->xr;}
 
-typedef struct {short y, xl, xr, dy;} Segment;
+typedef struct {
+    short y, xl, xr, dy;
+} Segment;
 
-
-static int iflood(int x, int y,       
-                  int width, int height, unsigned char *out, int *labels, int newvalue, int oldvalue)
+/**
+ * iflood
+ *
+ */ 
+static int iflood(int x, int y, int width, int height, 
+                  unsigned char *out, int *labels, int newvalue, int oldvalue)
 {
     int l, x1, x2, dy;
-    Segment stack[MAXS], *sp = stack;    /* stack of filled segments */
+    Segment stack[MAXS], *sp = stack;    /* Stack of filled segments. */
     int count = 0;
 
     if (x < 0 || x >= width || y < 0 || y >= height)
         return 0;
 
-    PUSH(y, x, x, 1);             /* needed in some cases */
-    PUSH(y+1, x, x, -1);          /* seed segment (popped 1st) */
+    PUSH(y, x, x, 1);             /* Needed in some cases. */
+    PUSH(y+1, x, x, -1);          /* Seed segment (popped 1st). */
 
     while (sp > stack) {
-        /* pop segment off stack and fill a neighboring scan line */
+        /* Pop segment off stack and fill a neighboring scan line. */
         POP(y, x1, x2, dy);
         /*
-         * segment of scan line y-dy for x1<=x<=x2 was previously filled,
+         * Segment of scan line y-dy for x1<=x<=x2 was previously filled,
          * now explore adjacent pixels in scan line y
          */
         for (x = x1; x >= 0 && out[y * width + x] != 0 && labels[y * width + x] == oldvalue; x--) {
@@ -322,7 +487,7 @@ static int iflood(int x, int y,
         l = x + 1;
         
         if (l < x1)
-            PUSH(y, l, x1-1, -dy);  /* leak on left? */
+            PUSH(y, l, x1 - 1, -dy);  /* Leak on left? */
         
         x = x1 + 1;
         
@@ -335,7 +500,7 @@ static int iflood(int x, int y,
             PUSH(y, l, x - 1, dy);
             
             if (x > x2 + 1)
-                PUSH(y, x2 + 1, x - 1, -dy);  /* leak on right? */
+                PUSH(y, x2 + 1, x - 1, -dy);  /* Leak on right? */
             
             skip:
             
@@ -347,6 +512,10 @@ static int iflood(int x, int y,
     return count;
 }
 
+/**
+ * alg_labeling
+ *
+ */ 
 static int alg_labeling(struct context *cnt)
 {
     struct images *imgs = &cnt->imgs;
@@ -357,60 +526,76 @@ static int alg_labeling(struct context *
     int height = imgs->height;
     int labelsize = 0;
     int current_label = 2;
+
     cnt->current_image->total_labels = 0;
     imgs->labelsize_max = 0;
-    /* ALL labels above threshold are counted as labelgroup */
+    /* ALL labels above threshold are counted as labelgroup. */
     imgs->labelgroup_max = 0;
     imgs->labels_above = 0;
 
-    /* init: 0 means no label set / not checked */
+    /* Init: 0 means no label set / not checked. */
     memset(labels, 0, width * height * sizeof(labels));
     pixelpos = 0;
+
     for (iy = 0; iy < height - 1; iy++) {
         for (ix = 0; ix < width - 1; ix++, pixelpos++) {
-            /* no motion - no label */
+            /* No motion - no label */
             if (out[pixelpos] == 0) {
                 labels[pixelpos] = 1;
                 continue;
             }
             
-            /* already visited by iflood */
+            /* Already visited by iflood */
             if (labels[pixelpos] > 0)
                 continue;
-            labelsize=iflood(ix, iy, width, height, out, labels, current_label, 0);
+
+            labelsize = iflood(ix, iy, width, height, out, labels, current_label, 0);
             
             if (labelsize > 0) {
-                /* Label above threshold? Mark it again (add 32768 to labelnumber) */
+                MOTION_LOG(DBG, TYPE_ALL, NO_ERRNO, "%s: Label: %i (%i) Size: %i (%i,%i)", 
+                            current_label, cnt->current_image->total_labels, 
+                           labelsize, ix, iy);
+
+                /* Label above threshold? Mark it again (add 32768 to labelnumber). */
                 if (labelsize > cnt->threshold) {
-                    labelsize=iflood(ix, iy, width, height, out, labels, current_label + 32768, current_label);
+                    labelsize = iflood(ix, iy, width, height, out, labels, current_label + 32768, current_label);
                     imgs->labelgroup_max += labelsize;
                     imgs->labels_above++;
                 }
                 
                 if (imgs->labelsize_max < labelsize) {
-                    imgs->labelsize_max=labelsize;
-                    imgs->largest_label=current_label;
+                    imgs->labelsize_max = labelsize;
+                    imgs->largest_label = current_label;
                 }
                 
                 cnt->current_image->total_labels++;
                 current_label++;
             }
         }
-        pixelpos++; /* compensate for ix<width-1 */
-    }    
-    /* return group of significant labels */
+        pixelpos++; /* Compensate for ix < width - 1 */
+    }
+
+    MOTION_LOG(DBG, TYPE_ALL, NO_ERRNO, "%s: %i Labels found. Largest connected Area: %i Pixel(s). "
+               "Largest Label: %i", imgs->largest_label, imgs->labelsize_max, 
+               cnt->current_image->total_labels);
+    
+    /* Return group of significant labels. */
     return imgs->labelgroup_max;
 }
 
-/* Dilates a 3x3 box */
+/** 
+ * dilate9 
+ *      Dilates a 3x3 box. 
+ */
 static int dilate9(unsigned char *img, int width, int height, void *buffer)
 {
-    /* - row1, row2 and row3 represent lines in the temporary buffer 
-     * - window is a sliding window containing max values of the columns
-     *   in the 3x3 matrix
-     * - widx is an index into the sliding window (this is faster than 
-     *   doing modulo 3 on i)
-     * - blob keeps the current max value
+    /* 
+     * - row1, row2 and row3 represent lines in the temporary buffer. 
+     * - Window is a sliding window containing max values of the columns
+     *   in the 3x3 matrix.
+     * - width is an index into the sliding window (this is faster than 
+     *   doing modulo 3 on i).
+     * - blob keeps the current max value.
      */
     int y, i, sum = 0, widx;
     unsigned char *row1, *row2, *row3, *rowTemp,*yp;
@@ -439,7 +624,7 @@ static int dilate9(unsigned char *img, i
         if (y == height - 1)
             memset(row3, 0, width);
         else
-            memcpy(row3, yp + width, width);
+            memcpy(row3, yp+width, width);
         
         /* Init slots 0 and 1 in the moving window. */
         window[0] = MAX3(row1[0], row2[0], row3[0]);
@@ -449,14 +634,16 @@ static int dilate9(unsigned char *img, i
         blob = MAX2(window[0], window[1]);
         widx = 2;
 
-        /* Iterate over the current row; index i is off by one to eliminate
+        /* 
+         * Iterate over the current row; index i is off by one to eliminate
          * a lot of +1es in the loop.
          */
         for (i = 2; i <= width - 1; i++) {
             /* Get the max value of the next column in the 3x3 matrix. */
             latest = window[widx] = MAX3(row1[i], row2[i], row3[i]);
 
-            /* If the value is larger than the current max, use it. Otherwise,
+            /* 
+             * If the value is larger than the current max, use it. Otherwise,
              * calculate a new max (because the new value may not be the max.
              */
             if (latest >= blob)
@@ -483,11 +670,15 @@ static int dilate9(unsigned char *img, i
     return sum;
 }
 
-/* Dilates a + shape */
+/** 
+ * dilate5 
+ *      Dilates a + shape. 
+ */
 static int dilate5(unsigned char *img, int width, int height, void *buffer)
 {
-    /* - row1, row2 and row3 represent lines in the temporary buffer 
-     * - mem holds the max value of the overlapping part of two + shapes
+    /* 
+     * - row1, row2 and row3 represent lines in the temporary buffer. 
+     * - mem holds the max value of the overlapping part of two + shapes.
      */
     int y, i, sum = 0;
     unsigned char *row1, *row2, *row3, *rowTemp, *yp;
@@ -516,7 +707,7 @@ static int dilate5(unsigned char *img, i
         if (y == height - 1)
             memset(row3, 0, width);
         else
-            memcpy(row3, yp+width, width);
+            memcpy(row3, yp + width, width);
 
         /* Init mem and set blob to force an evaluation of the entire + shape. */
         mem = MAX2(row2[0], row2[1]);
@@ -550,48 +741,59 @@ static int dilate5(unsigned char *img, i
     return sum;
 }
 
-/* Erodes a 3x3 box */
+/** 
+ * erode9 
+ *      Erodes a 3x3 box. 
+ */
 static int erode9(unsigned char *img, int width, int height, void *buffer, unsigned char flag)
 {
     int y, i, sum = 0;
     char *Row1,*Row2,*Row3;
+
     Row1 = buffer;
     Row2 = Row1 + width;
-    Row3 = Row1 + 2*width;
+    Row3 = Row1 + 2 * width;
     memset(Row2, flag, width);
     memcpy(Row3, img, width);
+
     for (y = 0; y < height; y++) {
         memcpy(Row1, Row2, width);
         memcpy(Row2, Row3, width);
-        if (y == height - 1)
+
+        if (y == height-1)
             memset(Row3, flag, width);
         else
-            memcpy(Row3, img+(y + 1) * width, width);
+            memcpy(Row3, img + (y+1) * width, width);
 
-        for (i = width-2; i >= 1; i--) {
-            if (Row1[i-1] == 0 ||
-                Row1[i]   == 0 ||
-                Row1[i+1] == 0 ||
-                Row2[i-1] == 0 ||
-                Row2[i]   == 0 ||
-                Row2[i+1] == 0 ||
-                Row3[i-1] == 0 ||
-                Row3[i]   == 0 ||
-                Row3[i+1] == 0)
+        for (i = width - 2; i >= 1; i--) {
+            if (Row1[i - 1] == 0 ||
+                Row1[i]     == 0 ||
+                Row1[i + 1] == 0 ||
+                Row2[i - 1] == 0 ||
+                Row2[i]     == 0 ||
+                Row2[i + 1] == 0 ||
+                Row3[i - 1] == 0 ||
+                Row3[i]     == 0 ||
+                Row3[i + 1] == 0)
                 img[y * width + i] = 0;
             else
                 sum++;
         }
+
         img[y * width] = img[y * width + width - 1] = flag;
     }
     return sum;
 }
 
-/* Erodes in a + shape */
+/**
+ * erode5 
+ *      Erodes in a + shape. 
+ */
 static int erode5(unsigned char *img, int width, int height, void *buffer, unsigned char flag)
 {
     int y, i, sum = 0;
     char *Row1,*Row2,*Row3;
+
     Row1 = buffer;
     Row2 = Row1 + width;
     Row3 = Row1 + 2 * width;
@@ -607,12 +809,12 @@ static int erode5(unsigned char *img, in
         else
             memcpy(Row3, img + (y + 1) * width, width);
 
-        for (i = width-2; i >= 1; i--) {
-            if (Row1[i]   == 0 ||
-                Row2[i-1] == 0 ||
-                Row2[i]   == 0 ||
-                Row2[i+1] == 0 ||
-                Row3[i]   == 0)
+        for (i = width - 2; i >= 1; i--) {
+            if (Row1[i]     == 0 ||
+                Row2[i - 1] == 0 ||
+                Row2[i]     == 0 ||
+                Row2[i + 1] == 0 ||
+                Row3[i]     == 0)
                 img[y * width + i] = 0;
             else
                 sum++;
@@ -623,20 +825,21 @@ static int erode5(unsigned char *img, in
     return sum;
 }
 
-/* 
- * Despeckling routine to remove noisy detections.
+/** 
+ * alg_despeckle 
+ *      Despeckling routine to remove noisy detections.
  */
 int alg_despeckle(struct context *cnt, int olddiffs)
 {
     int diffs = 0;
     unsigned char *out = cnt->imgs.out;
     int width = cnt->imgs.width;
-    int height= cnt->imgs.height;
-    int done = 0, i, len = strlen(cnt->conf.despeckle);
+    int height = cnt->imgs.height;
+    int done = 0, i, len = strlen(cnt->conf.despeckle_filter);
     unsigned char *common_buffer = cnt->imgs.common_buffer;
 
     for (i = 0; i < len; i++) {
-        switch (cnt->conf.despeckle[i]) {
+        switch (cnt->conf.despeckle_filter[i]) {
         case 'E':
             if ((diffs = erode9(out, width, height, common_buffer, 0)) == 0) 
                 i = len;
@@ -655,7 +858,7 @@ int alg_despeckle(struct context *cnt, i
             diffs = dilate5(out, width, height, common_buffer);
             done = 1;
             break;
-        /* no further despeckle after labeling! */
+        /* No further despeckle after labeling! */
         case 'l':
             diffs = alg_labeling(cnt);
             i = len;
@@ -664,58 +867,66 @@ int alg_despeckle(struct context *cnt, i
         }
     }
 
-    /* If conf.despeckle contains any valid action EeDdl */
+    /* If conf.despeckle_filter contains any valid action EeDdl */
     if (done) {
         if (done != 2) 
             cnt->imgs.labelsize_max = 0; // Disable Labeling
         return diffs;
     } else {
         cnt->imgs.labelsize_max = 0; // Disable Labeling
-    }
-
+    }    
+    
     return olddiffs;
 }
 
-/* Generate actual smartmask. Calculate sensitivity based on motion */
+/** 
+ * alg_tune_smartmask 
+ *      Generates actual smartmask. Calculate sensitivity based on motion.
+ */
 void alg_tune_smartmask(struct context *cnt)
 {
     int i, diff;
-    
     int motionsize = cnt->imgs.motionsize;
     unsigned char *smartmask = cnt->imgs.smartmask;
     unsigned char *smartmask_final = cnt->imgs.smartmask_final;
     int *smartmask_buffer = cnt->imgs.smartmask_buffer;
-    int sensitivity=cnt->lastrate*(11-cnt->smartmask_speed);
+    int sensitivity = cnt->lastrate * (11 - cnt->smartmask_speed);
 
     for (i = 0; i < motionsize; i++) {
-    
-        /* Decrease smart_mask sensitivity every 5*speed seconds only */
+        /* Decrease smart_mask sensitivity every 5*speed seconds only. */
         if (smartmask[i] > 0)
             smartmask[i]--;
-        /* Increase smart_mask sensitivity based on the buffered values */
+        /* Increase smart_mask sensitivity based on the buffered values. */
         diff = smartmask_buffer[i]/sensitivity;
+
         if (diff) {
             if (smartmask[i] <= diff + 80)
                 smartmask[i] += diff;
             else
-                smartmask[i]=80;
-            smartmask_buffer[i]%=sensitivity;
+                smartmask[i] = 80;
+            smartmask_buffer[i] %= sensitivity;
         }
-        /* Transfer raw mask to the final stage when above trigger value */
+        /* Transfer raw mask to the final stage when above trigger value. */
         if (smartmask[i] > 20)
             smartmask_final[i] = 0;
         else
             smartmask_final[i] = 255;
     }
-    /* Further expansion (here:erode due to inverted logic!) of the mask */
-    diff = erode9(smartmask_final, cnt->imgs.width, cnt->imgs.height, cnt->imgs.common_buffer, 255);
-    diff = erode5(smartmask_final, cnt->imgs.width, cnt->imgs.height, cnt->imgs.common_buffer, 255);
+    /* Further expansion (here:erode due to inverted logic!) of the mask. */
+    diff = erode9(smartmask_final, cnt->imgs.width, cnt->imgs.height, 
+                  cnt->imgs.common_buffer, 255);
+    diff = erode5(smartmask_final, cnt->imgs.width, cnt->imgs.height, 
+                  cnt->imgs.common_buffer, 255);
 }
 
 /* Increment for *smartmask_buffer in alg_diff_standard. */
 #define SMARTMASK_SENSITIVITY_INCR 5
 
-int alg_diff_standard (struct context *cnt, unsigned char *new)
+/**
+ * alg_diff_standard
+ *
+ */
+int alg_diff_standard(struct context *cnt, unsigned char *new)
 {
     struct images *imgs = &cnt->imgs;
     int i, diffs = 0;
@@ -724,23 +935,25 @@ int alg_diff_standard (struct context *c
     unsigned char *ref = imgs->ref;
     unsigned char *out = imgs->out;
     unsigned char *mask = imgs->mask;
-    unsigned char *smartmask_final=imgs->smartmask_final;
+    unsigned char *smartmask_final = imgs->smartmask_final;
     int *smartmask_buffer = imgs->smartmask_buffer;
 #ifdef HAVE_MMX
-    mmx_t mmtemp; /* used for transferring to/from memory */
-    int unload;   /* counter for unloading diff counts */
+    mmx_t mmtemp; /* Used for transferring to/from memory. */
+    int unload;   /* Counter for unloading diff counts. */
 #endif
 
     i = imgs->motionsize;
-    memset(out + i, 128, i / 2); /* motion pictures are now b/w i.o. green */
-    /* Keeping this memset in the MMX case when zeroes are necessarily 
+    memset(out + i, 128, i / 2); /* Motion pictures are now b/w i.o. green */
+    /* 
+     * Keeping this memset in the MMX case when zeroes are necessarily 
      * written anyway seems to be beneficial in terms of speed. Perhaps a
      * cache thing?
      */
     memset(out, 0, i);
 
 #ifdef HAVE_MMX
-    /* NOTE: The Pentium has two instruction pipes: U and V. I have grouped MMX
+    /* 
+     * NOTE: The Pentium has two instruction pipes: U and V. I have grouped MMX
      * instructions in pairs according to how I think they will be scheduled in 
      * the U and V pipes. Due to pairing constraints, the V pipe will sometimes
      * be empty (for example, memory access always goes into the U pipe).
@@ -753,13 +966,16 @@ int alg_diff_standard (struct context *c
      * -- Per Jonsson
      */
 
-    /* To avoid a div, we work with differences multiplied by 255 in the
+    /* 
+     * To avoid a div, we work with differences multiplied by 255 in the
      * default case and *mask otherwise. Thus, the limit to compare with is
-     * 255*(noise+1)-1).
+     * 255 * (noise + 1) - 1).
      */
-    mmtemp.uw[0] = mmtemp.uw[1] = mmtemp.uw[2] = mmtemp.uw[3] = (unsigned short)(noise * 255 + 254);
+    mmtemp.uw[0] = mmtemp.uw[1] = mmtemp.uw[2] = mmtemp.uw[3] =
+                   (unsigned short)(noise * 255 + 254);
     
-    /* Reset mm5 to zero, set the mm6 mask, and store the multiplied noise
+    /* 
+     * Reset mm5 to zero, set the mm6 mask, and store the multiplied noise
      * level as four words in mm7.
      */
     movq_m2r(mmtemp, mm7);             /* U */
@@ -768,7 +984,8 @@ int alg_diff_standard (struct context *c
     pxor_r2r(mm5, mm5);                /* U */
     psrlw_i2r(8, mm6);                 /* V */
 
-    /* We must unload mm5 every 255th round, because the diffs accumulate
+    /* 
+     * We must unload mm5 every 255th round, because the diffs accumulate
      * in each packed byte, which can hold at most 255 diffs before it
      * gets saturated.
      */
@@ -796,7 +1013,8 @@ int alg_diff_standard (struct context *c
         punpckhbw_r2r(mm4, mm1);       /* U: mm1 =    d7    d6    d5    d4 */
 
         if (mask) {
-            /* Load and expand 8 mask bytes to words in mm2 and mm3. Then
+            /*
+             * Load and expand 8 mask bytes to words in mm2 and mm3. Then
              * multiply by mm0 and mm1, respectively.
              */
             movq_m2r(*mask, mm2);      /* U: mm2 = m7 m6 m5 m4 m3 m2 m1 m0 */
@@ -809,9 +1027,10 @@ int alg_diff_standard (struct context *c
             
             pmullw_r2r(mm3, mm1);      /* U: mm1 = (d7*m7) ... (d4*m4) */
 
-            mask+=8;
+            mask += 8;
         } else {
-            /* Not using mask - multiply the absolute differences by 255. We
+            /* 
+             * Not using mask - multiply the absolute differences by 255. We
              * do this by left-shifting 8 places and then subtracting dX.
              */
             movq_r2r(mm0, mm2);        /* U: mm2 =    d3    d2    d1    d0 */
@@ -824,7 +1043,8 @@ int alg_diff_standard (struct context *c
             psubusw_r2r(mm3, mm1);     /* V */ 
         }
 
-        /* Next, compare the multiplied absolute differences with the multiplied
+        /* 
+         * Next, compare the multiplied absolute differences with the multiplied
          * noise level (repeated as 4 words in mm7), resulting in a "motion flag"
          * for each pixel.
          *
@@ -851,32 +1071,34 @@ int alg_diff_standard (struct context *c
         packuswb_r2r(mm1, mm0);        /* U: mm0 = f7 f6 f5 f4 f3 f2 f1 f0 */
 
         if (smartmask_speed) {
-            /* Apply the smartmask. Basically, if *smartmask_final is 0, the
+            /*
+             * Apply the smartmask. Basically, if *smartmask_final is 0, the
              * corresponding "motion flag" in mm0 will be reset.
              */
             movq_m2r(*smartmask_final, mm3); /* U: mm3 = s7 s6 s5 s4 s3 s2 s1 s0 */
 
-            /* ...but move the "motion flags" to memory before, in order to
+            /* 
+             * ...but move the "motion flags" to memory before, in order to
              * increment *smartmask_buffer properly below.
              */
             movq_r2m(mm0, mmtemp);           /* U */
             pcmpeqb_r2r(mm4, mm3);           /* V: mm3 = 0xff where sX==0 */
 
-            /* ANDN negates the target before anding. */
+            /* AND negates the target before anding. */
             pandn_r2r(mm0, mm3);             /* U: mm3 = 0xff where dX>noise && sX>0 */
 
             movq_r2r(mm3, mm0);              /* U */
 
             /* Add to *smartmask_buffer. This is probably the fastest way to do it. */
             if (cnt->event_nr != cnt->prev_event) {
-                if (mmtemp.ub[0]) smartmask_buffer[0]+=SMARTMASK_SENSITIVITY_INCR;
-                if (mmtemp.ub[1]) smartmask_buffer[1]+=SMARTMASK_SENSITIVITY_INCR;
-                if (mmtemp.ub[2]) smartmask_buffer[2]+=SMARTMASK_SENSITIVITY_INCR;
-                if (mmtemp.ub[3]) smartmask_buffer[3]+=SMARTMASK_SENSITIVITY_INCR;
-                if (mmtemp.ub[4]) smartmask_buffer[4]+=SMARTMASK_SENSITIVITY_INCR;
-                if (mmtemp.ub[5]) smartmask_buffer[5]+=SMARTMASK_SENSITIVITY_INCR;
-                if (mmtemp.ub[6]) smartmask_buffer[6]+=SMARTMASK_SENSITIVITY_INCR;
-                if (mmtemp.ub[7]) smartmask_buffer[7]+=SMARTMASK_SENSITIVITY_INCR;
+                if (mmtemp.ub[0]) smartmask_buffer[0] += SMARTMASK_SENSITIVITY_INCR;
+                if (mmtemp.ub[1]) smartmask_buffer[1] += SMARTMASK_SENSITIVITY_INCR;
+                if (mmtemp.ub[2]) smartmask_buffer[2] += SMARTMASK_SENSITIVITY_INCR;
+                if (mmtemp.ub[3]) smartmask_buffer[3] += SMARTMASK_SENSITIVITY_INCR;
+                if (mmtemp.ub[4]) smartmask_buffer[4] += SMARTMASK_SENSITIVITY_INCR;
+                if (mmtemp.ub[5]) smartmask_buffer[5] += SMARTMASK_SENSITIVITY_INCR;
+                if (mmtemp.ub[6]) smartmask_buffer[6] += SMARTMASK_SENSITIVITY_INCR;
+                if (mmtemp.ub[7]) smartmask_buffer[7] += SMARTMASK_SENSITIVITY_INCR;
             }
 
             smartmask_buffer += 8;
@@ -885,19 +1107,22 @@ int alg_diff_standard (struct context *c
 
         movq_m2r(*new, mm2);           /* U: mm1 = n7 n6 n5 n4 n3 n2 n1 n0 */
 
-        /* Cancel out pixels in *new according to the "motion flags" in mm0.
+        /*
+         * Cancel out pixels in *new according to the "motion flags" in mm0.
          * Each NX is either 0 or nX as from *new.
          */
         pand_r2r(mm0, mm2);            /* U: mm1 = N7 N6 N5 N4 N3 N2 N1 N0 */
         psubb_r2r(mm0, mm4);           /* V: mm4 = 0x01 where dX>noise */
 
-        /* mm5 holds 8 separate counts - each one is increased according to
+        /*
+         * mm5 holds 8 separate counts - each one is increased according to
          * the contents of mm4 (where each byte is either 0x00 or 0x01). 
          */
         movq_r2m(mm2, *out);           /* U: this will stall */
         paddusb_r2r(mm4, mm5);         /* V: add counts to mm5 */
         
-        /* Every 255th turn, we need to unload mm5 into the diffs variable,
+        /*
+         * Every 255th turn, we need to unload mm5 into the diffs variable,
          * because otherwise the packed bytes will get saturated.
          */
         if (--unload == 0) {
@@ -910,12 +1135,13 @@ int alg_diff_standard (struct context *c
             unload = 255;
         }
 
-        out+=8;
-        ref+=8;
-        new+=8;
+        out += 8;
+        ref += 8;
+        new += 8;
     }
 
-    /* Check if there are diffs left in mm5 that need to be copied to the
+    /* 
+     * Check if there are diffs left in mm5 that need to be copied to the
      * diffs variable. 
      */
     if (unload < 255) {
@@ -927,27 +1153,30 @@ int alg_diff_standard (struct context *c
     emms();
 
 #endif
-    /* Note that the non-MMX code is present even if the MMX code is present.
+    /*
+     * Note that the non-MMX code is present even if the MMX code is present.
      * This is necessary if the resolution is not a multiple of 8, in which
      * case the non-MMX code needs to take care of the remaining pixels.
      */
 
-    for (; i>0; i--) {
-        register unsigned char curdiff=(int)(abs(*ref - *new)); /* using a temp variable is 12% faster */
-        /* apply fixed mask */
+    for (; i > 0; i--) {
+        register unsigned char curdiff = (int)(abs(*ref - *new)); /* Using a temp variable is 12% faster. */
+        /* Apply fixed mask */
         if (mask)
-            curdiff=((int)(curdiff * *mask++) / 255);
+            curdiff = ((int)(curdiff * *mask++) / 255);
             
         if (smartmask_speed) {
             if (curdiff > noise) {
-                /* increase smart_mask sensitivity every frame when motion
-                   is detected. (with speed=5, mask is increased by 1 every
-                   second. To be able to increase by 5 every second (with
-                   speed=10) we add 5 here. NOT related to the 5 at ratio-
-                   calculation. */
+                /* 
+                 * Increase smart_mask sensitivity every frame when motion
+                 * is detected. (with speed=5, mask is increased by 1 every
+                 * second. To be able to increase by 5 every second (with
+                 * speed=10) we add 5 here. NOT related to the 5 at ratio-
+                 * calculation. 
+                 */
                 if (cnt->event_nr != cnt->prev_event)
                     (*smartmask_buffer) += SMARTMASK_SENSITIVITY_INCR;
-                /* apply smart_mask */
+                /* Apply smart_mask */
                 if (!*smartmask_final)
                     curdiff = 0;
             }
@@ -966,25 +1195,26 @@ int alg_diff_standard (struct context *c
     return diffs;
 }
 
-/*
-    Very fast diff function, does not apply mask overlaying.
-*/
+/**
+ * alg_diff_fast 
+ *      Very fast diff function, does not apply mask overlaying.
+ */
 static char alg_diff_fast(struct context *cnt, int max_n_changes, unsigned char *new)
 {
     struct images *imgs = &cnt->imgs;
-    int i, diffs = 0, step = imgs->motionsize / 10000;
-    int noise=cnt->noise;
+    int i, diffs = 0, step = imgs->motionsize/10000;
+    int noise = cnt->noise;
     unsigned char *ref = imgs->ref;
 
     if (!step % 2)
         step++;
-    /* we're checking only 1 of several pixels */
+    /* We're checking only 1 of several pixels. */
     max_n_changes /= step;
 
     i = imgs->motionsize;
 
     for (; i > 0; i -= step) {
-        register unsigned char curdiff = (int)(abs((char)(*ref-*new))); /* using a temp variable is 12% faster */
+        register unsigned char curdiff = (int)(abs((char)(*ref - *new))); /* Using a temp variable is 12% faster. */
         if (curdiff >  noise) {
             diffs++;
             if (diffs > max_n_changes)
@@ -997,9 +1227,11 @@ static char alg_diff_fast(struct context
     return 0;
 }
 
-/* alg_diff uses diff_fast to quickly decide if there is anything worth
- * sending to diff_standard.
-*/
+/** 
+ * alg_diff 
+ *      Uses diff_fast to quickly decide if there is anything worth
+ *      sending to diff_standard.
+ */
 int alg_diff(struct context *cnt, unsigned char *new)
 {
     int diffs = 0;
@@ -1010,9 +1242,11 @@ int alg_diff(struct context *cnt, unsign
     return diffs;
 }
 
-/* Detect a sudden massive change in the picture.
-   It is assumed to be the light being switched on or a camera displacement.
-   In any way the user doesn't think it is worth capturing.
+/** 
+ * alg_lightswitch 
+ *      Detects a sudden massive change in the picture.
+ *      It is assumed to be the light being switched on or a camera displacement.
+ *      In any way the user doesn't think it is worth capturing.
  */
 int alg_lightswitch(struct context *cnt, int diffs)
 {
@@ -1023,13 +1257,17 @@ int alg_lightswitch(struct context *cnt,
     if (cnt->conf.lightswitch > 100)
         cnt->conf.lightswitch = 100;
     
-    /* is lightswitch percent of the image changed?  */
+    /* Is lightswitch percent of the image changed? */
     if (diffs > (imgs->motionsize * cnt->conf.lightswitch / 100))
         return 1;
     
     return 0;
 }
 
+/**
+ * alg_switchfilter
+ *
+ */ 
 int alg_switchfilter(struct context *cnt, int diffs, unsigned char *newimg)
 {
     int linediff = diffs / cnt->imgs.height;
@@ -1042,7 +1280,6 @@ int alg_switchfilter(struct context *cnt
         for (x = 0; x < cnt->imgs.width; x++) {
             if (*(out++)) 
                 line++;
-            
         }
 
         if (line > cnt->imgs.width / 18) 
@@ -1050,7 +1287,6 @@ int alg_switchfilter(struct context *cnt
         
         if (line > linediff * 2) 
             lines++;
-        
     }
 
     if (vertlines > cnt->imgs.height / 10 && lines < vertlines / 3 &&
@@ -1058,7 +1294,7 @@ int alg_switchfilter(struct context *cnt
         if (cnt->conf.text_changes) {
             char tmp[80];
             sprintf(tmp, "%d %d", lines, vertlines);
-            draw_text(newimg, cnt->imgs.width-10, 20, cnt->imgs.width, tmp, cnt->conf.text_double);
+            draw_text(newimg, cnt->imgs.width - 10, 20, cnt->imgs.width, tmp, cnt->conf.text_double);
         }
         return diffs;
     }
@@ -1078,8 +1314,7 @@ int alg_switchfilter(struct context *cnt
  *   action - UPDATE_REF_FRAME or RESET_REF_FRAME
  *
  */
-/* Seconds */
-#define ACCEPT_STATIC_OBJECT_TIME 10
+#define ACCEPT_STATIC_OBJECT_TIME 10  /* Seconds */
 #define EXCLUDE_LEVEL_PERCENT 20
 void alg_update_reference_frame(struct context *cnt, int action) 
 {
@@ -1091,40 +1326,43 @@ void alg_update_reference_frame(struct c
     unsigned char *smartmask = cnt->imgs.smartmask_final;
     unsigned char *out = cnt->imgs.out;
 
-    if (cnt->lastrate > 5)  /* match rate limit */
+    if (cnt->lastrate > 5)  /* Match rate limit */
         accept_timer /= (cnt->lastrate / 3);
 
-    if (action == UPDATE_REF_FRAME) { /* black&white only for better performance */
+    if (action == UPDATE_REF_FRAME) { /* Black&white only for better performance. */
         threshold_ref = cnt->noise * EXCLUDE_LEVEL_PERCENT / 100;
+
         for (i = cnt->imgs.motionsize; i > 0; i--) {
-            /* exclude pixels from ref frame well below noise level */
+            /* Exclude pixels from ref frame well below noise level. */
             if (((int)(abs(*ref - *image_virgin)) > threshold_ref) && (*smartmask)) {
-                if (*ref_dyn == 0) { /* Always give new pixels a chance */
+                if (*ref_dyn == 0) { /* Always give new pixels a chance. */
                     *ref_dyn = 1;
-                } else if (*ref_dyn > accept_timer) { /* Include static Object after some time */
+                } else if (*ref_dyn > accept_timer) { /* Include static Object after some time. */
                     *ref_dyn = 0;
                     *ref = *image_virgin;
                 } else if (*out) {
-                    (*ref_dyn)++; /* Motionpixel? Keep excluding from ref frame */
+                    (*ref_dyn)++; /* Motionpixel? Keep excluding from ref frame. */
                 } else {
-                    *ref_dyn = 0; /* Nothing special - release pixel */
+                    *ref_dyn = 0; /* Nothing special - release pixel. */
                     *ref = (*ref + *image_virgin) / 2;
                 }
 
-            } else {  /* No motion: copy to ref frame */
-                *ref_dyn = 0; /* reset pixel */
+            } else {  /* No motion: copy to ref frame. */
+                *ref_dyn = 0; /* Reset pixel */
                 *ref = *image_virgin;
             }
+
             ref++;
             image_virgin++;
             smartmask++;
             ref_dyn++;
             out++;
         } /* end for i */
-    } else {   /* action == RESET_REF_FRAME - also used to initialize the frame at startup */
-        /* copy fresh image */
+
+    } else {   /* action == RESET_REF_FRAME - also used to initialize the frame at startup. */
+        /* Copy fresh image */
         memcpy(cnt->imgs.ref, cnt->imgs.image_virgin, cnt->imgs.size);
-        /* reset static objects */
-        memset(cnt->imgs.ref_dyn, 0, cnt->imgs.motionsize * sizeof(cnt->imgs.ref_dyn));
+        /* Reset static objects */
+        memset(cnt->imgs.ref_dyn, 0, cnt->imgs.motionsize * sizeof(cnt->imgs.ref_dyn)); 
     }
 }
--- motion-3.2.12.orig/alg.h
+++ motion-3.2.12/alg.h
@@ -32,7 +32,8 @@ struct segment {
 };
 
 void alg_locate_center_size(struct images *, int width, int height, struct coord *);
-void alg_draw_location(struct coord *, struct images *, int width, unsigned char *, int);
+void alg_draw_location(struct coord *, struct images *, int width, unsigned char *, int, int, int);
+void alg_draw_red_location(struct coord *, struct images *, int width, unsigned char *, int, int, int);
 int alg_diff(struct context *, unsigned char *);
 int alg_diff_standard(struct context *, unsigned char *);
 int alg_lightswitch(struct context *, int diffs);
--- /dev/null
+++ motion-3.2.12/commit-version.sh
@@ -0,0 +1,5 @@
+#!/bin/sh
+
+SNV_VERSION=`cd "$1" && LC_ALL=C svn info 2> /dev/null | grep Revision | cut -d' ' -f2`
+SNV_VERSION=`expr $SNV_VERSION + 1`
+echo -n "trunkREV$SNV_VERSION"
--- motion-3.2.12.orig/conf.c
+++ motion-3.2.12/conf.c
@@ -25,8 +25,7 @@
  */
 #include "motion.h"
 
-
-#if (defined(BSD))
+#if (defined(BSD) && !defined(PWCBSD))
 #include "video_freebsd.h"
 #else
 #include "video.h"
@@ -35,140 +34,151 @@
 #ifndef HAVE_GET_CURRENT_DIR_NAME
 char *get_current_dir_name(void)
 {
-    char *buf = malloc(MAXPATHLEN);
+    char *buf = mymalloc(MAXPATHLEN);
     getwd(buf);
     return buf;
 }
 #endif
 
-
-#define stripnewline(x) {if ((x)[strlen(x)-1]=='\n') (x)[strlen(x) - 1] = 0;}
-
+#define stripnewline(x) {if ((x)[strlen(x)-1]=='\n') (x)[strlen(x) - 1] = 0; }
 
 struct config conf_template = {
-    width:                      DEF_WIDTH,
-    height:                     DEF_HEIGHT,
-    quality:                    DEF_QUALITY,
-    rotate_deg:                 0,
-    max_changes:                DEF_CHANGES,
-    threshold_tune:             0,
-    output_normal:              "on",
-    motion_img:                 0,
-    output_all:                 0,
-    gap:                        DEF_GAP,
-    maxmpegtime:                DEF_MAXMPEGTIME,
-    snapshot_interval:          0,
-    locate:                     "off",
-    input:                      IN_DEFAULT,
-    norm:                       0,
-    frame_limit:                DEF_MAXFRAMERATE,
-    quiet:                      1,
-    ppm:                        0,
-    noise:                      DEF_NOISELEVEL,
-    noise_tune:                 1,
-    minimum_frame_time:         0,
-    lightswitch:                0,
-    autobright:                 0,
-    brightness:                 0,
-    contrast:                   0,
-    saturation:                 0,
-    hue:                        0,
-    roundrobin_frames:          1,
-    roundrobin_skip:            1,
-    pre_capture:                0,
-    post_capture:               0,
-    switchfilter:               0,
-    ffmpeg_cap_new:             0,
-    ffmpeg_cap_motion:          0,
-    ffmpeg_bps:                 DEF_FFMPEG_BPS,
-    ffmpeg_vbr:                 DEF_FFMPEG_VBR,
-    ffmpeg_video_codec:         DEF_FFMPEG_CODEC,
-    webcam_port:                0,
-    webcam_quality:             50,
-    webcam_motion:              0,
-    webcam_maxrate:             1,
-    webcam_localhost:           1,
-    webcam_limit:               0,
-    control_port:               0,
-    control_localhost:          1,
-    control_html_output:        1,
-    control_authentication:     NULL,
-    frequency:                  0,
-    tuner_number:               0,
-    timelapse:                  0,
-    timelapse_mode:             DEF_TIMELAPSE_MODE,
+    width:                          DEF_WIDTH,
+    height:                         DEF_HEIGHT,
+    quality:                        DEF_QUALITY,
+    rotate_deg:                     0,
+    max_changes:                    DEF_CHANGES,
+    threshold_tune:                 0,
+    output_pictures:                "on",
+    motion_img:                     0,
+    emulate_motion:                 0,
+    event_gap:                      DEF_EVENT_GAP,
+    max_movie_time:                 DEF_MAXMOVIETIME,
+    snapshot_interval:              0,
+    locate_motion_mode:             "off",
+    locate_motion_style:            "box",
+    input:                          IN_DEFAULT,
+    norm:                           0,
+    frame_limit:                    DEF_MAXFRAMERATE,
+    quiet:                          1,
+    picture_type:                   "jpeg",
+    noise:                          DEF_NOISELEVEL,
+    noise_tune:                     1,
+    minimum_frame_time:             0,
+    lightswitch:                    0,
+    autobright:                     0,
+    brightness:                     0,
+    contrast:                       0,
+    saturation:                     0,
+    hue:                            0,
+    roundrobin_frames:              1,
+    roundrobin_skip:                1,
+    pre_capture:                    0,
+    post_capture:                   0,
+    switchfilter:                   0,
+    ffmpeg_output:                  0,
+    extpipe:                        NULL,
+    useextpipe:                     0,
+    ffmpeg_output_debug:            0,
+    ffmpeg_bps:                     DEF_FFMPEG_BPS,
+    ffmpeg_vbr:                     DEF_FFMPEG_VBR,
+    ffmpeg_video_codec:             DEF_FFMPEG_CODEC,
+#ifdef HAVE_SDL
+    sdl_threadnr:                   0,
+#endif
+    ipv6_enabled:                   0,
+    stream_port:                    0,
+    stream_quality:                 50,
+    stream_motion:                  0,
+    stream_maxrate:                 1,
+    stream_localhost:               1,
+    stream_limit:                   0,
+    stream_auth_method:             0,
+    stream_authentication:          NULL,
+    webcontrol_port:                0,
+    webcontrol_localhost:           1,
+    webcontrol_html_output:         1,
+    webcontrol_authentication:      NULL,
+    frequency:                      0,
+    tuner_number:                   0,
+    timelapse:                      0,
+    timelapse_mode:                 DEF_TIMELAPSE_MODE,
 #if (defined(BSD))
-    tuner_device:               NULL,
+    tuner_device:                   NULL,
+#endif
+    video_device:                   VIDEO_DEVICE,
+    v4l2_palette:                   DEF_PALETTE,
+    vidpipe:                        NULL,
+    filepath:                       NULL,
+    imagepath:                      DEF_IMAGEPATH,
+    moviepath:                      DEF_MOVIEPATH,
+    snappath:                       DEF_SNAPPATH,
+    timepath:                       DEF_TIMEPATH,
+    on_event_start:                 NULL,
+    on_event_end:                   NULL,
+    mask_file:                      NULL,
+    smart_mask_speed:               0,
+#if defined(HAVE_MYSQL) || defined(HAVE_PGSQL) || defined(HAVE_SQLITE3)
+    sql_log_image:                  1,
+    sql_log_snapshot:               1,
+    sql_log_movie:                  0,
+    sql_log_timelapse:              0,
+    sql_query:                      DEF_SQL_QUERY,
+    database_type:                  NULL,
+    database_dbname:                NULL,
+    database_host:                  "localhost",
+    database_user:                  NULL,
+    database_password:              NULL,
+    database_port:                  0,
+#ifdef HAVE_SQLITE3
+    sqlite3_db:                     NULL,
 #endif
-    video_device:               VIDEO_DEVICE,
-    v4l2_palette:               8,        
-    vidpipe:                    NULL,
-    filepath:                   NULL,
-    jpegpath:                   DEF_JPEGPATH,
-    mpegpath:                   DEF_MPEGPATH,
-    snappath:                   DEF_SNAPPATH,
-    timepath:                   DEF_TIMEPATH,
-    on_event_start:             NULL,
-    on_event_end:               NULL,
-    mask_file:                  NULL,
-    smart_mask_speed:           0,
-    sql_log_image:              1,
-    sql_log_snapshot:           1,
-    sql_log_mpeg:               0,
-    sql_log_timelapse:          0,
-    sql_query:                  DEF_SQL_QUERY,
-    mysql_db:                   NULL,
-    mysql_host:                 "localhost",
-    mysql_user:                 NULL,
-    mysql_password:             NULL,
-    on_picture_save:            NULL,
-    on_motion_detected:         NULL,
-    on_area_detected:           NULL,
-    on_movie_start:             NULL,
-    on_movie_end:               NULL,
-    on_camera_lost:             NULL,
-    motionvidpipe:              NULL,
-    netcam_url:                 NULL,
-    netcam_userpass:            NULL,
-    netcam_http:                "1.0",    /* Choices: 1.0, 1.1, or keep_alive */
-    netcam_proxy:               NULL,
-    netcam_tolerant_check:      0,
-    pgsql_db:                   NULL,
-    pgsql_host:                 "localhost",
-    pgsql_user:                 NULL,
-    pgsql_password:             NULL,
-    pgsql_port:                 5432,
-    text_changes:               0,
-    text_left:                  NULL,
-    text_right:                 DEF_TIMESTAMP,
-    text_event:                 DEF_EVENTSTAMP,
-    text_double:                0,
-    despeckle:                  NULL,
-    area_detect:                NULL,
-    minimum_motion_frames:      1,
-    pid_file:                   NULL,
+#endif /* defined(HAVE_MYSQL) || defined(HAVE_PGSQL) || define(HAVE_SQLITE3) */
+    on_picture_save:                NULL,
+    on_motion_detected:             NULL,
+    on_area_detected:               NULL,
+    on_movie_start:                 NULL,
+    on_movie_end:                   NULL,
+    on_camera_lost:                 NULL,
+    motionvidpipe:                  NULL,
+    netcam_url:                     NULL,
+    netcam_userpass:                NULL,
+    netcam_keepalive:               "off",
+    netcam_proxy:                   NULL,
+    netcam_tolerant_check:          0,
+    rtsp_uses_tcp:                  1,
+    text_changes:                   0,
+    text_left:                      NULL,
+    text_right:                     DEF_TIMESTAMP,
+    text_event:                     DEF_EVENTSTAMP,
+    text_double:                    0,
+    despeckle_filter:               NULL,
+    area_detect:                    NULL,
+    minimum_motion_frames:          1,
+    exif_text:                      NULL,
+    pid_file:                       NULL,
+    log_file:                       NULL,
+    log_level:                      LEVEL_DEFAULT+10,
+    log_type_str:                   NULL,
 };
 
 
-
-static struct context ** copy_bool(struct context **, const char *, int);
-static struct context ** copy_int(struct context **, const char *, int);
-static struct context ** copy_short(struct context **, const char *, int);
-static struct context ** config_thread(struct context **cnt, const char *str, int val);
-
-static const char * print_bool(struct context **, char **, int, unsigned short int);
-static const char * print_int(struct context **, char **, int, unsigned short int);
-static const char * print_short(struct context **, char **, int, unsigned short int);
-static const char * print_string(struct context **, char **, int, unsigned short int);
-static const char * print_thread(struct context **, char **, int, unsigned short int);
+static struct context **copy_bool(struct context **, const char *, int);
+static struct context **copy_int(struct context **, const char *, int);
+static struct context **config_thread(struct context **cnt, const char *str, int val);
+
+static const char *print_bool(struct context **, char **, int, unsigned int);
+static const char *print_int(struct context **, char **, int, unsigned int);
+static const char *print_string(struct context **, char **, int, unsigned int);
+static const char *print_thread(struct context **, char **, int, unsigned int);
 
 static void usage(void);
 
 /* Pointer magic to determine relative addresses of variables to a
    struct context pointer */
 #define CNT_OFFSET(varname) ((long)&((struct context *)NULL)->varname)
-#define CONF_OFFSET(varname) ((long)&((struct context *)NULL)->conf.varname) 
-#define TRACK_OFFSET(varname) ((long)&((struct context *)NULL)->track.varname) 
+#define CONF_OFFSET(varname) ((long)&((struct context *)NULL)->conf.varname)
+#define TRACK_OFFSET(varname) ((long)&((struct context *)NULL)->track.varname)
 
 config_param config_params[] = {
     {
@@ -202,6 +212,30 @@ config_param config_params[] = {
     print_bool
     },
     {
+    "logfile",
+    "# Use a file to save logs messages, if not defined stderr and syslog is used. (default: not defined)",
+    1,
+    CONF_OFFSET(log_file),
+    copy_string,
+    print_string
+    },
+    {
+    "log_level",
+    "# Level of log messages [1..9] (EMR, ALR, CRT, ERR, WRN, NTC, ERR, DBG, ALL). (default: 6 / NTC)",
+    1,
+    CONF_OFFSET(log_level),
+    copy_int,
+    print_int
+    },
+    {
+    "log_type",
+    "# Filter to log messages by type (COR, STR, ENC, NET, DBL, EVT, TRK, VID, ALL). (default: ALL)",
+    1,
+    CONF_OFFSET(log_type_str),
+    copy_string,
+    print_string
+    },
+    {
     "videodevice",
     "\n###########################################################\n"
     "# Capture device options\n"
@@ -216,26 +250,36 @@ config_param config_params[] = {
     {
     "v4l2_palette",
     "# v4l2_palette allows to choose preferable palette to be use by motion\n"
-    "# to capture from those supported by your videodevice. (default: 8)\n"
+    "# to capture from those supported by your videodevice. (default: 17)\n"
     "# E.g. if your videodevice supports both V4L2_PIX_FMT_SBGGR8 and\n"
     "# V4L2_PIX_FMT_MJPEG then motion will by default use V4L2_PIX_FMT_MJPEG.\n"
-    "# Setting v4l2_palette to 1 forces motion to use V4L2_PIX_FMT_SBGGR8\n"
+    "# Setting v4l2_palette to 2 forces motion to use V4L2_PIX_FMT_SBGGR8\n"
     "# instead.\n"
     "#\n"
     "# Values :\n"
     "# V4L2_PIX_FMT_SN9C10X : 0  'S910'\n"
-    "# V4L2_PIX_FMT_SBGGR8  : 1  'BA81'\n"
-    "# V4L2_PIX_FMT_MJPEG   : 2  'MJPEG'\n"
-    "# V4L2_PIX_FMT_JPEG    : 3  'JPEG'\n"
-    "# V4L2_PIX_FMT_RGB24   : 4  'RGB3'\n"
-    "# V4L2_PIX_FMT_UYVY    : 5  'UYVY'\n"
-    "# V4L2_PIX_FMT_YUYV    : 6  'YUYV'\n"
-    "# V4L2_PIX_FMT_YUV422P : 7  '422P'\n"
-    "# V4L2_PIX_FMT_YUV420  : 8  'YU12'",
+    "# V4L2_PIX_FMT_SBGGR16 : 1  'BYR2'\n"
+    "# V4L2_PIX_FMT_SBGGR8  : 2  'BA81'\n"
+    "# V4L2_PIX_FMT_SPCA561 : 3  'S561'\n"
+    "# V4L2_PIX_FMT_SGBRG8  : 4  'GBRG'\n"
+    "# V4L2_PIX_FMT_SGRBG8  : 5  'GRBG'\n"
+    "# V4L2_PIX_FMT_PAC207  : 6  'P207'\n"
+    "# V4L2_PIX_FMT_PJPG    : 7  'PJPG'\n"
+    "# V4L2_PIX_FMT_MJPEG   : 8  'MJPEG'\n"
+    "# V4L2_PIX_FMT_JPEG    : 9  'JPEG'\n"
+    "# V4L2_PIX_FMT_RGB24   : 10 'RGB3'\n"
+    "# V4L2_PIX_FMT_SPCA501 : 11 'S501'\n"
+    "# V4L2_PIX_FMT_SPCA505 : 12 'S505'\n"
+    "# V4L2_PIX_FMT_SPCA508 : 13 'S508'\n"
+    "# V4L2_PIX_FMT_UYVY    : 14 'UYVY'\n"
+    "# V4L2_PIX_FMT_YUYV    : 15 'YUYV'\n"
+    "# V4L2_PIX_FMT_YUV422P : 16 '422P'\n"
+    "# V4L2_PIX_FMT_YUV420  : 17 'YU12'\n"
+    "#",
     0,
     CONF_OFFSET(v4l2_palette),
-    copy_short,
-    print_short
+    copy_int,
+    print_int
     },
 #if (defined(BSD))
     {
@@ -250,8 +294,8 @@ config_param config_params[] = {
 #endif
     {
     "input",
-    "# The video input to be used (default: 8)\n"
-    "# Should normally be set to 0 or 1 for video/TV cards, and 8 for USB cameras",
+    "# The video input to be used (default: -1)\n"
+    "# Should normally be set to 0 or 1 for video/TV cards, and -1 for USB cameras",
     0,
     CONF_OFFSET(input),
     copy_int,
@@ -277,7 +321,7 @@ config_param config_params[] = {
     {
     "rotate",
     "# Rotate image this number of degrees. The rotation affects all saved images as\n"
-    "# well as mpeg movies. Valid values: 0 (default = no rotation), 90, 180 and 270.",
+    "# well as movies. Valid values: 0 (default = no rotation), 90, 180 and 270.",
     0,
     CONF_OFFSET(rotate_deg),
     copy_int,
@@ -320,7 +364,7 @@ config_param config_params[] = {
     },
     {
     "netcam_url",
-    "# URL to use if you are using a network camera, size will be autodetected (incl http:// ftp:// or file:///)\n"
+    "# URL to use if you are using a network camera, size will be autodetected (incl http:// ftp:// mjpg:// or file:///)\n"
     "# Must be a URL that returns single jpeg pictures or a raw mjpeg stream. Default: Not defined",
     0,
     CONF_OFFSET(netcam_url),
@@ -337,14 +381,14 @@ config_param config_params[] = {
     print_string
     },
     {
-    "netcam_http",
+    "netcam_keepalive",
     "# The setting for keep-alive of network socket, should improve performance on compatible net cameras.\n"
-    "# 1.0:         The historical implementation using HTTP/1.0, closing the socket after each http request.\n"
-    "# keep_alive:  Use HTTP/1.0 requests with keep alive header to reuse the same connection.\n"
-    "# 1.1:         Use HTTP/1.1 requests that support keep alive as default.\n"
-    "# Default: 1.0",
+    "# off:   The historical implementation using HTTP/1.0, closing the socket after each http request.\n"
+    "# force: Use HTTP/1.0 requests with keep alive header to reuse the same connection.\n"
+    "# on:    Use HTTP/1.1 requests that support keep alive as default.\n"
+    "# Default: off",
     0,
-    CONF_OFFSET(netcam_http),
+    CONF_OFFSET(netcam_keepalive),
     copy_string,
     print_string
     },
@@ -361,11 +405,20 @@ config_param config_params[] = {
     {
     "netcam_tolerant_check",
     "# Set less strict jpeg checks for network cameras with a poor/buggy firmware.\n"
-    "# Default: off",    
+    "# Default: off",
     0,
     CONF_OFFSET(netcam_tolerant_check),
     copy_bool,
-    print_bool    
+    print_bool
+    },
+    {
+    "rtsp_uses_tcp",
+    "# RTSP connection uses TCP to communicate to the camera. Can prevent image corruption.\n"
+    "# Default: on",
+    1,
+    CONF_OFFSET(rtsp_uses_tcp),
+    copy_bool,
+    print_bool
     },
     {
     "auto_brightness",
@@ -480,22 +533,23 @@ config_param config_params[] = {
     print_bool
     },
     {
-    "despeckle",
+    "despeckle_filter",
     "# Despeckle motion image using (e)rode or (d)ilate or (l)abel (Default: not defined)\n"
     "# Recommended value is EedDl. Any combination (and number of) of E, e, d, and D is valid.\n"
     "# (l)abeling must only be used once and the 'l' must be the last letter.\n"
     "# Comment out to disable",
     0,
-    CONF_OFFSET(despeckle),
+    CONF_OFFSET(despeckle_filter),
     copy_string,
     print_string
     },
     {
     "area_detect",
-    "# Detect motion in predefined areas (1 - 9). Areas are numbered like that:  1 2 3\n" 
+    "# Detect motion in predefined areas (1 - 9). Areas are numbered like that:  1 2 3\n"
     "# A script (on_area_detected) is started immediately when motion is         4 5 6\n"
     "# detected in one of the given areas, but only once during an event.        7 8 9\n"
-    "# One or more areas can be specified with this option. (Default: not defined)",
+    "# One or more areas can be specified with this option. Take care: This option\n"
+    "# does NOT restrict detection to these areas! (Default: not defined)",
     0,
     CONF_OFFSET(area_detect),
     copy_string,
@@ -522,7 +576,9 @@ config_param config_params[] = {
     {
     "lightswitch",
     "# Ignore sudden massive light intensity changes given as a percentage of the picture\n"
-    "# area that changed intensity. Valid range: 0 - 100 , default: 0 = disabled",
+    "# area that changed intensity. If set to 1, motion will do some kind of\n"
+    "# auto-lightswitch. Valid range: 0 - 100 , default: 0 = disabled",
+
     0,
     CONF_OFFSET(lightswitch),
     copy_int,
@@ -544,7 +600,7 @@ config_param config_params[] = {
     "# was detected that will be output at motion detection.\n"
     "# Recommended range: 0 to 5 (default: 0)\n"
     "# Do not use large values! Large values will cause Motion to skip video frames and\n"
-    "# cause unsmooth mpegs. To smooth mpegs use larger values of post_capture instead.",
+    "# cause unsmooth movies. To smooth movies use larger values of post_capture instead.",
     0,
     CONF_OFFSET(pre_capture),
     copy_int,
@@ -559,35 +615,37 @@ config_param config_params[] = {
     print_int
     },
     {
-    "gap",
-    "# Gap is the seconds of no motion detection that triggers the end of an event\n"
+    "event_gap",
+    "# Event Gap is the seconds of no motion detection that triggers the end of an event.\n"
     "# An event is defined as a series of motion images taken within a short timeframe.\n"
-    "# Recommended value is 60 seconds (Default). The value 0 is allowed and disables\n"
-    "# events causing all Motion to be written to one single mpeg file and no pre_capture.",
+    "# Recommended value is 60 seconds (Default). The value -1 is allowed and disables\n"
+    "# events causing all Motion to be written to one single movie file and no pre_capture.\n"
+    "# If set to 0, motion is running in gapless mode. Movies don't have gaps anymore. An\n"
+    "# event ends right after no more motion is detected and post_capture is over.",
     0,
-    CONF_OFFSET(gap),
+    CONF_OFFSET(event_gap),
     copy_int,
     print_int
     },
     {
-    "max_mpeg_time",
-    "# Maximum length in seconds of an mpeg movie\n"
-    "# When value is exceeded a new mpeg file is created. (Default: 0 = infinite)",
+    "max_movie_time",
+    "# Maximum length in seconds of a movie\n"
+    "# When value is exceeded a new movie file is created. (Default: 0 = infinite)",
     0,
-    CONF_OFFSET(maxmpegtime),
+    CONF_OFFSET(max_movie_time),
     copy_int,
     print_int
     },
     {
-    "output_all",
+    "emulate_motion",
     "# Always save images even if there was no motion (default: off)",
     0,
-    CONF_OFFSET(output_all),
+    CONF_OFFSET(emulate_motion),
     copy_bool,
     print_bool
     },
     {
-    "output_normal",
+    "output_pictures",
     "\n############################################################\n"
     "# Image File Output\n"
     "############################################################\n\n"
@@ -598,12 +656,12 @@ config_param config_params[] = {
     "# Picture with motion nearest center of picture is saved when set to 'center'.\n"
     "# Can be used as preview shot for the corresponding movie.",
     0,
-    CONF_OFFSET(output_normal),
+    CONF_OFFSET(output_pictures),
     copy_string,
     print_string
     },
     {
-    "output_motion",
+    "output_debug_pictures",
     "# Output pictures with only the pixels moving object (ghost images) (default: off)",
     0,
     CONF_OFFSET(motion_img),
@@ -619,34 +677,35 @@ config_param config_params[] = {
     print_int
     },
     {
-    "ppm",
-    "# Output ppm images instead of jpeg (default: off)",
+    "picture_type",
+    "# Type of output images\n"
+    "# Valid values: jpeg, ppm (default: jpeg)",
     0,
-    CONF_OFFSET(ppm),
-    copy_bool,
-    print_bool
+    CONF_OFFSET(picture_type),
+    copy_string,
+    print_string
     },
 #ifdef HAVE_FFMPEG
     {
-    "ffmpeg_cap_new",
+    "ffmpeg_output_movies",
     "\n############################################################\n"
     "# FFMPEG related options\n"
-    "# Film (mpeg) file output, and deinterlacing of the video input\n"
+    "# Film (movie) file output, and deinterlacing of the video input\n"
     "# The options movie_filename and timelapse_filename are also used\n"
     "# by the ffmpeg feature\n"
     "############################################################\n\n"
-    "# Use ffmpeg to encode mpeg movies in realtime (default: off)",
+    "# Use ffmpeg to encode movies in realtime (default: off)",
     0,
-    CONF_OFFSET(ffmpeg_cap_new),
+    CONF_OFFSET(ffmpeg_output),
     copy_bool,
     print_bool
     },
     {
-    "ffmpeg_cap_motion",
+    "ffmpeg_output_debug_movies",
     "# Use ffmpeg to make movies with only the pixels moving\n"
     "# object (ghost images) (default: off)",
     0,
-    CONF_OFFSET(ffmpeg_cap_motion),
+    CONF_OFFSET(ffmpeg_output_debug),
     copy_bool,
     print_bool
     },
@@ -691,7 +750,7 @@ config_param config_params[] = {
     {
     "ffmpeg_video_codec",
     "# Codec to used by ffmpeg for the video compression.\n"
-    "# Timelapse mpegs are always made in mpeg1 format independent from this option.\n"
+    "# Timelapse movies are always made in mpeg1 format independent from this option.\n"
     "# Supported formats are: mpeg1 (ffmpeg-0.4.8 only), mpeg4 (default), and msmpeg4.\n"
     "# mpeg1 - gives you files with extension .mpg\n"
     "# mpeg4 or msmpeg4 - gives you files with extension .avi\n"
@@ -700,7 +759,8 @@ config_param config_params[] = {
     "# swf - gives you a flash film with extension .swf\n"
     "# flv - gives you a flash video with extension .flv\n"
     "# ffv1 - FF video codec 1 for Lossless Encoding ( experimental )\n"
-    "# mov - QuickTime ( testing )",
+    "# mov - QuickTime ( testing )\n"
+    "# ogg - Ogg/Theora ( testing )",
     0,
     CONF_OFFSET(ffmpeg_video_codec),
     copy_string,
@@ -717,6 +777,42 @@ config_param config_params[] = {
     print_bool
     },
 #endif /* HAVE_FFMPEG */
+#ifdef HAVE_SDL
+     {
+    "sdl_threadnr",
+    "\n############################################################\n"
+    "# SDL Window\n"
+    "############################################################\n\n"
+    "# Number of motion thread to show in SDL Window (default: 0 = disabled)",
+    1,
+    CONF_OFFSET(sdl_threadnr),
+    copy_int,
+    print_int
+    },
+#endif /* HAVE_SDL */
+    {
+    "use_extpipe",
+    "\n############################################################\n"
+    "# External pipe to video encoder\n"
+    "# Replacement for FFMPEG builtin encoder for ffmpeg_output_movies only.\n"
+    "# The options movie_filename and timelapse_filename are also used\n"
+    "# by the ffmpeg feature\n"
+    "############################################################\n\n"
+    "# Bool to enable or disable extpipe (default: off)",
+    0,
+    CONF_OFFSET(useextpipe),
+    copy_bool,
+    print_bool
+    },
+    {
+    "extpipe",
+    "# External program (full path and opts) to pipe raw video to\n"
+    "# Generally, use '-' for STDIN...",
+    0,
+    CONF_OFFSET(extpipe),
+    copy_string,
+    print_string
+    },
     {
     "snapshot_interval",
     "\n############################################################\n"
@@ -729,7 +825,7 @@ config_param config_params[] = {
     print_int
     },
     {
-    "locate",
+    "locate_motion_mode",
     "\n############################################################\n"
     "# Text Display\n"
     "# %Y = year, %m = month, %d = date,\n"
@@ -743,10 +839,23 @@ config_param config_params[] = {
     "# leading spaces\n"
     "############################################################\n\n"
     "# Locate and draw a box around the moving object.\n"
-    "# Valid values: on, off and preview (default: off)\n"
+    "# Valid values: on, off, preview (default: off)\n"
     "# Set to 'preview' will only draw a box in preview_shot pictures.",
     0,
-    CONF_OFFSET(locate),
+    CONF_OFFSET(locate_motion_mode),
+    copy_string,
+    print_string
+    },
+    {
+    "locate_motion_style",
+    "# Set the look and style of the locate box if enabled.\n"
+    "# Valid values: box, redbox, cross, redcross (default: box)\n"
+    "# Set to 'box' will draw the traditional box.\n"
+    "# Set to 'redbox' will draw a red box.\n"
+    "# Set to 'cross' will draw a little cross to mark center.\n"
+    "# Set to 'redcross' will draw a little red cross to mark center.",
+    0,
+    CONF_OFFSET(locate_motion_style),
     copy_string,
     print_string
     },
@@ -770,7 +879,7 @@ config_param config_params[] = {
     copy_string,
     print_string
     },
-    {
+     {
     "text_changes",
     "# Draw the number of changed pixed on the images (default: off)\n"
     "# Will normally be set to off except when you setup and adjust the motion settings\n"
@@ -802,10 +911,20 @@ config_param config_params[] = {
     print_bool
     },
     {
+    "exif_text",
+    "# Text to include in a JPEG EXIF comment\n"
+    "# May be any text, including conversion specifiers.\n"
+    "# The EXIF timestamp is included independent of this text.",
+    0,
+    CONF_OFFSET(exif_text),
+    copy_string,
+    print_string
+    },
+    {
     "target_dir",
     "\n############################################################\n"
     "# Target Directories and filenames For Images And Films\n"
-    "# For the options snapshot_, jpeg_, mpeg_ and timelapse_filename\n"
+    "# For the options snapshot_, picture_, movie_ and timelapse_filename\n"
     "# you can use conversion specifiers\n"
     "# %Y = year, %m = month, %d = date,\n"
     "# %H = hour, %M = minute, %S = second,\n"
@@ -838,36 +957,36 @@ config_param config_params[] = {
     print_string
     },
     {
-    "jpeg_filename",
+    "picture_filename",
     "# File path for motion triggered images (jpeg or ppm) relative to target_dir\n"
-    "# Default: "DEF_JPEGPATH"\n"
+    "# Default: "DEF_IMAGEPATH"\n"
     "# Default value is equivalent to legacy oldlayout option\n"
     "# For Motion 3.0 compatible mode choose: %Y/%m/%d/%H/%M/%S-%q\n"
     "# File extension .jpg or .ppm is automatically added so do not include this\n"
     "# Set to 'preview' together with best-preview feature enables special naming\n"
     "# convention for preview shots. See motion guide for details",
     0,
-    CONF_OFFSET(jpegpath),
+    CONF_OFFSET(imagepath),
     copy_string,
     print_string
     },
 #ifdef HAVE_FFMPEG
     {
     "movie_filename",
-    "# File path for motion triggered ffmpeg films (mpeg) relative to target_dir\n"
-    "# Default: "DEF_MPEGPATH"\n"
+    "# File path for motion triggered ffmpeg films (movies) relative to target_dir\n"
+    "# Default: "DEF_MOVIEPATH"\n"
     "# Default value is equivalent to legacy oldlayout option\n"
     "# For Motion 3.0 compatible mode choose: %Y/%m/%d/%H%M%S\n"
     "# File extension .mpg or .avi is automatically added so do not include this\n"
     "# This option was previously called ffmpeg_filename",
     0,
-    CONF_OFFSET(mpegpath),
+    CONF_OFFSET(moviepath),
     copy_string,
     print_string
     },
     {
     "timelapse_filename",
-    "# File path for timelapse mpegs relative to target_dir\n"
+    "# File path for timelapse movies relative to target_dir\n"
     "# Default: "DEF_TIMEPATH"\n"
     "# Default value is near equivalent to legacy oldlayout option\n"
     "# For Motion 3.0 compatible mode choose: %Y/%m/%d-timelapse\n"
@@ -879,107 +998,138 @@ config_param config_params[] = {
     },
 #endif /* HAVE_FFMPEG */
     {
-    "webcam_port",
+    "ipv6_enabled",
     "\n############################################################\n"
-    "# Live Webcam Server\n"
+    "# Global Network Options\n"
+    "############################################################\n\n"
+    "# Enable or disable IPV6 for http control and stream (default: off)",
+    0,
+    CONF_OFFSET(ipv6_enabled),
+    copy_bool,
+    print_bool
+    },
+    {
+    "stream_port",
+    "\n############################################################\n"
+    "# Live Stream Server\n"
     "############################################################\n\n"
     "# The mini-http server listens to this port for requests (default: 0 = disabled)",
     0,
-    CONF_OFFSET(webcam_port),
+    CONF_OFFSET(stream_port),
     copy_int,
     print_int
     },
     {
-    "webcam_quality",
+    "stream_quality",
     "# Quality of the jpeg (in percent) images produced (default: 50)",
     0,
-    CONF_OFFSET(webcam_quality),
+    CONF_OFFSET(stream_quality),
     copy_int,
     print_int
     },
     {
-    "webcam_motion",
+    "stream_motion",
     "# Output frames at 1 fps when no motion is detected and increase to the\n"
-    "# rate given by webcam_maxrate when motion is detected (default: off)",
+    "# rate given by stream_maxrate when motion is detected (default: off)",
     0,
-    CONF_OFFSET(webcam_motion),
+    CONF_OFFSET(stream_motion),
     copy_bool,
     print_bool
     },
     {
-    "webcam_maxrate",
-    "# Maximum framerate for webcam streams (default: 1)",
+    "stream_maxrate",
+    "# Maximum framerate for streams (default: 1)",
     0,
-    CONF_OFFSET(webcam_maxrate),
+    CONF_OFFSET(stream_maxrate),
     copy_int,
     print_int
     },
     {
-    "webcam_localhost",
-    "# Restrict webcam connections to localhost only (default: on)",
+    "stream_localhost",
+    "# Restrict stream connections to localhost only (default: on)",
     0,
-    CONF_OFFSET(webcam_localhost),
+    CONF_OFFSET(stream_localhost),
     copy_bool,
     print_bool
     },
     {
-    "webcam_limit",
+    "stream_limit",
     "# Limits the number of images per connection (default: 0 = unlimited)\n"
-    "# Number can be defined by multiplying actual webcam rate by desired number of seconds\n"
-    "# Actual webcam rate is the smallest of the numbers framerate and webcam_maxrate",
+    "# Number can be defined by multiplying actual stream rate by desired number of seconds\n"
+    "# Actual stream rate is the smallest of the numbers framerate and stream_maxrate",
+    0,
+    CONF_OFFSET(stream_limit),
+    copy_int,
+    print_int
+    },
+    {
+    "stream_auth_method",
+    "# Set the authentication method (default: 0)\n"
+    "# 0 = disabled \n"
+    "# 1 = Basic authentication\n"
+    "# 2 = MD5 digest (the safer authentication)\n",
     0,
-    CONF_OFFSET(webcam_limit),
+    CONF_OFFSET(stream_auth_method),
     copy_int,
     print_int
     },
     {
-    "control_port",
+    "stream_authentication",
+    "# Authentication for the stream. Syntax username:password\n"
+    "# Default: not defined (Disabled)",
+    1,
+    CONF_OFFSET(stream_authentication),
+    copy_string,
+    print_string
+    },
+    {
+    "webcontrol_port",
     "\n############################################################\n"
     "# HTTP Based Control\n"
     "############################################################\n\n"
     "# TCP/IP port for the http server to listen on (default: 0 = disabled)",
     1,
-    CONF_OFFSET(control_port),
+    CONF_OFFSET(webcontrol_port),
     copy_int,
     print_int
     },
     {
-    "control_localhost",
+    "webcontrol_localhost",
     "# Restrict control connections to localhost only (default: on)",
     1,
-    CONF_OFFSET(control_localhost),
+    CONF_OFFSET(webcontrol_localhost),
     copy_bool,
     print_bool
     },
     {
-    "control_html_output",
+    "webcontrol_html_output",
     "# Output for http server, select off to choose raw text plain (default: on)",
     1,
-    CONF_OFFSET(control_html_output),
+    CONF_OFFSET(webcontrol_html_output),
     copy_bool,
     print_bool
     },
     {
-    "control_authentication",
+    "webcontrol_authentication",
     "# Authentication for the http based control. Syntax username:password\n"
     "# Default: not defined (Disabled)",
     1,
-    CONF_OFFSET(control_authentication),
+    CONF_OFFSET(webcontrol_authentication),
     copy_string,
     print_string
-    },    
+    },
     {
     "track_type",
     "\n############################################################\n"
     "# Tracking (Pan/Tilt)\n"
     "############################################################\n\n"
-    "# Type of tracker (0=none (default), 1=stepper, 2=iomojo, 3=pwc, 4=generic, 5=uvcvideo)\n"
+    "# Type of tracker (0=none (default), 1=stepper, 2=iomojo, 3=pwc, 4=generic, 5=uvcvideo, 6=servo)\n"
     "# The generic type enables the definition of motion center and motion size to\n"
     "# be used with the conversion specifiers for options like on_motion_detected",
     0,
     TRACK_OFFSET(type),
-    copy_short,
-    print_short
+    copy_int,
+    print_int
     },
     {
     "track_auto",
@@ -1002,40 +1152,88 @@ config_param config_params[] = {
     "# Motor number for x-axis (default: 0)",
     0,
     TRACK_OFFSET(motorx),
-    copy_short,
-    print_short
+    copy_int,
+    print_int
+    },
+    {
+    "track_motorx_reverse",
+    "# Set motorx reverse (default: off)",
+    0,
+    TRACK_OFFSET(motorx_reverse),
+    copy_bool,
+    print_bool
     },
     {
     "track_motory",
     "# Motor number for y-axis (default: 0)",
     0,
     TRACK_OFFSET(motory),
-    copy_short,
-    print_short
+    copy_int,
+    print_int
+    },
+    {
+    "track_motory_reverse",
+    "# Set motory reverse (default: off)",
+    0,
+    TRACK_OFFSET(motory_reverse),
+    copy_bool,
+    print_bool
     },
     {
     "track_maxx",
     "# Maximum value on x-axis (default: 0)",
     0,
     TRACK_OFFSET(maxx),
-    copy_short,
-    print_short
+    copy_int,
+    print_int
+    },
+    {
+    "track_minx",
+    "# Minimum value on x-axis (default: 0)",
+    0,
+    TRACK_OFFSET(minx),
+    copy_int,
+    print_int
     },
     {
     "track_maxy",
     "# Maximum value on y-axis (default: 0)",
     0,
     TRACK_OFFSET(maxy),
-    copy_short,
-    print_short
+    copy_int,
+    print_int
+    },
+    {
+    "track_miny",
+    "# Minimum value on y-axis (default: 0)",
+    0,
+    TRACK_OFFSET(miny),
+    copy_int,
+    print_int
+    },
+    {
+    "track_homex",
+    "# Center value on x-axis (default: 0)",
+    0,
+    TRACK_OFFSET(homex),
+    copy_int,
+    print_int
+    },
+    {
+    "track_homey",
+    "# Center value on y-axis (default: 0)",
+    0,
+    TRACK_OFFSET(homey),
+    copy_int,
+    print_int
     },
     {
     "track_iomojo_id",
     "# ID of an iomojo camera if used (default: 0)",
     0,
     TRACK_OFFSET(iomojo_id),
-    copy_short,
-    print_short
+    copy_int,
+    print_int
     },
     {
     "track_step_angle_x",
@@ -1044,8 +1242,8 @@ config_param config_params[] = {
     "# Currently only used with pwc type cameras",
     0,
     TRACK_OFFSET(step_angle_x),
-    copy_short,
-    print_short
+    copy_int,
+    print_int
     },
     {
     "track_step_angle_y",
@@ -1054,8 +1252,8 @@ config_param config_params[] = {
     "# Currently only used with pwc type cameras",
     0,
     TRACK_OFFSET(step_angle_y),
-    copy_short,
-    print_short
+    copy_int,
+    print_int
     },
     {
     "track_move_wait",
@@ -1063,24 +1261,24 @@ config_param config_params[] = {
     "# of picture frames (default: 10)",
     0,
     TRACK_OFFSET(move_wait),
-    copy_short,
-    print_short
+    copy_int,
+    print_int
     },
     {
     "track_speed",
     "# Speed to set the motor to (stepper motor option) (default: 255)",
     0,
     TRACK_OFFSET(speed),
-    copy_short,
-    print_short
+    copy_int,
+    print_int
     },
     {
     "track_stepsize",
     "# Number of steps to make (stepper motor option) (default: 40)",
     0,
     TRACK_OFFSET(stepsize),
-    copy_short,
-    print_short
+    copy_int,
+    print_int
     },
     {
     "quiet",
@@ -1097,7 +1295,7 @@ config_param config_params[] = {
     "# %f = filename with full path\n"
     "# %n = number indicating filetype\n"
     "# Both %f and %n are only defined for on_picture_save,\n"
-    "# on_movie_start and on_movie_end\n" 
+    "# on_movie_start and on_movie_end\n"
     "# Quotation marks round string are allowed.\n"
     "############################################################\n\n"
     "# Do not sound beeps when detecting motion (default: on)\n"
@@ -1110,7 +1308,7 @@ config_param config_params[] = {
     {
     "on_event_start",
     "# Command to be executed when an event starts. (default: none)\n"
-    "# An event starts at first motion detected after a period of no motion defined by gap ",
+    "# An event starts at first motion detected after a period of no motion defined by event_gap ",
     0,
     CONF_OFFSET(on_event_start),
     copy_string,
@@ -1119,7 +1317,7 @@ config_param config_params[] = {
     {
     "on_event_end",
     "# Command to be executed when an event ends after a period of no motion\n"
-    "# (default: none). The period of no motion is defined by option gap.",
+    "# (default: none). The period of no motion is defined by option event_gap.",
     0,
     CONF_OFFSET(on_event_end),
     copy_string,
@@ -1174,21 +1372,21 @@ config_param config_params[] = {
     {
     "on_camera_lost",
     "# Command to be executed when a camera can't be opened or if it is lost\n"
-    "# NOTE: There is situations when motion doesn't detect a lost camera!\n"
-    "# It depends on the driver, some drivers don't detect a lost camera at all\n"
-    "# Some hang the motion thread. Some even hang the PC! (default: none)",
+    "# NOTE: There is situations when motion don't detect a lost camera!\n"
+    "# It depends on the driver, some drivers dosn't detect a lost camera at all\n"
+    "# Some hangs the motion thread. Some even hangs the PC! (default: none)",
     0,
     CONF_OFFSET(on_camera_lost),
     copy_string,
     print_string
     },
 
-#if defined(HAVE_MYSQL) || defined(HAVE_PGSQL)
+#if defined(HAVE_MYSQL) || defined(HAVE_PGSQL) || defined(HAVE_SQLITE3)
     {
-    "sql_log_image",
+    "sql_log_picture",
     "\n############################################################\n"
-    "# Common Options For MySQL and PostgreSQL database features.\n"
-    "# Options require the MySQL/PostgreSQL options to be active also.\n"
+    "# Common Options for database features.\n"
+    "# Options require the database options to be active also.\n"
     "############################################################\n\n"
     "# Log to the database when creating motion triggered image file  (default: on)",
     0,
@@ -1205,16 +1403,16 @@ config_param config_params[] = {
     print_bool
     },
     {
-    "sql_log_mpeg",
-    "# Log to the database when creating motion triggered mpeg file (default: off)",
+    "sql_log_movie",
+    "# Log to the database when creating motion triggered movie file (default: off)",
     0,
-    CONF_OFFSET(sql_log_mpeg),
+    CONF_OFFSET(sql_log_movie),
     copy_bool,
     print_bool
     },
     {
     "sql_log_timelapse",
-    "# Log to the database when creating timelapse mpeg file (default: off)",
+    "# Log to the database when creating timelapse movie file (default: off)",
     0,
     CONF_OFFSET(sql_log_timelapse),
     copy_bool,
@@ -1227,6 +1425,14 @@ config_param config_params[] = {
     "# Additional special conversion specifiers are\n"
     "# %n = the number representing the file_type\n"
     "# %f = filename with full path\n"
+    "# Create tables :\n"
+    "##\n"
+    "# Mysql\n"
+    "# CREATE TABLE security (camera int, filename char(80) not null, frame int, file_type int, time_stamp timestamp(14), event_time_stamp timestamp(14));\n"
+    "#\n"
+    "# Postgresql\n"
+    "# CREATE TABLE security (camera int, filename char(80) not null, frame int, file_type int, time_stamp timestamp without time zone, event_time_stamp timestamp without time zone);\n"
+    "#\n"
     "# Default value:\n"
     "# insert into security(camera, filename, frame, file_type, time_stamp, text_event) values('%t', '%f', '%q', '%n', '%Y-%m-%d %T', '%C')",
     0,
@@ -1234,98 +1440,80 @@ config_param config_params[] = {
     copy_string,
     print_string
     },
-#endif /* defined(HAVE_MYSQL) || defined(HAVE_PGSQL) */
-
-#ifdef HAVE_MYSQL
     {
-    "mysql_db",
+    "database_type",
     "\n############################################################\n"
-    "# Database Options For MySQL\n"
+    "# Database Options \n"
     "############################################################\n\n"
-    "# Mysql database to log to (default: not defined)",
+    "# database type : mysql, postgresql, sqlite3 (default : not defined)",
     0,
-    CONF_OFFSET(mysql_db),
+    CONF_OFFSET(database_type),
     copy_string,
     print_string
     },
     {
-    "mysql_host",
-    "# The host on which the database is located (default: localhost)",
+    "database_dbname",
+    "# database to log to (default: not defined)",
     0,
-    CONF_OFFSET(mysql_host),
+    CONF_OFFSET(database_dbname),
     copy_string,
     print_string
     },
     {
-    "mysql_user",
-    "# User account name for MySQL database (default: not defined)",
+    "database_host",
+    "# The host on which the database is located (default: not defined)",
     0,
-    CONF_OFFSET(mysql_user),
+    CONF_OFFSET(database_host),
     copy_string,
     print_string
     },
     {
-    "mysql_password",
-    "# User password for MySQL database (default: not defined)",
+    "database_user",
+    "# User account name for database (default: not defined)",
     0,
-    CONF_OFFSET(mysql_password),
+    CONF_OFFSET(database_user),
     copy_string,
     print_string
     },
-#endif /* HAVE_MYSQL */
-
-#ifdef HAVE_PGSQL
     {
-    "pgsql_db",
-    "\n############################################################\n"
-    "# Database Options For PostgreSQL\n"
-    "############################################################\n\n"
-    "# PostgreSQL database to log to (default: not defined)",
+    "database_password",
+    "# User password for database (default: not defined)",
     0,
-    CONF_OFFSET(pgsql_db),
+    CONF_OFFSET(database_password),
     copy_string,
     print_string
     },
     {
-    "pgsql_host",
-    "# The host on which the database is located (default: localhost)",
+    "database_port",
+    "# Port on which the database is located (default: not defined)\n"
+    "# mysql 3306 , postgresql 5432 (default: not defined)",
     0,
-    CONF_OFFSET(pgsql_host),
-    copy_string,
-    print_string
-    },
-    {
-    "pgsql_user",
-    "# User account name for PostgreSQL database (default: not defined)",
-    0,
-    CONF_OFFSET(pgsql_user),
-    copy_string,
-    print_string
+    CONF_OFFSET(database_port),
+    copy_int,
+    print_int
     },
+#ifdef HAVE_SQLITE3
     {
-    "pgsql_password",
-    "# User password for PostgreSQL database (default: not defined)",
+    "sqlite3_db",
+    "\n############################################################\n"
+    "# Database Options For SQLite3\n"
+    "############################################################\n\n"
+    "# SQLite3 database to log to (default: not defined)",
     0,
-    CONF_OFFSET(pgsql_password),
+    CONF_OFFSET(sqlite3_db),
     copy_string,
     print_string
     },
-    {
-    "pgsql_port",
-    "# Port on which the PostgreSQL database is located (default: 5432)",
-    0,
-    CONF_OFFSET(pgsql_port),
-    copy_int,
-    print_int
-    },
-#endif /* HAVE_PGSQL */
+#endif /* HAVE_SQLITE3 */
+
+#endif /* defined(HAVE_MYSQL) || defined(HAVE_PGSQL) || defined(HAVE_SQLITE3) */
     {
     "video_pipe",
     "\n############################################################\n"
     "# Video Loopback Device (vloopback project)\n"
     "############################################################\n\n"
     "# Output images to a video4linux loopback device\n"
-    "# The value '-' means next available (default: not defined)",    
+    "# The value '-' means next available (default: not defined)",
     0,
     CONF_OFFSET(vidpipe),
     copy_string,
@@ -1356,22 +1544,27 @@ config_param config_params[] = {
     { NULL, NULL, 0, 0, NULL, NULL }
 };
 
-/* conf_cmdline sets the conf struct options as defined by the command line.
- * Any option already set from a config file are overridden.
+/**
+ * conf_cmdline
+ *      Sets the conf struct options as defined by the Command-line.
+ *      Any option already set from a config file are overridden.
+ *
+ * Returns nothing.
  */
-static void conf_cmdline(struct context *cnt, short int thread)
+static void conf_cmdline(struct context *cnt, int thread)
 {
     struct config *conf = &cnt->conf;
     int c;
 
-    /* For the string options, we free() if necessary and malloc()
+    /*
+     * For the string options, we free() if necessary and malloc()
      * if necessary. This is accomplished by calling mystrcpy();
      * see this function for more information.
      */
-    while ((c = getopt(conf->argc, conf->argv, "c:d:hns?p:")) != EOF)
+    while ((c = getopt(conf->argc, conf->argv, "c:d:hmns?p:k:l:")) != EOF)
         switch (c) {
         case 'c':
-            if (thread == -1) 
+            if (thread == -1)
                 strcpy(cnt->conf_filename, optarg);
             break;
         case 'n':
@@ -1381,59 +1574,83 @@ static void conf_cmdline(struct context
             conf->setup_mode = 1;
             break;
         case 'd':
-            /* no validation - just take what user gives */
-            debug_level = (unsigned short int)atoi(optarg);
+            /* No validation - just take what user gives. */
+            if (thread == -1)
+                cnt->log_level = (unsigned int)atoi(optarg);
             break;
+        case 'k':
+	  if (thread == -1) {
+	    strncpy(cnt->log_type_str, optarg, sizeof(cnt->log_type_str) - 1);
+	    cnt->log_type_str[sizeof(cnt->log_type_str) - 1] = '\0';
+	  }
+	  break;
         case 'p':
-            if (thread == -1) 
-                strcpy(cnt->pid_file, optarg);
+	  if (thread == -1) {
+	    strncpy(cnt->pid_file, optarg, sizeof(cnt->pid_file) - 1);
+	    cnt->pid_file[sizeof(cnt->pid_file) - 1] = '\0';
+	  }
+	  break;
+        case 'l':
+	  if (thread == -1) {
+	    strncpy(cnt->log_file, optarg, sizeof(cnt->log_file) - 1);
+	    cnt->log_file[sizeof(cnt->log_file) - 1] = '\0';
+	  }
+	  break;
+        case 'm':
+            cnt->pause = 1;
             break;    
         case 'h':
         case '?':
         default:
-            usage();
-            exit(1);
+             usage();
+             exit(1);
         }
+
     optind = 1;
 }
 
 
-/* conf_cmdparse sets a config option given by 'cmd' to the value given by 'arg1'.
- * Based on the name of the option it searches through the struct 'config_params'
- * for an option where the config_params[i].param_name matches the option.
- * By calling the function pointed to by config_params[i].copy the option gets
- * assigned.
+/**
+ * conf_cmdparse
+ *      Sets a config option given by 'cmd' to the value given by 'arg1'.
+ *      Based on the name of the option it searches through the struct 'config_params'
+ *      for an option where the config_params[i].param_name matches the option.
+ *      By calling the function pointed to by config_params[i].copy the option gets
+ *      assigned.
+ *
+ * Returns context struct.
  */
 struct context **conf_cmdparse(struct context **cnt, const char *cmd, const char *arg1)
 {
-    unsigned short int i = 0;
+    unsigned int i = 0;
 
     if (!cmd)
         return cnt;
 
-    /* We search through config_params until we find a param_name that matches
-     * our option given by cmd (or reach the end = NULL)
+    /*
+     * We search through config_params until we find a param_name that matches
+     * our option given by cmd (or reach the end = NULL).
      */
     while (config_params[i].param_name != NULL) {
         if (!strncasecmp(cmd, config_params[i].param_name , 255 + 50)) { // Why +50?
-    
-            /* if config_param is string we don't want to check arg1 */        
-            if (strcmp(config_type(&config_params[i]),"string")) {
+
+            /* If config_param is string we don't want to check arg1. */
+            if (strcmp(config_type(&config_params[i]), "string")) {
                 if (config_params[i].conf_value && !arg1)
                     return cnt;
             }
-            
-            /* We call the function given by the pointer config_params[i].copy
+
+            /*
+             * We call the function given by the pointer config_params[i].copy
              * If the option is a bool, copy_bool is called.
              * If the option is an int, copy_int is called.
-             * If the option is a short, copy_short is called.
              * If the option is a string, copy_string is called.
              * If the option is a thread, config_thread is called.
              * The arguments to the function are:
-             *  cnt  - a pointer to the context structure
-             *  arg1 - a pointer to the new option value (represented as string)
+             *  cnt  - a pointer to the context structure.
+             *  arg1 - a pointer to the new option value (represented as string).
              *  config_params[i].conf_value - an integer value which is a pointer
-             *    to the context structure member relative to the pointer cnt.
+             *  to the context structure member relative to the pointer cnt.
              */
             cnt = config_params[i].copy(cnt, arg1, config_params[i].conf_value);
             return cnt;
@@ -1441,78 +1658,85 @@ struct context **conf_cmdparse(struct co
         i++;
     }
 
-    /* We reached the end of config_params without finding a matching option */
-    motion_log(LOG_ERR, 0, "Unknown config option \"%s\"", cmd);
+    /* We reached the end of config_params without finding a matching option. */
+    MOTION_LOG(ALR, TYPE_ALL, NO_ERRNO, "%s: Unknown config option \"%s\"",
+               cmd);
 
     return cnt;
 }
 
-/* conf_process walks through an already open config file line by line
- * Any line starting with '#' or ';' or empty lines are ignored as a comments.
- * Any non empty line is process so that the first word is the name of an option 'cnd'
- * and the rest of the line is the argument 'arg1'
- * White space before the first word, between option and argument and end of the line
- * is discarded. A '=' between option and first word in argument is also discarded.
- * Quotation marks round the argument are also discarded.
- * For each option/argument pair the function conf_cmdparse is called which takes
- * care of assigning the value to the option in the config structures.
+/**
+ * conf_process
+ *      Walks through an already open config file line by line
+ *      Any line starting with '#' or ';' or empty lines are ignored as a comments.
+ *      Any non empty line is process so that the first word is the name of an option 'cnd'
+ *      and the rest of the line is the argument 'arg1'
+ *      White space before the first word, between option and argument and end of the line
+ *      is discarded. A '=' between option and first word in argument is also discarded.
+ *      Quotation marks round the argument are also discarded.
+ *      For each option/argument pair the function conf_cmdparse is called which takes
+ *      care of assigning the value to the option in the config structures.
+ *
+ * Returns context struct.
  */
 static struct context **conf_process(struct context **cnt, FILE *fp)
 {
-    /* process each line from the config file */
-    
+    /* Process each line from the config file. */
+
     char line[PATH_MAX], *cmd = NULL, *arg1 = NULL;
     char *beg = NULL, *end = NULL;
 
     while (fgets(line, PATH_MAX-1, fp)) {
-        if (!(line[0] == '#' || line[0] == ';' || strlen(line) < 2)) {/* skipcomment */
-            
+        if (!(line[0] == '#' || line[0] == ';' || strlen(line) <  2)) {/* skipcomment */
+
             arg1 = NULL;
 
-            /* trim white space and any CR or LF at the end of the line */
-            end = line + strlen(line) - 1; /* Point to the last non-null character in the string */
+            /* Trim white space and any CR or LF at the end of the line. */
+            end = line + strlen(line) - 1; /* Point to the last non-null character in the string. */
             while (*end == ' ' || *end == '\t' || *end == '\n' || *end == '\r')
                 end--;
 
             *(end+1) = '\0';
-            
-            /* If line is only whitespace we continue to the next line */
+
+            /* If line is only whitespace we continue to the next line. */
             if (strlen(line) == 0)
                 continue;
 
-            /* trim leading whitespace from the line and find command */
+            /* Trim leading whitespace from the line and find command. */
             beg = line;
-            
             while (*beg == ' ' || *beg == '\t')
                 beg++;
 
-            cmd = beg; /* command starts here */
+
+            cmd = beg; /* Command starts here. */
 
             while (*beg != ' ' && *beg != '\t' && *beg != '=' && *beg != '\0')
                 beg++;
-            
-            *beg = '\0'; /* command string terminates here */
 
-            /* trim space between command and argument */
+            *beg = '\0'; /* Command string terminates here. */
+
+            /* Trim space between command and argument. */
             beg++;
 
             if (strlen(beg) > 0) {
                 while (*beg == ' ' || *beg == '\t' || *beg == '=' || *beg == '\n' || *beg == '\r')
                     beg++;
-                
 
-                /* If argument is in "" we will strip them off
-                   It is important that we can use "" so that we can use
-                   leading spaces in text_left and text_right */
-                if ((beg[0]=='"' && beg[strlen(beg)-1]=='"') ||
-                    (beg[0]=='\'' && beg[strlen(beg)-1]=='\'')) {
-                    beg[strlen(beg)-1]='\0';
+
+                /*
+                 * If argument is in "" we will strip them off
+                 * It is important that we can use "" so that we can use
+                 * leading spaces in text_left and text_right.
+                 */
+                if ((beg[0] == '"' && beg[strlen(beg)-1] == '"') ||
+                    (beg[0] == '\'' && beg[strlen(beg)-1] == '\'')) {
+                    beg[strlen(beg)-1] = '\0';
                     beg++;
                 }
-                
+
                 arg1 = beg; /* Argument starts here */
             }
-            /* else arg1 stays null pointer */
+            /* Else arg1 stays null pointer */
 
             cnt = conf_cmdparse(cnt, cmd, arg1);
         }
@@ -1522,19 +1746,25 @@ static struct context **conf_process(str
 }
 
 
-/* conf_print is used to write out the config file(s) motion.conf and any thread
- * config files. The function is called when using http remote control.
+/**
+ * conf_print
+ *       Is used to write out the config file(s) motion.conf and any thread
+ *       config files. The function is called when using http remote control.
+ *
+ * Returns nothing.
  */
 void conf_print(struct context **cnt)
 {
     const char *retval;
     char *val;
-    unsigned short int i, thread;
+    unsigned int i, thread;
     FILE *conffile;
 
     for (thread = 0; cnt[thread]; thread++) {
-        motion_log(LOG_INFO, 0, "Writing config file to %s",cnt[thread]->conf_filename);
-        conffile=myfopen(cnt[thread]->conf_filename, "w");
+        MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Writing config file to %s",
+                   cnt[thread]->conf_filename);
+
+        conffile = myfopen(cnt[thread]->conf_filename, "w", 0);
 
         if (!conffile)
             continue;
@@ -1544,13 +1774,14 @@ void conf_print(struct context **cnt)
         fprintf(conffile, "\n\n");
 
         for (i = 0; config_params[i].param_name; i++) {
-            retval=config_params[i].print(cnt, NULL, i, thread);
-            /*If config parameter has a value (not NULL) print it to the config file*/
-
+            retval = config_params[i].print(cnt, NULL, i, thread);
+            /* If config parameter has a value (not NULL) print it to the config file. */
             if (retval) {
                 fprintf(conffile, "%s\n", config_params[i].param_help);
-                /* If the option is a text_* and first char is a space put
-                   quotation marks around to allow leading spaces */
+                /*
+                 * If the option is a text_* and first char is a space put
+                 * quotation marks around to allow leading spaces.
+                 */
                 if (strncmp(config_params[i].param_name, "text", 4) || strncmp(retval, " ", 1))
                     fprintf(conffile, "%s %s\n\n", config_params[i].param_name, retval);
                 else
@@ -1558,34 +1789,38 @@ void conf_print(struct context **cnt)
             } else {
                 val = NULL;
                 config_params[i].print(cnt, &val, i, thread);
-                /* It can either be a thread file parameter or a disabled parameter
-                   If it is a thread parameter write it out
-                   Else write the disabled option to the config file but with a
-                   comment mark in front of the parameter name */
+                /*
+                 * It can either be a thread file parameter or a disabled parameter.
+                 * If it is a thread parameter write it out.
+                 * Else write the disabled option to the config file but with a
+                 * comment mark in front of the parameter name.
+                 */
                 if (val) {
-                    fprintf(conffile,"%s\n", config_params[i].param_help);
+                    fprintf(conffile, "%s\n", config_params[i].param_help);
                     fprintf(conffile, "%s\n", val);
 
                     if (strlen(val) == 0)
-                        fprintf(conffile,"; thread /usr/local/etc/thread1.conf\n");
+                        fprintf(conffile, "; thread /usr/local/etc/thread1.conf\n");
+
                     free(val);
-                } else if (thread == 0) {        
-                    fprintf(conffile,"%s\n", config_params[i].param_help);
-                    fprintf(conffile,"; %s value\n\n", config_params[i].param_name);
+                } else if (thread == 0) {
+                    fprintf(conffile, "%s\n", config_params[i].param_help);
+                    fprintf(conffile, "; %s value\n\n", config_params[i].param_name);
                 }
             }
         }
 
         fprintf(conffile, "\n");
-        fclose(conffile);
+        myfclose(conffile);
         conffile = NULL;
     }
 }
 
-/**************************************************************************
- * conf_load is the main function, called from motion.c
+/**
+ * conf_load
+ * Is the main function, called from motion.c
  * The function sets the important context structure "cnt" including
- * loading the config parameters from config files and command line.
+ * loading the config parameters from config files and Command-line.
  * The following takes place in the function:
  * - The default start values for cnt stored in the struct conf_template
  *   are copied to cnt[0] which is the default context structure common to
@@ -1596,31 +1831,35 @@ void conf_print(struct context **cnt)
  * - motion.conf is opened and processed. The process populates the cnt[0] and
  *   for each thread config file it populates a cnt[1], cnt[2]... for each
  *   thread
- * - Finally it process the options given in the command line. This is done
- *   for each thread cnt[i] so that the command line options overrides any
+ * - Finally it process the options given in the Command-line. This is done
+ *   for each thread cnt[i] so that the Command-line options overrides any
  *   option given by motion.conf or a thread config file.
- **************************************************************************/
+ *
+ * Returns context struct.
+ */
 struct context **conf_load(struct context **cnt)
 {
     FILE *fp = NULL;
     char filename[PATH_MAX];
     int i;
-    /* We preserve argc and argv because they get overwritten by the memcpy command */
+    /* We preserve argc and argv because they get overwritten by the memcpy command. */
     char **argv = cnt[0]->conf.argv;
     int argc = cnt[0]->conf.argc;
 
-    /* Copy the template config structure with all the default config values
+    /*
+     * Copy the template config structure with all the default config values
      * into cnt[0]->conf
      */
     memcpy(&cnt[0]->conf, &conf_template, sizeof(struct config));
-    
-    /* For each member of cnt[0] which is a pointer to a string
-     * if the member points to a string in conf_template and is not NULL
-     * 1. Reserve (malloc) memory for the string
-     * 2. Copy the conf_template given string to the reserved memory
-     * 3. Change the cnt[0] member (char*) pointing to the string in reserved memory
+
+    /*
+     * For each member of cnt[0] which is a pointer to a string
+     * if the member points to a string in conf_template and is not NULL.
+     * 1. Reserve (malloc) memory for the string.
+     * 2. Copy the conf_template given string to the reserved memory.
+     * 3. Change the cnt[0] member (char*) pointing to the string in reserved memory.
      * This ensures that we can free and malloc the string when changed
-     * via http remote control or config file or command line options
+     * via http remote control or config file or Command-line options.
      */
     malloc_strings(cnt[0]);
 
@@ -1628,29 +1867,37 @@ struct context **conf_load(struct contex
     cnt[0]->conf.argv = argv;
     cnt[0]->conf.argc = argc;
 
-    /* Open the motion.conf file. We try in this sequence:
-     * 1. commandline
+    /*
+     * Open the motion.conf file. We try in this sequence:
+     * 1. Command-line
      * 2. current working directory
      * 3. $HOME/.motion/motion.conf
      * 4. sysconfig/motion.conf
      */
-    /* Get filename & pid file from commandline */
+    /* Get filename , pid file & log file from Command-line. */
+    cnt[0]->log_type_str[0] = 0;
     cnt[0]->conf_filename[0] = 0;
     cnt[0]->pid_file[0] = 0;
+    cnt[0]->log_file[0] = 0;
+    cnt[0]->log_level = -1;
 
     conf_cmdline(cnt[0], -1);
-    if (cnt[0]->conf_filename[0]) { /* User has supplied filename on commandline*/
-        strcpy(filename, cnt[0]->conf_filename);
-        fp = fopen (filename, "r");
+
+    if (cnt[0]->conf_filename[0]) { /* User has supplied filename on Command-line. */
+      strncpy(filename, cnt[0]->conf_filename, PATH_MAX-1);
+      filename[PATH_MAX-1] = '\0';
+      fp = fopen (filename, "r");
     }
 
-    if (!fp) {      /* Commandline didn't work, try current dir */
+    if (!fp) {  /* Command-line didn't work, try current dir. */
         char *path = NULL;
+
         if (cnt[0]->conf_filename[0])
-            motion_log(-1, 1, "Configfile %s not found - trying defaults.", filename);
-        
+            MOTION_LOG(ALR, TYPE_ALL, SHOW_ERRNO, "%s: Configfile %s not found - trying defaults.",
+                       filename);
+
         if ((path = get_current_dir_name()) == NULL) {
-            motion_log(LOG_ERR, 1, "Error get_current_dir_name");
+            MOTION_LOG(ERR, TYPE_ALL, SHOW_ERRNO, "%s: Error get_current_dir_name");
             exit(-1);
         }
 
@@ -1659,65 +1906,89 @@ struct context **conf_load(struct contex
         free(path);
     }
 
-    if (!fp) {     /* specified file does not exist... try default file */
+    if (!fp) {  /* Specified file does not exist... try default file. */
         snprintf(filename, PATH_MAX, "%s/.motion/motion.conf", getenv("HOME"));
         fp = fopen(filename, "r");
+
         if (!fp) {
             snprintf(filename, PATH_MAX, "%s/motion.conf", sysconfdir);
             fp = fopen(filename, "r");
-            if (!fp)        /* there is no config file.... use defaults */
-                motion_log(-1, 1, "could not open configfile %s",filename);
+
+            if (!fp) /* There is no config file.... use defaults. */
+                MOTION_LOG(ALR, TYPE_ALL, SHOW_ERRNO, "%s: could not open configfile %s",
+                           filename);
         }
     }
 
-    /* Now we process the motion.conf config file and close it*/
+    /* Now we process the motion.conf config file and close it. */
     if (fp) {
-        strcpy(cnt[0]->conf_filename, filename);
-        motion_log(LOG_INFO, 0, "Processing thread 0 - config file %s",filename);
-        cnt = conf_process(cnt, fp);
-        fclose(fp);
+      strncpy(cnt[0]->conf_filename, filename, sizeof(cnt[0]->conf_filename) - 1);
+      cnt[0]->conf_filename[sizeof(cnt[0]->conf_filename) - 1] = '\0';
+      MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Processing thread 0 - config file %s",
+		 filename);
+      cnt = conf_process(cnt, fp);
+      myfclose(fp);
     } else {
-        motion_log(LOG_INFO, 0, "Not config file to process using default values");
+        MOTION_LOG(CRT, TYPE_ALL, NO_ERRNO, "%s: Not config file to process using default values");
     }
-    
 
-    /* For each thread (given by cnt[i]) being not null
+
+    /*
+     * For each thread (given by cnt[i]) being not null
      * cnt is an array of pointers to a context type structure
      * cnt[0] is the default context structure
      * cnt[1], cnt[2], ... are context structures for each thread
      * Command line options always wins over config file options
-     * so we go through each thread and overrides any set command line
-     * options
+     * so we go through each thread and overrides any set Command-line
+     * options.
      */
     i = -1;
+
     while (cnt[++i])
         conf_cmdline(cnt[i], i);
 
-    /* if pid file was passed from command line copy to main thread conf struct */
-    if (cnt[0]->pid_file[0])    
+    /* If pid file was passed from Command-line copy to main thread conf struct. */
+    if (cnt[0]->pid_file[0])
         cnt[0]->conf.pid_file = mystrcpy(cnt[0]->conf.pid_file, cnt[0]->pid_file);
 
+    /* If log file was passed from Command-line copy to main thread conf struct. */
+    if (cnt[0]->log_file[0])
+        cnt[0]->conf.log_file = mystrcpy(cnt[0]->conf.log_file, cnt[0]->log_file);
+
+    /* If log type string was passed from Command-line copy to main thread conf struct. */
+    if (cnt[0]->log_type_str[0])
+        cnt[0]->conf.log_type_str = mystrcpy(cnt[0]->conf.log_type_str, cnt[0]->log_type_str);
+
+    /* if log level was passed from Command-line copy to main thread conf struct. */
+    if (cnt[0]->log_level != -1)
+        cnt[0]->conf.log_level = cnt[0]->log_level;
+
     return cnt;
 }
 
-/* malloc_strings goes through the members of a context structure.
- * For each context structure member which is a pointer to a string it does this:
- * If the member points to a string and is not NULL
- * 1. Reserve (malloc) memory for the string
- * 2. Copy the original string to the reserved memory
- * 3. Change the cnt member (char*) pointing to the string in reserved memory
- * This ensures that we can free and malloc the string if it is later changed
+/**
+ * malloc_strings
+ *      goes through the members of a context structure.
+ *      For each context structure member which is a pointer to a string it does this:
+ *      If the member points to a string and is not NULL
+ *      1. Reserve (malloc) memory for the string
+ *      2. Copy the original string to the reserved memory
+ *      3. Change the cnt member (char*) pointing to the string in reserved memory
+ *      This ensures that we can free and malloc the string if it is later changed
+ *
+ * Returns nothing.
  */
-void malloc_strings(struct context * cnt)
+void malloc_strings(struct context *cnt)
 {
-    unsigned short int i = 0;
+    unsigned int i = 0;
     char **val;
     while (config_params[i].param_name != NULL) {
         if (config_params[i].copy == copy_string) { /* if member is a string */
-            /* val is made to point to a pointer to the current string */
+            /* val is made to point to a pointer to the current string. */
             val = (char **)((char *)cnt+config_params[i].conf_value);
 
-            /* if there is a string, malloc() space for it, copy
+            /*
+             * If there is a string, malloc() space for it, copy
              * the string to new space, and point to the new
              * string. we don't free() because we're copying a
              * static string.
@@ -1733,7 +2004,6 @@ void malloc_strings(struct context * cnt
  *
  *   copy_bool   - convert a bool representation to int
  *   copy_int    - convert a string to int
- *   copy_short  - convert a string to short
  *   copy_string - just a string copy
  *
  * @param str     - A char *, pointing to a string representation of the
@@ -1752,10 +2022,14 @@ void malloc_strings(struct context * cnt
  * the function will only assign the value for the given thread.
  ***********************************************************************/
 
-/* copy_bool assigns a config option to a new boolean value.
- * The boolean is given as a string in str which is converted to 0 or 1 
- * by the function. Values 1, yes and on are converted to 1 ignoring case.
- * Any other value is converted to 0.
+/**
+ * copy_bool
+ *      Assigns a config option to a new boolean value.
+ *      The boolean is given as a string in str which is converted to 0 or 1
+ *      by the function. Values 1, yes and on are converted to 1 ignoring case.
+ *      Any other value is converted to 0.
+ *
+ * Returns context struct.
  */
 static struct context **copy_bool(struct context **cnt, const char *str, int val_ptr)
 {
@@ -1764,8 +2038,9 @@ static struct context **copy_bool(struct
 
     i = -1;
     while (cnt[++i]) {
-        tmp = (char *)cnt[i] + (int)val_ptr;
-        if (!strcmp(str, "1") || !strcasecmp(str, "yes") || !strcasecmp(str,"on")) {
+        tmp = (char *)cnt[i]+(int)val_ptr;
+
+        if (!strcmp(str, "1") || !strcasecmp(str, "yes") || !strcasecmp(str, "on")) {
             *((int *)tmp) = 1;
         } else {
             *((int *)tmp) = 0;
@@ -1774,11 +2049,17 @@ static struct context **copy_bool(struct
         if (cnt[0]->threadnr)
             return cnt;
     }
+
     return cnt;
 }
 
-/* copy_int assigns a config option to a new integer value.
- * The integer is given as a string in str which is converted to integer by the function.
+/**
+ * copy_int
+ *      Assigns a config option to a new integer value.
+ *      The integer is given as a string in str which is converted to integer
+ *      by the function.
+ *
+ * Returns context struct.
  */
 static struct context **copy_int(struct context **cnt, const char *str, int val_ptr)
 {
@@ -1787,38 +2068,26 @@ static struct context **copy_int(struct
 
     i = -1;
     while (cnt[++i]) {
-        tmp = (char *)cnt[i] + val_ptr;
+        tmp = (char *)cnt[i]+val_ptr;
         *((int *)tmp) = atoi(str);
-        if (cnt[0]->threadnr)
-            return cnt;
-    }
-    return cnt;
-}
-
-/* copy_short assigns a config option to a new short value.
- * The integer is given as a string in str which is converted to short by the function.
- */ 
-static struct context **copy_short(struct context **cnt, const char *str, int val_ptr)
-{
-    void *tmp;
-    int i;
 
-    i = -1;
-    while (cnt[++i]) {
-        tmp = (char *)cnt[i] + val_ptr;
-        *((short int *)tmp) = atoi(str);
         if (cnt[0]->threadnr)
             return cnt;
     }
+
     return cnt;
 }
 
-/* copy_string assigns a new string value to a config option.
- * Strings are handled differently from bool and int.
- * the char *conf->option that we are working on is free()'d
- * (if memory for it has already been malloc()'d), and set to
- * a freshly malloc()'d string with the value from str,
- * or NULL if str is blank
+/**
+ * copy_string
+ *      Assigns a new string value to a config option.
+ *      Strings are handled differently from bool and int.
+ *      the char *conf->option that we are working on is free()'d
+ *      (if memory for it has already been malloc()'d), and set to
+ *      a freshly malloc()'d string with the value from str,
+ *      or NULL if str is blank.
+ *
+ * Returns context struct.
  */
 struct context **copy_string(struct context **cnt, const char *str, int val_ptr)
 {
@@ -1826,64 +2095,75 @@ struct context **copy_string(struct cont
     int i;
 
     i = -1;
+
     while (cnt[++i]) {
         tmp = (char **)((char *)cnt[i] + val_ptr);
 
-        /* mystrcpy assigns the new string value
+        /*
+         * mystrcpy assigns the new string value
          * including free'ing and reserving new memory for it.
          */
         *tmp = mystrcpy(*tmp, str);
 
-        /* set the option on all threads if setting the option
-         * for thread 0; otherwise just set that one thread's option
+        /*
+         * Set the option on all threads if setting the option
+         * for thread 0; otherwise just set that one thread's option.
          */
         if (cnt[0]->threadnr)
             return cnt;
     }
+
     return cnt;
 }
 
 
-/* mystrcpy is used to assign string type fields (e.g. config options)
- * In a way so that we the memory is malloc'ed to fit the string.
- * If a field is already pointing to a string (not NULL) the memory of the
- * old string is free'd and new memory is malloc'ed and filled with the
- * new string is copied into the the memory and with the char pointer
- * pointing to the new string.
+/**
+ * mystrcpy
+ *      Is used to assign string type fields (e.g. config options)
+ *      In a way so that we the memory is malloc'ed to fit the string.
+ *      If a field is already pointing to a string (not NULL) the memory of the
+ *      old string is free'd and new memory is malloc'ed and filled with the
+ *      new string is copied into the the memory and with the char pointer
+ *      pointing to the new string.
+ *
+ *      from - pointer to the new string we want to copy
+ *      to   - the pointer to the current string (or pointing to NULL)
+ *              If not NULL the memory it points to is free'd.
  *
- * from - pointer to the new string we want to copy
- * to   - the pointer to the current string (or pointing to NULL)
- *        If not NULL the memory it points to is free'd.
- * function returns pointer to the new string which is in malloc'ed memory
+ * Returns pointer to the new string which is in malloc'ed memory
  * FIXME The strings that are malloc'ed with this function should be freed
  * when the motion program is terminated normally instead of relying on the
  * OS to clean up.
  */
 char *mystrcpy(char *to, const char *from)
 {
-    /* free the memory used by the to string, if such memory exists,
+    /*
+     * Free the memory used by the to string, if such memory exists,
      * and return a pointer to a freshly malloc()'d string with the
      * same value as from.
      */
 
-    if (to != NULL) 
+    if (to != NULL)
         free(to);
 
     return mystrdup(from);
 }
 
 
-/* mystrdup return a pointer to a freshly malloc()'d string with the same
- * value as the string that the input parameter 'from' points to,
- * or NULL if the from string is 0 characters.
- * The function truncates the string to the length given by the environment
- * variable PATH_MAX to ensure that config options can always contain
- * a really long path but no more than that.
+/**
+ * mystrdup
+ *      Truncates the string to the length given by the environment
+ *      variable PATH_MAX to ensure that config options can always contain
+ *      a really long path but no more than that.
+ *
+ * Returns a pointer to a freshly malloc()'d string with the same
+ *      value as the string that the input parameter 'from' points to,
+ *      or NULL if the from string is 0 characters.
  */
 char *mystrdup(const char *from)
 {
     char *tmp;
-    int stringlength;
+    size_t stringlength;
 
     if (from == NULL || !strlen(from)) {
         tmp = NULL;
@@ -1893,33 +2173,46 @@ char *mystrdup(const char *from)
         tmp = (char *)mymalloc(stringlength + 1);
         strncpy(tmp, from, stringlength);
 
-        /* We must ensure the string always has a NULL terminator.
+        /*
+         * We must ensure the string always has a NULL terminator.
          * This necessary because strncpy will not append a NULL terminator
-         * if the original string is greater than stringlength.
+         * if the original string is greater than string length.
          */
         tmp += stringlength;
         *tmp = '\0';
         tmp -= stringlength;
     }
+
     return tmp;
 }
 
+/**
+ * config_type
+ *      Returns a pointer to string containing value the type of config parameter passed.
+ *
+ * Returns const char *.
+ */
 const char *config_type(config_param *configparam)
 {
     if (configparam->copy == copy_string)
         return "string";
     if (configparam->copy == copy_int)
         return "int";
-    if (configparam->copy == copy_short)
-        return "short";
     if (configparam->copy == copy_bool)
         return "bool";
 
     return "unknown";
 }
 
+
+/**
+ * print_bool
+ *      Returns a pointer to string containing boolean value 'on' / 'off' or NULL.
+ *
+ * Returns const char *.
+ */
 static const char *print_bool(struct context **cnt, char **str ATTRIBUTE_UNUSED,
-                               int parm, unsigned short int threadnr)
+                              int parm, unsigned int threadnr)
 {
     int val = config_params[parm].conf_value;
 
@@ -1933,22 +2226,27 @@ static const char *print_bool(struct con
         return "off";
 }
 
-/* print_string returns a pointer to a string containing the value of the config option
- * If the option is not defined NULL is returned.
- * If the thread number is not 0 the string is compared with the value of the same
- * option in thread 0. If the value is the same, NULL is returned which means that
- * the option is not written to the thread config file.
+/**
+ * print_string
+ *      Returns a pointer to a string containing the value of the config option,
+ *      If the thread number is not 0 the string is compared with the value of the same
+ *      option in thread 0.
+ *
+ * Returns If the option is not defined NULL is returned.
+ *         If the value is the same, NULL is returned which means that
+ *         the option is not written to the thread config file.
  */
 static const char *print_string(struct context **cnt,
-                                 char **str ATTRIBUTE_UNUSED, int parm,
-                                 unsigned short int threadnr)
+                                char **str ATTRIBUTE_UNUSED, int parm,
+                                unsigned int threadnr)
 {
     int val = config_params[parm].conf_value;
     const char **cptr0, **cptr1;
-    
-    /* strcmp does not like NULL so we have to check for this also */
+
+    /* strcmp does not like NULL so we have to check for this also. */
     cptr0 = (const char **)((char *)cnt[0] + val);
     cptr1 = (const char **)((char *)cnt[threadnr] + val);
+
     if ((threadnr) && (*cptr0 != NULL) && (*cptr1 != NULL) && (!strcmp(*cptr0, *cptr1)))
         return NULL;
 
@@ -1956,7 +2254,7 @@ static const char *print_string(struct c
 }
 
 static const char *print_int(struct context **cnt, char **str ATTRIBUTE_UNUSED,
-                              int parm, unsigned short int threadnr)
+                             int parm, unsigned int threadnr)
 {
     static char retval[20];
     int val = config_params[parm].conf_value;
@@ -1971,106 +2269,107 @@ static const char *print_int(struct cont
 }
 
 
-static const char *print_short(struct context **cnt, char **str ATTRIBUTE_UNUSED,
-                                int parm, unsigned short int threadnr) 
-{
-    static char retval[20];
-    int val = config_params[parm].conf_value;
-
-    if (threadnr &&
-        *(short int*)((char *)cnt[threadnr] + val) == *(short int*)((char *)cnt[0] + val))
-        return NULL;
-
-    sprintf(retval, "%d", *(short int*)((char *)cnt[threadnr] + val));
-
-    return retval;
-}
-
 static const char *print_thread(struct context **cnt, char **str,
-                                 int parm ATTRIBUTE_UNUSED, unsigned short int threadnr)
+                                int parm ATTRIBUTE_UNUSED, unsigned int threadnr)
 {
     char *retval;
-    unsigned short int i = 0;
+    unsigned int i = 0;
 
     if (!str || threadnr)
         return NULL;
 
     retval = mymalloc(1);
     retval[0] = 0;
+
     while (cnt[++i]) {
-        retval = myrealloc(retval, strlen(retval) + strlen(cnt[i]->conf_filename) + 10, "print_thread");
+        retval = myrealloc(retval, strlen(retval) + strlen(cnt[i]->conf_filename) + 10,
+                           "print_thread");
         sprintf(retval + strlen(retval), "thread %s\n", cnt[i]->conf_filename);
     }
+
     *str = retval;
 
     return NULL;
 }
 
-/* config_thread() is called during initial config file loading each time Motion
- * finds a thread option in motion.conf
- * The size of the context array is increased and the main context's values are
- * copied to the new thread.
+/**
+ * config_thread
+ *      Is called during initial config file loading each time Motion
+ *      finds a thread option in motion.conf
+ *      The size of the context array is increased and the main context's values are
+ *      copied to the new thread.
  *
- * cnt  - pointer to the array of pointers pointing to the context structures
- * str  - pointer to a string which is the filename of the thread config file
- * val  - is not used. It is defined to be function header compatible with
- *        copy_int, copy_bool and copy_string.
+ *      cnt  - pointer to the array of pointers pointing to the context structures
+ *      str  - pointer to a string which is the filename of the thread config file
+ *      val  - is not used. It is defined to be function header compatible with
+ *            copy_int, copy_bool and copy_string.
  */
 static struct context **config_thread(struct context **cnt, const char *str,
-                                       int val ATTRIBUTE_UNUSED)
+                                      int val ATTRIBUTE_UNUSED)
 {
     int i;
     FILE *fp;
-    
+
     if (cnt[0]->threadnr)
         return cnt;
 
     fp = fopen(str, "r");
 
     if (!fp) {
-        motion_log(LOG_ERR, 1, "Thread config file %s not found",str);
+        MOTION_LOG(ALR, TYPE_ALL, SHOW_ERRNO, "%s: Thread config file %s not found",
+                   str);
         return cnt;
     }
 
     /* Find the current number of threads defined. */
     i = -1;
+
     while (cnt[++i]);
 
-    /* Make space for the threads + the terminating NULL pointer
+    /*
+     * Make space for the threads + the terminating NULL pointer
      * in the array of pointers to context structures
-     * First thread is 0 so the number of threads is i+1
-     * plus an extra for the NULL pointer. This gives i+2
+     * First thread is 0 so the number of threads is i + 1
+     * plus an extra for the NULL pointer. This gives i + 2
      */
     cnt = myrealloc(cnt, sizeof(struct context *) * (i + 2), "config_thread");
 
     /* Now malloc space for an additional context structure for thread nr. i */
     cnt[i] = mymalloc(sizeof(struct context));
-    
+
     /* And make this an exact clone of the context structure for thread 0 */
     memcpy(cnt[i], cnt[0], sizeof(struct context));
 
-    /* All the integers are copies of the actual value.
+    /*
+     * All the integers are copies of the actual value.
      * The strings are all pointers to strings so we need to create
      * unique malloc'ed space for all the strings that are not NULL and
      * change the string pointers to point to the new strings.
      * malloc_strings takes care of this.
      */
     malloc_strings(cnt[i]);
-    
-    /* Mark the end if the array of pointers to context structures */
+
+    /* Mark the end if the array of pointers to context structures. */
     cnt[i + 1] = NULL;
 
-    /* process the thread's config file and notify user on console */
+    /* Process the thread's config file and notify user on console. */
     strcpy(cnt[i]->conf_filename, str);
-    motion_log(LOG_INFO, 0, "Processing config file %s", str);
-    conf_process(cnt+i, fp);
-    
-    /* Finally we close the thread config file */
-    fclose(fp);
+    MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Processing config file %s",
+               str);
+    conf_process(cnt + i, fp);
+
+    /* Finally we close the thread config file. */
+    myfclose(fp);
 
     return cnt;
 }
 
+/**
+ * usage
+ *      Prints usage and options allowed from Command-line.
+ *
+ * Returns nothing.
+ */
 static void usage()
 {
     printf("motion Version "VERSION", Copyright 2000-2005 Jeroen Vreeken/Folkert van Heusden/Kenneth Lavrsen\n");
@@ -2080,8 +2379,11 @@ static void usage()
     printf("-n\t\t\tRun in non-daemon mode.\n");
     printf("-s\t\t\tRun in setup mode.\n");
     printf("-c config\t\tFull path and filename of config file.\n");
-    printf("-d level\t\tDebug mode.\n");
+    printf("-d level\t\tLog level (1-9) (EMR, ALR, CRT, ERR, WRN, NTC, ERR, DBG, ALL). default: 6 / NTC.\n");
+    printf("-k type\t\t\tType of log (COR, STR, ENC, NET, DBL, EVT, TRK, VID, ALL). default: ALL.\n");
     printf("-p process_id_file\tFull path and filename of process id file (pid file).\n");
+    printf("-l log file \t\tFull path and filename of log file.\n");
+    printf("-m\t\t\tDisable motion detection at startup.\n");
     printf("-h\t\t\tShow this screen.\n");
     printf("\n");
     printf("Motion is configured using a config file only. If none is supplied,\n");
--- motion-3.2.12.orig/conf.h
+++ motion-3.2.12/conf.h
@@ -1,24 +1,27 @@
 /*
-  **
-  ** conf.h - function prototypes for the config handling routines
-  **
-  ** Originally written for the dproxy package by Matthew Pratt.
-  **
-  ** Copyright 2000 Jeroen Vreeken (pe1rxq@chello.nl)
-  **
-  ** This software is licensed under the terms of the GNU General
-  ** Public License (GPL). Please see the file COPYING for details.
-  **
-  **
-*/
+ *
+ * conf.h - function prototypes for the config handling routines
+ *
+ * Originally written for the dproxy package by Matthew Pratt.
+ *
+ * Copyright 2000 Jeroen Vreeken (pe1rxq@chello.nl)
+ *
+ * This software is licensed under the terms of the GNU General
+ * Public License (GPL). Please see the file COPYING for details.
+ *
+ *
+ */
 
 #ifndef _INCLUDE_CONF_H
 #define _INCLUDE_CONF_H
 
 /* 
-    more parameters may be added later.
+ * More parameters may be added later.
  */
 struct config {
+    unsigned int log_level;
+    char *log_type_str;
+    char *log_file;
     int setup_mode;
     int width;
     int height;
@@ -26,18 +29,21 @@ struct config {
     int rotate_deg;
     int max_changes;
     int threshold_tune;
-    const char *output_normal;
+    const char *output_pictures;
     int motion_img;
-    int output_all;
-    int gap;
-    int maxmpegtime;
+    int emulate_motion;
+    int event_gap;
+    int max_movie_time;
     int snapshot_interval;
-    const char *locate;
+    const char *locate_motion_mode;
+    const char *locate_motion_style;
     int input;
     int norm;
     int frame_limit;
     int quiet;
-    int ppm;
+    int useextpipe; /* ext_pipe on or off */
+    const char *extpipe; /* full Command-line for pipe -- must accept YUV420P images  */
+    const char *picture_type;
     int noise;
     int noise_tune;
     int minimum_frame_time;
@@ -52,22 +58,28 @@ struct config {
     int pre_capture;
     int post_capture;
     int switchfilter;
-    int ffmpeg_cap_new;
-    int ffmpeg_cap_motion;
+    int ffmpeg_output;
+    int ffmpeg_output_debug;
     int ffmpeg_bps;
     int ffmpeg_vbr;
     int ffmpeg_deinterlace;
     const char *ffmpeg_video_codec;
-    int webcam_port;
-    int webcam_quality;
-    int webcam_motion;
-    int webcam_maxrate;
-    int webcam_localhost;
-    int webcam_limit;
-    int control_port;
-    int control_localhost;
-    int control_html_output;
-    const char *control_authentication;
+#ifdef HAVE_SDL
+    int sdl_threadnr;
+#endif
+    int ipv6_enabled;
+    int stream_port;
+    int stream_quality;
+    int stream_motion;
+    int stream_maxrate;
+    int stream_localhost;
+    int stream_limit;
+    int stream_auth_method;
+    const char *stream_authentication;
+    int webcontrol_port;
+    int webcontrol_localhost;
+    int webcontrol_html_output;
+    const char *webcontrol_authentication;
     unsigned long frequency;
     int tuner_number;
     int timelapse;
@@ -76,11 +88,11 @@ struct config {
     const char *tuner_device;
 #endif
     const char *video_device;
-    short unsigned int v4l2_palette;
+    int v4l2_palette;
     const char *vidpipe;
     const char *filepath;
-    const char *jpegpath;
-    const char *mpegpath;
+    const char *imagepath;
+    const char *moviepath;
     const char *snappath;
     const char *timepath;
     char *on_event_start;
@@ -89,13 +101,16 @@ struct config {
     int smart_mask_speed;
     int sql_log_image;
     int sql_log_snapshot;
-    int sql_log_mpeg;
+    int sql_log_movie;
     int sql_log_timelapse;
     const char *sql_query;
-    const char *mysql_db;
-    const char *mysql_host;
-    const char *mysql_user;
-    const char *mysql_password;
+    const char *database_type;
+    const char *database_dbname;
+    const char *database_host;
+    const char *database_user;
+    const char *database_password;
+    const char *sqlite3_db;
+    int database_port;
     char *on_picture_save;
     char *on_area_detected;
     char *on_motion_detected;
@@ -105,22 +120,19 @@ struct config {
     const char *motionvidpipe;
     const char *netcam_url;
     const char *netcam_userpass;
-    const char *netcam_http;
+    const char *netcam_keepalive;
     const char *netcam_proxy;
     unsigned int netcam_tolerant_check;
-    const char *pgsql_db;
-    const char *pgsql_host;
-    const char *pgsql_user;
-    const char *pgsql_password;
-    int pgsql_port;
+    unsigned int rtsp_uses_tcp;
     int text_changes;
     const char *text_left;
     const char *text_right;
     const char *text_event;
     int text_double;
-    const char *despeckle;
+    const char *despeckle_filter;
     const char *area_detect;
     int minimum_motion_frames;
+    const char *exif_text;
     char *pid_file;
     int argc;
     char **argv;
@@ -130,28 +142,27 @@ struct config {
  * typedef for a param copy function. 
  */
 typedef struct context ** (* conf_copy_func)(struct context **, const char *, int);
-typedef const char *(* conf_print_func)(struct context **, char **, int, unsigned short int);
+typedef const char *(* conf_print_func)(struct context **, char **, int, unsigned int);
 
 /**
  * description for parameters in the config file
  */
 typedef struct {
-    const char * param_name;        /* name for this parameter                  */
-    const char * param_help;        /* short explanation for parameter          */
-    unsigned short int main_thread; /* belong only to main thread when value>0  */
-    int conf_value;                 /* pointer to a field in struct context     */
-    conf_copy_func  copy;           /* a function to set the value in 'config'  */
-    conf_print_func print;          /* a function to output the value to a file */
+    const char *param_name;           /* name for this parameter                  */
+    const char *param_help;           /* short explanation for parameter          */
+    unsigned int main_thread;         /* belong only to main thread when value>0  */
+    int conf_value;                   /* pointer to a field in struct context     */
+    conf_copy_func  copy;             /* a function to set the value in 'config'  */
+    conf_print_func print;            /* a function to output the value to a file */
 } config_param; 
 
-
 extern config_param config_params[];
 
 struct context **conf_load(struct context **);
 struct context **conf_cmdparse(struct context **, const char *, const char *);
 const char *config_type(config_param *);
 void conf_print(struct context **);
-void malloc_strings (struct context *);
+void malloc_strings(struct context *);
 char *mystrdup(const char *);
 char *mystrcpy(char *, const char *);
 struct context **copy_string(struct context **, const char *, int);
@@ -160,5 +171,4 @@ struct context **copy_string(struct cont
 char *get_current_dir_name(void);
 #endif
 
-
 #endif /* _INCLUDE_CONF_H */
--- /dev/null
+++ motion-3.2.12/config.h
@@ -0,0 +1,145 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#define HAVE_FCNTL_H 1
+
+/* Define to 1 if you have the `get_current_dir_name' function. */
+#define HAVE_GET_CURRENT_DIR_NAME 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the <linux/videodev2.h> header file. */
+#define HAVE_LINUX_VIDEODEV2_H 1
+
+/* Define to 1 if you have the <linux/videodev.h> header file. */
+/* #undef HAVE_LINUX_VIDEODEV_H */
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have MySQL support */
+/* #undef HAVE_MYSQL */
+
+/* Define to 1 if you have PostgreSQL support */
+/* #undef HAVE_PGSQL */
+
+/* Define to 1 if you have SDL support */
+/* #undef HAVE_SDL */
+
+/* Define to 1 if you have the <signal.h> header file. */
+#define HAVE_SIGNAL_H 1
+
+/* Define to 1 if you have SQLITE3 support */
+/* #undef HAVE_SQLITE3 */
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdio.h> header file. */
+#define HAVE_STDIO_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the <sys/ioctl.h> header file. */
+#define HAVE_SYS_IOCTL_H 1
+
+/* Define to 1 if you have the <sys/mman.h> header file. */
+#define HAVE_SYS_MMAN_H 1
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#define HAVE_SYS_PARAM_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <time.h> header file. */
+#define HAVE_TIME_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "motion"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "motion 3.2.12-4ppa01"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "motion"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "3.2.12-4ppa01"
+
+/* The size of `int', as computed by sizeof. */
+#define SIZEOF_INT 4
+
+/* The size of `int *', as computed by sizeof. */
+#define SIZEOF_INT_P 8
+
+/* The size of `long int', as computed by sizeof. */
+#define SIZEOF_LONG_INT 8
+
+/* The size of `long long', as computed by sizeof. */
+#define SIZEOF_LONG_LONG 8
+
+/* The size of `short', as computed by sizeof. */
+#define SIZEOF_SHORT 2
+
+/* The size of `void *', as computed by sizeof. */
+#define SIZEOF_VOID_P 8
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Enable extensions on AIX 3, Interix.  */
+#ifndef _ALL_SOURCE
+# define _ALL_SOURCE 1
+#endif
+/* Enable GNU extensions on systems that have them.  */
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE 1
+#endif
+/* Enable threading extensions on Solaris.  */
+#ifndef _POSIX_PTHREAD_SEMANTICS
+# define _POSIX_PTHREAD_SEMANTICS 1
+#endif
+/* Enable extensions on HP NonStop.  */
+#ifndef _TANDEM_SOURCE
+# define _TANDEM_SOURCE 1
+#endif
+/* Enable general extensions on Solaris.  */
+#ifndef __EXTENSIONS__
+# define __EXTENSIONS__ 1
+#endif
+
+
+/* Define to 1 if on MINIX. */
+/* #undef _MINIX */
+
+/* Define to 2 if the system does not provide POSIX.1 features except with
+   this defined. */
+/* #undef _POSIX_1_SOURCE */
+
+/* Define to 1 if you need to in order for `stat' and other things to work. */
+/* #undef _POSIX_SOURCE */
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
--- motion-3.2.12.orig/config.h.in
+++ motion-3.2.12/config.h.in
@@ -1,4 +1,4 @@
-/* config.h.in.  Generated from configure.in by autoheader.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
 
 /* Define to 1 if you have the <fcntl.h> header file. */
 #undef HAVE_FCNTL_H
@@ -24,9 +24,15 @@
 /* Define to 1 if you have PostgreSQL support */
 #undef HAVE_PGSQL
 
+/* Define to 1 if you have SDL support */
+#undef HAVE_SDL
+
 /* Define to 1 if you have the <signal.h> header file. */
 #undef HAVE_SIGNAL_H
 
+/* Define to 1 if you have SQLITE3 support */
+#undef HAVE_SQLITE3
+
 /* Define to 1 if you have the <stdint.h> header file. */
 #undef HAVE_STDINT_H
 
@@ -75,20 +81,64 @@
 /* Define to the one symbol short name of this package. */
 #undef PACKAGE_TARNAME
 
+/* Define to the home page for this package. */
+#undef PACKAGE_URL
+
 /* Define to the version of this package. */
 #undef PACKAGE_VERSION
 
 /* The size of `int', as computed by sizeof. */
 #undef SIZEOF_INT
 
+/* The size of `int *', as computed by sizeof. */
+#undef SIZEOF_INT_P
+
 /* The size of `long int', as computed by sizeof. */
 #undef SIZEOF_LONG_INT
 
-/* The size of `short int', as computed by sizeof. */
-#undef SIZEOF_SHORT_INT
+/* The size of `long long', as computed by sizeof. */
+#undef SIZEOF_LONG_LONG
+
+/* The size of `short', as computed by sizeof. */
+#undef SIZEOF_SHORT
+
+/* The size of `void *', as computed by sizeof. */
+#undef SIZEOF_VOID_P
 
 /* Define to 1 if you have the ANSI C header files. */
 #undef STDC_HEADERS
 
+/* Enable extensions on AIX 3, Interix.  */
+#ifndef _ALL_SOURCE
+# undef _ALL_SOURCE
+#endif
+/* Enable GNU extensions on systems that have them.  */
+#ifndef _GNU_SOURCE
+# undef _GNU_SOURCE
+#endif
+/* Enable threading extensions on Solaris.  */
+#ifndef _POSIX_PTHREAD_SEMANTICS
+# undef _POSIX_PTHREAD_SEMANTICS
+#endif
+/* Enable extensions on HP NonStop.  */
+#ifndef _TANDEM_SOURCE
+# undef _TANDEM_SOURCE
+#endif
+/* Enable general extensions on Solaris.  */
+#ifndef __EXTENSIONS__
+# undef __EXTENSIONS__
+#endif
+
+
+/* Define to 1 if on MINIX. */
+#undef _MINIX
+
+/* Define to 2 if the system does not provide POSIX.1 features except with
+   this defined. */
+#undef _POSIX_1_SOURCE
+
+/* Define to 1 if you need to in order for `stat' and other things to work. */
+#undef _POSIX_SOURCE
+
 /* Define to empty if `const' does not conform to ANSI C. */
 #undef const
--- motion-3.2.12.orig/configure
+++ motion-3.2.12/configure
@@ -1,11 +1,9 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.65 for motion 3.2.12.
+# Generated by GNU Autoconf 2.69 for motion 3.2.12-4ppa01.
 #
 #
-# Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
-# 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation,
-# Inc.
+# Copyright (C) 1992-1996, 1998-2012 Free Software Foundation, Inc.
 #
 #
 # This configure script is free software; the Free Software Foundation
@@ -89,6 +87,7 @@ fi
 IFS=" ""	$as_nl"
 
 # Find who we are.  Look in the path if we contain no directory separator.
+as_myself=
 case $0 in #((
   *[\\/]* ) as_myself=$0 ;;
   *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
@@ -133,6 +132,31 @@ export LANGUAGE
 # CDPATH.
 (unset CDPATH) >/dev/null 2>&1 && unset CDPATH
 
+# Use a proper internal environment variable to ensure we don't fall
+  # into an infinite loop, continuously re-executing ourselves.
+  if test x"${_as_can_reexec}" != xno && test "x$CONFIG_SHELL" != x; then
+    _as_can_reexec=no; export _as_can_reexec;
+    # We cannot yet assume a decent shell, so we have to provide a
+# neutralization value for shells without unset; and this also
+# works around shells that cannot unset nonexistent variables.
+# Preserve -v and -x to the replacement shell.
+BASH_ENV=/dev/null
+ENV=/dev/null
+(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
+case $- in # ((((
+  *v*x* | *x*v* ) as_opts=-vx ;;
+  *v* ) as_opts=-v ;;
+  *x* ) as_opts=-x ;;
+  * ) as_opts= ;;
+esac
+exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
+# Admittedly, this is quite paranoid, since all the known shells bail
+# out after a failed `exec'.
+$as_echo "$0: could not re-execute with $CONFIG_SHELL" >&2
+as_fn_exit 255
+  fi
+  # We don't want this to propagate to other subprocesses.
+          { _as_can_reexec=; unset _as_can_reexec;}
 if test "x$CONFIG_SHELL" = x; then
   as_bourne_compatible="if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :
   emulate sh
@@ -166,7 +190,8 @@ if ( set x; as_fn_ret_success y && test
 else
   exitcode=1; echo positional parameters were not saved.
 fi
-test x\$exitcode = x0 || exit 1"
+test x\$exitcode = x0 || exit 1
+test -x / || exit 1"
   as_suggested="  as_lineno_1=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_1a=\$LINENO
   as_lineno_2=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_2a=\$LINENO
   eval 'test \"x\$as_lineno_1'\$as_run'\" != \"x\$as_lineno_2'\$as_run'\" &&
@@ -211,14 +236,25 @@ IFS=$as_save_IFS
 
 
       if test "x$CONFIG_SHELL" != x; then :
-  # We cannot yet assume a decent shell, so we have to provide a
-	# neutralization value for shells without unset; and this also
-	# works around shells that cannot unset nonexistent variables.
-	BASH_ENV=/dev/null
-	ENV=/dev/null
-	(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
-	export CONFIG_SHELL
-	exec "$CONFIG_SHELL" "$as_myself" ${1+"$@"}
+  export CONFIG_SHELL
+             # We cannot yet assume a decent shell, so we have to provide a
+# neutralization value for shells without unset; and this also
+# works around shells that cannot unset nonexistent variables.
+# Preserve -v and -x to the replacement shell.
+BASH_ENV=/dev/null
+ENV=/dev/null
+(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
+case $- in # ((((
+  *v*x* | *x*v* ) as_opts=-vx ;;
+  *v* ) as_opts=-v ;;
+  *x* ) as_opts=-x ;;
+  * ) as_opts= ;;
+esac
+exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
+# Admittedly, this is quite paranoid, since all the known shells bail
+# out after a failed `exec'.
+$as_echo "$0: could not re-execute with $CONFIG_SHELL" >&2
+exit 255
 fi
 
     if test x$as_have_required = xno; then :
@@ -316,10 +352,18 @@ $as_echo X"$as_dir" |
       test -d "$as_dir" && break
     done
     test -z "$as_dirs" || eval "mkdir $as_dirs"
-  } || test -d "$as_dir" || as_fn_error "cannot create directory $as_dir"
+  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"
 
 
 } # as_fn_mkdir_p
+
+# as_fn_executable_p FILE
+# -----------------------
+# Test if FILE is an executable regular file.
+as_fn_executable_p ()
+{
+  test -f "$1" && test -x "$1"
+} # as_fn_executable_p
 # as_fn_append VAR VALUE
 # ----------------------
 # Append the text in VALUE to the end of the definition contained in VAR. Take
@@ -356,19 +400,19 @@ else
 fi # as_fn_arith
 
 
-# as_fn_error ERROR [LINENO LOG_FD]
-# ---------------------------------
+# as_fn_error STATUS ERROR [LINENO LOG_FD]
+# ----------------------------------------
 # Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
 # provided, also output the error to LOG_FD, referencing LINENO. Then exit the
-# script with status $?, using 1 if that was 0.
+# script with STATUS, using 1 if that was 0.
 as_fn_error ()
 {
-  as_status=$?; test $as_status -eq 0 && as_status=1
-  if test "$3"; then
-    as_lineno=${as_lineno-"$2"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-    $as_echo "$as_me:${as_lineno-$LINENO}: error: $1" >&$3
+  as_status=$1; test $as_status -eq 0 && as_status=1
+  if test "$4"; then
+    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
   fi
-  $as_echo "$as_me: error: $1" >&2
+  $as_echo "$as_me: error: $2" >&2
   as_fn_exit $as_status
 } # as_fn_error
 
@@ -441,6 +485,10 @@ as_cr_alnum=$as_cr_Letters$as_cr_digits
   chmod +x "$as_me.lineno" ||
     { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }
 
+  # If we had to re-execute with $CONFIG_SHELL, we're ensured to have
+  # already done that, so ensure we don't try to do so again and fall
+  # in an infinite loop.  This has already happened in practice.
+  _as_can_reexec=no; export _as_can_reexec
   # Don't try to exec as it changes $[0], causing all sort of problems
   # (the dirname of $[0] is not the place where we might find the
   # original and so on.  Autoconf is especially sensitive to this).
@@ -475,16 +523,16 @@ if (echo >conf$$.file) 2>/dev/null; then
     # ... but there are two gotchas:
     # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
     # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
-    # In both cases, we have to default to `cp -p'.
+    # In both cases, we have to default to `cp -pR'.
     ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
-      as_ln_s='cp -p'
+      as_ln_s='cp -pR'
   elif ln conf$$.file conf$$ 2>/dev/null; then
     as_ln_s=ln
   else
-    as_ln_s='cp -p'
+    as_ln_s='cp -pR'
   fi
 else
-  as_ln_s='cp -p'
+  as_ln_s='cp -pR'
 fi
 rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
 rmdir conf$$.dir 2>/dev/null
@@ -496,28 +544,8 @@ else
   as_mkdir_p=false
 fi
 
-if test -x / >/dev/null 2>&1; then
-  as_test_x='test -x'
-else
-  if ls -dL / >/dev/null 2>&1; then
-    as_ls_L_option=L
-  else
-    as_ls_L_option=
-  fi
-  as_test_x='
-    eval sh -c '\''
-      if test -d "$1"; then
-	test -d "$1/.";
-      else
-	case $1 in #(
-	-*)set "./$1";;
-	esac;
-	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
-	???[sx]*):;;*)false;;esac;fi
-    '\'' sh
-  '
-fi
-as_executable_p=$as_test_x
+as_test_x='test -x'
+as_executable_p=as_fn_executable_p
 
 # Sed expression to map a string onto a valid CPP name.
 as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
@@ -530,7 +558,7 @@ test -n "$DJDIR" || exec 7<&0 </dev/null
 exec 6>&1
 
 # Name of the host.
-# hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
+# hostname on some systems (SVR3.2, old GNU/Linux) returns a bogus exit status,
 # so uname gets run too.
 ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
 
@@ -549,12 +577,11 @@ MAKEFLAGS=
 # Identity of this package.
 PACKAGE_NAME='motion'
 PACKAGE_TARNAME='motion'
-PACKAGE_VERSION='3.2.12'
-PACKAGE_STRING='motion 3.2.12'
+PACKAGE_VERSION='3.2.12-4ppa01'
+PACKAGE_STRING='motion 3.2.12-4ppa01'
 PACKAGE_BUGREPORT=''
 PACKAGE_URL=''
 
-ac_unique_file="motion.c"
 # Factoring default headers for most tests.
 ac_includes_default="\
 #include <stdio.h>
@@ -591,14 +618,17 @@ ac_includes_default="\
 # include <unistd.h>
 #endif"
 
+ac_unique_file="motion.c"
 ac_subst_vars='LTLIBOBJS
 LIBOBJS
 BIN_PATH
-DOC_DIR
+RTPS_OBJ
+FFMPEG_OBJ
+SDL_OBJ
+VIDEO
 EGREP
 GREP
 CPP
-FFMPEG_OBJ
 OBJEXT
 EXEEXT
 ac_ct_CC
@@ -606,7 +636,6 @@ CPPFLAGS
 LDFLAGS
 CFLAGS
 CC
-VIDEO
 target_alias
 host_alias
 build_alias
@@ -652,8 +681,13 @@ with_linuxthreads
 with_pwcbsd
 with_bktr
 with_v4l
+with_sdl
+with_jpeg_turbo
 with_jpeg_mmx
 with_ffmpeg
+with_ffmpeg_headers
+with_ffmpeg_libs
+with_sqlite3
 with_mysql
 with_mysql_lib
 with_mysql_include
@@ -734,8 +768,9 @@ do
   fi
 
   case $ac_option in
-  *=*)	ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
-  *)	ac_optarg=yes ;;
+  *=?*) ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
+  *=)   ac_optarg= ;;
+  *)    ac_optarg=yes ;;
   esac
 
   # Accept the important Cygnus configure options, so we can diagnose typos.
@@ -780,7 +815,7 @@ do
     ac_useropt=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error "invalid feature name: $ac_useropt"
+      as_fn_error $? "invalid feature name: $ac_useropt"
     ac_useropt_orig=$ac_useropt
     ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
@@ -806,7 +841,7 @@ do
     ac_useropt=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error "invalid feature name: $ac_useropt"
+      as_fn_error $? "invalid feature name: $ac_useropt"
     ac_useropt_orig=$ac_useropt
     ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
@@ -1010,7 +1045,7 @@ do
     ac_useropt=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error "invalid package name: $ac_useropt"
+      as_fn_error $? "invalid package name: $ac_useropt"
     ac_useropt_orig=$ac_useropt
     ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
@@ -1026,7 +1061,7 @@ do
     ac_useropt=`expr "x$ac_option" : 'x-*without-\(.*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error "invalid package name: $ac_useropt"
+      as_fn_error $? "invalid package name: $ac_useropt"
     ac_useropt_orig=$ac_useropt
     ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
@@ -1056,8 +1091,8 @@ do
   | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
     x_libraries=$ac_optarg ;;
 
-  -*) as_fn_error "unrecognized option: \`$ac_option'
-Try \`$0 --help' for more information."
+  -*) as_fn_error $? "unrecognized option: \`$ac_option'
+Try \`$0 --help' for more information"
     ;;
 
   *=*)
@@ -1065,7 +1100,7 @@ Try \`$0 --help' for more information."
     # Reject names that are not valid shell variable names.
     case $ac_envvar in #(
       '' | [0-9]* | *[!_$as_cr_alnum]* )
-      as_fn_error "invalid variable name: \`$ac_envvar'" ;;
+      as_fn_error $? "invalid variable name: \`$ac_envvar'" ;;
     esac
     eval $ac_envvar=\$ac_optarg
     export $ac_envvar ;;
@@ -1075,7 +1110,7 @@ Try \`$0 --help' for more information."
     $as_echo "$as_me: WARNING: you should use --build, --host, --target" >&2
     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
       $as_echo "$as_me: WARNING: invalid host type: $ac_option" >&2
-    : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
+    : "${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}"
     ;;
 
   esac
@@ -1083,13 +1118,13 @@ done
 
 if test -n "$ac_prev"; then
   ac_option=--`echo $ac_prev | sed 's/_/-/g'`
-  as_fn_error "missing argument to $ac_option"
+  as_fn_error $? "missing argument to $ac_option"
 fi
 
 if test -n "$ac_unrecognized_opts"; then
   case $enable_option_checking in
     no) ;;
-    fatal) as_fn_error "unrecognized options: $ac_unrecognized_opts" ;;
+    fatal) as_fn_error $? "unrecognized options: $ac_unrecognized_opts" ;;
     *)     $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2 ;;
   esac
 fi
@@ -1112,7 +1147,7 @@ do
     [\\/$]* | ?:[\\/]* )  continue;;
     NONE | '' ) case $ac_var in *prefix ) continue;; esac;;
   esac
-  as_fn_error "expected an absolute directory name for --$ac_var: $ac_val"
+  as_fn_error $? "expected an absolute directory name for --$ac_var: $ac_val"
 done
 
 # There might be people who depend on the old broken behavior: `$host'
@@ -1126,8 +1161,6 @@ target=$target_alias
 if test "x$host_alias" != x; then
   if test "x$build_alias" = x; then
     cross_compiling=maybe
-    $as_echo "$as_me: WARNING: If you wanted to set the --build type, don't use --host.
-    If a cross compiler is detected then cross compile mode will be used." >&2
   elif test "x$build_alias" != "x$host_alias"; then
     cross_compiling=yes
   fi
@@ -1142,9 +1175,9 @@ test "$silent" = yes && exec 6>/dev/null
 ac_pwd=`pwd` && test -n "$ac_pwd" &&
 ac_ls_di=`ls -di .` &&
 ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
-  as_fn_error "working directory cannot be determined"
+  as_fn_error $? "working directory cannot be determined"
 test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
-  as_fn_error "pwd does not report name of working directory"
+  as_fn_error $? "pwd does not report name of working directory"
 
 
 # Find the source files, if location was not specified.
@@ -1183,11 +1216,11 @@ else
 fi
 if test ! -r "$srcdir/$ac_unique_file"; then
   test "$ac_srcdir_defaulted" = yes && srcdir="$ac_confdir or .."
-  as_fn_error "cannot find sources ($ac_unique_file) in $srcdir"
+  as_fn_error $? "cannot find sources ($ac_unique_file) in $srcdir"
 fi
 ac_msg="sources are in $srcdir, but \`cd $srcdir' does not work"
 ac_abs_confdir=`(
-	cd "$srcdir" && test -r "./$ac_unique_file" || as_fn_error "$ac_msg"
+	cd "$srcdir" && test -r "./$ac_unique_file" || as_fn_error $? "$ac_msg"
 	pwd)`
 # When building in place, set srcdir=.
 if test "$ac_abs_confdir" = "$ac_pwd"; then
@@ -1213,7 +1246,7 @@ if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures motion 3.2.12 to adapt to many kinds of systems.
+\`configure' configures motion 3.2.12-4ppa01 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1227,7 +1260,7 @@ Configuration:
       --help=short        display options specific to this package
       --help=recursive    display the short help of all the included packages
   -V, --version           display version information and exit
-  -q, --quiet, --silent   do not print \`checking...' messages
+  -q, --quiet, --silent   do not print \`checking ...' messages
       --cache-file=FILE   cache test results in FILE [disabled]
   -C, --config-cache      alias for \`--cache-file=config.cache'
   -n, --no-create         do not create output files
@@ -1274,7 +1307,7 @@ fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of motion 3.2.12:";;
+     short | recursive ) echo "Configuration of motion 3.2.12-4ppa01:";;
    esac
   cat <<\_ACEOF
 
@@ -1294,6 +1327,11 @@ Optional Packages:
   --without-v4l           Exclude using v4l (video4linux) subsystem.
                           Makes Motion so it only supports network cameras.
 
+  --without-sdl           Compile without sdl support to get stream in SDL window.
+
+  --with-jpeg-turbo=DIR   Specify the prefix for the install path for
+                          jpeg-turbo for optimized jpeg handling (optional).
+
   --with-jpeg-mmx=DIR     Specify the prefix for the install path for
                           jpeg-mmx for optimized jpeg handling (optional).
                           If this is not specified motion will try to find
@@ -1305,6 +1343,12 @@ Optional Packages:
                           If this is not specified motion will try to find
                           the libraries in /usr and /usr/local.
 
+  --with-ffmpeg-headers=DIR Specify the prefix for ffmpeg headers.
+
+  --with-ffmpeg-libs=libs  Specify the extra libs for ffmpeg
+
+  --without-sqlite3       Disable sqlite3 support in motion.
+
   --without-mysql         Disable mysql support in motion.
 
   --with-mysql-lib=DIR        Normally, configure will scan all possible default
@@ -1413,10 +1457,10 @@ fi
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-motion configure 3.2.12
-generated by GNU Autoconf 2.65
+motion configure 3.2.12-4ppa01
+generated by GNU Autoconf 2.69
 
-Copyright (C) 2009 Free Software Foundation, Inc.
+Copyright (C) 2012 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
 _ACEOF
@@ -1460,57 +1504,11 @@ sed 's/^/| /' conftest.$ac_ext >&5
 
 	ac_retval=1
 fi
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
   as_fn_set_status $ac_retval
 
 } # ac_fn_c_try_compile
 
-# ac_fn_c_try_link LINENO
-# -----------------------
-# Try to link conftest.$ac_ext, and return whether this succeeded.
-ac_fn_c_try_link ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  rm -f conftest.$ac_objext conftest$ac_exeext
-  if { { ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_link") 2>conftest.err
-  ac_status=$?
-  if test -s conftest.err; then
-    grep -v '^ *+' conftest.err >conftest.er1
-    cat conftest.er1 >&5
-    mv -f conftest.er1 conftest.err
-  fi
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then :
-  ac_retval=0
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_retval=1
-fi
-  # Delete the IPA/IPO (Inter Procedural Analysis/Optimization) information
-  # created by the PGI compiler (conftest_ipa8_conftest.oo), as it would
-  # interfere with the next link command; also delete a directory that is
-  # left behind by Apple's compiler.  We do this before executing the actions.
-  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
-  as_fn_set_status $ac_retval
-
-} # ac_fn_c_try_link
-
 # ac_fn_c_try_cpp LINENO
 # ----------------------
 # Try to preprocess conftest.$ac_ext, and return whether this succeeded.
@@ -1532,7 +1530,7 @@ $as_echo "$ac_try_echo"; } >&5
     mv -f conftest.er1 conftest.err
   fi
   $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } >/dev/null && {
+  test $ac_status = 0; } > conftest.i && {
 	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
 	 test ! -s conftest.err
        }; then :
@@ -1543,53 +1541,11 @@ sed 's/^/| /' conftest.$ac_ext >&5
 
     ac_retval=1
 fi
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
   as_fn_set_status $ac_retval
 
 } # ac_fn_c_try_cpp
 
-# ac_fn_c_try_run LINENO
-# ----------------------
-# Try to link conftest.$ac_ext, and return whether this succeeded. Assumes
-# that executables *can* be run.
-ac_fn_c_try_run ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  if { { ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && { ac_try='./conftest$ac_exeext'
-  { { case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; }; then :
-  ac_retval=0
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-       $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-       ac_retval=$ac_status
-fi
-  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
-  as_fn_set_status $ac_retval
-
-} # ac_fn_c_try_run
-
 # ac_fn_c_check_header_mongrel LINENO HEADER VAR INCLUDES
 # -------------------------------------------------------
 # Tests whether HEADER exists, giving a warning if it cannot be compiled using
@@ -1598,10 +1554,10 @@ fi
 ac_fn_c_check_header_mongrel ()
 {
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+  if eval \${$3+:} false; then :
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
 $as_echo_n "checking for $2... " >&6; }
-if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval \${$3+:} false; then :
   $as_echo_n "(cached) " >&6
 fi
 eval ac_res=\$$3
@@ -1637,7 +1593,7 @@ if ac_fn_c_try_cpp "$LINENO"; then :
 else
   ac_header_preproc=no
 fi
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.err conftest.i conftest.$ac_ext
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_preproc" >&5
 $as_echo "$ac_header_preproc" >&6; }
 
@@ -1664,7 +1620,7 @@ $as_echo "$as_me: WARNING: $2: proceedin
 esac
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
 $as_echo_n "checking for $2... " >&6; }
-if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval \${$3+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   eval "$3=\$ac_header_compiler"
@@ -1673,10 +1629,52 @@ eval ac_res=\$$3
 	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
 fi
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
 
 } # ac_fn_c_check_header_mongrel
 
+# ac_fn_c_try_run LINENO
+# ----------------------
+# Try to link conftest.$ac_ext, and return whether this succeeded. Assumes
+# that executables *can* be run.
+ac_fn_c_try_run ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  if { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && { ac_try='./conftest$ac_exeext'
+  { { case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: program exited with status $ac_status" >&5
+       $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+       ac_retval=$ac_status
+fi
+  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  as_fn_set_status $ac_retval
+
+} # ac_fn_c_try_run
+
 # ac_fn_c_check_header_compile LINENO HEADER VAR INCLUDES
 # -------------------------------------------------------
 # Tests whether HEADER exists and can be compiled using the include files in
@@ -1686,7 +1684,7 @@ ac_fn_c_check_header_compile ()
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
 $as_echo_n "checking for $2... " >&6; }
-if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval \${$3+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -1704,10 +1702,56 @@ fi
 eval ac_res=\$$3
 	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
 
 } # ac_fn_c_check_header_compile
 
+# ac_fn_c_try_link LINENO
+# -----------------------
+# Try to link conftest.$ac_ext, and return whether this succeeded.
+ac_fn_c_try_link ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  rm -f conftest.$ac_objext conftest$ac_exeext
+  if { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 test -x conftest$ac_exeext
+       }; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_retval=1
+fi
+  # Delete the IPA/IPO (Inter Procedural Analysis/Optimization) information
+  # created by the PGI compiler (conftest_ipa8_conftest.oo), as it would
+  # interfere with the next link command; also delete a directory that is
+  # left behind by Apple's compiler.  We do this before executing the actions.
+  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  as_fn_set_status $ac_retval
+
+} # ac_fn_c_try_link
+
 # ac_fn_c_check_func LINENO FUNC VAR
 # ----------------------------------
 # Tests whether FUNC exists, setting the cache variable VAR accordingly
@@ -1716,7 +1760,7 @@ ac_fn_c_check_func ()
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
 $as_echo_n "checking for $2... " >&6; }
-if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval \${$3+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -1771,7 +1815,7 @@ fi
 eval ac_res=\$$3
 	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
 
 } # ac_fn_c_check_func
 
@@ -1784,7 +1828,7 @@ ac_fn_c_check_type ()
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
 $as_echo_n "checking for $2... " >&6; }
-if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval \${$3+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   eval "$3=no"
@@ -1825,7 +1869,7 @@ fi
 eval ac_res=\$$3
 	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
 
 } # ac_fn_c_check_type
 
@@ -1846,7 +1890,8 @@ int
 main ()
 {
 static int test_array [1 - 2 * !(($2) >= 0)];
-test_array [0] = 0
+test_array [0] = 0;
+return test_array [0];
 
   ;
   return 0;
@@ -1862,7 +1907,8 @@ int
 main ()
 {
 static int test_array [1 - 2 * !(($2) <= $ac_mid)];
-test_array [0] = 0
+test_array [0] = 0;
+return test_array [0];
 
   ;
   return 0;
@@ -1888,7 +1934,8 @@ int
 main ()
 {
 static int test_array [1 - 2 * !(($2) < 0)];
-test_array [0] = 0
+test_array [0] = 0;
+return test_array [0];
 
   ;
   return 0;
@@ -1904,7 +1951,8 @@ int
 main ()
 {
 static int test_array [1 - 2 * !(($2) >= $ac_mid)];
-test_array [0] = 0
+test_array [0] = 0;
+return test_array [0];
 
   ;
   return 0;
@@ -1938,7 +1986,8 @@ int
 main ()
 {
 static int test_array [1 - 2 * !(($2) <= $ac_mid)];
-test_array [0] = 0
+test_array [0] = 0;
+return test_array [0];
 
   ;
   return 0;
@@ -2002,7 +2051,7 @@ rm -f core *.core core.conftest.* gmon.o
 rm -f conftest.val
 
   fi
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
   as_fn_set_status $ac_retval
 
 } # ac_fn_c_compute_int
@@ -2010,8 +2059,8 @@ cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by motion $as_me 3.2.12, which was
-generated by GNU Autoconf 2.65.  Invocation command line was
+It was created by motion $as_me 3.2.12-4ppa01, which was
+generated by GNU Autoconf 2.69.  Invocation command line was
 
   $ $0 $@
 
@@ -2121,11 +2170,9 @@ trap 'exit_status=$?
   {
     echo
 
-    cat <<\_ASBOX
-## ---------------- ##
+    $as_echo "## ---------------- ##
 ## Cache variables. ##
-## ---------------- ##
-_ASBOX
+## ---------------- ##"
     echo
     # The following way of writing the cache mishandles newlines in values,
 (
@@ -2159,11 +2206,9 @@ $as_echo "$as_me: WARNING: cache variabl
 )
     echo
 
-    cat <<\_ASBOX
-## ----------------- ##
+    $as_echo "## ----------------- ##
 ## Output variables. ##
-## ----------------- ##
-_ASBOX
+## ----------------- ##"
     echo
     for ac_var in $ac_subst_vars
     do
@@ -2176,11 +2221,9 @@ _ASBOX
     echo
 
     if test -n "$ac_subst_files"; then
-      cat <<\_ASBOX
-## ------------------- ##
+      $as_echo "## ------------------- ##
 ## File substitutions. ##
-## ------------------- ##
-_ASBOX
+## ------------------- ##"
       echo
       for ac_var in $ac_subst_files
       do
@@ -2194,11 +2237,9 @@ _ASBOX
     fi
 
     if test -s confdefs.h; then
-      cat <<\_ASBOX
-## ----------- ##
+      $as_echo "## ----------- ##
 ## confdefs.h. ##
-## ----------- ##
-_ASBOX
+## ----------- ##"
       echo
       cat confdefs.h
       echo
@@ -2253,7 +2294,12 @@ _ACEOF
 ac_site_file1=NONE
 ac_site_file2=NONE
 if test -n "$CONFIG_SITE"; then
-  ac_site_file1=$CONFIG_SITE
+  # We do not want a PATH search for config.site.
+  case $CONFIG_SITE in #((
+    -*)  ac_site_file1=./$CONFIG_SITE;;
+    */*) ac_site_file1=$CONFIG_SITE;;
+    *)   ac_site_file1=./$CONFIG_SITE;;
+  esac
 elif test "x$prefix" != xNONE; then
   ac_site_file1=$prefix/share/config.site
   ac_site_file2=$prefix/etc/config.site
@@ -2268,7 +2314,11 @@ do
     { $as_echo "$as_me:${as_lineno-$LINENO}: loading site script $ac_site_file" >&5
 $as_echo "$as_me: loading site script $ac_site_file" >&6;}
     sed 's/^/| /' "$ac_site_file" >&5
-    . "$ac_site_file"
+    . "$ac_site_file" \
+      || { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "failed to load site script $ac_site_file
+See \`config.log' for more details" "$LINENO" 5; }
   fi
 done
 
@@ -2344,7 +2394,7 @@ if $ac_cache_corrupted; then
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
   { $as_echo "$as_me:${as_lineno-$LINENO}: error: changes in the environment can compromise the build" >&5
 $as_echo "$as_me: error: changes in the environment can compromise the build" >&2;}
-  as_fn_error "run \`make distclean' and/or \`rm $cache_file' and start over" "$LINENO" 5
+  as_fn_error $? "run \`make distclean' and/or \`rm $cache_file' and start over" "$LINENO" 5
 fi
 ## -------------------- ##
 ## Main body of script. ##
@@ -2357,134 +2407,47 @@ ac_link='$CC -o conftest$ac_exeext $CFLA
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 
-
-ac_config_headers="$ac_config_headers config.h"
-
-
-THREAD_CFLAGS=""
-THREAD_CHECK="/usr/include/pthread.h"
-
-Darwin=""
-FreeBSD=""
-
-LINUXTHREADS="no"
-
-# Check whether --with-linuxthreads was given.
-if test "${with_linuxthreads+set}" = set; then :
-  withval=$with_linuxthreads; LINUXTHREADS="$withval"
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}gcc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="${ac_tool_prefix}gcc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
 
 fi
-
-
-PWCBSD="no"
-
-# Check whether --with-pwcbsd was given.
-if test "${with_pwcbsd+set}" = set; then :
-  withval=$with_pwcbsd; PWCBSD="$withval"
-
-fi
-
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Darwin" >&5
-$as_echo_n "checking for Darwin... " >&6; }
-Darwin=`uname -a | grep "Darwin"`
-
-if test "${Darwin}" = ""; then
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for *BSD" >&5
-$as_echo_n "checking for *BSD... " >&6; }
-
-	FreeBSD=`uname -a | grep "BSD"`
-	if test "${FreeBSD}" = ""; then
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-		VIDEO="video.o video2.o video_common.o"
-	else
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-		if test "${LINUXTHREADS}" = "no"; then
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: checking Linuxthreads" >&5
-$as_echo_n "checking Linuxthreads... " >&6; }
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: skipping" >&5
-$as_echo "skipping" >&6; }
-		else
-			THREAD_CHECK="/usr/local/include/pthread/linuxthreads/pthread.h"
-			THREAD_LIB_CHECK="/usr/local/lib/liblthread.so"
-		fi
-
-		if test "${PWCBSD}" != "no"; then
-			VIDEO="video.o video2.o video_common.o"
-			TEMP_CFLAGS="${CFLAGS} -I/usr/local/include -DPWCBSD"
-		else
-			VIDEO="video_freebsd.o"
-			TEMP_CFLAGS="${CFLAGS} -I/usr/local/include"
-		fi
-
-		TEMP_LDFLAGS="${LDFLAGS} -L/usr/local/lib"
-		TEMP_LIBS="-L/usr/local/lib"
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: Build with PWCBSD support $PWCBSD" >&5
-$as_echo "Build with PWCBSD support $PWCBSD" >&6; }
-
-	fi
-else
-	TEMP_CFLAGS="${CFLAGS} -I/sw/include"
-	TEMP_LDFLAGS="${LDFLAGS} -L/sw/lib"
-	TEMP_LIBS="-L/sw/lib"
-	VIDEO="video_freebsd.o"
-	FINK_LIB="-L/sw/lib"
-	Darwin="yes"
-	V4L="no"
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $Darwin" >&5
-$as_echo "$Darwin" >&6; }
-fi
-
-
-
-
-# Checks for programs.
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
-set dummy ${ac_tool_prefix}gcc; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_CC+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_CC="${ac_tool_prefix}gcc"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-CC=$ac_cv_prog_CC
-if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
 
 
 fi
@@ -2494,7 +2457,7 @@ if test -z "$ac_cv_prog_CC"; then
 set dummy gcc; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_CC+set}" = set; then :
+if ${ac_cv_prog_ac_ct_CC+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_CC"; then
@@ -2506,7 +2469,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_CC="gcc"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -2547,7 +2510,7 @@ if test -z "$CC"; then
 set dummy ${ac_tool_prefix}cc; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_CC+set}" = set; then :
+if ${ac_cv_prog_CC+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$CC"; then
@@ -2559,7 +2522,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_CC="${ac_tool_prefix}cc"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -2587,7 +2550,7 @@ if test -z "$CC"; then
 set dummy cc; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_CC+set}" = set; then :
+if ${ac_cv_prog_CC+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$CC"; then
@@ -2600,7 +2563,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
        ac_prog_rejected=yes
        continue
@@ -2646,7 +2609,7 @@ if test -z "$CC"; then
 set dummy $ac_tool_prefix$ac_prog; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_CC+set}" = set; then :
+if ${ac_cv_prog_CC+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$CC"; then
@@ -2658,7 +2621,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -2690,7 +2653,7 @@ do
 set dummy $ac_prog; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_CC+set}" = set; then :
+if ${ac_cv_prog_ac_ct_CC+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_CC"; then
@@ -2702,7 +2665,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_CC="$ac_prog"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -2744,8 +2707,8 @@ fi
 
 test -z "$CC" && { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "no acceptable C compiler found in \$PATH
-See \`config.log' for more details." "$LINENO" 5; }
+as_fn_error $? "no acceptable C compiler found in \$PATH
+See \`config.log' for more details" "$LINENO" 5; }
 
 # Provide some information about the compiler.
 $as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler version" >&5
@@ -2859,9 +2822,8 @@ sed 's/^/| /' conftest.$ac_ext >&5
 
 { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ as_fn_set_status 77
-as_fn_error "C compiler cannot create executables
-See \`config.log' for more details." "$LINENO" 5; }; }
+as_fn_error 77 "C compiler cannot create executables
+See \`config.log' for more details" "$LINENO" 5; }
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
@@ -2903,8 +2865,8 @@ done
 else
   { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "cannot compute suffix of executables: cannot compile and link
-See \`config.log' for more details." "$LINENO" 5; }
+as_fn_error $? "cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details" "$LINENO" 5; }
 fi
 rm -f conftest conftest$ac_cv_exeext
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_exeext" >&5
@@ -2961,9 +2923,9 @@ $as_echo "$ac_try_echo"; } >&5
     else
 	{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "cannot run C compiled programs.
+as_fn_error $? "cannot run C compiled programs.
 If you meant to cross compile, use \`--host'.
-See \`config.log' for more details." "$LINENO" 5; }
+See \`config.log' for more details" "$LINENO" 5; }
     fi
   fi
 fi
@@ -2974,7 +2936,7 @@ rm -f conftest.$ac_ext conftest$ac_cv_ex
 ac_clean_files=$ac_clean_files_save
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of object files" >&5
 $as_echo_n "checking for suffix of object files... " >&6; }
-if test "${ac_cv_objext+set}" = set; then :
+if ${ac_cv_objext+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -3014,8 +2976,8 @@ sed 's/^/| /' conftest.$ac_ext >&5
 
 { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "cannot compute suffix of object files: cannot compile
-See \`config.log' for more details." "$LINENO" 5; }
+as_fn_error $? "cannot compute suffix of object files: cannot compile
+See \`config.log' for more details" "$LINENO" 5; }
 fi
 rm -f conftest.$ac_cv_objext conftest.$ac_ext
 fi
@@ -3025,7 +2987,7 @@ OBJEXT=$ac_cv_objext
 ac_objext=$OBJEXT
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C compiler" >&5
 $as_echo_n "checking whether we are using the GNU C compiler... " >&6; }
-if test "${ac_cv_c_compiler_gnu+set}" = set; then :
+if ${ac_cv_c_compiler_gnu+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -3062,7 +3024,7 @@ ac_test_CFLAGS=${CFLAGS+set}
 ac_save_CFLAGS=$CFLAGS
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
 $as_echo_n "checking whether $CC accepts -g... " >&6; }
-if test "${ac_cv_prog_cc_g+set}" = set; then :
+if ${ac_cv_prog_cc_g+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_save_c_werror_flag=$ac_c_werror_flag
@@ -3140,7 +3102,7 @@ else
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $CC option to accept ISO C89" >&5
 $as_echo_n "checking for $CC option to accept ISO C89... " >&6; }
-if test "${ac_cv_prog_cc_c89+set}" = set; then :
+if ${ac_cv_prog_cc_c89+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_cv_prog_cc_c89=no
@@ -3149,8 +3111,7 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_
 /* end confdefs.h.  */
 #include <stdarg.h>
 #include <stdio.h>
-#include <sys/types.h>
-#include <sys/stat.h>
+struct stat;
 /* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
 struct buf { int x; };
 FILE * (*rcsopen) (struct buf *, struct stat *, int);
@@ -3236,64 +3197,1688 @@ ac_link='$CC -o conftest$ac_exeext $CFLA
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 
-TEMP_LIBS="-lm ${TEMP_LIBS}"
-TEMP_CFLAGS="${TEMP_CFLAGS} ${CFLAGS}"
-TEMP_LDFLAGS="${TEMP_LDFLAGS} ${LDFLAGS}"
-
-
-if test "${FreeBSD}" != "" && test "${PWCBSD}" = "no"; then
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking bktr headers in /usr/include/dev/bktr" >&5
-$as_echo_n "checking bktr headers in /usr/include/dev/bktr... " >&6; }
-
-	if test -f /usr/include/dev/bktr/ioctl_meteor.h && test -f /usr/include/dev/bktr/ioctl_bt848.h; then
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-	else
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-		TEMP_CFLAGS="${TEMP_CFLAGS} -DOLD_BKTR"
-	fi
-#
-# Check to Exclude BKTR
-#
-BKTR="yes"
-
-# Check whether --with-bktr was given.
-if test "${with_bktr+set}" = set; then :
-  withval=$with_bktr; BKTR="$withval"
-
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to run the C preprocessor" >&5
+$as_echo_n "checking how to run the C preprocessor... " >&6; }
+# On Suns, sometimes $CPP names a directory.
+if test -n "$CPP" && test -d "$CPP"; then
+  CPP=
 fi
-
-
-
-	if test "${BKTR}" = "no"; then
-        	TEMP_CFLAGS="${TEMP_CFLAGS} -DWITHOUT_V4L"
-	fi
-
+if test -z "$CPP"; then
+  if ${ac_cv_prog_CPP+:} false; then :
+  $as_echo_n "(cached) " >&6
 else
+      # Double quotes because CPP needs to be expanded
+    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
+    do
+      ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
 
-#
-# Check to Exclude V4L
-#
-V4L="yes"
+else
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.i conftest.$ac_ext
 
-# Check whether --with-v4l was given.
-if test "${with_v4l+set}" = set; then :
-  withval=$with_v4l; V4L="$withval"
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+  # Broken: success on invalid input.
+continue
+else
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.i conftest.$ac_ext
 
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.i conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then :
+  break
 fi
 
+    done
+    ac_cv_prog_CPP=$CPP
 
 fi
+  CPP=$ac_cv_prog_CPP
+else
+  ac_cv_prog_CPP=$CPP
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $CPP" >&5
+$as_echo "$CPP" >&6; }
+ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
 
+else
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.i conftest.$ac_ext
 
-if test "${V4L}" = "no"; then
-	TEMP_CFLAGS="${TEMP_CFLAGS} -DWITHOUT_V4L"
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+  # Broken: success on invalid input.
+continue
+else
+  # Passes both tests.
+ac_preproc_ok=:
+break
 fi
+rm -f conftest.err conftest.i conftest.$ac_ext
 
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.i conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then :
 
-if test "${FreeBSD}" != "" && test "${LINUXTHREADS}" != "no" ; then
+else
+  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details" "$LINENO" 5; }
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for grep that handles long lines and -e" >&5
+$as_echo_n "checking for grep that handles long lines and -e... " >&6; }
+if ${ac_cv_path_GREP+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -z "$GREP"; then
+  ac_path_GREP_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in grep ggrep; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
+      as_fn_executable_p "$ac_path_GREP" || continue
+# Check for GNU ac_path_GREP and select it if it is found.
+  # Check for GNU $ac_path_GREP
+case `"$ac_path_GREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_GREP="$ac_path_GREP" ac_path_GREP_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo 'GREP' >> "conftest.nl"
+    "$ac_path_GREP" -e 'GREP$' -e '-(cannot match)-' < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
+    if test $ac_count -gt ${ac_path_GREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_GREP="$ac_path_GREP"
+      ac_path_GREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_GREP_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_GREP"; then
+    as_fn_error $? "no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+  fi
+else
+  ac_cv_path_GREP=$GREP
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_GREP" >&5
+$as_echo "$ac_cv_path_GREP" >&6; }
+ GREP="$ac_cv_path_GREP"
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for egrep" >&5
+$as_echo_n "checking for egrep... " >&6; }
+if ${ac_cv_path_EGREP+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if echo a | $GREP -E '(a|b)' >/dev/null 2>&1
+   then ac_cv_path_EGREP="$GREP -E"
+   else
+     if test -z "$EGREP"; then
+  ac_path_EGREP_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in egrep; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
+      as_fn_executable_p "$ac_path_EGREP" || continue
+# Check for GNU ac_path_EGREP and select it if it is found.
+  # Check for GNU $ac_path_EGREP
+case `"$ac_path_EGREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_EGREP="$ac_path_EGREP" ac_path_EGREP_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo 'EGREP' >> "conftest.nl"
+    "$ac_path_EGREP" 'EGREP$' < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
+    if test $ac_count -gt ${ac_path_EGREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_EGREP="$ac_path_EGREP"
+      ac_path_EGREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_EGREP_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_EGREP"; then
+    as_fn_error $? "no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+  fi
+else
+  ac_cv_path_EGREP=$EGREP
+fi
+
+   fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_EGREP" >&5
+$as_echo "$ac_cv_path_EGREP" >&6; }
+ EGREP="$ac_cv_path_EGREP"
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ANSI C header files" >&5
+$as_echo_n "checking for ANSI C header files... " >&6; }
+if ${ac_cv_header_stdc+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <float.h>
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_header_stdc=yes
+else
+  ac_cv_header_stdc=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+if test $ac_cv_header_stdc = yes; then
+  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <string.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "memchr" >/dev/null 2>&1; then :
+
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdlib.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "free" >/dev/null 2>&1; then :
+
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
+  if test "$cross_compiling" = yes; then :
+  :
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ctype.h>
+#include <stdlib.h>
+#if ((' ' & 0x0FF) == 0x020)
+# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
+# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
+#else
+# define ISLOWER(c) \
+		   (('a' <= (c) && (c) <= 'i') \
+		     || ('j' <= (c) && (c) <= 'r') \
+		     || ('s' <= (c) && (c) <= 'z'))
+# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
+#endif
+
+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 256; i++)
+    if (XOR (islower (i), ISLOWER (i))
+	|| toupper (i) != TOUPPER (i))
+      return 2;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+
+else
+  ac_cv_header_stdc=no
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_header_stdc" >&5
+$as_echo "$ac_cv_header_stdc" >&6; }
+if test $ac_cv_header_stdc = yes; then
+
+$as_echo "#define STDC_HEADERS 1" >>confdefs.h
+
+fi
+
+# On IRIX 5.3, sys/types and inttypes.h are conflicting.
+for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
+		  inttypes.h stdint.h unistd.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default
+"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+  ac_fn_c_check_header_mongrel "$LINENO" "minix/config.h" "ac_cv_header_minix_config_h" "$ac_includes_default"
+if test "x$ac_cv_header_minix_config_h" = xyes; then :
+  MINIX=yes
+else
+  MINIX=
+fi
+
+
+  if test "$MINIX" = yes; then
+
+$as_echo "#define _POSIX_SOURCE 1" >>confdefs.h
+
+
+$as_echo "#define _POSIX_1_SOURCE 2" >>confdefs.h
+
+
+$as_echo "#define _MINIX 1" >>confdefs.h
+
+  fi
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether it is safe to define __EXTENSIONS__" >&5
+$as_echo_n "checking whether it is safe to define __EXTENSIONS__... " >&6; }
+if ${ac_cv_safe_to_define___extensions__+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#         define __EXTENSIONS__ 1
+          $ac_includes_default
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_safe_to_define___extensions__=yes
+else
+  ac_cv_safe_to_define___extensions__=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_safe_to_define___extensions__" >&5
+$as_echo "$ac_cv_safe_to_define___extensions__" >&6; }
+  test $ac_cv_safe_to_define___extensions__ = yes &&
+    $as_echo "#define __EXTENSIONS__ 1" >>confdefs.h
+
+  $as_echo "#define _ALL_SOURCE 1" >>confdefs.h
+
+  $as_echo "#define _GNU_SOURCE 1" >>confdefs.h
+
+  $as_echo "#define _POSIX_PTHREAD_SEMANTICS 1" >>confdefs.h
+
+  $as_echo "#define _TANDEM_SOURCE 1" >>confdefs.h
+
+
+
+
+ac_config_headers="$ac_config_headers config.h"
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}gcc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="${ac_tool_prefix}gcc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "gcc", so it can be a program name with args.
+set dummy gcc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_ac_ct_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="gcc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
+$as_echo "$ac_ct_CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+else
+  CC="$ac_cv_prog_CC"
+fi
+
+if test -z "$CC"; then
+          if test -n "$ac_tool_prefix"; then
+    # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}cc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="${ac_tool_prefix}cc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  fi
+fi
+if test -z "$CC"; then
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  ac_prog_rejected=no
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
+       ac_prog_rejected=yes
+       continue
+     fi
+    ac_cv_prog_CC="cc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# != 0; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
+  fi
+fi
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  for ac_prog in cl.exe
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+    test -n "$CC" && break
+  done
+fi
+if test -z "$CC"; then
+  ac_ct_CC=$CC
+  for ac_prog in cl.exe
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_ac_ct_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
+$as_echo "$ac_ct_CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$ac_ct_CC" && break
+done
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+fi
+
+fi
+
+
+test -z "$CC" && { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "no acceptable C compiler found in \$PATH
+See \`config.log' for more details" "$LINENO" 5; }
+
+# Provide some information about the compiler.
+$as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler version" >&5
+set X $ac_compile
+ac_compiler=$2
+for ac_option in --version -v -V -qversion; do
+  { { ac_try="$ac_compiler $ac_option >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compiler $ac_option >&5") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    sed '10a\
+... rest of stderr output deleted ...
+         10q' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+  fi
+  rm -f conftest.er1 conftest.err
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+done
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C compiler" >&5
+$as_echo_n "checking whether we are using the GNU C compiler... " >&6; }
+if ${ac_cv_c_compiler_gnu+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_compiler_gnu=yes
+else
+  ac_compiler_gnu=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_c_compiler_gnu=$ac_compiler_gnu
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_compiler_gnu" >&5
+$as_echo "$ac_cv_c_compiler_gnu" >&6; }
+if test $ac_compiler_gnu = yes; then
+  GCC=yes
+else
+  GCC=
+fi
+ac_test_CFLAGS=${CFLAGS+set}
+ac_save_CFLAGS=$CFLAGS
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
+$as_echo_n "checking whether $CC accepts -g... " >&6; }
+if ${ac_cv_prog_cc_g+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_save_c_werror_flag=$ac_c_werror_flag
+   ac_c_werror_flag=yes
+   ac_cv_prog_cc_g=no
+   CFLAGS="-g"
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_g=yes
+else
+  CFLAGS=""
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+
+else
+  ac_c_werror_flag=$ac_save_c_werror_flag
+	 CFLAGS="-g"
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_g=yes
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+   ac_c_werror_flag=$ac_save_c_werror_flag
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_g" >&5
+$as_echo "$ac_cv_prog_cc_g" >&6; }
+if test "$ac_test_CFLAGS" = set; then
+  CFLAGS=$ac_save_CFLAGS
+elif test $ac_cv_prog_cc_g = yes; then
+  if test "$GCC" = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-g"
+  fi
+else
+  if test "$GCC" = yes; then
+    CFLAGS="-O2"
+  else
+    CFLAGS=
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $CC option to accept ISO C89" >&5
+$as_echo_n "checking for $CC option to accept ISO C89... " >&6; }
+if ${ac_cv_prog_cc_c89+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_prog_cc_c89=no
+ac_save_CC=$CC
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdarg.h>
+#include <stdio.h>
+struct stat;
+/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
+struct buf { int x; };
+FILE * (*rcsopen) (struct buf *, struct stat *, int);
+static char *e (p, i)
+     char **p;
+     int i;
+{
+  return p[i];
+}
+static char *f (char * (*g) (char **, int), char **p, ...)
+{
+  char *s;
+  va_list v;
+  va_start (v,p);
+  s = g (p, va_arg (v,int));
+  va_end (v);
+  return s;
+}
+
+/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
+   function prototypes and stuff, but not '\xHH' hex character constants.
+   These don't provoke an error unfortunately, instead are silently treated
+   as 'x'.  The following induces an error, until -std is added to get
+   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
+   array size at least.  It's necessary to write '\x00'==0 to get something
+   that's true only with -std.  */
+int osf4_cc_array ['\x00' == 0 ? 1 : -1];
+
+/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters
+   inside strings and character constants.  */
+#define FOO(x) 'x'
+int xlc6_cc_array[FOO(a) == 'x' ? 1 : -1];
+
+int test (int i, double x);
+struct s1 {int (*f) (int a);};
+struct s2 {int (*f) (double a);};
+int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
+int argc;
+char **argv;
+int
+main ()
+{
+return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
+  ;
+  return 0;
+}
+_ACEOF
+for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std \
+	-Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
+do
+  CC="$ac_save_CC $ac_arg"
+  if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_c89=$ac_arg
+fi
+rm -f core conftest.err conftest.$ac_objext
+  test "x$ac_cv_prog_cc_c89" != "xno" && break
+done
+rm -f conftest.$ac_ext
+CC=$ac_save_CC
+
+fi
+# AC_CACHE_VAL
+case "x$ac_cv_prog_cc_c89" in
+  x)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
+$as_echo "none needed" >&6; } ;;
+  xno)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
+$as_echo "unsupported" >&6; } ;;
+  *)
+    CC="$CC $ac_cv_prog_cc_c89"
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c89" >&5
+$as_echo "$ac_cv_prog_cc_c89" >&6; } ;;
+esac
+if test "x$ac_cv_prog_cc_c89" != xno; then :
+
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+
+THREAD_CFLAGS=""
+THREAD_CHECK="/usr/include/pthread.h"
+
+Darwin=""
+FreeBSD=""
+
+LINUXTHREADS="no"
+
+# Check whether --with-linuxthreads was given.
+if test "${with_linuxthreads+set}" = set; then :
+  withval=$with_linuxthreads; LINUXTHREADS="$withval"
+
+fi
+
+
+PWCBSD="no"
+
+# Check whether --with-pwcbsd was given.
+if test "${with_pwcbsd+set}" = set; then :
+  withval=$with_pwcbsd; PWCBSD="$withval"
+
+fi
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Darwin" >&5
+$as_echo_n "checking for Darwin... " >&6; }
+Darwin=`uname -a | grep "Darwin"`
+
+if test "${Darwin}" = ""; then
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for *BSD" >&5
+$as_echo_n "checking for *BSD... " >&6; }
+
+	FreeBSD=`uname -a | grep "BSD"`
+	if test "${FreeBSD}" = ""; then
+		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+		VIDEO="video.o video2.o video_common.o"
+	else
+		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+		if test "${LINUXTHREADS}" = "no"; then
+			{ $as_echo "$as_me:${as_lineno-$LINENO}: checking Linuxthreads" >&5
+$as_echo_n "checking Linuxthreads... " >&6; }
+			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: skipping" >&5
+$as_echo "skipping" >&6; }
+		else
+			THREAD_CHECK="/usr/local/include/pthread/linuxthreads/pthread.h"
+			THREAD_LIB_CHECK="/usr/local/lib/liblthread.so"
+		fi
+
+		if test "${PWCBSD}" != "no"; then
+			VIDEO="video.o video2.o video_common.o"
+			TEMP_CFLAGS="${CFLAGS} -I/usr/local/include -DPWCBSD"
+		else
+			VIDEO="video_freebsd.o"
+			TEMP_CFLAGS="${CFLAGS} -I/usr/local/include"
+		fi
+
+		TEMP_LDFLAGS="${LDFLAGS} -L/usr/local/lib"
+		TEMP_LIBS="-L/usr/local/lib"
+		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: Build with PWCBSD support $PWCBSD" >&5
+$as_echo "Build with PWCBSD support $PWCBSD" >&6; }
+
+	fi
+else
+	TEMP_CFLAGS="${CFLAGS} -I/sw/include"
+	TEMP_LDFLAGS="${LDFLAGS} -L/sw/lib"
+	TEMP_LIBS="-L/sw/lib"
+	VIDEO="video_freebsd.o"
+	FINK_LIB="-L/sw/lib"
+	Darwin="yes"
+	V4L="no"
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $Darwin" >&5
+$as_echo "$Darwin" >&6; }
+fi
+
+
+
+
+# Checks for programs.
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}gcc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="${ac_tool_prefix}gcc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "gcc", so it can be a program name with args.
+set dummy gcc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_ac_ct_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="gcc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
+$as_echo "$ac_ct_CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+else
+  CC="$ac_cv_prog_CC"
+fi
+
+if test -z "$CC"; then
+          if test -n "$ac_tool_prefix"; then
+    # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}cc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="${ac_tool_prefix}cc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  fi
+fi
+if test -z "$CC"; then
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  ac_prog_rejected=no
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
+       ac_prog_rejected=yes
+       continue
+     fi
+    ac_cv_prog_CC="cc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# != 0; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
+  fi
+fi
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  for ac_prog in cl.exe
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+    test -n "$CC" && break
+  done
+fi
+if test -z "$CC"; then
+  ac_ct_CC=$CC
+  for ac_prog in cl.exe
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_ac_ct_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
+$as_echo "$ac_ct_CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$ac_ct_CC" && break
+done
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+fi
+
+fi
+
+
+test -z "$CC" && { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "no acceptable C compiler found in \$PATH
+See \`config.log' for more details" "$LINENO" 5; }
+
+# Provide some information about the compiler.
+$as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler version" >&5
+set X $ac_compile
+ac_compiler=$2
+for ac_option in --version -v -V -qversion; do
+  { { ac_try="$ac_compiler $ac_option >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compiler $ac_option >&5") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    sed '10a\
+... rest of stderr output deleted ...
+         10q' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+  fi
+  rm -f conftest.er1 conftest.err
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+done
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C compiler" >&5
+$as_echo_n "checking whether we are using the GNU C compiler... " >&6; }
+if ${ac_cv_c_compiler_gnu+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_compiler_gnu=yes
+else
+  ac_compiler_gnu=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_c_compiler_gnu=$ac_compiler_gnu
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_compiler_gnu" >&5
+$as_echo "$ac_cv_c_compiler_gnu" >&6; }
+if test $ac_compiler_gnu = yes; then
+  GCC=yes
+else
+  GCC=
+fi
+ac_test_CFLAGS=${CFLAGS+set}
+ac_save_CFLAGS=$CFLAGS
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
+$as_echo_n "checking whether $CC accepts -g... " >&6; }
+if ${ac_cv_prog_cc_g+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_save_c_werror_flag=$ac_c_werror_flag
+   ac_c_werror_flag=yes
+   ac_cv_prog_cc_g=no
+   CFLAGS="-g"
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_g=yes
+else
+  CFLAGS=""
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+
+else
+  ac_c_werror_flag=$ac_save_c_werror_flag
+	 CFLAGS="-g"
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_g=yes
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+   ac_c_werror_flag=$ac_save_c_werror_flag
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_g" >&5
+$as_echo "$ac_cv_prog_cc_g" >&6; }
+if test "$ac_test_CFLAGS" = set; then
+  CFLAGS=$ac_save_CFLAGS
+elif test $ac_cv_prog_cc_g = yes; then
+  if test "$GCC" = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-g"
+  fi
+else
+  if test "$GCC" = yes; then
+    CFLAGS="-O2"
+  else
+    CFLAGS=
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $CC option to accept ISO C89" >&5
+$as_echo_n "checking for $CC option to accept ISO C89... " >&6; }
+if ${ac_cv_prog_cc_c89+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_prog_cc_c89=no
+ac_save_CC=$CC
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdarg.h>
+#include <stdio.h>
+struct stat;
+/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
+struct buf { int x; };
+FILE * (*rcsopen) (struct buf *, struct stat *, int);
+static char *e (p, i)
+     char **p;
+     int i;
+{
+  return p[i];
+}
+static char *f (char * (*g) (char **, int), char **p, ...)
+{
+  char *s;
+  va_list v;
+  va_start (v,p);
+  s = g (p, va_arg (v,int));
+  va_end (v);
+  return s;
+}
+
+/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
+   function prototypes and stuff, but not '\xHH' hex character constants.
+   These don't provoke an error unfortunately, instead are silently treated
+   as 'x'.  The following induces an error, until -std is added to get
+   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
+   array size at least.  It's necessary to write '\x00'==0 to get something
+   that's true only with -std.  */
+int osf4_cc_array ['\x00' == 0 ? 1 : -1];
+
+/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters
+   inside strings and character constants.  */
+#define FOO(x) 'x'
+int xlc6_cc_array[FOO(a) == 'x' ? 1 : -1];
+
+int test (int i, double x);
+struct s1 {int (*f) (int a);};
+struct s2 {int (*f) (double a);};
+int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
+int argc;
+char **argv;
+int
+main ()
+{
+return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
+  ;
+  return 0;
+}
+_ACEOF
+for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std \
+	-Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
+do
+  CC="$ac_save_CC $ac_arg"
+  if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_c89=$ac_arg
+fi
+rm -f core conftest.err conftest.$ac_objext
+  test "x$ac_cv_prog_cc_c89" != "xno" && break
+done
+rm -f conftest.$ac_ext
+CC=$ac_save_CC
+
+fi
+# AC_CACHE_VAL
+case "x$ac_cv_prog_cc_c89" in
+  x)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
+$as_echo "none needed" >&6; } ;;
+  xno)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
+$as_echo "unsupported" >&6; } ;;
+  *)
+    CC="$CC $ac_cv_prog_cc_c89"
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c89" >&5
+$as_echo "$ac_cv_prog_cc_c89" >&6; } ;;
+esac
+if test "x$ac_cv_prog_cc_c89" != xno; then :
+
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+TEMP_LIBS="-lm ${TEMP_LIBS}"
+TEMP_CFLAGS="${TEMP_CFLAGS} ${CFLAGS}"
+TEMP_LDFLAGS="${TEMP_LDFLAGS} ${LDFLAGS}"
+
+if test "${FreeBSD}" != "" && test "${PWCBSD}" = "no"; then
+
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking bktr headers in /usr/include/dev/bktr" >&5
+$as_echo_n "checking bktr headers in /usr/include/dev/bktr... " >&6; }
+
+	if test -f /usr/include/dev/bktr/ioctl_meteor.h && test -f /usr/include/dev/bktr/ioctl_bt848.h; then
+		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+	else
+		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+		TEMP_CFLAGS="${TEMP_CFLAGS} -DOLD_BKTR"
+	fi
+#
+# Check to Exclude BKTR
+#
+BKTR="yes"
+
+# Check whether --with-bktr was given.
+if test "${with_bktr+set}" = set; then :
+  withval=$with_bktr; BKTR="$withval"
+
+fi
+
+
+	if test "${BKTR}" = "no"; then
+		TEMP_CFLAGS="${TEMP_CFLAGS} -DWITHOUT_V4L"
+	fi
+
+else
+
+#
+# Check to Exclude V4L
+#
+V4L="yes"
+
+# Check whether --with-v4l was given.
+if test "${with_v4l+set}" = set; then :
+  withval=$with_v4l; V4L="$withval"
+
+fi
+
+
+fi
+
+
+if test "${V4L}" = "no"; then
+	TEMP_CFLAGS="${TEMP_CFLAGS} -DWITHOUT_V4L"
+fi
+
+
+if test "${FreeBSD}" != "" && test "${LINUXTHREADS}" != "no" ; then
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for linuxthreads" >&5
 $as_echo_n "checking for linuxthreads... " >&6; }
@@ -3302,10 +4887,10 @@ $as_echo_n "checking for linuxthreads...
 # Check for thread header
 #
 	if test -f "${THREAD_CHECK}"; then
-        	HEADERS_THREAD_CFLAGS="-I/usr/local/include/pthread/linuxthreads"
-        	THREADS="yes"
+		HEADERS_THREAD_CFLAGS="-I/usr/local/include/pthread/linuxthreads"
+		THREADS="yes"
 	else
-        	THREADS="no"
+		THREADS="no"
 	fi
 
 #
@@ -3315,7 +4900,7 @@ $as_echo_n "checking for linuxthreads...
 		THREADS="yes"
 		LIB_THREAD="-llthread -llgcc_r"
 	else
-        	THREADS="no"
+		THREADS="no"
 	fi
 
 # Checks for Library linuxthreads for FreeBSD
@@ -3328,26 +4913,25 @@ $as_echo_n "checking for linuxthreads...
 
 	if test "${THREADS}" = "yes"; then
 		TEMP_CFLAGS="${HEADERS_THREAD_CFLAGS} $TEMP_CFLAGS -DWITH_LINUXTREADS"
-                TEMP_LIBS="$TEMP_LIBS ${LIB_THREAD}"
-                THREAD_CFLAGS="-D_THREAD_SAFE"
-                PTHREAD_SUPPORT="yes"
-                { $as_echo "$as_me:${as_lineno-$LINENO}: result: $THREADS" >&5
+        TEMP_LIBS="$TEMP_LIBS ${LIB_THREAD}"
+        THREAD_CFLAGS="-D_THREAD_SAFE"
+        PTHREAD_SUPPORT="yes"
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: $THREADS" >&5
 $as_echo "$THREADS" >&6; }
-        else
-                PTHREAD_SUPPORT="no"
-                { $as_echo "$as_me:${as_lineno-$LINENO}: result: $THREADS" >&5
+    else
+        PTHREAD_SUPPORT="no"
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: $THREADS" >&5
 $as_echo "$THREADS" >&6; }
-                echo
-                echo "You do not have linuxthread installed"
-                echo
-        fi
+        echo
+        echo "You do not have linuxthread installed"
+        echo
+    fi
 
 elif test -f "${THREAD_CHECK}"; then
 
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking threads" >&5
 $as_echo_n "checking threads... " >&6; }
-
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <pthread.h>
@@ -3388,6 +4972,142 @@ else
 fi
 
 
+#
+# Check for sdl library
+#
+SDL_SUPPORT="no"
+
+# Check whether --with-sdl was given.
+if test "${with_sdl+set}" = set; then :
+  withval=$with_sdl;
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for sdl" >&5
+$as_echo_n "checking for sdl... " >&6; }
+if test "x$withval" = "xno"; then
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: skipped" >&5
+$as_echo "skipped" >&6; }
+else
+	if test "${FreeBSD}" != ""; then
+		CONFIG_SDL='sdl11-config'
+	else
+		CONFIG_SDL='sdl-config'
+	fi
+	if test -z "`($CONFIG_SDL --version) 2>/dev/null`" ;then
+		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+		if test "$withval" = "yes"; then
+			echo ""
+			echo "****************************************************"
+			echo "* sdl-config could not be found. Please install it *"
+			echo "* and remove the --with-sdl configure argument.    *"
+			echo "* libSDL can be found at http://www.libsdl.org     *"
+			echo "****************************************************"
+			echo ""
+		fi
+	else
+		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+		SDL_SUPPORT="yes"
+		TEMP_LIBS="$TEMP_LIBS `${CONFIG_SDL} --libs`"
+		TEMP_CFLAGS="${TEMP_CFLAGS} `${CONFIG_SDL} --cflags`"
+
+$as_echo "#define HAVE_SDL 1" >>confdefs.h
+
+		SDL_OBJ="sdl.o"
+
+	fi
+fi
+
+#
+# Check for the libjpeg-turbo library
+#
+JPEG_TURBO="no"
+JPEG_TURBO_OK="not_found"
+
+
+# Check whether --with-jpeg-turbo was given.
+if test "${with_jpeg_turbo+set}" = set; then :
+  withval=$with_jpeg_turbo; JPEG_TURBO="$withval"
+
+fi
+
+
+if test "${JPEG_TURBO}" = "no"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for libjpeg-turbo" >&5
+$as_echo_n "checking for libjpeg-turbo... " >&6; }
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: skipping" >&5
+$as_echo "skipping" >&6; }
+else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for libjpeg-turbo in -> ${JPEG_TURBO} <-" >&5
+$as_echo_n "checking for libjpeg-turbo in -> ${JPEG_TURBO} <-... " >&6; }
+    if test -f ${JPEG_TURBO}/lib/libjpeg.a ; then
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: found" >&5
+$as_echo "found" >&6; }
+        JPEG_TURBO_OK="found"
+    else
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+$as_echo "not found" >&6; }
+    fi
+fi
+
+
+if test "${JPEG_TURBO_OK}" = "found"; then
+    saved_CFLAGS="$CFLAGS"
+    saved_LIBS="$LIBS"
+    saved_LDFLAGS="$LDFLAGS"
+    LDFLAGS="-L${JPEG_TURBO}/lib"
+    CFLAGS="$CFLAGS -I${JPEG_TURBO}/include"
+    LIBS="$LIBS -L${JPEG_TURBO}/lib -ljpeg"
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for jpeg_start_compress in -ljpeg" >&5
+$as_echo_n "checking for jpeg_start_compress in -ljpeg... " >&6; }
+if ${ac_cv_lib_jpeg_jpeg_start_compress+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ljpeg  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char jpeg_start_compress ();
+int
+main ()
+{
+return jpeg_start_compress ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_jpeg_jpeg_start_compress=yes
+else
+  ac_cv_lib_jpeg_jpeg_start_compress=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_jpeg_jpeg_start_compress" >&5
+$as_echo "$ac_cv_lib_jpeg_jpeg_start_compress" >&6; }
+if test "x$ac_cv_lib_jpeg_jpeg_start_compress" = xyes; then :
+   TEMP_LIBS="$LIBS"
+          TEMP_CFLAGS="${CFLAGS}"
+          TEMP_LDFLAGS="$TEMP_LDFLAGS $LDFLAGS"
+          JPEG_SUPPORT="yes"
+fi
+
+    LIBS="$saved_LIBS"
+    CFLAGS="$saved_CFLAGS"
+    LDFLAGS="$saved_LDFLAGS"
+    JPEG_SUPPORT_TURBO="yes"
+fi
+
 
 #
 # Check for the special mmx accelerated jpeg library
@@ -3406,7 +5126,7 @@ fi
 # --without-jpeg-mmx or with-jpeg-mmx=no
 #
 
-if test "${JPEG_MMX}" = "no"; then
+if test "${JPEG_MMX}" = "no" || test x$JPEG_SUPPORT != xyes; then
         { $as_echo "$as_me:${as_lineno-$LINENO}: checking for libjpeg-mmx" >&5
 $as_echo_n "checking for libjpeg-mmx... " >&6; }
         { $as_echo "$as_me:${as_lineno-$LINENO}: result: skipping" >&5
@@ -3450,7 +5170,7 @@ if test "${JPEG_MMX_OK}" = "found"; then
 	LIBS="$LIBS -L${JPEG_MMX}"
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for jpeg_start_compress in -ljpeg-mmx" >&5
 $as_echo_n "checking for jpeg_start_compress in -ljpeg-mmx... " >&6; }
-if test "${ac_cv_lib_jpeg_mmx_jpeg_start_compress+set}" = set; then :
+if ${ac_cv_lib_jpeg_mmx_jpeg_start_compress+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -3484,7 +5204,7 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_jpeg_mmx_jpeg_start_compress" >&5
 $as_echo "$ac_cv_lib_jpeg_mmx_jpeg_start_compress" >&6; }
-if test "x$ac_cv_lib_jpeg_mmx_jpeg_start_compress" = x""yes; then :
+if test "x$ac_cv_lib_jpeg_mmx_jpeg_start_compress" = xyes; then :
    TEMP_LIBS="$TEMP_LIBS -ljpeg-mmx"
 		TEMP_CFLAGS="${TEMP_CFLAGS} -I${JPEG_MMX}"
 		JPEG_SUPPORT="yes"
@@ -3500,15 +5220,11 @@ fi
 #
 if test x$JPEG_SUPPORT != xyes ; then
   # Checks for libraries
-  LDFLAGS="$TEMP_LDFLAGS"
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for libjpeg" >&5
-$as_echo_n "checking for libjpeg... " >&6; }
-  echo
+  LDFLAGS=$TEMP_LDFLAGS
 
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for jpeg_set_defaults in -ljpeg" >&5
 $as_echo_n "checking for jpeg_set_defaults in -ljpeg... " >&6; }
-if test "${ac_cv_lib_jpeg_jpeg_set_defaults+set}" = set; then :
+if ${ac_cv_lib_jpeg_jpeg_set_defaults+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -3542,7 +5258,7 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_jpeg_jpeg_set_defaults" >&5
 $as_echo "$ac_cv_lib_jpeg_jpeg_set_defaults" >&6; }
-if test "x$ac_cv_lib_jpeg_jpeg_set_defaults" = x""yes; then :
+if test "x$ac_cv_lib_jpeg_jpeg_set_defaults" = xyes; then :
 
 		TEMP_LIBS="$TEMP_LIBS -ljpeg"
 		JPEG_SUPPORT="yes"
@@ -3562,6 +5278,7 @@ fi
 #
 # Check for libavcodec and libavformat from ffmpeg
 #
+
 FFMPEG_DIR="yes"
 FFMPEG_OK="no_found"
 FFMPEG_OBJ=""
@@ -3572,6 +5289,31 @@ if test "${with_ffmpeg+set}" = set; then
 
 fi
 
+
+#
+# ffmpeg headers custom location
+#
+FFMPEG_HEADERS_DIR="yes"
+
+# Check whether --with-ffmpeg_headers was given.
+if test "${with_ffmpeg_headers+set}" = set; then :
+  withval=$with_ffmpeg_headers; FFMPEG_HEADERS_DIR="$withval"
+
+fi
+
+
+#
+# ffmpeg custom extra libraries
+#
+FFMPEG_EXTRALIBS=" -lavformat -lavcodec -lavutil -lm -lz -lswscale "
+
+# Check whether --with-ffmpeg-libs was given.
+if test "${with_ffmpeg_libs+set}" = set; then :
+  withval=$with_ffmpeg_libs; FFMPEG_EXTRALIBS="$withval"
+
+fi
+
+
 #
 # --without-ffmpeg or with-ffmpeg=no
 #
@@ -3585,8 +5327,8 @@ $as_echo "skipping" >&6; }
 #
 else if test "${FFMPEG_DIR}" = "yes"; then
 	# AUTODETECT STATIC/SHARED LIB
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ffmpeg autodetecting" >&5
-$as_echo_n "checking for ffmpeg autodetecting... " >&6; }
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ffmpeg autodetecting libraries" >&5
+$as_echo_n "checking for ffmpeg autodetecting libraries... " >&6; }
 
 	if test -f /usr/lib64/libavcodec.a -o -f /usr/lib64/libavcodec.so && test -f /usr/lib64/libavformat.a -o -f /usr/lib64/libavformat.so ; then
 		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: found in /usr/lib64" >&5
@@ -3606,6 +5348,18 @@ $as_echo "found in /usr/local/lib" >&6;
 		FFMPEG_OK="found"
 		FFMPEG_LIB="/usr/local/lib"
 		FFMPEG_DIR="/usr/local"
+    elif test -f /usr/lib/x86_64-linux-gnu/libavcodec.a -o -f /usr/lib/x86_64-linux-gnu/libavcodec.so && test /usr/lib/x86_64-linux-gnu/libavformat.a -o -f /usr/lib/x86_64-linux-gnu/libavformat.so ; then
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: found in /usr/lib/x86_64-linux-gnu" >&5
+$as_echo "found in /usr/lib/x86_64-linux-gnu" >&6; }
+        FFMPEG_OK="found"
+        FFMPEG_LIB="/usr/lib/x86_64-linux-gnu"
+        FFMPEG_DIR="/usr"
+	elif test -f /usr/lib/i386-linux-gnu/libavcodec.a -o -f /usr/lib/i386-linux-gnu/libavcodec.so && test /usr/lib/i386-linux-gnu/libavformat.a -o -f /usr/lib/i386-linux-gnu/libavformat.so ; then
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: found in /usr/lib/i386-linux-gnu" >&5
+$as_echo "found in /usr/lib/i386-linux-gnu" >&6; }
+        FFMPEG_OK="found"
+        FFMPEG_LIB="/usr/lib/i386-linux-gnu"
+        FFMPEG_DIR="/usr"
 	else
 		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
 $as_echo "not found" >&6; }
@@ -3621,8 +5375,8 @@ $as_echo "not found" >&6; }
 		echo ""
 	fi
 else
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ffmpeg in -> ${FFMPEG_DIR} <-" >&5
-$as_echo_n "checking for ffmpeg in -> ${FFMPEG_DIR} <-... " >&6; }
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ffmpeg libraries in -> ${FFMPEG_DIR} <-" >&5
+$as_echo_n "checking for ffmpeg libraries in -> ${FFMPEG_DIR} <-... " >&6; }
 	if test -f ${FFMPEG_DIR}/lib/libavcodec.a -o -f ${FFMPEG_DIR}/lib/libavcodec.so && test -f ${FFMPEG_DIR}/lib/libavformat.a -o -f ${FFMPEG_DIR}/lib/libavformat.so ; then
 		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: found" >&5
 $as_echo "found" >&6; }
@@ -3651,94 +5405,202 @@ $as_echo "not found" >&6; }
 	fi
 fi
 
+
 #
 # Now check for ffmpeg headers ( avformat.h ) if ffmpeg libs were found
 #
 
+AVFORMAT_DIR=""
+
 if test "${FFMPEG_OK}" = "found"; then
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ffmpeg headers in ${FFMPEG_DIR}" >&5
+    if test "${FFMPEG_HEADERS_DIR}" = "yes"; then
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ffmpeg headers in ${FFMPEG_DIR}" >&5
 $as_echo_n "checking for ffmpeg headers in ${FFMPEG_DIR}... " >&6; }
+        AVFORMAT_DIR="${FFMPEG_DIR}"
+    else
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ffmpeg headers in ${FFMPEG_HEADERS_DIR}" >&5
+$as_echo_n "checking for ffmpeg headers in ${FFMPEG_HEADERS_DIR}... " >&6; }
+        FFMPEG_DIR="${FFMPEG_HEADERS_DIR}"
+        AVFORMAT_DIR="${FFMPEG_DIR}"
+    fi
 
-	if test -f ${FFMPEG_DIR}/include/avformat.h; then
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: found ${FFMPEG_DIR}/include/avformat.h" >&5
+    if test -f ${FFMPEG_DIR}/include/avformat.h; then
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: found ${FFMPEG_DIR}/include/avformat.h" >&5
 $as_echo "found ${FFMPEG_DIR}/include/avformat.h" >&6; }
-		FFMPEG_CFLAGS="-I${FFMPEG_DIR}/include"
-	elif test -f ${FFMPEG_DIR}/avformat.h; then
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: found ${FFMPEG_DIR}/avformat.h" >&5
+        FFMPEG_CFLAGS="-I${FFMPEG_DIR}/include"
+        AVFORMAT_DIR="${FFMPEG_DIR}/include/avformat.h"
+    elif test -f ${FFMPEG_DIR}/avformat.h; then
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: found ${FFMPEG_DIR}/avformat.h" >&5
 $as_echo "found ${FFMPEG_DIR}/avformat.h" >&6; }
-		FFMPEG_CFLAGS="-I${FFMPEG_DIR}"
-	elif test -f ${FFMPEG_DIR}/include/ffmpeg/avformat.h; then
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: found ${FFMPEG_DIR}/include/ffmpeg/avformat.h" >&5
+        FFMPEG_CFLAGS="-I${FFMPEG_DIR}"
+        AVFORMAT_DIR="${FFMPEG_DIR}/avformat.h"
+    elif test -f ${FFMPEG_DIR}/include/ffmpeg/avformat.h; then
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: found ${FFMPEG_DIR}/include/ffmpeg/avformat.h" >&5
 $as_echo "found ${FFMPEG_DIR}/include/ffmpeg/avformat.h" >&6; }
-		FFMPEG_CFLAGS="-I${FFMPEG_DIR}/include/ffmpeg"
-	elif test -f ${FFMPEG_DIR}/include/libavformat/avformat.h; then
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: found ${FFMPEG_DIR}/include/libavformat/avformat.h" >&5
+        FFMPEG_CFLAGS="-I${FFMPEG_DIR}/include/ffmpeg"
+        AVFORMAT_DIR="${FFMPEG_DIR}/include/ffmpeg/avformat.h"
+    elif test -f ${FFMPEG_DIR}/include/libavformat/avformat.h; then
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: found ${FFMPEG_DIR}/include/libavformat/avformat.h" >&5
 $as_echo "found ${FFMPEG_DIR}/include/libavformat/avformat.h" >&6; }
-		FFMPEG_CFLAGS="-I${FFMPEG_DIR}/include -DFFMPEG_NEW_INCLUDES"
+        FFMPEG_CFLAGS="-I${FFMPEG_DIR}/include -DFFMPEG_NEW_INCLUDES"
+        AVFORMAT="-I${FFMPEG_DIR}/include/libavformat"
+        AVFORMAT_DIR="${FFMPEG_DIR}/include/libavformat/avformat.h"
     elif test -f ${FFMPEG_DIR}/include/ffmpeg/libavformat/avformat.h; then
         { $as_echo "$as_me:${as_lineno-$LINENO}: result: found ${FFMPEG_DIR}/include/ffmpeg/libavformat/avformat.h" >&5
 $as_echo "found ${FFMPEG_DIR}/include/ffmpeg/libavformat/avformat.h" >&6; }
         FFMPEG_CFLAGS="-I${FFMPEG_DIR}/include/ffmpeg -DFFMPEG_NEW_INCLUDES"
-	else
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+        AVFORMAT="-I${FFMPEG_DIR}/include/ffmpeg/libavformat"
+        AVFORMAT_DIR="${FFMPEG_DIR}/include/ffmpeg/libavformat/avformat.h"
+    elif test -f ${FFMPEG_DIR}/libavformat/avformat.h; then
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: found ${FFMPEG_DIR}/libavformat/avformat.h" >&5
+$as_echo "found ${FFMPEG_DIR}/libavformat/avformat.h" >&6; }
+        FFMPEG_CFLAGS="-I${FFMPEG_DIR} -DFFMPEG_NEW_INCLUDES"
+        AVFORMAT="-I{FFMPEG_DIR}/libavformat"
+        AVFORMAT_DIR="${FFMPEG_DIR}/libavformat/avformat.h"
+    else
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
 $as_echo "not found" >&6; }
-		FFMPEG_OK="no_found"
-		echo "**********************************************"
-		echo "*       avformat.h not found:                *"
-		echo "*    ALL FFMPEG FEATURES DISABLED            *"
-		echo "*                                            *"
-		echo "* Please read the Motion Guide for help:     *"
-		echo "* http://motion.sourceforge.net              *"
-		echo "**********************************************"
-		echo ""
-	fi
+        FFMPEG_OK="no_found"
+        AVFORMAT_DIR="avformat.h"
+        echo "**********************************************"
+        echo "*       avformat.h not found:                *"
+        echo "*    ALL FFMPEG FEATURES DISABLED            *"
+        echo "*                                            *"
+        echo "* Please read the Motion Guide for help:     *"
+        echo "* http://motion.sourceforge.net              *"
+        echo "**********************************************"
+        echo ""
+    fi
 
 #
 # If ffmpeg libs and headers have been found
 #
 
-	if  test "${FFMPEG_OK}" = "found"; then
-		TEMP_LIBS="$TEMP_LIBS -L${FFMPEG_LIB} -lavformat -lavcodec -lavutil -lm -lz"
-		TEMP_LDFLAGS="${TEMP_LDFLAGS} -L${FFMPEG_LIB}"
-		TEMP_CFLAGS="${TEMP_CFLAGS} -DHAVE_FFMPEG ${FFMPEG_CFLAGS}"
+    if  test "${FFMPEG_OK}" = "found"; then
+        TEMP_LIBS="$TEMP_LIBS -L${FFMPEG_LIB} ${FFMPEG_EXTRALIBS}"
+        TEMP_LDFLAGS="${TEMP_LDFLAGS} -L${FFMPEG_LIB}"
+        TEMP_CFLAGS="${TEMP_CFLAGS} -DHAVE_FFMPEG ${FFMPEG_CFLAGS}"
 
-		FFMPEG_OBJ="ffmpeg.o"
+        FFMPEG_OBJ="ffmpeg.o"
 
 
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking file_protocol is defined in ffmpeg ?" >&5
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking file_protocol is defined in ffmpeg ?" >&5
 $as_echo_n "checking file_protocol is defined in ffmpeg ?... " >&6; }
-		saved_CFLAGS=$CFLAGS
-		saved_LIBS=$LIBS
-		CFLAGS="${FFMPEG_CFLAGS}"
-		LIBS="$TEMP_LIBS"
+        saved_CFLAGS=$CFLAGS
+        saved_LIBS=$LIBS
+
+        CFLAGS="${FFMPEG_CFLAGS} ${AVFORMAT}"
+        LIBS="$TEMP_LIBS"
+
+        cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
-		cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+
+             #include <${AVFORMAT_DIR}>
+             URLProtocol test_file_protocol;
+             int main(void){
+                 test_file_protocol.url_read  = file_protocol.url_read;
+                 return 0;
+             }
+
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+
+             { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+             TEMP_CFLAGS="${TEMP_CFLAGS} -DHAVE_FFMPEG_NEW"
+
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+        CFLAGS=$saved_CFLAGS
+        LIBS=$saved_LIBS
+    fi
+fi
+fi
+
+# Revised RTSP module so that it can be included
+# whether or not FFMPEG is found.
+
+    RTPS_OBJ="netcam_rtsp.o"
+
+
+#
+# Check SQLITE3
+#
+
+SQLITE3_SUPPORT="no"
+
+# Check whether --with-sqlite3 was given.
+if test "${with_sqlite3+set}" = set; then :
+  withval=$with_sqlite3; SQLITE3="$withval"
+    # if not given argument, assume standard
+
+fi
+
+
+if test "${SQLITE3}" = "no"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for sqlite3" >&5
+$as_echo_n "checking for sqlite3... " >&6; }
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: skipping" >&5
+$as_echo "skipping" >&6; }
+else
+    saved_CFLAGS=$CFLAGS
+    saved_LIBS=$LIBS
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for sqlite3_open in -lsqlite3" >&5
+$as_echo_n "checking for sqlite3_open in -lsqlite3... " >&6; }
+if ${ac_cv_lib_sqlite3_sqlite3_open+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsqlite3  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
-			#include <avformat.h>
-			URLProtocol test_file_protocol;
-			int main(void){
-				test_file_protocol.url_read  = file_protocol.url_read;
-				return 0;
-			}
-
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char sqlite3_open ();
+int
+main ()
+{
+return sqlite3_open ();
+  ;
+  return 0;
+}
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_sqlite3_sqlite3_open=yes
 else
+  ac_cv_lib_sqlite3_sqlite3_open=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_sqlite3_sqlite3_open" >&5
+$as_echo "$ac_cv_lib_sqlite3_sqlite3_open" >&6; }
+if test "x$ac_cv_lib_sqlite3_sqlite3_open" = xyes; then :
+
+    TEMP_LIBS="$TEMP_LIBS -lsqlite3"
+    SQLITE3_SUPPORT="yes"
+
+$as_echo "#define HAVE_SQLITE3 1" >>confdefs.h
 
-				{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-				TEMP_CFLAGS="${TEMP_CFLAGS} -DHAVE_FFMPEG_NEW"
 
 
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-		CFLAGS=$saved_CFLAGS
-		LIBS=$saved_LIBS
-	fi
-fi
+
+
+    CFLAGS=$saved_CFLAGS
+    LIBS=$saved_LIBS
 fi
 
 
@@ -3821,8 +5683,8 @@ $as_echo "skipped" >&6; }
 		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for mysql headers in $MYSQL_HEADERS" >&5
 $as_echo_n "checking for mysql headers in $MYSQL_HEADERS... " >&6; }
 		# Manual detection for <withval>
-        	if test -f $MYSQL_HEADERS/mysql.h; then
-                	MYSQL_INCDIR=$MYSQL_HEADERS
+		if test -f $MYSQL_HEADERS/mysql.h; then
+			MYSQL_INCDIR=$MYSQL_HEADERS
 	        fi
 	fi
 
@@ -3832,8 +5694,8 @@ $as_echo_n "checking for mysql headers i
 $as_echo "not found" >&6; }
 		echo "Invalid MySQL directory - unable to find mysql.h."
 	else
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
+		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $MYSQL_INCDIR yes" >&5
+$as_echo "$MYSQL_INCDIR yes" >&6; }
 		MYSQL_HEADERS="yes"
 	fi
 
@@ -3844,8 +5706,8 @@ $as_echo "yes" >&6; }
 	if test "${MYSQL_LIBS}" = "yes"; then
 		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking autodect mysql libs" >&5
 $as_echo_n "checking autodect mysql libs... " >&6; }
-        	# Autodetect
-		for w in /usr/lib64 /usr/lib /usr/local/lib /usr/mysql /usr/local/mysql /usr/local/mysql/lib /opt /opt/mysql; do
+		# Autodetect
+		for w in /usr/lib64 /usr/lib /usr/local/lib /usr/mysql /usr/local/mysql /usr/local/mysql/lib /opt /opt/mysql /usr/lib/x86_64-linux-gnu; do
 			# check for plain setups
 			if test -f $w/libmysqlclient.a -o -f $w/libmysqlclient.so; then
 				MYSQL_LIBDIR=$w
@@ -3863,7 +5725,7 @@ $as_echo_n "checking autodect mysql libs
 			fi
 		done
 	elif test "${MYSQL_LIBS}" = "no"; then
-        	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for mysql libs" >&5
+		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for mysql libs" >&5
 $as_echo_n "checking for mysql libs... " >&6; }
 	        { $as_echo "$as_me:${as_lineno-$LINENO}: result: skipped" >&5
 $as_echo "skipped" >&6; }
@@ -3891,7 +5753,7 @@ $as_echo "$MYSQL_LIBDIR" >&6; }
 		LIBS="-L$MYSQL_LIBDIR"
 		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for mysql_init in -lmysqlclient" >&5
 $as_echo_n "checking for mysql_init in -lmysqlclient... " >&6; }
-if test "${ac_cv_lib_mysqlclient_mysql_init+set}" = set; then :
+if ${ac_cv_lib_mysqlclient_mysql_init+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -3925,7 +5787,7 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_mysqlclient_mysql_init" >&5
 $as_echo "$ac_cv_lib_mysqlclient_mysql_init" >&6; }
-if test "x$ac_cv_lib_mysqlclient_mysql_init" = x""yes; then :
+if test "x$ac_cv_lib_mysqlclient_mysql_init" = xyes; then :
 
 					TEMP_LIBS="$TEMP_LIBS -L$MYSQL_LIBDIR -lmysqlclient -lz"
 					TEMP_CFLAGS="$TEMP_CFLAGS -I$MYSQL_INCDIR"
@@ -3935,7 +5797,7 @@ $as_echo "#define HAVE_MYSQL 1" >>confde
 
 
 else
-  as_fn_error "MySQL support can't build without MySQL libraries" "$LINENO" 5
+  as_fn_error $? "MySQL support can't build without MySQL libraries" "$LINENO" 5
 fi
 
 		CFLAGS=$saved_CFLAGS
@@ -4018,8 +5880,8 @@ $as_echo "skipped" >&6; }
 		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for pgsql headers in $PGSQL_HEADERS" >&5
 $as_echo_n "checking for pgsql headers in $PGSQL_HEADERS... " >&6; }
 		# Manual detection for <withval>
-        	if test -f $PGSQL_HEADERS/libpq-fe.h; then
-                	PGSQL_INCDIR=$PGSQL_HEADERS
+		if test -f $PGSQL_HEADERS/libpq-fe.h; then
+			PGSQL_INCDIR=$PGSQL_HEADERS
 	        fi
 	fi
 
@@ -4037,386 +5899,118 @@ $as_echo "yes $PGSQL_INCDIR" >&6; }
 
 	if test "${PGSQL_HEADERS}" = "yes"; then
 
-		# ******* Search pgsql libs *********
-		if test "${PGSQL_LIBS}" = "yes"; then
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: checking autodect pgsql libs" >&5
-$as_echo_n "checking autodect pgsql libs... " >&6; }
-			# Autodetect
-			PGSQL_INCLUDE="-I$PGSQL_INCDIR"
-			PGSQL_LIBDIR=$PGSQL_DIR/lib
-
-			if test -f /usr/lib64/libpq.so ; then
-				PGSQL_LIBDIR=/usr/lib64
-			elif test -f $PGSQL_DIR/lib/pgsql/libpq.so ; then
-				PGSQL_LIBDIR=$PGSQL_DIR/lib/pgsql
-			elif test -f $PGSQL_DIR/lib/postgresql/libpq.so ; then
-				PGSQL_LIBDIR=$PGSQL_DIR/lib/postgresql
-			elif test -f $PGSQL_DIR/lib/libpq.so ; then
-				PGSQL_LIBDIR=$PGSQL_DIR/lib
-			else
-				PGSQL_LIBDIR=""
-			fi
-
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $PGSQL_LIBDIR" >&5
-$as_echo "$PGSQL_LIBDIR" >&6; }
-
-		elif test "${PGSQL_LIBS}" = "no"; then
-	        	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for pgsql libs" >&5
-$as_echo_n "checking for pgsql libs... " >&6; }
-		        { $as_echo "$as_me:${as_lineno-$LINENO}: result: skipped" >&5
-$as_echo "skipped" >&6; }
-		else
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for pgsql libs in $PGSQL_LIBS" >&5
-$as_echo_n "checking for pgsql libs in $PGSQL_LIBS... " >&6; }
-			# Manual detection for <withval>
-			if test -f $PGSQL_LIBS/libpq.a -o -f $PGSQL_LIBS/libpq.so; then
-				PGSQL_LIBDIR=$PGSQL_LIBS
-			fi
-		fi
-
-
-		if test -z "$PGSQL_LIBDIR" ; then
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
-			echo "Invalid PostgreSQL directory $PGSQL_LIBDIR - unable to find libpq.a or libpq.so."
-		else
-			#LDFLAGS="$TEMP_LDFLAGS -L$PGSQL_LIBDIR"
-			saved_CFLAGS=$CFLAGS
-			saved_LIBS=$LIBS
-			CFLAGS="-I$PGSQL_INCDIR"
-			LIBS="-L$PGSQL_LIBDIR"
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for PQconnectStart in -lpq" >&5
-$as_echo_n "checking for PQconnectStart in -lpq... " >&6; }
-if test "${ac_cv_lib_pq_PQconnectStart+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lpq  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char PQconnectStart ();
-int
-main ()
-{
-return PQconnectStart ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_pq_PQconnectStart=yes
-else
-  ac_cv_lib_pq_PQconnectStart=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_pq_PQconnectStart" >&5
-$as_echo "$ac_cv_lib_pq_PQconnectStart" >&6; }
-if test "x$ac_cv_lib_pq_PQconnectStart" = x""yes; then :
-
-						PGSQL_SUPPORT="yes"
-						TEMP_LIBS="$TEMP_LIBS -L$PGSQL_LIBDIR -lpq"
-						TEMP_CFLAGS="$TEMP_CFLAGS -I$PGSQL_INCDIR"
-
-$as_echo "#define HAVE_PGSQL 1" >>confdefs.h
-
-
-else
-  as_fn_error "PostgreSQL support can't build without PostgreSQL libraries" "$LINENO" 5
-fi
-
-			LDFLAGS=""
-			CFLAGS=$saved_CFLAGS
-			LIBS=$saved_LIBS
-		fi
-
-	fi # end pgsql-include , pgsql-libs
-
-# end PostgreSQL detection
-fi
-
-
-#Checks for header files.
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to run the C preprocessor" >&5
-$as_echo_n "checking how to run the C preprocessor... " >&6; }
-# On Suns, sometimes $CPP names a directory.
-if test -n "$CPP" && test -d "$CPP"; then
-  CPP=
-fi
-if test -z "$CPP"; then
-  if test "${ac_cv_prog_CPP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-      # Double quotes because CPP needs to be expanded
-    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
-    do
-      ac_preproc_ok=false
-for ac_c_preproc_warn_flag in '' yes
-do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-		     Syntax error
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-
-else
-  # Broken: fails on valid input.
-continue
-fi
-rm -f conftest.err conftest.$ac_ext
-
-  # OK, works on sane cases.  Now check whether nonexistent headers
-  # can be detected and how.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <ac_nonexistent.h>
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-  # Broken: success on invalid input.
-continue
-else
-  # Passes both tests.
-ac_preproc_ok=:
-break
-fi
-rm -f conftest.err conftest.$ac_ext
-
-done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then :
-  break
-fi
-
-    done
-    ac_cv_prog_CPP=$CPP
-
-fi
-  CPP=$ac_cv_prog_CPP
-else
-  ac_cv_prog_CPP=$CPP
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $CPP" >&5
-$as_echo "$CPP" >&6; }
-ac_preproc_ok=false
-for ac_c_preproc_warn_flag in '' yes
-do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-		     Syntax error
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-
-else
-  # Broken: fails on valid input.
-continue
-fi
-rm -f conftest.err conftest.$ac_ext
-
-  # OK, works on sane cases.  Now check whether nonexistent headers
-  # can be detected and how.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <ac_nonexistent.h>
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-  # Broken: success on invalid input.
-continue
-else
-  # Passes both tests.
-ac_preproc_ok=:
-break
-fi
-rm -f conftest.err conftest.$ac_ext
-
-done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then :
+		# ******* Search pgsql libs *********
+		if test "${PGSQL_LIBS}" = "yes"; then
+			{ $as_echo "$as_me:${as_lineno-$LINENO}: checking autodect pgsql libs" >&5
+$as_echo_n "checking autodect pgsql libs... " >&6; }
+			# Autodetect
+			PGSQL_INCLUDE="-I$PGSQL_INCDIR"
+			PGSQL_LIBDIR=$PGSQL_DIR/lib
 
-else
-  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "C preprocessor \"$CPP\" fails sanity check
-See \`config.log' for more details." "$LINENO" 5; }
-fi
+			if test -f /usr/lib64/libpq.so ; then
+				PGSQL_LIBDIR=/usr/lib64
+			elif test -f $PGSQL_DIR/lib/pgsql/libpq.so ; then
+				PGSQL_LIBDIR=$PGSQL_DIR/lib/pgsql
+			elif test -f $PGSQL_DIR/lib/postgresql/libpq.so ; then
+				PGSQL_LIBDIR=$PGSQL_DIR/lib/postgresql
+			elif test -f $PGSQL_DIR/lib/libpq.so ; then
+				PGSQL_LIBDIR=$PGSQL_DIR/lib
+			else
+				PGSQL_LIBDIR=""
+			fi
 
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
+			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $PGSQL_LIBDIR" >&5
+$as_echo "$PGSQL_LIBDIR" >&6; }
 
+		elif test "${PGSQL_LIBS}" = "no"; then
+			{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for pgsql libs" >&5
+$as_echo_n "checking for pgsql libs... " >&6; }
+		        { $as_echo "$as_me:${as_lineno-$LINENO}: result: skipped" >&5
+$as_echo "skipped" >&6; }
+		else
+			{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for pgsql libs in $PGSQL_LIBS" >&5
+$as_echo_n "checking for pgsql libs in $PGSQL_LIBS... " >&6; }
+			# Manual detection for <withval>
+			if test -f $PGSQL_LIBS/libpq.a -o -f $PGSQL_LIBS/libpq.so; then
+				PGSQL_LIBDIR=$PGSQL_LIBS
+			fi
+		fi
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for grep that handles long lines and -e" >&5
-$as_echo_n "checking for grep that handles long lines and -e... " >&6; }
-if test "${ac_cv_path_GREP+set}" = set; then :
+
+		if test -z "$PGSQL_LIBDIR" ; then
+			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+$as_echo "not found" >&6; }
+			echo "Invalid PostgreSQL directory $PGSQL_LIBDIR - unable to find libpq.a or libpq.so."
+		else
+			#LDFLAGS="$TEMP_LDFLAGS -L$PGSQL_LIBDIR"
+			saved_CFLAGS=$CFLAGS
+			saved_LIBS=$LIBS
+			CFLAGS="-I$PGSQL_INCDIR"
+			LIBS="-L$PGSQL_LIBDIR"
+			{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for PQconnectStart in -lpq" >&5
+$as_echo_n "checking for PQconnectStart in -lpq... " >&6; }
+if ${ac_cv_lib_pq_PQconnectStart+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  if test -z "$GREP"; then
-  ac_path_GREP_found=false
-  # Loop through the user's path and test for each of PROGNAME-LIST
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_prog in grep ggrep; do
-    for ac_exec_ext in '' $ac_executable_extensions; do
-      ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_GREP" && $as_test_x "$ac_path_GREP"; } || continue
-# Check for GNU ac_path_GREP and select it if it is found.
-  # Check for GNU $ac_path_GREP
-case `"$ac_path_GREP" --version 2>&1` in
-*GNU*)
-  ac_cv_path_GREP="$ac_path_GREP" ac_path_GREP_found=:;;
-*)
-  ac_count=0
-  $as_echo_n 0123456789 >"conftest.in"
-  while :
-  do
-    cat "conftest.in" "conftest.in" >"conftest.tmp"
-    mv "conftest.tmp" "conftest.in"
-    cp "conftest.in" "conftest.nl"
-    $as_echo 'GREP' >> "conftest.nl"
-    "$ac_path_GREP" -e 'GREP$' -e '-(cannot match)-' < "conftest.nl" >"conftest.out" 2>/dev/null || break
-    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
-    as_fn_arith $ac_count + 1 && ac_count=$as_val
-    if test $ac_count -gt ${ac_path_GREP_max-0}; then
-      # Best one so far, save it but keep looking for a better one
-      ac_cv_path_GREP="$ac_path_GREP"
-      ac_path_GREP_max=$ac_count
-    fi
-    # 10*(2^10) chars as input seems more than enough
-    test $ac_count -gt 10 && break
-  done
-  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
-esac
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lpq  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
-      $ac_path_GREP_found && break 3
-    done
-  done
-  done
-IFS=$as_save_IFS
-  if test -z "$ac_cv_path_GREP"; then
-    as_fn_error "no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
-  fi
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char PQconnectStart ();
+int
+main ()
+{
+return PQconnectStart ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_pq_PQconnectStart=yes
 else
-  ac_cv_path_GREP=$GREP
+  ac_cv_lib_pq_PQconnectStart=no
 fi
-
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_GREP" >&5
-$as_echo "$ac_cv_path_GREP" >&6; }
- GREP="$ac_cv_path_GREP"
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_pq_PQconnectStart" >&5
+$as_echo "$ac_cv_lib_pq_PQconnectStart" >&6; }
+if test "x$ac_cv_lib_pq_PQconnectStart" = xyes; then :
 
+						PGSQL_SUPPORT="yes"
+						TEMP_LIBS="$TEMP_LIBS -L$PGSQL_LIBDIR -lpq"
+						TEMP_CFLAGS="$TEMP_CFLAGS -I$PGSQL_INCDIR"
+
+$as_echo "#define HAVE_PGSQL 1" >>confdefs.h
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for egrep" >&5
-$as_echo_n "checking for egrep... " >&6; }
-if test "${ac_cv_path_EGREP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if echo a | $GREP -E '(a|b)' >/dev/null 2>&1
-   then ac_cv_path_EGREP="$GREP -E"
-   else
-     if test -z "$EGREP"; then
-  ac_path_EGREP_found=false
-  # Loop through the user's path and test for each of PROGNAME-LIST
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_prog in egrep; do
-    for ac_exec_ext in '' $ac_executable_extensions; do
-      ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_EGREP" && $as_test_x "$ac_path_EGREP"; } || continue
-# Check for GNU ac_path_EGREP and select it if it is found.
-  # Check for GNU $ac_path_EGREP
-case `"$ac_path_EGREP" --version 2>&1` in
-*GNU*)
-  ac_cv_path_EGREP="$ac_path_EGREP" ac_path_EGREP_found=:;;
-*)
-  ac_count=0
-  $as_echo_n 0123456789 >"conftest.in"
-  while :
-  do
-    cat "conftest.in" "conftest.in" >"conftest.tmp"
-    mv "conftest.tmp" "conftest.in"
-    cp "conftest.in" "conftest.nl"
-    $as_echo 'EGREP' >> "conftest.nl"
-    "$ac_path_EGREP" 'EGREP$' < "conftest.nl" >"conftest.out" 2>/dev/null || break
-    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
-    as_fn_arith $ac_count + 1 && ac_count=$as_val
-    if test $ac_count -gt ${ac_path_EGREP_max-0}; then
-      # Best one so far, save it but keep looking for a better one
-      ac_cv_path_EGREP="$ac_path_EGREP"
-      ac_path_EGREP_max=$ac_count
-    fi
-    # 10*(2^10) chars as input seems more than enough
-    test $ac_count -gt 10 && break
-  done
-  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
-esac
 
-      $ac_path_EGREP_found && break 3
-    done
-  done
-  done
-IFS=$as_save_IFS
-  if test -z "$ac_cv_path_EGREP"; then
-    as_fn_error "no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
-  fi
 else
-  ac_cv_path_EGREP=$EGREP
+  as_fn_error $? "PostgreSQL support can't build without PostgreSQL libraries" "$LINENO" 5
 fi
 
-   fi
+			LDFLAGS=""
+			CFLAGS=$saved_CFLAGS
+			LIBS=$saved_LIBS
+		fi
+
+	fi # end pgsql-include , pgsql-libs
+
+# end PostgreSQL detection
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_EGREP" >&5
-$as_echo "$ac_cv_path_EGREP" >&6; }
- EGREP="$ac_cv_path_EGREP"
 
 
+#Checks for header files.
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ANSI C header files" >&5
 $as_echo_n "checking for ANSI C header files... " >&6; }
-if test "${ac_cv_header_stdc+set}" = set; then :
+if ${ac_cv_header_stdc+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -4526,30 +6120,11 @@ $as_echo "#define STDC_HEADERS 1" >>conf
 
 fi
 
-# On IRIX 5.3, sys/types and inttypes.h are conflicting.
-for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
-		  inttypes.h stdint.h unistd.h
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default
-"
-eval as_val=\$$as_ac_Header
-   if test "x$as_val" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-
 for ac_header in stdio.h unistd.h stdint.h fcntl.h time.h signal.h sys/ioctl.h sys/mman.h linux/videodev.h linux/videodev2.h sys/param.h sys/types.h
 do :
   as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
 ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-eval as_val=\$$as_ac_Header
-   if test "x$as_val" = x""yes; then :
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -4562,7 +6137,7 @@ done
 for ac_func in get_current_dir_name
 do :
   ac_fn_c_check_func "$LINENO" "get_current_dir_name" "ac_cv_func_get_current_dir_name"
-if test "x$ac_cv_func_get_current_dir_name" = x""yes; then :
+if test "x$ac_cv_func_get_current_dir_name" = xyes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_GET_CURRENT_DIR_NAME 1
 _ACEOF
@@ -4575,7 +6150,6 @@ done
 SUPPORTED_V4L2=false
 SUPPORTED_V4L2_old=false
 
-
 if test "${V4L}" = "no"; then
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for V42L support" >&5
 $as_echo_n "checking for V42L support... " >&6; }
@@ -4585,7 +6159,7 @@ else
 	ac_fn_c_check_type "$LINENO" "struct v4l2_buffer" "ac_cv_type_struct_v4l2_buffer" "#include <sys/time.h>
 			#include <linux/videodev.h>
 "
-if test "x$ac_cv_type_struct_v4l2_buffer" = x""yes; then :
+if test "x$ac_cv_type_struct_v4l2_buffer" = xyes; then :
   SUPPORTED_V4L2=true
 else
   SUPPORTED_V4L2=false
@@ -4613,7 +6187,7 @@ $as_echo "testing" >&6; }
 do :
   ac_fn_c_check_header_compile "$LINENO" "linux/videodev2.h" "ac_cv_header_linux_videodev2_h" "#include <asm/types.h>
 "
-if test "x$ac_cv_header_linux_videodev2_h" = x""yes; then :
+if test "x$ac_cv_header_linux_videodev2_h" = xyes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LINUX_VIDEODEV2_H 1
 _ACEOF
@@ -4640,7 +6214,7 @@ fi
 # This bug is HP SR number 8606223364.
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking size of short" >&5
 $as_echo_n "checking size of short... " >&6; }
-if test "${ac_cv_sizeof_short+set}" = set; then :
+if ${ac_cv_sizeof_short+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (short))" "ac_cv_sizeof_short"        "$ac_includes_default"; then :
@@ -4649,9 +6223,8 @@ else
   if test "$ac_cv_type_short" = yes; then
      { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ as_fn_set_status 77
-as_fn_error "cannot compute sizeof (short)
-See \`config.log' for more details." "$LINENO" 5; }; }
+as_fn_error 77 "cannot compute sizeof (short)
+See \`config.log' for more details" "$LINENO" 5; }
    else
      ac_cv_sizeof_short=0
    fi
@@ -4674,7 +6247,7 @@ _ACEOF
 # This bug is HP SR number 8606223364.
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking size of int" >&5
 $as_echo_n "checking size of int... " >&6; }
-if test "${ac_cv_sizeof_int+set}" = set; then :
+if ${ac_cv_sizeof_int+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (int))" "ac_cv_sizeof_int"        "$ac_includes_default"; then :
@@ -4683,9 +6256,8 @@ else
   if test "$ac_cv_type_int" = yes; then
      { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ as_fn_set_status 77
-as_fn_error "cannot compute sizeof (int)
-See \`config.log' for more details." "$LINENO" 5; }; }
+as_fn_error 77 "cannot compute sizeof (int)
+See \`config.log' for more details" "$LINENO" 5; }
    else
      ac_cv_sizeof_int=0
    fi
@@ -4708,7 +6280,7 @@ _ACEOF
 # This bug is HP SR number 8606223364.
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking size of long int" >&5
 $as_echo_n "checking size of long int... " >&6; }
-if test "${ac_cv_sizeof_long_int+set}" = set; then :
+if ${ac_cv_sizeof_long_int+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (long int))" "ac_cv_sizeof_long_int"        "$ac_includes_default"; then :
@@ -4717,9 +6289,8 @@ else
   if test "$ac_cv_type_long_int" = yes; then
      { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ as_fn_set_status 77
-as_fn_error "cannot compute sizeof (long int)
-See \`config.log' for more details." "$LINENO" 5; }; }
+as_fn_error 77 "cannot compute sizeof (long int)
+See \`config.log' for more details" "$LINENO" 5; }
    else
      ac_cv_sizeof_long_int=0
    fi
@@ -4742,7 +6313,7 @@ _ACEOF
 # This bug is HP SR number 8606223364.
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking size of long long" >&5
 $as_echo_n "checking size of long long... " >&6; }
-if test "${ac_cv_sizeof_long_long+set}" = set; then :
+if ${ac_cv_sizeof_long_long+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (long long))" "ac_cv_sizeof_long_long"        "$ac_includes_default"; then :
@@ -4751,9 +6322,8 @@ else
   if test "$ac_cv_type_long_long" = yes; then
      { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ as_fn_set_status 77
-as_fn_error "cannot compute sizeof (long long)
-See \`config.log' for more details." "$LINENO" 5; }; }
+as_fn_error 77 "cannot compute sizeof (long long)
+See \`config.log' for more details" "$LINENO" 5; }
    else
      ac_cv_sizeof_long_long=0
    fi
@@ -4776,7 +6346,7 @@ _ACEOF
 # This bug is HP SR number 8606223364.
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking size of int *" >&5
 $as_echo_n "checking size of int *... " >&6; }
-if test "${ac_cv_sizeof_int_p+set}" = set; then :
+if ${ac_cv_sizeof_int_p+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (int *))" "ac_cv_sizeof_int_p"        "$ac_includes_default"; then :
@@ -4785,9 +6355,8 @@ else
   if test "$ac_cv_type_int_p" = yes; then
      { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ as_fn_set_status 77
-as_fn_error "cannot compute sizeof (int *)
-See \`config.log' for more details." "$LINENO" 5; }; }
+as_fn_error 77 "cannot compute sizeof (int *)
+See \`config.log' for more details" "$LINENO" 5; }
    else
      ac_cv_sizeof_int_p=0
    fi
@@ -4810,7 +6379,7 @@ _ACEOF
 # This bug is HP SR number 8606223364.
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking size of void *" >&5
 $as_echo_n "checking size of void *... " >&6; }
-if test "${ac_cv_sizeof_void_p+set}" = set; then :
+if ${ac_cv_sizeof_void_p+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (void *))" "ac_cv_sizeof_void_p"        "$ac_includes_default"; then :
@@ -4819,9 +6388,8 @@ else
   if test "$ac_cv_type_void_p" = yes; then
      { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ as_fn_set_status 77
-as_fn_error "cannot compute sizeof (void *)
-See \`config.log' for more details." "$LINENO" 5; }; }
+as_fn_error 77 "cannot compute sizeof (void *)
+See \`config.log' for more details" "$LINENO" 5; }
    else
      ac_cv_sizeof_void_p=0
    fi
@@ -4875,7 +6443,7 @@ fi
 # Checks for typedefs, structures, and compiler characteristics.
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for an ANSI C-conforming const" >&5
 $as_echo_n "checking for an ANSI C-conforming const... " >&6; }
-if test "${ac_cv_c_const+set}" = set; then :
+if ${ac_cv_c_const+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -4884,11 +6452,11 @@ else
 int
 main ()
 {
-/* FIXME: Include the comments suggested by Paul. */
+
 #ifndef __cplusplus
-  /* Ultrix mips cc rejects this.  */
+  /* Ultrix mips cc rejects this sort of thing.  */
   typedef int charset[2];
-  const charset cs;
+  const charset cs = { 0, 0 };
   /* SunOS 4.1.1 cc rejects this.  */
   char const *const *pcpcc;
   char **ppc;
@@ -4905,8 +6473,9 @@ main ()
   ++pcpcc;
   ppc = (char**) pcpcc;
   pcpcc = (char const *const *) ppc;
-  { /* SCO 3.2v4 cc rejects this.  */
-    char *t;
+  { /* SCO 3.2v4 cc rejects this sort of thing.  */
+    char tx;
+    char *t = &tx;
     char const *s = 0 ? (char *) 0 : (char const *) 0;
 
     *t++ = 0;
@@ -4922,10 +6491,10 @@ main ()
     iptr p = 0;
     ++p;
   }
-  { /* AIX XL C 1.02.0.0 rejects this saying
+  { /* AIX XL C 1.02.0.0 rejects this sort of thing, saying
        "k.c", line 2.27: 1506-025 (S) Operand must be a modifiable lvalue. */
-    struct s { int j; const int *ap[3]; };
-    struct s *b; b->j = 5;
+    struct s { int j; const int *ap[3]; } bx;
+    struct s *b = &bx; b->j = 5;
   }
   { /* ULTRIX-32 V3.1 (Rev 9) vcc rejects this */
     const int foo = 10;
@@ -4992,6 +6561,7 @@ if test -e "/proc/cpuinfo" ; then
 	intel[152]="-march=pentium4"
 	intel[154]="-march=pentium4"
 	intel[614]="-march=prescott"
+	intel[628]="-march=core2"
 	amd[50]="-march=i586"
 	amd[51]="-march=i586"
 	amd[52]="-march=i586"
@@ -5063,6 +6633,9 @@ if test -e "/proc/cpuinfo" ; then
 		sse3)
 			CPU_FPU="-msse3"
 			;;
+		ssse3)
+			CPU_FPU="-mfpmath=sse -msse2 -mssse3"
+			;;
 		3dnow)
 			CPU_EXT="$CPU_EXT -m3dnow"
 			;;
@@ -5137,7 +6710,7 @@ if test "x${CPU_TYPE}" = "xunknown"; the
 			CPU_OPTIONS="-march=k6-3"
 			;;
 		*)
-			CPU_OPTIONS=""
+			CPU_OPTIONS="-march=native -mtune=native"
 			;;
 		esac
 	fi
@@ -5205,7 +6778,7 @@ rm -f core conftest.err conftest.$ac_obj
 
 
 if test "${DEVELOPER_FLAGS}" = "yes"; then
-	TEMP_CFLAGS="${TEMP_CFLAGS} -W -Wshadow -Wpointer-arith -Wcast-align -Wwrite-strings -Waggregate-return -Wstrict-prototypes -Wmissing-prototypes -Wnested-externs -Winline -Wredundant-decls -Wno-long-long -ggdb -g3 "
+	TEMP_CFLAGS="${TEMP_CFLAGS} -W -Wshadow -Wpointer-arith -Wcast-align -Wwrite-strings -Waggregate-return -Wstrict-prototypes -Wmissing-prototypes -Wnested-externs -Winline -Wredundant-decls -Wno-long-long -ggdb -g3"
 fi
 
 CFLAGS="${TEMP_CFLAGS} $UNAME_DEFS  $CPU_OPTIONS"
@@ -5213,6 +6786,7 @@ CFLAGS="${TEMP_CFLAGS} $UNAME_DEFS  $CPU
 LIBS="${TEMP_LIBS}"
 LDFLAGS="${TEMP_LDFLAGS}"
 
+
 #
 # Add the right exec path for rc scripts
 #
@@ -5234,7 +6808,6 @@ fi
 
 
 
-
 ac_config_files="$ac_config_files thread1.conf thread2.conf thread3.conf thread4.conf motion-dist.conf motion.init-FreeBSD.sh motion.init-Debian motion.init-Fedora motion.spec Makefile"
 
 cat >confcache <<\_ACEOF
@@ -5301,10 +6874,21 @@ $as_echo "$as_me: WARNING: cache variabl
      :end' >>confcache
 if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
   if test -w "$cache_file"; then
-    test "x$cache_file" != "x/dev/null" &&
+    if test "x$cache_file" != "x/dev/null"; then
       { $as_echo "$as_me:${as_lineno-$LINENO}: updating cache $cache_file" >&5
 $as_echo "$as_me: updating cache $cache_file" >&6;}
-    cat confcache >$cache_file
+      if test ! -f "$cache_file" || test -h "$cache_file"; then
+	cat confcache >"$cache_file"
+      else
+        case $cache_file in #(
+        */* | ?:*)
+	  mv -f confcache "$cache_file"$$ &&
+	  mv -f "$cache_file"$$ "$cache_file" ;; #(
+        *)
+	  mv -f confcache "$cache_file" ;;
+	esac
+      fi
+    fi
   else
     { $as_echo "$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file" >&5
 $as_echo "$as_me: not updating unwritable cache $cache_file" >&6;}
@@ -5320,6 +6904,7 @@ DEFS=-DHAVE_CONFIG_H
 
 ac_libobjs=
 ac_ltlibobjs=
+U=
 for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
   # 1. Remove the extension, and $U if already installed.
   ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
@@ -5335,7 +6920,7 @@ LTLIBOBJS=$ac_ltlibobjs
 
 
 
-: ${CONFIG_STATUS=./config.status}
+: "${CONFIG_STATUS=./config.status}"
 ac_write_fail=0
 ac_clean_files_save=$ac_clean_files
 ac_clean_files="$ac_clean_files $CONFIG_STATUS"
@@ -5436,6 +7021,7 @@ fi
 IFS=" ""	$as_nl"
 
 # Find who we are.  Look in the path if we contain no directory separator.
+as_myself=
 case $0 in #((
   *[\\/]* ) as_myself=$0 ;;
   *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
@@ -5481,19 +7067,19 @@ export LANGUAGE
 (unset CDPATH) >/dev/null 2>&1 && unset CDPATH
 
 
-# as_fn_error ERROR [LINENO LOG_FD]
-# ---------------------------------
+# as_fn_error STATUS ERROR [LINENO LOG_FD]
+# ----------------------------------------
 # Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
 # provided, also output the error to LOG_FD, referencing LINENO. Then exit the
-# script with status $?, using 1 if that was 0.
+# script with STATUS, using 1 if that was 0.
 as_fn_error ()
 {
-  as_status=$?; test $as_status -eq 0 && as_status=1
-  if test "$3"; then
-    as_lineno=${as_lineno-"$2"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-    $as_echo "$as_me:${as_lineno-$LINENO}: error: $1" >&$3
+  as_status=$1; test $as_status -eq 0 && as_status=1
+  if test "$4"; then
+    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
   fi
-  $as_echo "$as_me: error: $1" >&2
+  $as_echo "$as_me: error: $2" >&2
   as_fn_exit $as_status
 } # as_fn_error
 
@@ -5631,16 +7217,16 @@ if (echo >conf$$.file) 2>/dev/null; then
     # ... but there are two gotchas:
     # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
     # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
-    # In both cases, we have to default to `cp -p'.
+    # In both cases, we have to default to `cp -pR'.
     ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
-      as_ln_s='cp -p'
+      as_ln_s='cp -pR'
   elif ln conf$$.file conf$$ 2>/dev/null; then
     as_ln_s=ln
   else
-    as_ln_s='cp -p'
+    as_ln_s='cp -pR'
   fi
 else
-  as_ln_s='cp -p'
+  as_ln_s='cp -pR'
 fi
 rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
 rmdir conf$$.dir 2>/dev/null
@@ -5689,7 +7275,7 @@ $as_echo X"$as_dir" |
       test -d "$as_dir" && break
     done
     test -z "$as_dirs" || eval "mkdir $as_dirs"
-  } || test -d "$as_dir" || as_fn_error "cannot create directory $as_dir"
+  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"
 
 
 } # as_fn_mkdir_p
@@ -5700,28 +7286,16 @@ else
   as_mkdir_p=false
 fi
 
-if test -x / >/dev/null 2>&1; then
-  as_test_x='test -x'
-else
-  if ls -dL / >/dev/null 2>&1; then
-    as_ls_L_option=L
-  else
-    as_ls_L_option=
-  fi
-  as_test_x='
-    eval sh -c '\''
-      if test -d "$1"; then
-	test -d "$1/.";
-      else
-	case $1 in #(
-	-*)set "./$1";;
-	esac;
-	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
-	???[sx]*):;;*)false;;esac;fi
-    '\'' sh
-  '
-fi
-as_executable_p=$as_test_x
+
+# as_fn_executable_p FILE
+# -----------------------
+# Test if FILE is an executable regular file.
+as_fn_executable_p ()
+{
+  test -f "$1" && test -x "$1"
+} # as_fn_executable_p
+as_test_x='test -x'
+as_executable_p=as_fn_executable_p
 
 # Sed expression to map a string onto a valid CPP name.
 as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
@@ -5742,8 +7316,8 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_wri
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by motion $as_me 3.2.12, which was
-generated by GNU Autoconf 2.65.  Invocation command line was
+This file was extended by motion $as_me 3.2.12-4ppa01, which was
+generated by GNU Autoconf 2.69.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
@@ -5804,11 +7378,11 @@ _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
 ac_cs_version="\\
-motion config.status 3.2.12
-configured by $0, generated by GNU Autoconf 2.65,
+motion config.status 3.2.12-4ppa01
+configured by $0, generated by GNU Autoconf 2.69,
   with options \\"\$ac_cs_config\\"
 
-Copyright (C) 2009 Free Software Foundation, Inc.
+Copyright (C) 2012 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
 
@@ -5823,11 +7397,16 @@ ac_need_defaults=:
 while test $# != 0
 do
   case $1 in
-  --*=*)
+  --*=?*)
     ac_option=`expr "X$1" : 'X\([^=]*\)='`
     ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
     ac_shift=:
     ;;
+  --*=)
+    ac_option=`expr "X$1" : 'X\([^=]*\)='`
+    ac_optarg=
+    ac_shift=:
+    ;;
   *)
     ac_option=$1
     ac_optarg=$2
@@ -5849,6 +7428,7 @@ do
     $ac_shift
     case $ac_optarg in
     *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    '') as_fn_error $? "missing file argument" ;;
     esac
     as_fn_append CONFIG_FILES " '$ac_optarg'"
     ac_need_defaults=false;;
@@ -5861,7 +7441,7 @@ do
     ac_need_defaults=false;;
   --he | --h)
     # Conflict between --help and --header
-    as_fn_error "ambiguous option: \`$1'
+    as_fn_error $? "ambiguous option: \`$1'
 Try \`$0 --help' for more information.";;
   --help | --hel | -h )
     $as_echo "$ac_cs_usage"; exit ;;
@@ -5870,7 +7450,7 @@ Try \`$0 --help' for more information.";
     ac_cs_silent=: ;;
 
   # This is an error.
-  -*) as_fn_error "unrecognized option: \`$1'
+  -*) as_fn_error $? "unrecognized option: \`$1'
 Try \`$0 --help' for more information." ;;
 
   *) as_fn_append ac_config_targets " $1"
@@ -5890,7 +7470,7 @@ fi
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 if \$ac_cs_recheck; then
-  set X '$SHELL' '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+  set X $SHELL '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
   shift
   \$as_echo "running CONFIG_SHELL=$SHELL \$*" >&6
   CONFIG_SHELL='$SHELL'
@@ -5931,7 +7511,7 @@ do
     "motion.spec") CONFIG_FILES="$CONFIG_FILES motion.spec" ;;
     "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
 
-  *) as_fn_error "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
+  *) as_fn_error $? "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
   esac
 done
 
@@ -5953,9 +7533,10 @@ fi
 # after its creation but before its name has been assigned to `$tmp'.
 $debug ||
 {
-  tmp=
+  tmp= ac_tmp=
   trap 'exit_status=$?
-  { test -z "$tmp" || test ! -d "$tmp" || rm -fr "$tmp"; } && exit $exit_status
+  : "${ac_tmp:=$tmp}"
+  { test ! -d "$ac_tmp" || rm -fr "$ac_tmp"; } && exit $exit_status
 ' 0
   trap 'as_fn_exit 1' 1 2 13 15
 }
@@ -5963,12 +7544,13 @@ $debug ||
 
 {
   tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
-  test -n "$tmp" && test -d "$tmp"
+  test -d "$tmp"
 }  ||
 {
   tmp=./conf$$-$RANDOM
   (umask 077 && mkdir "$tmp")
-} || as_fn_error "cannot create a temporary directory in ." "$LINENO" 5
+} || as_fn_error $? "cannot create a temporary directory in ." "$LINENO" 5
+ac_tmp=$tmp
 
 # Set up the scripts for CONFIG_FILES section.
 # No need to generate them if there are no CONFIG_FILES.
@@ -5985,12 +7567,12 @@ if test "x$ac_cr" = x; then
 fi
 ac_cs_awk_cr=`$AWK 'BEGIN { print "a\rb" }' </dev/null 2>/dev/null`
 if test "$ac_cs_awk_cr" = "a${ac_cr}b"; then
-  ac_cs_awk_cr='\r'
+  ac_cs_awk_cr='\\r'
 else
   ac_cs_awk_cr=$ac_cr
 fi
 
-echo 'BEGIN {' >"$tmp/subs1.awk" &&
+echo 'BEGIN {' >"$ac_tmp/subs1.awk" &&
 _ACEOF
 
 
@@ -5999,18 +7581,18 @@ _ACEOF
   echo "$ac_subst_vars" | sed 's/.*/&!$&$ac_delim/' &&
   echo "_ACEOF"
 } >conf$$subs.sh ||
-  as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
-ac_delim_num=`echo "$ac_subst_vars" | grep -c '$'`
+  as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
+ac_delim_num=`echo "$ac_subst_vars" | grep -c '^'`
 ac_delim='%!_!# '
 for ac_last_try in false false false false false :; do
   . ./conf$$subs.sh ||
-    as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
+    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
 
   ac_delim_n=`sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X`
   if test $ac_delim_n = $ac_delim_num; then
     break
   elif $ac_last_try; then
-    as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
+    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
   else
     ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
   fi
@@ -6018,7 +7600,7 @@ done
 rm -f conf$$subs.sh
 
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-cat >>"\$tmp/subs1.awk" <<\\_ACAWK &&
+cat >>"\$ac_tmp/subs1.awk" <<\\_ACAWK &&
 _ACEOF
 sed -n '
 h
@@ -6066,7 +7648,7 @@ t delim
 rm -f conf$$subs.awk
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 _ACAWK
-cat >>"\$tmp/subs1.awk" <<_ACAWK &&
+cat >>"\$ac_tmp/subs1.awk" <<_ACAWK &&
   for (key in S) S_is_set[key] = 1
   FS = ""
 
@@ -6098,21 +7680,29 @@ if sed "s/$ac_cr//" < /dev/null > /dev/n
   sed "s/$ac_cr\$//; s/$ac_cr/$ac_cs_awk_cr/g"
 else
   cat
-fi < "$tmp/subs1.awk" > "$tmp/subs.awk" \
-  || as_fn_error "could not setup config files machinery" "$LINENO" 5
+fi < "$ac_tmp/subs1.awk" > "$ac_tmp/subs.awk" \
+  || as_fn_error $? "could not setup config files machinery" "$LINENO" 5
 _ACEOF
 
-# VPATH may cause trouble with some makes, so we remove $(srcdir),
-# ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
+# VPATH may cause trouble with some makes, so we remove sole $(srcdir),
+# ${srcdir} and @srcdir@ entries from VPATH if srcdir is ".", strip leading and
 # trailing colons and then remove the whole line if VPATH becomes empty
 # (actually we leave an empty line to preserve line numbers).
 if test "x$srcdir" = x.; then
-  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
-s/:*\$(srcdir):*/:/
-s/:*\${srcdir}:*/:/
-s/:*@srcdir@:*/:/
-s/^\([^=]*=[	 ]*\):*/\1/
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=[	 ]*/{
+h
+s///
+s/^/:/
+s/[	 ]*$/:/
+s/:\$(srcdir):/:/g
+s/:\${srcdir}:/:/g
+s/:@srcdir@:/:/g
+s/^:*//
 s/:*$//
+x
+s/\(=[	 ]*\).*/\1/
+G
+s/\n//
 s/^[^=]*=[	 ]*$//
 }'
 fi
@@ -6124,7 +7714,7 @@ fi # test -n "$CONFIG_FILES"
 # No need to generate them if there are no CONFIG_HEADERS.
 # This happens for instance with `./config.status Makefile'.
 if test -n "$CONFIG_HEADERS"; then
-cat >"$tmp/defines.awk" <<\_ACAWK ||
+cat >"$ac_tmp/defines.awk" <<\_ACAWK ||
 BEGIN {
 _ACEOF
 
@@ -6136,11 +7726,11 @@ _ACEOF
 # handling of long lines.
 ac_delim='%!_!# '
 for ac_last_try in false false :; do
-  ac_t=`sed -n "/$ac_delim/p" confdefs.h`
-  if test -z "$ac_t"; then
+  ac_tt=`sed -n "/$ac_delim/p" confdefs.h`
+  if test -z "$ac_tt"; then
     break
   elif $ac_last_try; then
-    as_fn_error "could not make $CONFIG_HEADERS" "$LINENO" 5
+    as_fn_error $? "could not make $CONFIG_HEADERS" "$LINENO" 5
   else
     ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
   fi
@@ -6225,7 +7815,7 @@ cat >>$CONFIG_STATUS <<_ACEOF || ac_writ
 _ACAWK
 _ACEOF
 cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-  as_fn_error "could not setup config headers machinery" "$LINENO" 5
+  as_fn_error $? "could not setup config headers machinery" "$LINENO" 5
 fi # test -n "$CONFIG_HEADERS"
 
 
@@ -6238,7 +7828,7 @@ do
   esac
   case $ac_mode$ac_tag in
   :[FHL]*:*);;
-  :L* | :C*:*) as_fn_error "invalid tag \`$ac_tag'" "$LINENO" 5;;
+  :L* | :C*:*) as_fn_error $? "invalid tag \`$ac_tag'" "$LINENO" 5;;
   :[FH]-) ac_tag=-:-;;
   :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
   esac
@@ -6257,7 +7847,7 @@ do
     for ac_f
     do
       case $ac_f in
-      -) ac_f="$tmp/stdin";;
+      -) ac_f="$ac_tmp/stdin";;
       *) # Look for the file first in the build tree, then in the source tree
 	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
 	 # because $ac_f cannot contain `:'.
@@ -6266,7 +7856,7 @@ do
 	   [\\/$]*) false;;
 	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
 	   esac ||
-	   as_fn_error "cannot find input file: \`$ac_f'" "$LINENO" 5;;
+	   as_fn_error 1 "cannot find input file: \`$ac_f'" "$LINENO" 5;;
       esac
       case $ac_f in *\'*) ac_f=`$as_echo "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
       as_fn_append ac_file_inputs " '$ac_f'"
@@ -6292,8 +7882,8 @@ $as_echo "$as_me: creating $ac_file" >&6
     esac
 
     case $ac_tag in
-    *:-:* | *:-) cat >"$tmp/stdin" \
-      || as_fn_error "could not create $ac_file" "$LINENO" 5 ;;
+    *:-:* | *:-) cat >"$ac_tmp/stdin" \
+      || as_fn_error $? "could not create $ac_file" "$LINENO" 5 ;;
     esac
     ;;
   esac
@@ -6418,23 +8008,24 @@ s&@abs_builddir@&$ac_abs_builddir&;t t
 s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
 $ac_datarootdir_hack
 "
-eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$tmp/subs.awk" >$tmp/out \
-  || as_fn_error "could not create $ac_file" "$LINENO" 5
+eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$ac_tmp/subs.awk" \
+  >$ac_tmp/out || as_fn_error $? "could not create $ac_file" "$LINENO" 5
 
 test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
-  { ac_out=`sed -n '/\${datarootdir}/p' "$tmp/out"`; test -n "$ac_out"; } &&
-  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' "$tmp/out"`; test -z "$ac_out"; } &&
+  { ac_out=`sed -n '/\${datarootdir}/p' "$ac_tmp/out"`; test -n "$ac_out"; } &&
+  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' \
+      "$ac_tmp/out"`; test -z "$ac_out"; } &&
   { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \`datarootdir'
-which seems to be undefined.  Please make sure it is defined." >&5
+which seems to be undefined.  Please make sure it is defined" >&5
 $as_echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
-which seems to be undefined.  Please make sure it is defined." >&2;}
+which seems to be undefined.  Please make sure it is defined" >&2;}
 
-  rm -f "$tmp/stdin"
+  rm -f "$ac_tmp/stdin"
   case $ac_file in
-  -) cat "$tmp/out" && rm -f "$tmp/out";;
-  *) rm -f "$ac_file" && mv "$tmp/out" "$ac_file";;
+  -) cat "$ac_tmp/out" && rm -f "$ac_tmp/out";;
+  *) rm -f "$ac_file" && mv "$ac_tmp/out" "$ac_file";;
   esac \
-  || as_fn_error "could not create $ac_file" "$LINENO" 5
+  || as_fn_error $? "could not create $ac_file" "$LINENO" 5
  ;;
   :H)
   #
@@ -6443,21 +8034,21 @@ which seems to be undefined.  Please mak
   if test x"$ac_file" != x-; then
     {
       $as_echo "/* $configure_input  */" \
-      && eval '$AWK -f "$tmp/defines.awk"' "$ac_file_inputs"
-    } >"$tmp/config.h" \
-      || as_fn_error "could not create $ac_file" "$LINENO" 5
-    if diff "$ac_file" "$tmp/config.h" >/dev/null 2>&1; then
+      && eval '$AWK -f "$ac_tmp/defines.awk"' "$ac_file_inputs"
+    } >"$ac_tmp/config.h" \
+      || as_fn_error $? "could not create $ac_file" "$LINENO" 5
+    if diff "$ac_file" "$ac_tmp/config.h" >/dev/null 2>&1; then
       { $as_echo "$as_me:${as_lineno-$LINENO}: $ac_file is unchanged" >&5
 $as_echo "$as_me: $ac_file is unchanged" >&6;}
     else
       rm -f "$ac_file"
-      mv "$tmp/config.h" "$ac_file" \
-	|| as_fn_error "could not create $ac_file" "$LINENO" 5
+      mv "$ac_tmp/config.h" "$ac_file" \
+	|| as_fn_error $? "could not create $ac_file" "$LINENO" 5
     fi
   else
     $as_echo "/* $configure_input  */" \
-      && eval '$AWK -f "$tmp/defines.awk"' "$ac_file_inputs" \
-      || as_fn_error "could not create -" "$LINENO" 5
+      && eval '$AWK -f "$ac_tmp/defines.awk"' "$ac_file_inputs" \
+      || as_fn_error $? "could not create -" "$LINENO" 5
   fi
  ;;
 
@@ -6472,7 +8063,7 @@ _ACEOF
 ac_clean_files=$ac_clean_files_save
 
 test $ac_write_fail = 0 ||
-  as_fn_error "write failure creating $CONFIG_STATUS" "$LINENO" 5
+  as_fn_error $? "write failure creating $CONFIG_STATUS" "$LINENO" 5
 
 
 # configure is writing to config.log, and then calls config.status.
@@ -6493,7 +8084,7 @@ if test "$no_create" != yes; then
   exec 5>>config.log
   # Use ||, not &&, to avoid exiting from the if with $? = 1, which
   # would make configure fail if this is the last instruction.
-  $ac_cs_success || as_fn_exit $?
+  $ac_cs_success || as_fn_exit 1
 fi
 if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
@@ -6502,92 +8093,104 @@ fi
 
 
 echo ""
-echo "   *******************************"
-echo "      Configure status    "
+echo "   **************************"
+echo "      Configure status       "
 echo "      ${PACKAGE_NAME} ${PACKAGE_VERSION}"
-echo "   *******************************"
+echo "   **************************"
 echo
 
 
 if test "${Darwin}" != ""; then
-	echo "OS             :     Darwin"
+    echo "OS             :     Darwin"
 elif test "${FreeBSD}" != ""; then
-	echo "OS             :     *BSD"
+    echo "OS             :     *BSD"
 else
-	echo "OS             :     Linux"
+    echo "OS             :     Linux"
 fi
 
 if test "${PTHREAD_SUPPORT}" = "yes"; then
-	echo "pthread Support:     Yes"
+    echo "pthread support:     Yes"
 else
-	echo "pthread Support:     No"
-	echo "**********************************************"
-        echo "** Fatal Error YOU MUST HAVE pthread Support *"
-        echo "**********************************************"
+    echo "pthread support:     No"
+    echo "**********************************************"
+    echo "** Fatal Error YOU MUST HAVE pthread Support *"
+    echo "**********************************************"
 fi
 
-if test "${JPEG_SUPPORT_MMX}" = "yes"; then
-	echo "jpeg-mmx Support:    Yes"
+
+if test "${JPEG_SUPPORT_TURBO}" = "yes"; then
+    echo "jpeg turbo support:  Yes"
+elif test "${JPEG_SUPPORT_MMX}" = "yes"; then
+    echo "jpeg-mmx support:    Yes"
 elif test "${JPEG_SUPPORT}" = "yes"; then
-	echo "jpeg Support:        Yes"
+    echo "jpeg support:        Yes"
 else
-	echo "jpeg Support:        No"
-	echo "**********************************************"
-        echo "** Fatal Error YOU MUST HAVE jpeg Support  ***"
-        echo "**********************************************"
+    echo "jpeg support:        No"
+    echo "**********************************************"
+    echo "** Fatal Error YOU MUST HAVE jpeg Support  ***"
+    echo "**********************************************"
 fi
 
 if test "${FreeBSD}" != ""; then
 	if test "${BKTR}" = "yes"; then
-        	echo "BKTR included:       Yes"
+        echo "BKTR included:       Yes"
 	else
-        	echo "BKTR included:       No"
+        echo "BKTR included:       No"
 	fi
 
 	if test "${PWCBSD}" = "yes"; then
-		echo "PWCBSD include:      Yes"
+        echo "PWCBSD include:      Yes"
 	else
-		echo "PWCBSD include:      No"
+        echo "PWCBSD include:      No"
 	fi
 
 else
 	if test "${V4L}" = "yes"; then
-		echo "V4L included:        Yes"
+        echo "V4L support:         Yes"
 	else
-		echo "V4L included:        No"
+        echo "V4L support:         No"
 	fi
 
 	if test x$SUPPORTED_V4L2 = xtrue; then
-		echo "V4L2 supported:      Yes"
+        echo "V4L2 support:        Yes"
 	else
-		echo "V4L2 supported:      No"
+        echo "V4L2 support:        No"
 	fi
 fi
 
+if test "${SDL_SUPPORT}" = "yes"; then
+	echo "SDL support:         Yes"
+else
+	echo "SDL support:         No"
+fi
+
 if test "${FFMPEG_OK}" = "found"; then
-	echo "FFmpeg Support:      Yes"
+    echo "FFmpeg support:      Yes"
+else
+    echo "FFmpeg support:      No"
+fi
+
+if test "${SQLITE3_SUPPORT}" = "yes"; then
+    echo "SQLite3 support:     Yes"
 else
-	echo "FFmpeg Support:      No"
+    echo "SQLite3 support:     No"
 fi
 
 if test "${MYSQL_SUPPORT}" = "yes"; then
-	echo "MYSQL Support:       Yes"
+    echo "MYSQL support:       Yes"
 else
-	echo "MYSQL Support:       No"
+    echo "MYSQL support:       No"
 fi
 
 if test "${PGSQL_SUPPORT}" = "yes"; then
-	echo "PostgreSQL Support:  Yes"
+    echo "PostgreSQL support:  Yes"
 else
-	echo "PostgreSQL Support:  No"
+    echo "PostgreSQL support:  No"
 fi
 echo
-
 echo "CFLAGS: $CFLAGS"
 echo "LIBS: $LIBS"
 echo "LDFLAGS: $LDFLAGS"
-
 echo
 echo  "Install prefix:       $prefix"
 echo
-
--- /dev/null
+++ motion-3.2.12/configure.ac
@@ -0,0 +1,1386 @@
+# Process this file with autoconf to produce a configure script
+
+AC_INIT(motion, esyscmd(['./version.sh']))
+AC_GNU_SOURCE
+AC_CONFIG_SRCDIR([motion.c])
+AC_CONFIG_HEADERS(config.h)
+AC_PROG_CC
+
+
+THREAD_CFLAGS=""
+THREAD_CHECK="/usr/include/pthread.h"
+
+Darwin=""
+FreeBSD=""
+
+LINUXTHREADS="no"
+AC_ARG_WITH(linuxthreads,
+[  --with-linuxthreads     Use linuxthreads in BSD instead of native pthreads
+				]
+				,
+LINUXTHREADS="$withval"
+)
+
+PWCBSD="no"
+AC_ARG_WITH(pwcbsd,
+[  --with-pwcbsd           Use pwcbsd based webcams ( only BSD )
+]
+,
+PWCBSD="$withval"
+)
+
+
+AC_MSG_CHECKING(for Darwin)
+Darwin=`uname -a | grep "Darwin"`
+
+if test "${Darwin}" = ""; then
+	AC_MSG_RESULT(no)
+	AC_MSG_CHECKING(for *BSD)
+
+	FreeBSD=`uname -a | grep "BSD"`
+	if test "${FreeBSD}" = ""; then
+		AC_MSG_RESULT(no)
+		VIDEO="video.o video2.o video_common.o"
+	else
+		AC_MSG_RESULT(yes)
+		if test "${LINUXTHREADS}" = "no"; then
+			AC_MSG_CHECKING(Linuxthreads)
+			AC_MSG_RESULT(skipping)
+		else
+			THREAD_CHECK="/usr/local/include/pthread/linuxthreads/pthread.h"
+			THREAD_LIB_CHECK="/usr/local/lib/liblthread.so"
+		fi
+
+		if test "${PWCBSD}" != "no"; then
+			VIDEO="video.o video2.o video_common.o"
+			TEMP_CFLAGS="${CFLAGS} -I/usr/local/include -DPWCBSD"
+		else
+			VIDEO="video_freebsd.o"
+			TEMP_CFLAGS="${CFLAGS} -I/usr/local/include"
+		fi
+
+		TEMP_LDFLAGS="${LDFLAGS} -L/usr/local/lib"
+		TEMP_LIBS="-L/usr/local/lib"
+		AC_MSG_RESULT(Build with PWCBSD support $PWCBSD)
+
+	fi
+else
+	TEMP_CFLAGS="${CFLAGS} -I/sw/include"
+	TEMP_LDFLAGS="${LDFLAGS} -L/sw/lib"
+	TEMP_LIBS="-L/sw/lib"
+	VIDEO="video_freebsd.o"
+	FINK_LIB="-L/sw/lib"
+	Darwin="yes"
+	V4L="no"
+	AC_MSG_RESULT($Darwin)
+fi
+
+
+AC_SUBST(VIDEO)
+
+# Checks for programs.
+AC_PROG_CC
+
+TEMP_LIBS="-lm ${TEMP_LIBS}"
+TEMP_CFLAGS="${TEMP_CFLAGS} ${CFLAGS}"
+TEMP_LDFLAGS="${TEMP_LDFLAGS} ${LDFLAGS}"
+
+if test "${FreeBSD}" != "" && test "${PWCBSD}" = "no"; then
+
+	AC_MSG_CHECKING(bktr headers in /usr/include/dev/bktr)
+
+	if test -f /usr/include/dev/bktr/ioctl_meteor.h && test -f /usr/include/dev/bktr/ioctl_bt848.h; then
+		AC_MSG_RESULT(yes)
+	else
+		AC_MSG_RESULT(no)
+		TEMP_CFLAGS="${TEMP_CFLAGS} -DOLD_BKTR"
+	fi
+#
+# Check to Exclude BKTR
+#
+BKTR="yes"
+AC_ARG_WITH(bktr,
+[  --without-bktr          Exclude to use bktr subsystem , that usually useful
+                          for devices as network cameras ( ONLY used in *BSD).
+                          ]
+                          ,
+BKTR="$withval"
+)
+
+	if test "${BKTR}" = "no"; then
+		TEMP_CFLAGS="${TEMP_CFLAGS} -DWITHOUT_V4L"
+	fi
+
+else
+
+#
+# Check to Exclude V4L
+#
+V4L="yes"
+AC_ARG_WITH(v4l,
+[  --without-v4l           Exclude using v4l (video4linux) subsystem.
+                          Makes Motion so it only supports network cameras.
+                          ],
+V4L="$withval"
+)
+
+fi
+
+
+if test "${V4L}" = "no"; then
+	TEMP_CFLAGS="${TEMP_CFLAGS} -DWITHOUT_V4L"
+fi
+
+
+if test "${FreeBSD}" != "" && test "${LINUXTHREADS}" != "no" ; then
+
+AC_MSG_CHECKING(for linuxthreads)
+
+#
+# Check for thread header
+#
+	if test -f "${THREAD_CHECK}"; then
+		HEADERS_THREAD_CFLAGS="-I/usr/local/include/pthread/linuxthreads"
+		THREADS="yes"
+	else
+		THREADS="no"
+	fi
+
+#
+# Check for thread lib
+#
+	if test -f "${THREAD_LIB_CHECK}" ; then
+		THREADS="yes"
+		LIB_THREAD="-llthread -llgcc_r"
+	else
+		THREADS="no"
+	fi
+
+# Checks for Library linuxthreads for FreeBSD
+#
+# linuxthreads on freeBSD, ports collection
+# /usr/local/include/pthreads/linuxthreads/pthread.h
+# #include <linuxthreads/pthread.h>
+# /usr/local/lib/libpthread.so
+#
+
+	if test "${THREADS}" = "yes"; then
+		TEMP_CFLAGS="${HEADERS_THREAD_CFLAGS} $TEMP_CFLAGS -DWITH_LINUXTREADS"
+        TEMP_LIBS="$TEMP_LIBS ${LIB_THREAD}"
+        THREAD_CFLAGS="-D_THREAD_SAFE"
+        PTHREAD_SUPPORT="yes"
+        AC_MSG_RESULT($THREADS)
+    else
+        PTHREAD_SUPPORT="no"
+        AC_MSG_RESULT($THREADS)
+        echo
+        echo "You do not have linuxthread installed"
+        echo
+    fi
+
+elif test -f "${THREAD_CHECK}"; then
+
+
+AC_MSG_CHECKING(threads)
+AC_TRY_LINK([#include <pthread.h>],
+[pthread_t th; pthread_join(th, 0);
+ pthread_attr_init(0); pthread_cleanup_push(0, 0);
+ pthread_create(0,0,0,0); pthread_cleanup_pop(0); ],
+ [PTHREAD_LIB=yes])
+
+if test x$PTHREAD_LIB != xyes; then
+
+	if test "${FreeBSD}" != ""; then
+		TEMP_LIBS="$TEMP_LIBS -pthread"
+		TEMP_CFLAGS="${TEMP_CFLAGS} -D_REENTRANT -D_THREAD_SAFE"
+	else
+		TEMP_LIBS="$TEMP_LIBS -lpthread"
+		TEMP_CFLAGS="${TEMP_CFLAGS} -D_REENTRANT"
+	fi
+	PTHREAD_SUPPORT="yes"
+fi
+	AC_MSG_RESULT($PTHREAD_SUPPORT)
+
+else
+	echo
+	echo "You do not have threads support"
+	echo
+fi
+
+
+#
+# Check for sdl library
+#
+SDL_SUPPORT="no"
+AC_ARG_WITH(sdl,
+[  --without-sdl           Compile without sdl support to get stream in SDL window.
+],
+[],
+[])
+AC_MSG_CHECKING(for sdl)
+if test "x$withval" = "xno"; then
+	AC_MSG_RESULT(skipped)
+else
+	if test "${FreeBSD}" != ""; then
+		CONFIG_SDL='sdl11-config'
+	else
+		CONFIG_SDL='sdl-config'
+	fi
+	if test -z "`($CONFIG_SDL --version) 2>/dev/null`" ;then
+		AC_MSG_RESULT(no)
+		if test "$withval" = "yes"; then
+			echo ""
+			echo "****************************************************"
+			echo "* sdl-config could not be found. Please install it *"
+			echo "* and remove the --with-sdl configure argument.    *"
+			echo "* libSDL can be found at http://www.libsdl.org     *"
+			echo "****************************************************"
+			echo ""
+		fi
+	else
+		AC_MSG_RESULT(yes)
+		SDL_SUPPORT="yes"
+		TEMP_LIBS="$TEMP_LIBS `${CONFIG_SDL} --libs`"
+		TEMP_CFLAGS="${TEMP_CFLAGS} `${CONFIG_SDL} --cflags`"
+		AC_DEFINE([HAVE_SDL],1,[Define to 1 if you have SDL support])
+		SDL_OBJ="sdl.o"
+		AC_SUBST(SDL_OBJ)
+	fi
+fi
+
+#
+# Check for the libjpeg-turbo library
+#
+JPEG_TURBO="no"
+JPEG_TURBO_OK="not_found"
+
+AC_ARG_WITH(jpeg-turbo,
+[  --with-jpeg-turbo[=DIR]   Specify the prefix for the install path for
+                          jpeg-turbo for optimized jpeg handling (optional).
+                          ],
+JPEG_TURBO="$withval"
+)
+
+if test "${JPEG_TURBO}" = "no"; then
+    AC_MSG_CHECKING(for libjpeg-turbo)
+    AC_MSG_RESULT(skipping)
+else
+    AC_MSG_CHECKING(for libjpeg-turbo in -> [${JPEG_TURBO}] <-)
+    if test -f ${JPEG_TURBO}/lib/libjpeg.a ; then
+        AC_MSG_RESULT(found)
+        JPEG_TURBO_OK="found"
+    else
+        AC_MSG_RESULT(not found)
+    fi
+fi
+
+
+if test "${JPEG_TURBO_OK}" = "found"; then
+    saved_CFLAGS="$CFLAGS"
+    saved_LIBS="$LIBS"
+    saved_LDFLAGS="$LDFLAGS"
+    LDFLAGS="-L${JPEG_TURBO}/lib"
+    CFLAGS="$CFLAGS -I${JPEG_TURBO}/include"
+    LIBS="$LIBS -L${JPEG_TURBO}/lib -ljpeg"
+    AC_CHECK_LIB(jpeg, jpeg_start_compress,
+        [ TEMP_LIBS="$LIBS"
+          TEMP_CFLAGS="${CFLAGS}"
+          TEMP_LDFLAGS="$TEMP_LDFLAGS $LDFLAGS"
+          JPEG_SUPPORT="yes"],,)
+    LIBS="$saved_LIBS"
+    CFLAGS="$saved_CFLAGS"
+    LDFLAGS="$saved_LDFLAGS"
+    JPEG_SUPPORT_TURBO="yes"
+fi
+
+
+#
+# Check for the special mmx accelerated jpeg library
+#
+JPEG_MMX="no"
+JPEG_MMX_OK="not_found"
+AC_ARG_WITH(jpeg-mmx,
+[  --with-jpeg-mmx[=DIR]     Specify the prefix for the install path for
+                          jpeg-mmx for optimized jpeg handling (optional).
+                          If this is not specified motion will try to find
+                          the library /usr/lib/libjpeg-mmx.a /usr/local/lib/libjpeg-mmx.a.
+                          ],
+JPEG_MMX="$withval"
+)
+
+#
+# --without-jpeg-mmx or with-jpeg-mmx=no
+#
+
+if test "${JPEG_MMX}" = "no" || test x$JPEG_SUPPORT != xyes; then
+        AC_MSG_CHECKING(for libjpeg-mmx)
+        AC_MSG_RESULT(skipping)
+elif test "${JPEG_MMX}" = "yes"; then
+	# AUTODETECT STATIC LIB
+	AC_MSG_CHECKING(for libjpeg-mmx autodetecting)
+
+	if test -f /usr/lib/libjpeg-mmx.a ; then
+		AC_MSG_RESULT(found)
+		JPEG_MMX_OK="found"
+		JPEG_MMX="/usr/lib"
+	elif test -f /usr/local/lib/libjpeg-mmx.a ; then
+		AC_MSG_RESULT(found)
+		JPEG_MMX_OK="found"
+		JPEG_MMX="/usr/local/lib"
+	else
+		AC_MSG_RESULT(not found)
+	fi
+else
+	AC_MSG_CHECKING(for libjpeg-mmx in -> [${JPEG_MMX}] <-)
+	if test -f ${JPEG_MMX}/libjpeg-mmx.a ; then
+		AC_MSG_RESULT(found)
+		JPEG_MMX_OK="found"
+	else
+		AC_MSG_RESULT(not found)
+	fi
+fi
+
+if test "${JPEG_MMX_OK}" = "found"; then
+	saved_CFLAGS="$CFLAGS"
+	saved_LIBS="$LIBS"
+	CFLAGS="$CFLAGS -I${JPEG_MMX}"
+	LIBS="$LIBS -L${JPEG_MMX}"
+	AC_CHECK_LIB(jpeg-mmx, jpeg_start_compress,
+		[ TEMP_LIBS="$TEMP_LIBS -ljpeg-mmx"
+		TEMP_CFLAGS="${TEMP_CFLAGS} -I${JPEG_MMX}"
+		JPEG_SUPPORT="yes"],,)
+	LIBS="$saved_LIBS"
+	CFLAGS="$saved_CFLAGS"
+	JPEG_SUPPORT_MMX="yes"
+fi
+
+#
+# Look for _a_ jpeg lib that will work.
+#
+if test x$JPEG_SUPPORT != xyes ; then
+  # Checks for libraries
+  LDFLAGS=$TEMP_LDFLAGS
+
+  AC_CHECK_LIB(jpeg, jpeg_set_defaults, [
+		TEMP_LIBS="$TEMP_LIBS -ljpeg"
+		JPEG_SUPPORT="yes"
+	], [
+		echo
+		echo "You do not have libjpeg installed"
+		echo
+	]
+  )
+fi
+
+
+#
+# Check for libavcodec and libavformat from ffmpeg
+#
+
+FFMPEG_DIR="yes"
+FFMPEG_OK="no_found"
+FFMPEG_OBJ=""
+AC_ARG_WITH(ffmpeg,
+[  --with-ffmpeg[=DIR]       Specify the prefix for the install path for
+                          libavcodec/libavformat (part of ffmpeg) be able to
+                          encode mpeg movies realtime.
+                          If this is not specified motion will try to find
+                          the libraries in /usr and /usr/local.
+                          ],
+FFMPEG_DIR="$withval"
+)
+
+#
+# ffmpeg headers custom location
+#
+FFMPEG_HEADERS_DIR="yes"
+AC_ARG_WITH(ffmpeg_headers,
+[  --with-ffmpeg-headers[=DIR] Specify the prefix for ffmpeg headers.
+                               ],
+FFMPEG_HEADERS_DIR="$withval"
+)
+
+#
+# ffmpeg custom extra libraries
+#
+FFMPEG_EXTRALIBS=" -lavformat -lavcodec -lavutil -lm -lz -lswscale "
+AC_ARG_WITH(ffmpeg-libs,
+[  --with-ffmpeg-libs[=libs]  Specify the extra libs for ffmpeg
+                               ],
+FFMPEG_EXTRALIBS="$withval"
+)
+
+#
+# --without-ffmpeg or with-ffmpeg=no
+#
+if test "${FFMPEG_DIR}" = "no"; then
+	AC_MSG_CHECKING(for ffmpeg)
+	AC_MSG_RESULT(skipping)
+#
+# with-ffmpeg=<dir> or nothing
+#
+else if test "${FFMPEG_DIR}" = "yes"; then
+	# AUTODETECT STATIC/SHARED LIB
+	AC_MSG_CHECKING(for ffmpeg autodetecting libraries)
+
+	if test -f /usr/lib64/libavcodec.a -o -f /usr/lib64/libavcodec.so && test -f /usr/lib64/libavformat.a -o -f /usr/lib64/libavformat.so ; then
+		AC_MSG_RESULT(found in /usr/lib64)
+		FFMPEG_OK="found"
+		FFMPEG_LIB="/usr/lib64"
+		FFMPEG_DIR="/usr"
+	elif test -f /usr/lib/libavcodec.a -o -f /usr/lib/libavcodec.so && test -f /usr/lib/libavformat.a -o -f /usr/lib/libavformat.so ; then
+		AC_MSG_RESULT(found in /usr/lib)
+		FFMPEG_OK="found"
+		FFMPEG_LIB="/usr/lib"
+		FFMPEG_DIR="/usr"
+	elif test -f /usr/local/lib/libavcodec.a -o -f /usr/local/lib/libavcodec.so && test -f /usr/local/lib/libavformat.a -o -f /usr/local/lib/libavformat.so ; then
+		AC_MSG_RESULT(found in /usr/local/lib)
+		FFMPEG_OK="found"
+		FFMPEG_LIB="/usr/local/lib"
+		FFMPEG_DIR="/usr/local"
+    elif test -f /usr/lib/x86_64-linux-gnu/libavcodec.a -o -f /usr/lib/x86_64-linux-gnu/libavcodec.so && test /usr/lib/x86_64-linux-gnu/libavformat.a -o -f /usr/lib/x86_64-linux-gnu/libavformat.so ; then
+        AC_MSG_RESULT(found in /usr/lib/x86_64-linux-gnu)
+        FFMPEG_OK="found"
+        FFMPEG_LIB="/usr/lib/x86_64-linux-gnu"
+        FFMPEG_DIR="/usr"
+	elif test -f /usr/lib/i386-linux-gnu/libavcodec.a -o -f /usr/lib/i386-linux-gnu/libavcodec.so && test /usr/lib/i386-linux-gnu/libavformat.a -o -f /usr/lib/i386-linux-gnu/libavformat.so ; then
+        AC_MSG_RESULT(found in /usr/lib/i386-linux-gnu)
+        FFMPEG_OK="found"
+        FFMPEG_LIB="/usr/lib/i386-linux-gnu"
+        FFMPEG_DIR="/usr"
+	else
+		AC_MSG_RESULT(not found)
+		echo ""
+		echo "**********************************************"
+		echo "* libavcodec.a or libavcodec.so or           *"
+		echo "* libavformat.a or libavformat.so not found: *"
+		echo "*    ALL FFMPEG FEATURES DISABLED            *"
+		echo "*                                            *"
+		echo "* Please read the Motion Guide for help:     *"
+		echo "* http://motion.sourceforge.net              *"
+		echo "**********************************************"
+		echo ""
+	fi
+else
+	AC_MSG_CHECKING(for ffmpeg libraries in -> [${FFMPEG_DIR}] <-)
+	if test -f ${FFMPEG_DIR}/lib/libavcodec.a -o -f ${FFMPEG_DIR}/lib/libavcodec.so && test -f ${FFMPEG_DIR}/lib/libavformat.a -o -f ${FFMPEG_DIR}/lib/libavformat.so ; then
+		AC_MSG_RESULT(found)
+		FFMPEG_OK="found"
+		FFMPEG_LIB="${FFMPEG_DIR}/lib"
+	elif test -f ${FFMPEG_DIR}/libavcodec.a -o -f ${FFMPEG_DIR}/libavcodec.so && test -f ${FFMPEG_DIR}/libavformat.a -o -f ${FFMPEG_DIR}/libavformat.so ; then
+		AC_MSG_RESULT(found)
+		FFMPEG_LIB="${FFMPEG_DIR}"
+		FFMPEG_OK="found"
+	else
+		AC_MSG_RESULT(not found)
+		if test "${FFMPEG_OK}" != "found"; then
+			echo ""
+			echo "**********************************************"
+			echo "* libavcodec.a or libavcodec.so or           *"
+			echo "* libavformat.a or libavformat.so not found: *"
+			echo "*    ALL FFMPEG FEATURES DISABLED            *"
+			echo "*                                            *"
+			echo "* Please read the Motion Guide for help:     *"
+			echo "* http://motion.sourceforge.net              *"
+			echo "**********************************************"
+			echo ""
+		fi
+	fi
+fi
+
+
+#
+# Now check for ffmpeg headers ( avformat.h ) if ffmpeg libs were found
+#
+
+AVFORMAT_DIR=""
+
+if test "${FFMPEG_OK}" = "found"; then
+    if test "${FFMPEG_HEADERS_DIR}" = "yes"; then
+        AC_MSG_CHECKING(for ffmpeg headers in ${FFMPEG_DIR})
+        AVFORMAT_DIR="${FFMPEG_DIR}"
+    else
+        AC_MSG_CHECKING(for ffmpeg headers in ${FFMPEG_HEADERS_DIR})
+        FFMPEG_DIR="${FFMPEG_HEADERS_DIR}"
+        AVFORMAT_DIR="${FFMPEG_DIR}"
+    fi
+
+    if test -f ${FFMPEG_DIR}/include/avformat.h; then
+        AC_MSG_RESULT(found ${FFMPEG_DIR}/include/avformat.h)
+        FFMPEG_CFLAGS="-I${FFMPEG_DIR}/include"
+        AVFORMAT_DIR="${FFMPEG_DIR}/include/avformat.h"
+    elif test -f ${FFMPEG_DIR}/avformat.h; then
+        AC_MSG_RESULT(found ${FFMPEG_DIR}/avformat.h)
+        FFMPEG_CFLAGS="-I${FFMPEG_DIR}"
+        AVFORMAT_DIR="${FFMPEG_DIR}/avformat.h"
+    elif test -f ${FFMPEG_DIR}/include/ffmpeg/avformat.h; then
+        AC_MSG_RESULT(found ${FFMPEG_DIR}/include/ffmpeg/avformat.h)
+        FFMPEG_CFLAGS="-I${FFMPEG_DIR}/include/ffmpeg"
+        AVFORMAT_DIR="${FFMPEG_DIR}/include/ffmpeg/avformat.h"
+    elif test -f ${FFMPEG_DIR}/include/libavformat/avformat.h; then
+        AC_MSG_RESULT(found ${FFMPEG_DIR}/include/libavformat/avformat.h)
+        FFMPEG_CFLAGS="-I${FFMPEG_DIR}/include -DFFMPEG_NEW_INCLUDES"
+        AVFORMAT="-I${FFMPEG_DIR}/include/libavformat"
+        AVFORMAT_DIR="${FFMPEG_DIR}/include/libavformat/avformat.h"
+    elif test -f ${FFMPEG_DIR}/include/ffmpeg/libavformat/avformat.h; then
+        AC_MSG_RESULT(found ${FFMPEG_DIR}/include/ffmpeg/libavformat/avformat.h)
+        FFMPEG_CFLAGS="-I${FFMPEG_DIR}/include/ffmpeg -DFFMPEG_NEW_INCLUDES"
+        AVFORMAT="-I${FFMPEG_DIR}/include/ffmpeg/libavformat"
+        AVFORMAT_DIR="${FFMPEG_DIR}/include/ffmpeg/libavformat/avformat.h"
+    elif test -f ${FFMPEG_DIR}/libavformat/avformat.h; then
+        AC_MSG_RESULT(found ${FFMPEG_DIR}/libavformat/avformat.h)
+        FFMPEG_CFLAGS="-I${FFMPEG_DIR} -DFFMPEG_NEW_INCLUDES"
+        AVFORMAT="-I{FFMPEG_DIR}/libavformat"
+        AVFORMAT_DIR="${FFMPEG_DIR}/libavformat/avformat.h"
+    else
+        AC_MSG_RESULT(not found)
+        FFMPEG_OK="no_found"
+        AVFORMAT_DIR="avformat.h"
+        echo "**********************************************"
+        echo "*       avformat.h not found:                *"
+        echo "*    ALL FFMPEG FEATURES DISABLED            *"
+        echo "*                                            *"
+        echo "* Please read the Motion Guide for help:     *"
+        echo "* http://motion.sourceforge.net              *"
+        echo "**********************************************"
+        echo ""
+    fi
+
+#
+# If ffmpeg libs and headers have been found
+#
+
+    if  test "${FFMPEG_OK}" = "found"; then
+        TEMP_LIBS="$TEMP_LIBS -L${FFMPEG_LIB} ${FFMPEG_EXTRALIBS}"
+        TEMP_LDFLAGS="${TEMP_LDFLAGS} -L${FFMPEG_LIB}"
+        TEMP_CFLAGS="${TEMP_CFLAGS} -DHAVE_FFMPEG ${FFMPEG_CFLAGS}"
+
+        FFMPEG_OBJ="ffmpeg.o"
+        AC_SUBST(FFMPEG_OBJ)
+
+        AC_MSG_CHECKING([file_protocol is defined in ffmpeg ?])
+        saved_CFLAGS=$CFLAGS
+        saved_LIBS=$LIBS
+
+        CFLAGS="${FFMPEG_CFLAGS} ${AVFORMAT}"
+        LIBS="$TEMP_LIBS"
+
+        AC_COMPILE_IFELSE([AC_LANG_SOURCE([
+            [
+             #include <${AVFORMAT_DIR}>
+             URLProtocol test_file_protocol;
+             int main(void){
+                 test_file_protocol.url_read  = file_protocol.url_read;
+                 return 0;
+             }
+            ]])],
+            [AC_MSG_RESULT(yes)],
+            [
+             AC_MSG_RESULT(no)
+             TEMP_CFLAGS="${TEMP_CFLAGS} -DHAVE_FFMPEG_NEW"
+            ]
+        )
+        CFLAGS=$saved_CFLAGS
+        LIBS=$saved_LIBS
+    fi
+fi
+fi
+
+# Revised RTSP module so that it can be included
+# whether or not FFMPEG is found.
+
+    RTPS_OBJ="netcam_rtsp.o"
+    AC_SUBST(RTPS_OBJ)
+
+#
+# Check SQLITE3
+#
+
+SQLITE3_SUPPORT="no"
+AC_ARG_WITH(sqlite3,
+    [  --without-sqlite3       Disable sqlite3 support in motion.
+    ],
+    SQLITE3="$withval"
+    # if not given argument, assume standard
+)
+
+if test "${SQLITE3}" = "no"; then
+    AC_MSG_CHECKING(for sqlite3)
+    AC_MSG_RESULT(skipping)
+else
+    saved_CFLAGS=$CFLAGS
+    saved_LIBS=$LIBS
+
+    AC_CHECK_LIB(sqlite3, sqlite3_open,
+    [
+    TEMP_LIBS="$TEMP_LIBS -lsqlite3"
+    SQLITE3_SUPPORT="yes"
+    AC_DEFINE([HAVE_SQLITE3],1,[Define to 1 if you have SQLITE3 support])
+    ]
+    )
+
+    CFLAGS=$saved_CFLAGS
+    LIBS=$saved_LIBS
+fi
+
+
+#
+# Check Mysql
+#
+
+MYSQL="yes"
+MYSQL_SUPPORT="no"
+MYSQL_HEADERS="yes"
+MYSQL_LIBS="yes"
+
+AC_MSG_CHECKING(for mysql support)
+
+AC_ARG_WITH(mysql,
+[  --without-mysql         Disable mysql support in motion.
+                          ],
+MYSQL="$withval"
+# if not given argument, assume standard
+)
+
+AC_ARG_WITH(mysql-lib,
+[  --with-mysql-lib[=DIR]        Normally, configure will scan all possible default
+                          installation paths for mysql libs. When it fails, use
+                          this command to tell configure where mysql libs
+                          installation root directory is.
+                          ],
+MYSQL_LIBS="$withval"
+# if not given argument, assume standard
+)
+
+
+AC_ARG_WITH(mysql-include,
+[  --with-mysql-include[=DIR]    Normally, configure will scan all possible default
+                          installation paths for mysql include. When it fails, use
+                          this command to tell configure where mysql include
+                          installation root directory is.
+                          ],
+MYSQL_HEADERS="$withval"
+# if not given argument, assume standard
+)
+
+
+if test "${MYSQL}" = "no"; then
+	AC_MSG_RESULT(skipped)
+else
+	AC_MSG_RESULT(testing)
+	# ******* Search mysql headers *******
+
+	if test "${MYSQL_HEADERS}" = "yes"; then
+		AC_MSG_CHECKING(autodect mysql headers)
+		# Autodetect
+		for w in /usr/include /usr/local/include /usr/mysql /usr/local/mysql /usr/local/mysql/include /opt /opt/mysql; do
+			# check for plain setups
+			if test -f $w/mysql.h; then
+				MYSQL_INCDIR=$w
+				break
+			fi
+			# check for "/usr/include/<packagename>" type setups
+			if test -f $w/mysql/mysql.h; then
+				MYSQL_INCDIR=$w/mysql
+				break
+			fi
+			# check for "/usr/<packagename>/include" type setups
+			if test -f $w/mysql/include/mysql.h; then
+				MYSQL_INCDIR=$w/mysql/include
+				break
+			fi
+		done
+	elif test "${MYSQL_HEADERS}" = "no"; then
+		AC_MSG_CHECKING(for mysql headers)
+		AC_MSG_RESULT(skipped)
+	else
+		AC_MSG_CHECKING(for mysql headers in $MYSQL_HEADERS)
+		# Manual detection for <withval>
+		if test -f $MYSQL_HEADERS/mysql.h; then
+			MYSQL_INCDIR=$MYSQL_HEADERS
+	        fi
+	fi
+
+	if test -z "$MYSQL_INCDIR" ; then
+		MYSQL_HEADERS="no"
+		AC_MSG_RESULT(not found)
+		echo "Invalid MySQL directory - unable to find mysql.h."
+	else
+		AC_MSG_RESULT($MYSQL_INCDIR yes)
+		MYSQL_HEADERS="yes"
+	fi
+
+
+	if test "${MYSQL_HEADERS}" = "yes"; then
+
+	# ******* Search mysql libs *********
+	if test "${MYSQL_LIBS}" = "yes"; then
+		AC_MSG_CHECKING(autodect mysql libs)
+		# Autodetect
+		for w in /usr/lib64 /usr/lib /usr/local/lib /usr/mysql /usr/local/mysql /usr/local/mysql/lib /opt /opt/mysql /usr/lib/x86_64-linux-gnu; do
+			# check for plain setups
+			if test -f $w/libmysqlclient.a -o -f $w/libmysqlclient.so; then
+				MYSQL_LIBDIR=$w
+				break
+			fi
+			# check for "/usr/lib/<packagename>" type setups
+			if test -f $w/mysql/libmysqlclient.a -o -f $w/mysql/libmysqlclient.so; then
+				MYSQL_LIBDIR=$w/mysql
+				break
+			fi
+			# check for "/usr/<packagename>/lib" type setups
+			if test -f $w/mysql/lib/libmysqlclient.a -o -f $w/mysql/lib/libmysqlclient.so; then
+				MYSQL_LIBDIR=$w/mysql/lib
+				break
+			fi
+		done
+	elif test "${MYSQL_LIBS}" = "no"; then
+		AC_MSG_CHECKING(for mysql libs)
+	        AC_MSG_RESULT(skipped)
+	else
+		AC_MSG_CHECKING(for mysql libs in $MYSQL_LIBS)
+		# Manual detection for <withval>
+		if test -f $MYSQL_LIBS/libmysqlclient.a -o -f $MYSQL_LIBS/libmysqlclient.so; then
+			MYSQL_LIBDIR=$MYSQL_LIBS
+		fi
+	fi
+
+
+	if test -z "$MYSQL_LIBDIR" ; then
+		AC_MSG_RESULT(not found)
+		echo "Invalid MySQL directory - unable to find libmysqlclient.a or libmysqlclient.so."
+	else
+		AC_MSG_RESULT($MYSQL_LIBDIR)
+		#LDFLAGS="-L$MYSQL_LIBDIR"
+		saved_CFLAGS=$CFLAGS
+		saved_LIBS=$LIBS
+		CFLAGS="-I$MYSQL_INCDIR"
+		LIBS="-L$MYSQL_LIBDIR"
+		AC_CHECK_LIB(mysqlclient,mysql_init,[
+					TEMP_LIBS="$TEMP_LIBS -L$MYSQL_LIBDIR -lmysqlclient -lz"
+					TEMP_CFLAGS="$TEMP_CFLAGS -I$MYSQL_INCDIR"
+					MYSQL_SUPPORT="yes"
+					AC_DEFINE([HAVE_MYSQL],1,[Define to 1 if you have MySQL support])
+					],
+					AC_MSG_ERROR(MySQL support can't build without MySQL libraries))
+		CFLAGS=$saved_CFLAGS
+		LIBS=$saved_LIBS
+	fi
+
+	# end mysql-include , mysql-libs
+	fi
+
+# end Mysql detection
+fi
+
+
+#
+# Check PostgreSQL
+#
+PGSQL="yes"
+PGSQL_SUPPORT="no"
+PGSQL_HEADERS="yes"
+PGSQL_LIBS="yes"
+
+AC_DEFUN([PGSQL_INC_CHK],[if test -r $i$1/libpq-fe.h; then PGSQL_DIR=$i; PGSQL_INCDIR=$i$1])
+
+AC_ARG_WITH(pgsql,
+[  --without-pgsql         Disable PostgreSQL support in motion.
+                          ],
+PGSQL="$withval"
+# if not given argument, assume standard
+)
+
+AC_ARG_WITH(pgsql-lib,
+[  --with-pgsql-lib[=DIR]        Normally, configure will scan all possible default
+                          installation paths for pgsql libs. When it fails, use
+                          this command to tell configure where pgsql libs
+                          installation root directory is.
+                          ],
+PGSQL_LIBS="$withval"
+# if not given argument, assume standard
+)
+
+AC_ARG_WITH(pgsql-include,
+[  --with-pgsql-include[=DIR]    Normally, configure will scan all possible default
+                          installation paths for pgsql include. When it fails, use
+                          this command to tell configure where pgsql include
+                          installation root directory is.
+                          ],
+PGSQL_HEADERS="$withval"
+# if not given argument, assume standard
+)
+
+AC_MSG_CHECKING(for PostgreSQL)
+
+if test "${PGSQL}" = "no"; then
+	AC_MSG_RESULT(skipped)
+else
+	AC_MSG_RESULT(testing)
+
+	# ******* Search pgsql headers *******
+	if test "${PGSQL_HEADERS}" = "yes"; then
+
+		AC_MSG_CHECKING(autodect pgsql headers)
+		# Autodetect
+		for i in /usr /usr/local /usr/local/pgsql $PHP_PGSQL; do
+			PGSQL_INC_CHK(/include)
+			el[]PGSQL_INC_CHK(/include/pgsql)
+			el[]PGSQL_INC_CHK(/include/postgresql)
+			fi
+		done
+
+	elif test "${PGSQL_HEADERS}" = "no"; then
+		AC_MSG_CHECKING(for pgsql headers)
+		AC_MSG_RESULT(skipped)
+	else
+		AC_MSG_CHECKING(for pgsql headers in $PGSQL_HEADERS)
+		# Manual detection for <withval>
+		if test -f $PGSQL_HEADERS/libpq-fe.h; then
+			PGSQL_INCDIR=$PGSQL_HEADERS
+	        fi
+	fi
+
+	if test -z "$PGSQL_INCDIR" ; then
+		PGSQL_HEADERS="no"
+		AC_MSG_RESULT(not found)
+		echo "Invalid PostgreSQL directory - unable to find libpq-fe.h."
+	else
+		AC_MSG_RESULT(yes [$PGSQL_INCDIR])
+		PGSQL_HEADERS="yes"
+	fi
+
+
+	if test "${PGSQL_HEADERS}" = "yes"; then
+
+		# ******* Search pgsql libs *********
+		if test "${PGSQL_LIBS}" = "yes"; then
+			AC_MSG_CHECKING(autodect pgsql libs)
+			# Autodetect
+			PGSQL_INCLUDE="-I$PGSQL_INCDIR"
+			PGSQL_LIBDIR=$PGSQL_DIR/lib
+
+			if test -f /usr/lib64/libpq.so ; then
+				PGSQL_LIBDIR=/usr/lib64
+			elif test -f $PGSQL_DIR/lib/pgsql/libpq.so ; then
+				PGSQL_LIBDIR=$PGSQL_DIR/lib/pgsql
+			elif test -f $PGSQL_DIR/lib/postgresql/libpq.so ; then
+				PGSQL_LIBDIR=$PGSQL_DIR/lib/postgresql
+			elif test -f $PGSQL_DIR/lib/libpq.so ; then
+				PGSQL_LIBDIR=$PGSQL_DIR/lib
+			else
+				PGSQL_LIBDIR=""
+			fi
+
+			AC_MSG_RESULT($PGSQL_LIBDIR)
+
+		elif test "${PGSQL_LIBS}" = "no"; then
+			AC_MSG_CHECKING(for pgsql libs)
+		        AC_MSG_RESULT(skipped)
+		else
+			AC_MSG_CHECKING(for pgsql libs in $PGSQL_LIBS)
+			# Manual detection for <withval>
+			if test -f $PGSQL_LIBS/libpq.a -o -f $PGSQL_LIBS/libpq.so; then
+				PGSQL_LIBDIR=$PGSQL_LIBS
+			fi
+		fi
+
+
+		if test -z "$PGSQL_LIBDIR" ; then
+			AC_MSG_RESULT(not found)
+			echo "Invalid PostgreSQL directory [$PGSQL_LIBDIR] - unable to find libpq.a or libpq.so."
+		else
+			#LDFLAGS="$TEMP_LDFLAGS -L$PGSQL_LIBDIR"
+			saved_CFLAGS=$CFLAGS
+			saved_LIBS=$LIBS
+			CFLAGS="-I$PGSQL_INCDIR"
+			LIBS="-L$PGSQL_LIBDIR"
+			AC_CHECK_LIB(pq, PQconnectStart, [
+						PGSQL_SUPPORT="yes"
+						TEMP_LIBS="$TEMP_LIBS -L$PGSQL_LIBDIR -lpq"
+						TEMP_CFLAGS="$TEMP_CFLAGS -I$PGSQL_INCDIR"
+						AC_DEFINE([HAVE_PGSQL],1,[Define to 1 if you have PostgreSQL support])
+					],
+			AC_MSG_ERROR(PostgreSQL support can't build without PostgreSQL libraries))
+			LDFLAGS=""
+			CFLAGS=$saved_CFLAGS
+			LIBS=$saved_LIBS
+		fi
+
+	fi # end pgsql-include , pgsql-libs
+
+# end PostgreSQL detection
+fi
+
+
+#Checks for header files.
+AC_HEADER_STDC
+AC_CHECK_HEADERS(stdio.h unistd.h stdint.h fcntl.h time.h signal.h sys/ioctl.h sys/mman.h linux/videodev.h linux/videodev2.h sys/param.h sys/types.h)
+
+AC_CHECK_FUNCS(get_current_dir_name)
+
+# Check if v4l2 is available
+SUPPORTED_V4L2=false
+SUPPORTED_V4L2_old=false
+
+if test "${V4L}" = "no"; then
+	AC_MSG_CHECKING(for V42L support)
+	AC_MSG_RESULT(skipping)
+else
+	AC_CHECK_TYPE([struct v4l2_buffer],
+		[SUPPORTED_V4L2=true],
+		[SUPPORTED_V4L2=false],
+		[#include <sys/time.h>
+			#include <linux/videodev.h>])
+
+	AC_MSG_CHECKING(for V42L support)
+	if test x$SUPPORTED_V4L2 = xtrue; then
+		AC_MSG_RESULT(yes)
+		TEMP_CFLAGS="${TEMP_CFLAGS} -DMOTION_V4L2"
+	else
+		AC_MSG_RESULT(no)
+	fi
+
+	# linux/videodev.h doesn't include videodev2.h
+	if test x$SUPPORTED_V4L2 = xfalse; then
+		AC_MSG_CHECKING(for V42L *old* support)
+		AC_MSG_RESULT(testing)
+		AC_CHECK_HEADERS(linux/videodev2.h,[SUPPORTED_V4L2_old=true],[], [#include <asm/types.h>])
+	fi
+
+
+	if test x$SUPPORTED_V4L2_old = xtrue; then
+		TEMP_CFLAGS="${TEMP_CFLAGS} -DMOTION_V4L2 -DMOTION_V4L2_OLD"
+		SUPPORTED_V4L2=true
+	fi
+
+fi
+
+
+# Check sizes of integer types
+AC_CHECK_SIZEOF(short)
+AC_CHECK_SIZEOF(int)
+AC_CHECK_SIZEOF(long int)
+AC_CHECK_SIZEOF(long long)
+AC_CHECK_SIZEOF(int *)
+AC_CHECK_SIZEOF(void *)
+
+if test "$ac_cv_sizeof_short" = "4"; then
+	TEMP_CFLAGS="${TEMP_CFLAGS} -DTYPE_32BIT=\"short\""
+else
+	if test "$ac_cv_sizeof_int" = "4"; then
+		TEMP_CFLAGS="${TEMP_CFLAGS} -DTYPE_32BIT=\"int\""
+	else
+		if test "$ac_cv_sizeof_long_int" = "4"; then
+			TEMP_CFLAGS="${TEMP_CFLAGS} -DTYPE_32BIT=\"long int\""
+		fi
+	fi
+fi
+
+
+OPTIMIZECPU="yes"
+
+AC_ARG_WITH(optimizecpu,
+[  --without-optimizecpu   Exclude autodetecting platform and cpu type.
+                          This will disable the compilation of gcc
+                          optimizing code by platform and cpu.
+			  ],
+OPTIMIZECPU="$withval"
+)
+
+DEVELOPER_FLAGS="no"
+
+AC_ARG_WITH(developer-flags,
+[  --with-developer-flags  Causes practically all of the possible gcc
+                          warning flags to be set.  This may produce
+                          a large amount of warnings.],
+DEVELOPER_FLAGS="$withval"
+)
+
+# Checks for typedefs, structures, and compiler characteristics.
+AC_C_CONST
+
+if test "${FreeBSD}" != ""; then
+	OPTIMIZECPU=""
+fi
+
+if test "${OPTIMIZECPU}" = "yes"; then
+
+# Try to autodetect cpu type
+CPU_NAME="unknown"
+CPU_TYPE="unknown"
+if test -e "/proc/cpuinfo" ; then
+	intel[[30]]="-march=i386"
+	intel[[32]]="-march=i386"
+	intel[[34]]="-march=i386"
+	intel[[40]]="-march=i486"
+	intel[[41]]="-march=i486"
+	intel[[42]]="-march=i486"
+	intel[[43]]="-march=i486"
+	intel[[44]]="-march=i486"
+	intel[[45]]="-march=i486"
+	intel[[47]]="-march=i486"
+	intel[[48]]="-march=i486"
+	intel[[51]]="-march=pentium"
+	intel[[52]]="-march=pentium"
+	intel[[54]]="-march=pentium-mmx"
+	intel[[56]]="-march=pentium-mmx"
+	intel[[61]]="-march=pentiumpro"
+	intel[[63]]="-march=pentium2"
+	intel[[65]]="-march=pentium2"
+	intel[[66]]="-march=pentium2"
+	intel[[67]]="-march=pentium3"
+	intel[[68]]="-march=pentium3"
+	intel[[610]]="-march=pentium3"
+	intel[[611]]="-march=pentium3"
+	intel[[150]]="-march=pentium4"
+	intel[[151]]="-march=pentium4"
+	intel[[152]]="-march=pentium4"
+	intel[[154]]="-march=pentium4"
+	intel[[614]]="-march=prescott"
+	intel[[628]]="-march=core2"
+	amd[[50]]="-march=i586"
+	amd[[51]]="-march=i586"
+	amd[[52]]="-march=i586"
+	amd[[53]]="-march=i586"
+	amd[[56]]="-march=k6"
+	amd[[57]]="-march=k6"
+	amd[[58]]="-march=k6-2"
+	amd[[510]]="-march=k6-2"
+	amd[[59]]="-march=k6-3"
+	amd[[513]]="-march=k6-3"
+	amd[[61]]="-march=athlon"
+	amd[[62]]="-march=athlon"
+	amd[[63]]="-march=athlon"
+	amd[[64]]="-march=athlon"
+	amd[[66]]="-march=athlon"
+	amd[[67]]="-march=athlon"
+	amd[[68]]="-march=athlon"
+	amd[[610]]="-march=athlon"
+	amd[[158]]="-march=athlon-xp"
+	amd[[154]]="-march=k8"
+	amd[[155]]="-march=athlon64"
+	amd[[1543]]="-march=athlon64"
+	amd[[1544]]="-march=athlon64"
+	amd[[1565]]="-march=opteron"
+	amd[[1572]]="-march=k8"
+	via[[67]]="-march=c3"
+	via[[68]]="-march=c3"
+	via[[69]]="-march=i686"
+	via[[610]]="-march=i686"
+
+	CPU_TYPE="known"
+	CPU_FAMILY=`cat /proc/cpuinfo | grep "cpu family" | head -n1`
+	CPU_MODEL=`cat /proc/cpuinfo | grep model[[^\ ]] | head -n1`
+	CPU_NAME=`cat /proc/cpuinfo | grep "model name" | head -n1`
+	CPU_FLAGS=`cat /proc/cpuinfo | grep "flags" | head -n1`
+	CPU_VENDOR=`cat /proc/cpuinfo | grep "vendor_id" | head -n1`
+	CPU_FAMILY=${CPU_FAMILY#*: }
+	CPU_MODEL=${CPU_MODEL#*: }
+	CPU_NAME=${CPU_NAME#*: }
+	CPU_FLAGS=${CPU_FLAGS#*: }
+	CPU_VENDOR=${CPU_VENDOR#*: }
+	if test "x${CPU_VENDOR}" = "xGenuineIntel" ; then
+		CPU_OPTIONS=${intel[[$CPU_FAMILY$CPU_MODEL]]}
+	fi
+	if test "x${CPU_VENDOR}" = "xAuthenticAMD" ; then
+		CPU_OPTIONS=${amd[[$CPU_FAMILY$CPU_MODEL]]}
+	fi
+	if test "x${CPU_VENDOR}" = "xCentaurHauls"; then
+		CPU_OPTIONS=${via[[$CPU_FAMILY$CPU_MODEL]]}
+	fi
+	if test "x${CPU_OPTIONS}" = "x" ; then
+		CPU_TYPE="unknown"
+	fi
+	CPU_EXT=""
+	for i in $CPU_FLAGS ; do
+		case $i in
+		fpu)
+			CPU_FPU="-mfpmath=387"
+			;;
+		mmx)
+			CPU_EXT="$CPU_EXT -mmmx"
+			;;
+		sse)
+			CPU_FPU="-mfpmath=sse -msse"
+			;;
+		sse2)
+			CPU_FPU="-mfpmath=sse -msse2"
+			;;
+		sse3)
+			CPU_FPU="-msse3"
+			;;
+		ssse3)
+			CPU_FPU="-mfpmath=sse -msse2 -mssse3"
+			;;
+		3dnow)
+			CPU_EXT="$CPU_EXT -m3dnow"
+			;;
+		esac
+	done
+	CPU_OPTIONS="$CPU_OPTIONS $CPU_FPU $CPU_EXT"
+fi
+if test "x${CPU_TYPE}" = "xunknown"; then
+	CPU_TYPE=`( uname -p ) 2>&1`
+	case $CPU_TYPE in
+	i386)
+		CPU_OPTIONS="-march=i386"
+		;;
+	i486)
+		CPU_OPTIONS="-march=i486"
+		;;
+	Pentium2)
+		CPU_OPTIONS="-march=pentium2"
+		;;
+	Pentiumpro)
+		CPU_OPTIONS="-march=pentiumpro"
+		;;
+	Pentium*)
+		CPU_OPTIONS="-march=pentium"
+		;;
+	k6)
+		CPU_OPTIONS="-march=k6"
+		;;
+	k6-2)
+		CPU_OPTIONS="-march=k6-2"
+		;;
+	k6-3)
+		CPU_OPTIONS="-march=k6-3"
+		;;
+	"VIA C3 Ezra")
+		CPU_OPTIONS="-march=c3"
+		CPU_TYPE="known"
+               ;;
+	*)
+		CPU_OPTIONS=""
+		CPU_TYPE="unknown"
+		;;
+	esac
+	if test "x${CPU_TYPE}" = "xunknown"; then
+		CPU_TYPE=`( uname -m ) 2>&1`
+		case $CPU_TYPE in
+		i386)
+			CPU_OPTIONS="-march=i386"
+			;;
+		i486)
+			CPU_OPTIONS="-march=i486"
+			;;
+		i586)
+			CPU_OPTIONS="-march=i586"
+			;;
+		i686)
+			CPU_OPTIONS="-march=i686"
+			;;
+		Pentium2)
+			CPU_OPTIONS="-march=pentium2"
+			;;
+		Pentiumpro)
+			CPU_OPTIONS="-march=pentiumpro"
+			;;
+		k6)
+			CPU_OPTIONS="-march=k6"
+			;;
+		k6-2)
+			CPU_OPTIONS="-march=k6-2"
+			;;
+		k6-3)
+			CPU_OPTIONS="-march=k6-3"
+			;;
+		*)
+			CPU_OPTIONS="-march=native -mtune=native"
+			;;
+		esac
+	fi
+fi
+echo "Detected CPU: $CPU_NAME"
+# Now we check if the compiler supports the detected cpu
+COMPILER=$CC
+for I in "$TMPDIR" "$TEMPDIR" "/tmp" ; do
+	test "$I" && break
+done
+TMPC="$I/cpu_test-$RANDOM-$$.c"
+TMPO="$I/cpu_test-$RANDOM-$$.o"
+cat > $TMPC << EOF
+int main(void) { return 0; }
+EOF
+( $COMPILER $CPU_OPTIONS -o $TMPO $TMPC ) 2>&1
+TMP="$?"
+rm -f $TMPO
+rm -f $TMPC
+
+
+if test "x${TMP}" = "x1" ; then
+	CPU_OPTIONS=""
+	echo "No CPU optimizations will be added"
+else
+	echo "CPU optimization: $CPU_OPTIONS"
+fi
+
+else
+	CPU_OPTIONS=""
+fi
+
+
+AC_MSG_CHECKING(for bswap instruction)
+AC_LINK_IFELSE([
+	AC_LANG_PROGRAM([ ],
+		[unsigned int __x=0;
+		register unsigned int __v;
+		__asm("bswap %0" : "=r" (__v) : "0" (__x));])
+	],
+	[
+		TEMP_CFLAGS="${TEMP_CFLAGS} -DHAVE_BSWAP"
+		AC_MSG_RESULT(yes)
+	],
+	[
+		AC_MSG_RESULT(no)
+	])
+
+
+if test "${DEVELOPER_FLAGS}" = "yes"; then
+	TEMP_CFLAGS="${TEMP_CFLAGS} -W -Wshadow -Wpointer-arith -Wcast-align -Wwrite-strings -Waggregate-return -Wstrict-prototypes -Wmissing-prototypes -Wnested-externs -Winline -Wredundant-decls -Wno-long-long -ggdb -g3"
+fi
+
+CFLAGS="${TEMP_CFLAGS} $UNAME_DEFS  $CPU_OPTIONS"
+
+LIBS="${TEMP_LIBS}"
+LDFLAGS="${TEMP_LDFLAGS}"
+
+
+#
+# Add the right exec path for rc scripts
+#
+if test $prefix = "NONE";then
+	BIN_PATH="$ac_default_prefix"
+	if test $exec_prefix = "NONE"; then
+		BIN_PATH="$BIN_PATH/bin"
+	else
+		BIN_PATH="$BIN_PATH/$bindir"
+	fi
+else
+	if test $exec_prefix = "NONE";then
+		BIN_PATH="$prefix/bin"
+	else
+		BIN_PATH="$prefix/$bindir"
+	fi
+fi
+
+
+AC_SUBST(BIN_PATH)
+
+AC_CONFIG_FILES([
+thread1.conf
+thread2.conf
+thread3.conf
+thread4.conf
+motion-dist.conf
+motion.init-FreeBSD.sh
+motion.init-Debian
+motion.init-Fedora
+motion.spec
+Makefile
+])
+AC_OUTPUT
+
+echo ""
+echo "   **************************"
+echo "      Configure status       "
+echo "      ${PACKAGE_NAME} ${PACKAGE_VERSION}"
+echo "   **************************"
+echo
+
+
+if test "${Darwin}" != ""; then
+    echo "OS             :     Darwin"
+elif test "${FreeBSD}" != ""; then
+    echo "OS             :     *BSD"
+else
+    echo "OS             :     Linux"
+fi
+
+if test "${PTHREAD_SUPPORT}" = "yes"; then
+    echo "pthread support:     Yes"
+else
+    echo "pthread support:     No"
+    echo "**********************************************"
+    echo "** Fatal Error YOU MUST HAVE pthread Support *"
+    echo "**********************************************"
+fi
+
+
+if test "${JPEG_SUPPORT_TURBO}" = "yes"; then
+    echo "jpeg turbo support:  Yes"
+elif test "${JPEG_SUPPORT_MMX}" = "yes"; then
+    echo "jpeg-mmx support:    Yes"
+elif test "${JPEG_SUPPORT}" = "yes"; then
+    echo "jpeg support:        Yes"
+else
+    echo "jpeg support:        No"
+    echo "**********************************************"
+    echo "** Fatal Error YOU MUST HAVE jpeg Support  ***"
+    echo "**********************************************"
+fi
+
+if test "${FreeBSD}" != ""; then
+	if test "${BKTR}" = "yes"; then
+        echo "BKTR included:       Yes"
+	else
+        echo "BKTR included:       No"
+	fi
+
+	if test "${PWCBSD}" = "yes"; then
+        echo "PWCBSD include:      Yes"
+	else
+        echo "PWCBSD include:      No"
+	fi
+
+else
+	if test "${V4L}" = "yes"; then
+        echo "V4L support:         Yes"
+	else
+        echo "V4L support:         No"
+	fi
+
+	if test x$SUPPORTED_V4L2 = xtrue; then
+        echo "V4L2 support:        Yes"
+	else
+        echo "V4L2 support:        No"
+	fi
+fi
+
+if test "${SDL_SUPPORT}" = "yes"; then
+	echo "SDL support:         Yes"
+else
+	echo "SDL support:         No"
+fi
+
+if test "${FFMPEG_OK}" = "found"; then
+    echo "FFmpeg support:      Yes"
+else
+    echo "FFmpeg support:      No"
+fi
+
+if test "${SQLITE3_SUPPORT}" = "yes"; then
+    echo "SQLite3 support:     Yes"
+else
+    echo "SQLite3 support:     No"
+fi
+
+if test "${MYSQL_SUPPORT}" = "yes"; then
+    echo "MYSQL support:       Yes"
+else
+    echo "MYSQL support:       No"
+fi
+
+if test "${PGSQL_SUPPORT}" = "yes"; then
+    echo "PostgreSQL support:  Yes"
+else
+    echo "PostgreSQL support:  No"
+fi
+echo
+echo "CFLAGS: $CFLAGS"
+echo "LIBS: $LIBS"
+echo "LDFLAGS: $LDFLAGS"
+echo
+echo  "Install prefix:       $prefix"
+echo
--- motion-3.2.12.orig/draw.c
+++ motion-3.2.12/draw.c
@@ -12,7 +12,7 @@
 #include <ctype.h>
 #include "motion.h"
 
-/* highest ascii value is 126 (~) */
+/* Highest ascii value is 126 (~) */
 #define ASCII_MAX 127
 
 unsigned char *small_char_arr_ptr[ASCII_MAX];
@@ -1075,8 +1075,10 @@ struct draw_char draw_table[]= {
 struct big_char big_table[sizeof(draw_table) / sizeof(struct draw_char)];
 
 #define NEWLINE "\\n"
-
-static int draw_textn (unsigned char *image, int startx, int starty, int width, const char *text, int len, unsigned short int factor)
+/**
+ * draw_textn
+ */ 
+static int draw_textn(unsigned char *image, unsigned int startx, unsigned int starty, unsigned int width, const char *text, int len, unsigned int factor)
 {
     int pos, x, y, line_offset, next_char_offs;
     unsigned char *image_ptr, *char_ptr, **char_arr_ptr;
@@ -1084,9 +1086,6 @@ static int draw_textn (unsigned char *im
     if (startx > width / 2)
         startx -= len * (6 * (factor + 1));
 
-    if (startx < 0)
-        startx = 0;
-    
     if (startx + len * 6 * (factor + 1) >= width)
         len = (width-startx-1)/(6*(factor+1));
     
@@ -1098,10 +1097,19 @@ static int draw_textn (unsigned char *im
     char_arr_ptr = factor ? big_char_arr_ptr : small_char_arr_ptr;
     
     for (pos = 0; pos < len; pos++) {
-        char_ptr = char_arr_ptr[(int)text[pos]];
+        int pos_check = (int)text[pos];
+
+        char_ptr = char_arr_ptr[pos_check];
 
         for (y = 8 * (factor + 1); y--;) {
             for (x = 7 * (factor + 1); x--;) {
+
+                if (pos_check < 0) {
+                    image_ptr++;
+                    char_ptr++;
+                    continue;
+                }                    
+                            
                 switch(*char_ptr) {
                 case 1:
                     *image_ptr = 0;
@@ -1124,13 +1132,16 @@ static int draw_textn (unsigned char *im
     return 0;
 }
 
-int draw_text (unsigned char *image, int startx, int starty, int width, const char *text, unsigned short int factor)
+/**
+ * draw_text 
+ */
+int draw_text(unsigned char *image, unsigned int startx, unsigned int starty, unsigned int width, const char *text, unsigned int factor)
 {
     int num_nl = 0;
     const char *end, *begin;
     const int line_space = (factor + 1) * 9;
     
-    /* Count the number of newlines in "text" so we scroll it up the image */
+    /* Count the number of newlines in "text" so we scroll it up the image. */
     end = text;
 
     while ((end = strstr(end, NEWLINE))) {
@@ -1139,6 +1150,7 @@ int draw_text (unsigned char *image, int
     }
 
     starty -= line_space * num_nl;
+    
     begin = end = text;
 
     while ((end = strstr(end, NEWLINE))) {
@@ -1155,6 +1167,9 @@ int draw_text (unsigned char *image, int
     return 0;
 }
 
+/**
+ * initialize_chars
+ */ 
 int initialize_chars(void)
 {
     unsigned int i, x, y;
@@ -1167,19 +1182,19 @@ int initialize_chars(void)
         big_table[i].ascii = draw_table[i].ascii;
 
         for(x = 0; x < 14; x++) {
-            for(y = 0; y < 16; y++) 
+            for(y = 0; y < 16; y++)
                 big_table[i].pix[y][x] = draw_table[i].pix[y / 2][x / 2];
             
         }
     }
 
-    /* first init all char ptr's to a space character */
+    /* First init all char ptr's to a space character. */
     for (i = 0; i < ASCII_MAX; i++) {
         small_char_arr_ptr[i] = &draw_table[0].pix[0][0];
         big_char_arr_ptr[i] = &big_table[0].pix[0][0];
     }
             
-    /* build [big_]char_arr_ptr table to point to each available ascii */
+    /* Build [big_]char_arr_ptr table to point to each available ascii. */
     for (i = 0; i < draw_table_size; i++) {
         small_char_arr_ptr[(int)draw_table[i].ascii] = &draw_table[i].pix[0][0];
         big_char_arr_ptr[(int)draw_table[i].ascii] = &big_table[i].pix[0][0];
--- motion-3.2.12.orig/event.c
+++ motion-3.2.12/event.c
@@ -6,34 +6,33 @@
     Copyright Jeroen Vreeken, 2002
     This software is distributed under the GNU Public License Version 2
     see also the file 'COPYING'.
-
 */
 
 #include "ffmpeg.h"    /* must be first to avoid 'shadow' warning */
-#include "picture.h"    /* already includes motion.h */
+#include "picture.h"   /* already includes motion.h */
 #include "event.h"
-#if !defined(BSD) 
+#if (!defined(BSD))
 #include "video.h"
 #endif
 
-/*
- *    Various functions (most doing the actual action)
- */
+/* Various functions (most doing the actual action) */
 
-/* Execute 'command' with 'arg' as its argument.
- * if !arg command is started with no arguments
- * Before we call execl we need to close all the file handles
- * that the fork inherited from the parent in order not to pass
- * the open handles on to the shell
+/**
+ * exec_command
+ *      Execute 'command' with 'arg' as its argument.
+ *      if !arg command is started with no arguments
+ *      Before we call execl we need to close all the file handles
+ *      that the fork inherited from the parent in order not to pass
+ *      the open handles on to the shell
  */
 static void exec_command(struct context *cnt, char *command, char *filename, int filetype)
 {
     char stamp[PATH_MAX];
     mystrftime(cnt, stamp, sizeof(stamp), command, &cnt->current_image->timestamp_tm, filename, filetype);
-    
+
     if (!fork()) {
         int i;
-        
+
         /* Detach from parent */
         setsid();
 
@@ -43,27 +42,30 @@ static void exec_command(struct context
          */
         for (i = getdtablesize(); i > 2; --i)
             close(i);
-        
+
         execl("/bin/sh", "sh", "-c", stamp, " &", NULL);
 
         /* if above function succeeds the program never reach here */
-        motion_log(LOG_ERR, 1, "Unable to start external command '%s'", stamp);
+        MOTION_LOG(ALR, TYPE_EVENTS, SHOW_ERRNO, "%s: Unable to start external command '%s'",
+                   stamp);
 
         exit(1);
-    } else if (cnt->conf.setup_mode) {
-        motion_log(-1, 0, "Executing external command '%s'", stamp);
-    }    
+    }
+
+    MOTION_LOG(DBG, TYPE_EVENTS, NO_ERRNO, "%s: Executing external command '%s'",
+               stamp);
 }
 
-/* 
- *    Event handlers
+/*
+ * Event handlers
  */
 
 static void event_newfile(struct context *cnt ATTRIBUTE_UNUSED,
             int type ATTRIBUTE_UNUSED, unsigned char *dummy ATTRIBUTE_UNUSED,
             char *filename, void *ftype, struct tm *tm ATTRIBUTE_UNUSED)
 {
-    motion_log(-1, 0, "File of type %ld saved to: %s", (unsigned long)ftype, filename);
+    MOTION_LOG(NTC, TYPE_EVENTS, NO_ERRNO, "%s: File of type %ld saved to: %s",
+               (unsigned long)ftype, filename);
 }
 
 
@@ -77,17 +79,19 @@ static void event_beep(struct context *c
         printf("\a");
 }
 
-/* on_picture_save_command handles both on_picture_save and on_movie_start
- * If arg = FTYPE_IMAGE_ANY on_picture_save script is executed
- * If arg = FTYPE_MPEG_ANY on_movie_start script is executed
- * The scripts are executed with the filename of picture or movie appended
- * to the config parameter.
+/**
+ * on_picture_save_command
+ *      handles both on_picture_save and on_movie_start
+ *      If arg = FTYPE_IMAGE_ANY on_picture_save script is executed
+ *      If arg = FTYPE_MPEG_ANY on_movie_start script is executed
+ *      The scripts are executed with the filename of picture or movie appended
+ *      to the config parameter.
  */
 static void on_picture_save_command(struct context *cnt,
             int type ATTRIBUTE_UNUSED, unsigned char *dummy ATTRIBUTE_UNUSED,
             char *filename, void *arg, struct tm *tm ATTRIBUTE_UNUSED)
 {
-    int filetype = (unsigned long)arg;    
+    int filetype = (unsigned long)arg;
 
     if ((filetype & FTYPE_IMAGE_ANY) != 0 && cnt->conf.on_picture_save)
         exec_command(cnt, cnt->conf.on_picture_save, filename, filetype);
@@ -105,7 +109,7 @@ static void on_motion_detected_command(s
         exec_command(cnt, cnt->conf.on_motion_detected, NULL, 0);
 }
 
-#if defined(HAVE_MYSQL) || defined(HAVE_PGSQL)
+#if defined(HAVE_MYSQL) || defined(HAVE_PGSQL) || defined(HAVE_SQLITE3)
 
 static void event_sqlnewfile(struct context *cnt, int type  ATTRIBUTE_UNUSED,
             unsigned char *dummy ATTRIBUTE_UNUSED,
@@ -114,66 +118,102 @@ static void event_sqlnewfile(struct cont
     int sqltype = (unsigned long)arg;
 
     /* Only log the file types we want */
-    if (!(cnt->conf.mysql_db || cnt->conf.pgsql_db) || (sqltype & cnt->sql_mask) == 0) 
+    if (!(cnt->conf.database_type) || (sqltype & cnt->sql_mask) == 0)
         return;
 
-    /* We place the code in a block so we only spend time making space in memory
+    /*
+     * We place the code in a block so we only spend time making space in memory
      * for the sqlquery and timestr when we actually need it.
      */
     {
         char sqlquery[PATH_MAX];
-    
-        mystrftime(cnt, sqlquery, sizeof(sqlquery), cnt->conf.sql_query, 
-                   &cnt->current_image->timestamp_tm, filename, sqltype);
-        
-#ifdef HAVE_MYSQL
-        if (cnt->conf.mysql_db) {
-            int ret;
 
-            ret = mysql_query(cnt->database, sqlquery);
+        mystrftime(cnt, sqlquery, sizeof(sqlquery), cnt->conf.sql_query,
+                   &cnt->current_image->timestamp_tm, filename, sqltype);
 
-            if (ret != 0) {
+#ifdef HAVE_MYSQL
+        if (!strcmp(cnt->conf.database_type, "mysql")) {
+            if (mysql_query(cnt->database, sqlquery) != 0) {
                 int error_code = mysql_errno(cnt->database);
-                
-                motion_log(LOG_ERR, 1, "Mysql query failed %s error code %d",
+
+                MOTION_LOG(ERR, TYPE_DB, SHOW_ERRNO, "%s: Mysql query failed %s error code %d",
                            mysql_error(cnt->database), error_code);
                 /* Try to reconnect ONCE if fails continue and discard this sql query */
                 if (error_code >= 2000) {
+                    // Close connection before start a new connection
+                    mysql_close(cnt->database);
+
                     cnt->database = (MYSQL *) mymalloc(sizeof(MYSQL));
                     mysql_init(cnt->database);
 
-                    if (!mysql_real_connect(cnt->database, cnt->conf.mysql_host, 
-                         cnt->conf.mysql_user, cnt->conf.mysql_password, 
-                         cnt->conf.mysql_db, 0, NULL, 0)) {
-                        motion_log(LOG_ERR, 0, "Cannot reconnect to MySQL database %s on host %s with user %s", 
-                                   cnt->conf.mysql_db, cnt->conf.mysql_host, cnt->conf.mysql_user);
-                        motion_log(LOG_ERR, 0, "MySQL error was %s", mysql_error(cnt->database));
-                    } else { 
-                        mysql_query(cnt->database, sqlquery);
-                    }    
-                }    
-                
-            }    
+                    if (!mysql_real_connect(cnt->database, cnt->conf.database_host,
+                                            cnt->conf.database_user, cnt->conf.database_password,
+                                            cnt->conf.database_dbname, 0, NULL, 0)) {
+                        MOTION_LOG(ALR, TYPE_DB, NO_ERRNO, "%s: Cannot reconnect to MySQL"
+                                   " database %s on host %s with user %s MySQL error was %s",
+                                   cnt->conf.database_dbname,
+                                   cnt->conf.database_host, cnt->conf.database_user,
+                                   mysql_error(cnt->database));
+                    } else {
+                        MOTION_LOG(INF, TYPE_DB, NO_ERRNO, "%s: Re-Connection to Mysql database '%s' Succeed",
+                                   cnt->conf.database_dbname);
+                        if (mysql_query(cnt->database, sqlquery) != 0) {
+                            int error_my = mysql_errno(cnt->database);
+                            MOTION_LOG(ERR, TYPE_DB, SHOW_ERRNO, "%s: after re-connection Mysql query failed %s error code %d",
+                                       mysql_error(cnt->database), error_my);
+                        }
+                    }
+                }
+            }
         }
 #endif /* HAVE_MYSQL */
 
 #ifdef HAVE_PGSQL
-        if (cnt->conf.pgsql_db) {
+        if (!strcmp(cnt->conf.database_type, "postgresql")) {
             PGresult *res;
 
             res = PQexec(cnt->database_pg, sqlquery);
 
-            if (PQresultStatus(res) != PGRES_COMMAND_OK) {
-                motion_log(LOG_ERR, 1, "PGSQL query failed");
+            if (PQstatus(cnt->database_pg) == CONNECTION_BAD) {
+
+                MOTION_LOG(ERR, TYPE_DB, NO_ERRNO, "%s: Connection to PostgreSQL database '%s' failed: %s",
+                           cnt->conf.database_dbname, PQerrorMessage(cnt->database_pg));
+                
+                // This function will close the connection to the server and attempt to reestablish a new connection to the same server, 
+                // using all the same parameters previously used. This may be useful for error recovery if a working connection is lost
+                PQreset(cnt->database_pg);
+
+                if (PQstatus(cnt->database_pg) == CONNECTION_BAD) {
+                    MOTION_LOG(ERR, TYPE_DB, NO_ERRNO, "%s: Re-Connection to PostgreSQL database '%s' failed: %s",
+                               cnt->conf.database_dbname, PQerrorMessage(cnt->database_pg));
+                } else {
+                    MOTION_LOG(INF, TYPE_DB, NO_ERRNO, "%s: Re-Connection to PostgreSQL database '%s' Succeed",
+                               cnt->conf.database_dbname);
+                }
+
+            } else if (PQresultStatus(res) != PGRES_COMMAND_OK) {
+                MOTION_LOG(ERR, TYPE_DB, SHOW_ERRNO, "%s: PGSQL query [%s] failed", sqlquery);
                 PQclear(res);
-            }
+            } 
         }
 #endif /* HAVE_PGSQL */
 
+#ifdef HAVE_SQLITE3
+        if ((!strcmp(cnt->conf.database_type, "sqlite3")) && (cnt->conf.sqlite3_db)) {
+            int res;
+            char *errmsg = 0;
+            res = sqlite3_exec(cnt->database_sqlite3, sqlquery, NULL, 0, &errmsg);
+            if (res != SQLITE_OK ) {
+                MOTION_LOG(ERR, TYPE_DB, NO_ERRNO, "%s: SQLite error was %s",
+                           errmsg);
+                sqlite3_free(errmsg);
+            }
+        }
+#endif /* HAVE_SQLITE3 */
     }
 }
 
-#endif /* defined HAVE_MYSQL || defined HAVE_PGSQL */
+#endif /* defined HAVE_MYSQL || defined HAVE_PGSQL || defined(HAVE_SQLITE3) */
 
 static void on_area_command(struct context *cnt, int type ATTRIBUTE_UNUSED,
             unsigned char *dummy1 ATTRIBUTE_UNUSED,
@@ -202,41 +242,50 @@ static void on_event_end_command(struct
         exec_command(cnt, cnt->conf.on_event_end, NULL, 0);
 }
 
-static void event_stop_webcam(struct context *cnt, int type ATTRIBUTE_UNUSED,
+static void event_stop_stream(struct context *cnt, int type ATTRIBUTE_UNUSED,
             unsigned char *dummy1 ATTRIBUTE_UNUSED,
             char *dummy2 ATTRIBUTE_UNUSED, void *dummy3 ATTRIBUTE_UNUSED,
             struct tm *tm ATTRIBUTE_UNUSED)
 {
-    if ((cnt->conf.webcam_port) && (cnt->webcam.socket != -1))
-        webcam_stop(cnt);
-    
+    if ((cnt->conf.stream_port) && (cnt->stream.socket != -1))
+        stream_stop(cnt);
 }
 
-static void event_webcam_put(struct context *cnt, int type ATTRIBUTE_UNUSED,
+static void event_stream_put(struct context *cnt, int type ATTRIBUTE_UNUSED,
             unsigned char *img, char *dummy1 ATTRIBUTE_UNUSED,
             void *dummy2 ATTRIBUTE_UNUSED, struct tm *tm ATTRIBUTE_UNUSED)
 {
-    if (cnt->conf.webcam_port)
-        webcam_put(cnt, img);
+    if (cnt->conf.stream_port)
+        stream_put(cnt, img);
 }
 
-#if !defined(WITHOUT_V4L) && !defined(BSD)
+#ifdef HAVE_SDL
+static void event_sdl_put(struct context *cnt, int type ATTRIBUTE_UNUSED,
+            unsigned char *img, char *dummy1 ATTRIBUTE_UNUSED,
+            void *dummy2 ATTRIBUTE_UNUSED, struct tm *tm ATTRIBUTE_UNUSED)
+{
+    sdl_put(img, cnt->imgs.width, cnt->imgs.height);
+}
+#endif
+
+
+#if defined(HAVE_LINUX_VIDEODEV_H) && !defined(WITHOUT_V4L) && !defined(BSD)
 static void event_vid_putpipe(struct context *cnt, int type ATTRIBUTE_UNUSED,
             unsigned char *img, char *dummy ATTRIBUTE_UNUSED, void *devpipe,
             struct tm *tm ATTRIBUTE_UNUSED)
 {
     if (*(int *)devpipe >= 0) {
         if (vid_putpipe(*(int *)devpipe, img, cnt->imgs.size) == -1)
-            motion_log(LOG_ERR, 1, "Failed to put image into video pipe");
+            MOTION_LOG(ERR, TYPE_EVENTS, SHOW_ERRNO, "%s: Failed to put image into video pipe");
     }
 }
-#endif /* WITHOUT_V4L && !BSD */
-
+#endif /* !WITHOUT_V4L && !BSD */
 
 const char *imageext(struct context *cnt)
 {
-    if (cnt->conf.ppm)
+    if (cnt->imgs.picture_type == IMAGE_TYPE_PPM)
         return "ppm";
+
     return "jpg";
 }
 
@@ -248,17 +297,20 @@ static void event_image_detect(struct co
     char filename[PATH_MAX];
 
     if (cnt->new_img & NEWIMG_ON) {
-        const char *jpegpath;
+        const char *imagepath;
 
-        /* conf.jpegpath would normally be defined but if someone deleted it by control interface
-           it is better to revert to the default than fail */
-        if (cnt->conf.jpegpath)
-            jpegpath = cnt->conf.jpegpath;
+        /*
+         *  conf.imagepath would normally be defined but if someone deleted it by control interface
+         *  it is better to revert to the default than fail
+         */
+        if (cnt->conf.imagepath)
+            imagepath = cnt->conf.imagepath;
         else
-            jpegpath = DEF_JPEGPATH;
-            
-        mystrftime(cnt, filename, sizeof(filename), jpegpath, currenttime_tm, NULL, 0);
+            imagepath = DEF_IMAGEPATH;
+
+        mystrftime(cnt, filename, sizeof(filename), imagepath, currenttime_tm, NULL, 0);
         snprintf(fullfilename, PATH_MAX, "%s/%s.%s", cnt->conf.filepath, filename, imageext(cnt));
+
         put_picture(cnt, fullfilename, newimg, FTYPE_IMAGE);
     }
 }
@@ -267,22 +319,24 @@ static void event_imagem_detect(struct c
             unsigned char *newimg ATTRIBUTE_UNUSED, char *dummy1 ATTRIBUTE_UNUSED,
             void *dummy2 ATTRIBUTE_UNUSED, struct tm *currenttime_tm)
 {
-    struct config *conf=&cnt->conf;
+    struct config *conf = &cnt->conf;
     char fullfilenamem[PATH_MAX];
     char filename[PATH_MAX];
     char filenamem[PATH_MAX];
 
     if (conf->motion_img) {
-        const char *jpegpath;
+        const char *imagepath;
 
-        /* conf.jpegpath would normally be defined but if someone deleted it by control interface
-           it is better to revert to the default than fail */
-        if (cnt->conf.jpegpath)
-            jpegpath = cnt->conf.jpegpath;
+        /*
+         *  conf.imagepath would normally be defined but if someone deleted it by control interface
+         *  it is better to revert to the default than fail
+         */
+        if (cnt->conf.imagepath)
+            imagepath = cnt->conf.imagepath;
         else
-            jpegpath = DEF_JPEGPATH;
-            
-        mystrftime(cnt, filename, sizeof(filename), jpegpath, currenttime_tm, NULL, 0);
+            imagepath = DEF_IMAGEPATH;
+
+        mystrftime(cnt, filename, sizeof(filename), imagepath, currenttime_tm, NULL, 0);
         /* motion images gets same name as normal images plus an appended 'm' */
         snprintf(filenamem, PATH_MAX, "%sm", filename);
         snprintf(fullfilenamem, PATH_MAX, "%s/%s.%s", cnt->conf.filepath, filenamem, imageext(cnt));
@@ -302,25 +356,30 @@ static void event_image_snapshot(struct
         char filepath[PATH_MAX];
         char linkpath[PATH_MAX];
         const char *snappath;
-        /* conf.snappath would normally be defined but if someone deleted it by control interface
-           it is better to revert to the default than fail */
+        /*
+         *  conf.snappath would normally be defined but if someone deleted it by control interface
+         *  it is better to revert to the default than fail
+         */
         if (cnt->conf.snappath)
             snappath = cnt->conf.snappath;
         else
             snappath = DEF_SNAPPATH;
-            
+
         mystrftime(cnt, filepath, sizeof(filepath), snappath, currenttime_tm, NULL, 0);
         snprintf(filename, PATH_MAX, "%s.%s", filepath, imageext(cnt));
         snprintf(fullfilename, PATH_MAX, "%s/%s", cnt->conf.filepath, filename);
         put_picture(cnt, fullfilename, img, FTYPE_IMAGE_SNAPSHOT);
 
-        /* Update symbolic link *after* image has been written so that
-           the link always points to a valid file. */
+        /*
+         *  Update symbolic link *after* image has been written so that
+         *  the link always points to a valid file.
+         */
         snprintf(linkpath, PATH_MAX, "%s/lastsnap.%s", cnt->conf.filepath, imageext(cnt));
         remove(linkpath);
 
         if (symlink(filename, linkpath)) {
-            motion_log(LOG_ERR, 1, "Could not create symbolic link [%s]", filename);
+            MOTION_LOG(ERR, TYPE_EVENTS, SHOW_ERRNO, "%s: Could not create symbolic link [%s]",
+                       filename);
             return;
         }
     } else {
@@ -340,13 +399,6 @@ static void event_camera_lost(struct con
         exec_command(cnt, cnt->conf.on_camera_lost, NULL, 0);
 }
 
-#ifdef HAVE_FFMPEG
-static void grey2yuv420p(unsigned char *u, unsigned char *v, int width, int height)
-{
-    memset(u, 128, width * height / 4);
-    memset(v, 128, width * height / 4);
-}
-
 static void on_movie_end_command(struct context *cnt, int type ATTRIBUTE_UNUSED,
                                  unsigned char *dummy ATTRIBUTE_UNUSED, char *filename,
                                  void *arg, struct tm *tm ATTRIBUTE_UNUSED)
@@ -357,6 +409,134 @@ static void on_movie_end_command(struct
         exec_command(cnt, cnt->conf.on_movie_end, filename, filetype);
 }
 
+static void event_extpipe_end(struct context *cnt, int type ATTRIBUTE_UNUSED,
+            unsigned char *dummy ATTRIBUTE_UNUSED, char *dummy1 ATTRIBUTE_UNUSED,
+            void *dummy2 ATTRIBUTE_UNUSED, struct tm *tm ATTRIBUTE_UNUSED)
+{
+    if (cnt->extpipe_open) {
+        cnt->extpipe_open = 0;
+        fflush(cnt->extpipe);
+        MOTION_LOG(NTC, TYPE_EVENTS, NO_ERRNO, "%s: CLOSING: extpipe file desc %d, error state %d",
+                   fileno(cnt->extpipe), ferror(cnt->extpipe));
+        MOTION_LOG(NTC, TYPE_EVENTS, NO_ERRNO, "%s: pclose return: %d",
+                   pclose(cnt->extpipe));
+        event(cnt, EVENT_FILECLOSE, NULL, cnt->extpipefilename, (void *)FTYPE_MPEG, NULL);
+    }
+}
+
+static void event_create_extpipe(struct context *cnt, int type ATTRIBUTE_UNUSED,
+            unsigned char *dummy ATTRIBUTE_UNUSED, char *dummy1 ATTRIBUTE_UNUSED,
+            void *dummy2 ATTRIBUTE_UNUSED, struct tm *currenttime_tm)
+{
+    if ((cnt->conf.useextpipe) && (cnt->conf.extpipe)) {
+        char stamp[PATH_MAX] = "";
+        const char *moviepath;
+        FILE *fd_dummy = NULL;
+
+        /*
+         *  conf.mpegpath would normally be defined but if someone deleted it by control interface
+         *  it is better to revert to the default than fail
+         */
+        if (cnt->conf.moviepath) {
+            moviepath = cnt->conf.moviepath;
+        } else {
+            moviepath = DEF_MOVIEPATH;
+            MOTION_LOG(NTC, TYPE_EVENTS, NO_ERRNO, "%s: moviepath: %s",
+                       moviepath);
+        }
+
+        mystrftime(cnt, stamp, sizeof(stamp), moviepath, currenttime_tm, NULL, 0);
+        snprintf(cnt->extpipefilename, PATH_MAX - 4, "%s/%s", cnt->conf.filepath, stamp);
+
+        /* Open a dummy file to check if path is correct */
+        fd_dummy = myfopen(cnt->extpipefilename, "w", 0);
+
+        /* TODO: trigger some warning instead of only log an error message */
+        if (fd_dummy == NULL) {
+            /* Permission denied */
+            if (errno ==  EACCES) {
+                MOTION_LOG(ERR, TYPE_EVENTS, SHOW_ERRNO, "%s: error opening file %s ..."
+                           "check access rights to target directory",
+                           cnt->extpipefilename);
+                return ;
+            } else {
+                MOTION_LOG(ERR, TYPE_EVENTS, SHOW_ERRNO, "%s: error opening file %s",
+                           cnt->extpipefilename);
+                return ;
+            }
+
+        }
+
+        myfclose(fd_dummy);
+        unlink(cnt->extpipefilename);
+
+        mystrftime(cnt, stamp, sizeof(stamp), cnt->conf.extpipe, currenttime_tm, cnt->extpipefilename, 0);
+
+        MOTION_LOG(NTC, TYPE_EVENTS, NO_ERRNO, "%s: pipe: %s",
+                   stamp);
+        MOTION_LOG(NTC, TYPE_EVENTS, NO_ERRNO, "%s: cnt->moviefps: %d",
+                   cnt->movie_fps);
+
+        event(cnt, EVENT_FILECREATE, NULL, cnt->extpipefilename, (void *)FTYPE_MPEG, NULL);
+        cnt->extpipe = popen(stamp, "w");
+
+        if (cnt->extpipe == NULL) {
+            MOTION_LOG(ERR, TYPE_EVENTS, SHOW_ERRNO, "%s: popen failed");
+            return;
+        }
+
+        setbuf(cnt->extpipe, NULL);
+        cnt->extpipe_open = 1;
+    }
+}
+
+static void event_extpipe_put(struct context *cnt, int type ATTRIBUTE_UNUSED,
+            unsigned char *img, char *dummy1 ATTRIBUTE_UNUSED,
+            void *dummy2 ATTRIBUTE_UNUSED, struct tm *tm ATTRIBUTE_UNUSED)
+{
+    /* Check use_extpipe enabled and ext_pipe not NULL */
+    if ((cnt->conf.useextpipe) && (cnt->extpipe != NULL)) {
+        MOTION_LOG(DBG, TYPE_EVENTS, NO_ERRNO, "%s:");
+
+        /* Check that is open */
+        if ((cnt->extpipe_open) && (fileno(cnt->extpipe) > 0)) {
+            if (!fwrite(img, cnt->imgs.size, 1, cnt->extpipe))
+                MOTION_LOG(ERR, TYPE_EVENTS, SHOW_ERRNO, "%s: Error writting in pipe , state error %d",
+                           ferror(cnt->extpipe));
+        } else {
+            MOTION_LOG(ERR, TYPE_EVENTS, NO_ERRNO, "%s: pipe %s not created or closed already ",
+                       cnt->extpipe);
+        }
+    }
+}
+
+
+static void event_new_video(struct context *cnt, int type ATTRIBUTE_UNUSED,
+            unsigned char *dummy ATTRIBUTE_UNUSED, char *dummy1 ATTRIBUTE_UNUSED,
+            void *dummy2 ATTRIBUTE_UNUSED, struct tm *tm ATTRIBUTE_UNUSED)
+{
+    cnt->movie_last_shot = -1;
+
+    cnt->movie_fps = cnt->lastrate;
+
+    MOTION_LOG(NTC, TYPE_EVENTS, NO_ERRNO, "%s FPS %d",
+               cnt->movie_fps);
+
+    if (cnt->movie_fps > 30)
+        cnt->movie_fps = 30;
+    else if (cnt->movie_fps < 2)
+        cnt->movie_fps = 2;
+}
+
+#ifdef HAVE_FFMPEG
+
+static void grey2yuv420p(unsigned char *u, unsigned char *v, int width, int height)
+{
+    memset(u, 128, width * height / 4);
+    memset(v, 128, width * height / 4);
+}
+
+
 static void event_ffmpeg_newfile(struct context *cnt, int type ATTRIBUTE_UNUSED,
             unsigned char *img, char *dummy1 ATTRIBUTE_UNUSED,
             void *dummy2 ATTRIBUTE_UNUSED, struct tm *currenttime_tm)
@@ -364,30 +544,33 @@ static void event_ffmpeg_newfile(struct
     int width = cnt->imgs.width;
     int height = cnt->imgs.height;
     unsigned char *convbuf, *y, *u, *v;
-    int fps = 0;
     char stamp[PATH_MAX];
-    const char *mpegpath;
+    const char *moviepath;
 
-    if (!cnt->conf.ffmpeg_cap_new && !cnt->conf.ffmpeg_cap_motion)
+    if (!cnt->conf.ffmpeg_output && !cnt->conf.ffmpeg_output_debug)
         return;
-        
-    /* conf.mpegpath would normally be defined but if someone deleted it by control interface
-       it is better to revert to the default than fail */
-    if (cnt->conf.mpegpath)
-        mpegpath = cnt->conf.mpegpath;
+
+    /*
+     *  conf.mpegpath would normally be defined but if someone deleted it by control interface
+     *  it is better to revert to the default than fail
+     */
+    if (cnt->conf.moviepath)
+        moviepath = cnt->conf.moviepath;
     else
-        mpegpath = DEF_MPEGPATH;
+        moviepath = DEF_MOVIEPATH;
 
-    mystrftime(cnt, stamp, sizeof(stamp), mpegpath, currenttime_tm, NULL, 0);
+    mystrftime(cnt, stamp, sizeof(stamp), moviepath, currenttime_tm, NULL, 0);
 
-    /* motion mpegs get the same name as normal mpegs plus an appended 'm' */
-    /* PATH_MAX - 4 to allow for .mpg to be appended without overflow */
+    /*
+     *  motion movies get the same name as normal movies plus an appended 'm'
+     *  PATH_MAX - 4 to allow for .mpg to be appended without overflow
+     */
     snprintf(cnt->motionfilename, PATH_MAX - 4, "%s/%sm", cnt->conf.filepath, stamp);
     snprintf(cnt->newfilename, PATH_MAX - 4, "%s/%s", cnt->conf.filepath, stamp);
 
-    if (cnt->conf.ffmpeg_cap_new) {
+    if (cnt->conf.ffmpeg_output) {
         if (cnt->imgs.type == VIDEO_PALETTE_GREY) {
-            convbuf=mymalloc((width * height) / 2);
+            convbuf = mymalloc((width * height) / 2);
             y = img;
             u = convbuf;
             v = convbuf + (width * height) / 4;
@@ -399,29 +582,21 @@ static void event_ffmpeg_newfile(struct
             v = u + (width * height) / 4;
         }
 
-        fps = cnt->lastrate;
-
-        if (debug_level >= CAMERA_DEBUG) 
-            motion_log(LOG_DEBUG, 0, "%s FPS %d",__FUNCTION__, fps);
-
-        if (fps > 30)
-            fps = 30;
-        else if (fps < 2)
-            fps = 2;
-
-        if ((cnt->ffmpeg_new =
-             ffmpeg_open((char *)cnt->conf.ffmpeg_video_codec, cnt->newfilename, y, u, v,
-                         cnt->imgs.width, cnt->imgs.height, fps, cnt->conf.ffmpeg_bps,
+        if ((cnt->ffmpeg_output =
+            ffmpeg_open((char *)cnt->conf.ffmpeg_video_codec, cnt->newfilename, y, u, v,
+                         cnt->imgs.width, cnt->imgs.height, cnt->movie_fps, cnt->conf.ffmpeg_bps,
                          cnt->conf.ffmpeg_vbr)) == NULL) {
-            motion_log(LOG_ERR, 1, "ffopen_open error creating (new) file [%s]",cnt->newfilename);
+            MOTION_LOG(ERR, TYPE_EVENTS, SHOW_ERRNO, "%s: ffopen_open error creating (new) file [%s]",
+                       cnt->newfilename);
             cnt->finish = 1;
             return;
         }
-        ((struct ffmpeg *)cnt->ffmpeg_new)->udata=convbuf;
+
+        ((struct ffmpeg *)cnt->ffmpeg_output)->udata = convbuf;
         event(cnt, EVENT_FILECREATE, NULL, cnt->newfilename, (void *)FTYPE_MPEG, NULL);
     }
 
-    if (cnt->conf.ffmpeg_cap_motion) {
+    if (cnt->conf.ffmpeg_output_debug) {
         if (cnt->imgs.type == VIDEO_PALETTE_GREY) {
             convbuf = mymalloc((width * height) / 2);
             y = cnt->imgs.out;
@@ -430,30 +605,22 @@ static void event_ffmpeg_newfile(struct
             grey2yuv420p(u, v, width, height);
         } else {
             y = cnt->imgs.out;
-            u = cnt->imgs.out + width * height;
+            u = cnt->imgs.out + width *height;
             v = u + (width * height) / 4;
             convbuf = NULL;
         }
 
-        if (debug_level >= CAMERA_DEBUG) 
-            motion_log(LOG_DEBUG, 0, "%s FPS %d", __FUNCTION__, fps);
-
-        fps = cnt->lastrate;
-
-        if (fps > 30)
-            fps = 30;
-        else if (fps < 2)
-            fps = 2;
-
-        if ((cnt->ffmpeg_motion =
-             ffmpeg_open((char *)cnt->conf.ffmpeg_video_codec, cnt->motionfilename, y, u, v,
-                         cnt->imgs.width, cnt->imgs.height, fps, cnt->conf.ffmpeg_bps,
+        if ((cnt->ffmpeg_output_debug =
+            ffmpeg_open((char *)cnt->conf.ffmpeg_video_codec, cnt->motionfilename, y, u, v,
+                         cnt->imgs.width, cnt->imgs.height, cnt->movie_fps, cnt->conf.ffmpeg_bps,
                          cnt->conf.ffmpeg_vbr)) == NULL) {
-            motion_log(LOG_ERR, 1, "ffopen_open error creating (motion) file [%s]", cnt->motionfilename);
+            MOTION_LOG(ERR, TYPE_EVENTS, SHOW_ERRNO, "%s: ffopen_open error creating (motion) file [%s]",
+                       cnt->motionfilename);
             cnt->finish = 1;
             return;
         }
-        cnt->ffmpeg_motion->udata = convbuf;
+
+        cnt->ffmpeg_output_debug->udata = convbuf;
         event(cnt, EVENT_FILECREATE, NULL, cnt->motionfilename, (void *)FTYPE_MPEG_MOTION, NULL);
     }
 }
@@ -471,23 +638,25 @@ static void event_ffmpeg_timelapse(struc
         char tmp[PATH_MAX];
         const char *timepath;
 
-        /* conf.timepath would normally be defined but if someone deleted it by control interface
-           it is better to revert to the default than fail */
+        /*
+         *  conf.timepath would normally be defined but if someone deleted it by control interface
+         *  it is better to revert to the default than fail
+         */
         if (cnt->conf.timepath)
             timepath = cnt->conf.timepath;
         else
             timepath = DEF_TIMEPATH;
-        
+
         mystrftime(cnt, tmp, sizeof(tmp), timepath, currenttime_tm, NULL, 0);
-        
+
         /* PATH_MAX - 4 to allow for .mpg to be appended without overflow */
         snprintf(cnt->timelapsefilename, PATH_MAX - 4, "%s/%s", cnt->conf.filepath, tmp);
-        
+
         if (cnt->imgs.type == VIDEO_PALETTE_GREY) {
             convbuf = mymalloc((width * height) / 2);
             y = img;
             u = convbuf;
-            v = convbuf+(width * height) / 4;
+            v = convbuf + (width * height) / 4;
             grey2yuv420p(u, v, width, height);
         } else {
             convbuf = NULL;
@@ -495,54 +664,65 @@ static void event_ffmpeg_timelapse(struc
             u = img + width * height;
             v = u + (width * height) / 4;
         }
-        
+
         if ((cnt->ffmpeg_timelapse =
-             ffmpeg_open((char *)TIMELAPSE_CODEC, cnt->timelapsefilename, y, u, v,
+            ffmpeg_open((char *)TIMELAPSE_CODEC, cnt->timelapsefilename, y, u, v,
                          cnt->imgs.width, cnt->imgs.height, 24, cnt->conf.ffmpeg_bps,
                          cnt->conf.ffmpeg_vbr)) == NULL) {
-            motion_log(LOG_ERR, 1, "ffopen_open error creating (timelapse) file [%s]", cnt->timelapsefilename);
+            MOTION_LOG(ERR, TYPE_EVENTS, SHOW_ERRNO, "%s: ffopen_open error creating "
+                       "(timelapse) file [%s]", cnt->timelapsefilename);
             cnt->finish = 1;
             return;
         }
-        
+
         cnt->ffmpeg_timelapse->udata = convbuf;
         event(cnt, EVENT_FILECREATE, NULL, cnt->timelapsefilename, (void *)FTYPE_MPEG_TIMELAPSE, NULL);
     }
-    
+
     y = img;
-    
+
     if (cnt->imgs.type == VIDEO_PALETTE_GREY)
         u = cnt->ffmpeg_timelapse->udata;
     else
         u = img + width * height;
-    
+
     v = u + (width * height) / 4;
-    ffmpeg_put_other_image(cnt->ffmpeg_timelapse, y, u, v);
-    
+
+    if (ffmpeg_put_other_image(cnt->ffmpeg_timelapse, y, u, v) == -1) {
+        cnt->finish = 1;
+        cnt->restart = 0;
+    }
+
 }
 
 static void event_ffmpeg_put(struct context *cnt, int type ATTRIBUTE_UNUSED,
             unsigned char *img, char *dummy1 ATTRIBUTE_UNUSED,
             void *dummy2 ATTRIBUTE_UNUSED, struct tm *tm ATTRIBUTE_UNUSED)
 {
-    if (cnt->ffmpeg_new) {
-        int width=cnt->imgs.width;
-        int height=cnt->imgs.height;
+    if (cnt->ffmpeg_output) {
+        int width = cnt->imgs.width;
+        int height = cnt->imgs.height;
         unsigned char *y = img;
         unsigned char *u, *v;
-        
+
         if (cnt->imgs.type == VIDEO_PALETTE_GREY)
             u = cnt->ffmpeg_timelapse->udata;
         else
             u = y + (width * height);
-        
+
         v = u + (width * height) / 4;
-        ffmpeg_put_other_image(cnt->ffmpeg_new, y, u, v);
+        if (ffmpeg_put_other_image(cnt->ffmpeg_output, y, u, v) == -1) {
+            cnt->finish = 1;
+            cnt->restart = 0;
+        }
+    }
+
+    if (cnt->ffmpeg_output_debug) {
+        if (ffmpeg_put_image(cnt->ffmpeg_output_debug) == -1) {
+            cnt->finish = 1;
+            cnt->restart = 0;
+        }
     }
-    
-    if (cnt->ffmpeg_motion) 
-        ffmpeg_put_image(cnt->ffmpeg_motion);
-    
 }
 
 static void event_ffmpeg_closefile(struct context *cnt,
@@ -550,22 +730,23 @@ static void event_ffmpeg_closefile(struc
             char *dummy2 ATTRIBUTE_UNUSED, void *dummy3 ATTRIBUTE_UNUSED,
             struct tm *tm ATTRIBUTE_UNUSED)
 {
-    
-    if (cnt->ffmpeg_new) {
-        if (cnt->ffmpeg_new->udata)
-            free(cnt->ffmpeg_new->udata);
-        ffmpeg_close(cnt->ffmpeg_new);
-        cnt->ffmpeg_new = NULL;
+
+    if (cnt->ffmpeg_output) {
+        if (cnt->ffmpeg_output->udata)
+            free(cnt->ffmpeg_output->udata);
+
+        ffmpeg_close(cnt->ffmpeg_output);
+        cnt->ffmpeg_output = NULL;
 
         event(cnt, EVENT_FILECLOSE, NULL, cnt->newfilename, (void *)FTYPE_MPEG, NULL);
     }
 
-    if (cnt->ffmpeg_motion) {
-        if (cnt->ffmpeg_motion->udata)
-            free(cnt->ffmpeg_motion->udata);
+    if (cnt->ffmpeg_output_debug) {
+        if (cnt->ffmpeg_output_debug->udata)
+            free(cnt->ffmpeg_output_debug->udata);
 
-        ffmpeg_close(cnt->ffmpeg_motion);
-        cnt->ffmpeg_motion = NULL;
+        ffmpeg_close(cnt->ffmpeg_output_debug);
+        cnt->ffmpeg_output_debug = NULL;
 
         event(cnt, EVENT_FILECLOSE, NULL, cnt->motionfilename, (void *)FTYPE_MPEG_MOTION, NULL);
     }
@@ -590,8 +771,8 @@ static void event_ffmpeg_timelapseend(st
 #endif /* HAVE_FFMPEG */
 
 
-/*  
- *    Starting point for all events
+/*
+ * Starting point for all events
  */
 
 struct event_handlers {
@@ -600,7 +781,7 @@ struct event_handlers {
 };
 
 struct event_handlers event_handlers[] = {
-#if defined(HAVE_MYSQL) || defined(HAVE_PGSQL) 
+#if defined(HAVE_MYSQL) || defined(HAVE_PGSQL) || defined(HAVE_SQLITE3)
     {
     EVENT_FILECREATE,
     event_sqlnewfile
@@ -646,15 +827,29 @@ struct event_handlers event_handlers[] =
     EVENT_IMAGE_SNAPSHOT,
     event_image_snapshot
     },
-#if !defined(WITHOUT_V4L) && !defined(BSD)
+#ifdef HAVE_SDL
     {
-    EVENT_IMAGE | EVENT_IMAGEM,
+    EVENT_SDL_PUT,
+    event_sdl_put
+    },
+#endif
+#if defined(HAVE_LINUX_VIDEODEV_H) && !defined(WITHOUT_V4L) && !defined(BSD)
+    {
+    EVENT_IMAGE,
     event_vid_putpipe
     },
-#endif /* WITHOUT_V4L && !BSD */
     {
-    EVENT_WEBCAM,
-    event_webcam_put
+    EVENT_IMAGEM,
+    event_vid_putpipe
+    },
+#endif /* !WITHOUT_V4L && !BSD */
+    {
+    EVENT_STREAM,
+    event_stream_put
+    },
+    {
+    EVENT_FIRSTMOTION,
+    event_new_video
     },
 #ifdef HAVE_FFMPEG
     {
@@ -666,6 +861,10 @@ struct event_handlers event_handlers[] =
     event_ffmpeg_put
     },
     {
+    EVENT_FFMPEG_PUT,
+    event_ffmpeg_put
+    },
+    {
     EVENT_ENDMOTION,
     event_ffmpeg_closefile
     },
@@ -677,39 +876,57 @@ struct event_handlers event_handlers[] =
     EVENT_TIMELAPSEEND,
     event_ffmpeg_timelapseend
     },
+#endif /* HAVE_FFMPEG */
     {
     EVENT_FILECLOSE,
     on_movie_end_command
     },
-#endif /* HAVE_FFMPEG */
+    {
+    EVENT_FIRSTMOTION,
+    event_create_extpipe
+    },
+    {
+    EVENT_IMAGE_DETECTED,
+    event_extpipe_put
+    },
+    {
+    EVENT_FFMPEG_PUT,
+    event_extpipe_put
+    },
+    {
+    EVENT_ENDMOTION,
+    event_extpipe_end
+    },
     {
     EVENT_CAMERA_LOST,
     event_camera_lost
     },
     {
     EVENT_STOP,
-    event_stop_webcam
+    event_stop_stream
     },
     {0, NULL}
 };
 
 
-/* The event functions are defined with the following parameters:
- * - Type as defined in event.h (EVENT_...)
- * - The global context struct cnt
- * - image - A pointer to unsigned char as used for images
- * - filename - A pointer to typically a string for a file path
- * - eventdata - A void pointer that can be cast to anything. E.g. FTYPE_...
- * - tm - A tm struct that carries a full time structure
+/**
+ * event
+ *   defined with the following parameters:
+ *      - Type as defined in event.h (EVENT_...)
+ *      - The global context struct cnt
+ *      - image - A pointer to unsigned char as used for images
+ *      - filename - A pointer to typically a string for a file path
+ *      - eventdata - A void pointer that can be cast to anything. E.g. FTYPE_...
+ *      - tm - A tm struct that carries a full time structure
  * The split between unsigned images and signed filenames was introduced in 3.2.2
  * as a code reading friendly solution to avoid a stream of compiler warnings in gcc 4.0.
  */
 void event(struct context *cnt, int type, unsigned char *image, char *filename, void *eventdata, struct tm *tm)
 {
-    int i = -1;
+    int i=-1;
 
     while (event_handlers[++i].handler) {
-        if (type & event_handlers[i].type)
+        if (type == event_handlers[i].type)
             event_handlers[i].handler(cnt, type, image, filename, eventdata, tm);
     }
 }
--- motion-3.2.12.orig/event.h
+++ motion-3.2.12/event.h
@@ -13,22 +13,25 @@
 
 #define EVENT_FILECREATE        1
 #define EVENT_MOTION            2
-#define EVENT_FIRSTMOTION       4
-#define EVENT_ENDMOTION         8
-#define EVENT_STOP              16
-#define EVENT_TIMELAPSE         32
-#define EVENT_TIMELAPSEEND      64
-#define EVENT_WEBCAM            128
-#define EVENT_IMAGE_DETECTED    256
-#define EVENT_IMAGEM_DETECTED   512
-#define EVENT_IMAGE_SNAPSHOT    1024
-#define EVENT_IMAGE             2048
-#define EVENT_IMAGEM            8192
-#define EVENT_FILECLOSE         16384
-#define EVENT_DEBUG             65536
-#define EVENT_CRITICAL          131072
-#define EVENT_AREA_DETECTED     262144
-#define EVENT_CAMERA_LOST       524288
+#define EVENT_FIRSTMOTION       3
+#define EVENT_ENDMOTION         4
+#define EVENT_STOP              5
+#define EVENT_TIMELAPSE         6
+#define EVENT_TIMELAPSEEND      7
+#define EVENT_STREAM            8
+#define EVENT_IMAGE_DETECTED    9
+#define EVENT_IMAGEM_DETECTED   10
+#define EVENT_IMAGE_SNAPSHOT    11
+#define EVENT_IMAGE             12
+#define EVENT_IMAGEM            13
+#define EVENT_FILECLOSE         14
+#define EVENT_DEBUG             15
+#define EVENT_CRITICAL          16
+#define EVENT_AREA_DETECTED     17
+#define EVENT_CAMERA_LOST       18
+#define EVENT_FFMPEG_PUT        19
+#define EVENT_SDL_PUT           20
+
 
 typedef void(* event_handler)(struct context *, int, unsigned char *, char *, void *, struct tm *);
 
--- motion-3.2.12.orig/ffmpeg.c
+++ motion-3.2.12/ffmpeg.c
@@ -1,14 +1,14 @@
-/**********************************************************************
+/*
  *
  * ffmpeg.c
  *
  * This software is distributed under the GNU Public License version 2
  * See also the file 'COPYING'.
  *
- * The contents of this file has been derived from output_example.c 
+ * The contents of this file has been derived from output_example.c
  * and apiexample.c from the FFmpeg distribution.
  *
- **********************************************************************/
+ */
 
 #ifdef HAVE_FFMPEG
 
@@ -16,37 +16,32 @@
 #include "motion.h"
 
 #if LIBAVCODEC_BUILD > 4680
-/* FFmpeg after build 4680 doesn't have support for mpeg1 videos with 
- * non-standard framerates. Previous builds contained a broken hack 
+/*
+ * FFmpeg after build 4680 doesn't have support for mpeg1 videos with
+ * non-standard framerates. Previous builds contained a broken hack
  * that padded with B frames to obtain the correct framerate.
  */
 #    define FFMPEG_NO_NONSTD_MPEG1
-#    ifdef __GNUC__
-/* #warning is a non-standard gcc extension */
-#        warning **************************************************
-#        warning Your version of FFmpeg is newer than version 0.4.8
-#        warning Newer versions of ffmpeg do not support MPEG1 with
-#        warning non-standard framerate. MPEG1 will be disabled for
-#        warning normal video output. You can still use mpeg4 and
-#        warning and mpeg4ms which are both better in terms of size
-#        warning and quality. MPEG1 is always used for timelapse.
-#        warning Please read the Motion Guide for more information.
-#        warning Note that this is not an error message!
-#        warning **************************************************
-#    endif /* __GNUC__ */
 #endif /* LIBAVCODEC_BUILD > 4680 */
 
+#if defined LIBAVFORMAT_VERSION_MAJOR && defined LIBAVFORMAT_VERSION_MINOR 
+#   if LIBAVFORMAT_VERSION_MAJOR < 53 && LIBAVFORMAT_VERSION_MINOR < 45
+#       define GUESS_NO_DEPRECATED 
+#   endif
+#endif
 
 #if LIBAVFORMAT_BUILD >= 4616
-/* The API for av_write_frame changed with FFmpeg version 0.4.9pre1.
+/*
+ * The API for av_write_frame changed with FFmpeg version 0.4.9pre1.
  * It now uses an AVPacket struct instead of direct parameters to the
- * function. The
+ * function.
  */
 #    define FFMPEG_AVWRITEFRAME_NEWAPI
 #endif /* LIBAVFORMAT_BUILD >= 4616 */
 
 #if LIBAVFORMAT_BUILD >= 4629
-/* In this build/header version, the codec member of struct AVStream
+/*
+ * In this build/header version, the codec member of struct AVStream
  * was changed to a pointer so changes to AVCodecContext shouldn't
  * break binary compatibility with AVStream.
  */
@@ -55,52 +50,83 @@
 #    define AVSTREAM_CODEC_PTR(avs_ptr) (&avs_ptr->codec)
 #endif /* LIBAVFORMAT_BUILD >= 4629 */
 
-/* Name of custom file protocol for appending to existing files instead
+// AV_VERSION_INT(a, b, c) (a<<16 | b<<8 | c) 
+// (54*2^16 | 6*2^8 | 100)
+#if LIBAVFORMAT_BUILD >= 3540580
+#define FF_API_NEW_AVIO
+#define URL_RDONLY  AVIO_FLAG_READ       /**< read-only */
+#define URL_WRONLY  AVIO_FLAG_WRITE      /**< write-only */
+#define URL_RDWR    AVIO_FLAG_READ_WRITE /**< read-write pseudo flag */
+#endif
+
+
+/*
+ * Name of custom file protocol for appending to existing files instead
  * of truncating.
  */
 #define APPEND_PROTO "appfile"
 
 /* Some forward-declarations. */
-void ffmpeg_put_frame(struct ffmpeg *, AVFrame *);
+int ffmpeg_put_frame(struct ffmpeg *, AVFrame *);
 void ffmpeg_cleanups(struct ffmpeg *);
-AVFrame *ffmpeg_prepare_frame(struct ffmpeg *, unsigned char *, 
+AVFrame *ffmpeg_prepare_frame(struct ffmpeg *, unsigned char *,
                               unsigned char *, unsigned char *);
 
 /* This is the trailer used to end mpeg1 videos. */
 static unsigned char mpeg1_trailer[] = {0x00, 0x00, 0x01, 0xb7};
 
-/* Append version of the file open function used in libavformat when opening
- * an ordinary file. The original file open function truncates an existing
- * file, but this version appends to it instead.
+
+// FFMPEG API changed in 0.8
+#if defined FF_API_NEW_AVIO
+
+// TODO 
+
+	
+#else
+
+/**
+ * file_open_append
+ *      Append version of the file open function used in libavformat when opening
+ *      an ordinary file. The original file open function truncates an existing
+ *      file, but this version appends to it instead.
+ *
+ *  Returns 0 on success and AVERROR(ENOENT) on error.
+ *
  */
 static int file_open_append(URLContext *h, const char *filename, int flags)
 {
     const char *colon;
-    int access_flags, fd;
+    const char *mode;
+    FILE *fh;
+    size_t bufsize = 0;
 
     /* Skip past the protocol part of filename. */
     colon = strchr(filename, ':');
-    if (colon) 
+
+    if (colon)
         filename = colon + 1;
-    
+
 
     if (flags & URL_RDWR) {
-        access_flags = O_CREAT | O_APPEND | O_RDWR;
+        mode = "ab+";
+        bufsize = BUFSIZE_1MEG;
     } else if (flags & URL_WRONLY) {
-        access_flags = O_CREAT | O_APPEND | O_WRONLY;
+        mode = "ab";
+        bufsize = BUFSIZE_1MEG;
     } else {
-        access_flags = O_RDONLY;
+        mode = "rb";
     }
 
-    fd = open(filename, access_flags, 0666);
-    if (fd < 0) 
+    fh = myfopen(filename, mode, bufsize);
+    if (fh == NULL)
         return AVERROR(ENOENT);
-    
-    h->priv_data = (void *)(size_t)fd;
+
+    h->priv_data = (void *)fh;
     return 0;
 }
 
-/* URLProtocol entry for the append file protocol, which we use for mpeg1 videos
+/*
+ * URLProtocol entry for the append file protocol, which we use for mpeg1 videos
  * in order to get append behavior with url_fopen.
  *
  * Libavformat uses protocols for achieving flexibility when handling files
@@ -117,134 +143,97 @@ URLProtocol mpeg1_file_protocol = {
 
 #ifdef HAVE_FFMPEG_NEW
 
-/*
- * file_procotol has been removed from avio.h
- * 
- */ 
-
+/* file_procotol has been removed from avio.h */
 #ifdef FFMPEG_NEW_INCLUDES
 #include <libavutil/avstring.h>
 #else
 #include "avstring.h"
 #endif
 
-static int file_open(URLContext *h, const char *filename, int flags)
-{
-    int access_flags, fd;
-                              
-    av_strstart(filename, "file:", &filename);
+#endif // HAVE_FFMPEG_NEW
 
-    if (flags & URL_RDWR) {
-        access_flags = O_CREAT | O_TRUNC | O_RDWR;
-    } else if (flags & URL_WRONLY) {
-        access_flags = O_CREAT | O_TRUNC | O_WRONLY;
-    } else {
-        access_flags = O_RDONLY;
-    }
-#ifdef O_BINARY
-    access_flags |= O_BINARY;
+#endif // FF_API_NEW_AVIO
+/****************************************************************************
+ *  The section below is the "my" section of functions.
+ *  These are designed to be extremely simple version specific
+ *  variants of the libav functions.
+ ****************************************************************************/
+AVFrame *my_frame_alloc(void){
+    AVFrame *pic;
+#if (LIBAVFORMAT_VERSION_MAJOR >= 55)
+    pic = av_frame_alloc();
+#else
+    pic = avcodec_alloc_frame();
 #endif
-    fd = open(filename, access_flags, 0666);
-    if (fd < 0)
-        return AVERROR(ENOENT);
-
-    h->priv_data = (void *)(size_t)fd;
-    return 0;
+    return pic;
 }
 
-static int file_read(URLContext *h, unsigned char *buf, int size)
-{
-    int fd = (size_t)h->priv_data;
-    return read(fd, buf, size);
-}
-         
-static int file_write(URLContext *h, unsigned char *buf, int size)
-{
-    int fd = (size_t)h->priv_data;
-    return write(fd, buf, size);
-}
-
-static int64_t file_seek(URLContext *h, int64_t pos, int whence)
-{
-    int fd = (size_t)h->priv_data;
-    return lseek(fd, pos, whence);
-}
-
-static int file_close(URLContext *h)
-{
-    int fd = (size_t)h->priv_data;
-    return close(fd);
-}
-
-URLProtocol file_protocol = {
-    "file",
-    file_open,
-    file_read,
-    file_write,
-    file_seek,
-    file_close,
-#if LIBAVFORMAT_BUILD >= (52<<16 | 31<<8)
-    NULL,
-    NULL,
-    NULL,
-#endif    
-};
-
+void my_frame_free(AVFrame *frame){
+#if (LIBAVFORMAT_VERSION_MAJOR >= 55)
+    av_frame_free(&frame);
+#else
+    //avcodec_free_frame(&frame);
+    //av_frame_free(&netcam->rtsp->frame);
+    av_freep(&frame);
 #endif
+}
 
-
-/* We set AVOutputFormat->write_trailer to this function for mpeg1. That way,
- * the mpeg1 video gets a proper trailer when it is closed.
+/****************************************************************************
+ ****************************************************************************
+ ****************************************************************************/
+
+/**
+ * mpeg1_write_trailer
+ *      We set AVOutputFormat->write_trailer to this function for mpeg1. That way,
+ *      the mpeg1 video gets a proper trailer when it is closed.
+ *
+ *  Returns 0
+ *
  */
 static int mpeg1_write_trailer(AVFormatContext *s)
 {
-#if LIBAVFORMAT_BUILD >= (52<<16) 
-    put_buffer(s->pb, mpeg1_trailer, 4);
-    put_flush_packet(s->pb);    
-#else
-    put_buffer(&s->pb, mpeg1_trailer, 4);
-    put_flush_packet(&s->pb);
-#endif /* LIBAVFORMAT_BUILD >= (52<<16) */
+    avio_write(s->pb, mpeg1_trailer, 4);
+    avio_flush(s->pb);
 
     return 0; /* success */
 }
 
-/* ffmpeg_init initializes for libavformat. */
+/**
+ * ffmpeg_init
+ *      Initializes for libavformat.
+ *
+ * Returns
+ *      Function returns nothing.
+ */
 void ffmpeg_init()
 {
-    motion_log(LOG_INFO, 0, "ffmpeg LIBAVCODEC_BUILD %d LIBAVFORMAT_BUILD %d", LIBAVCODEC_BUILD, LIBAVFORMAT_BUILD);
+    MOTION_LOG(NTC, TYPE_ENCODER, NO_ERRNO, "%s: ffmpeg LIBAVCODEC_BUILD %d"
+               " LIBAVFORMAT_BUILD %d", LIBAVCODEC_BUILD, 
+               LIBAVFORMAT_BUILD);
     av_register_all();
 
 #if LIBAVCODEC_BUILD > 4680
-    av_log_set_callback( (void *)ffmpeg_avcodec_log );
+    av_log_set_callback((void *)ffmpeg_avcodec_log);
+    av_log_set_level(AV_LOG_ERROR);
 #endif
 
-    /* Copy the functions to use for the append file protocol from the standard
-     * file protocol.
-     */
-    mpeg1_file_protocol.url_read  = file_protocol.url_read;
-    mpeg1_file_protocol.url_write = file_protocol.url_write;
-    mpeg1_file_protocol.url_seek  = file_protocol.url_seek;
-    mpeg1_file_protocol.url_close = file_protocol.url_close;
-
-    /* Register the append file protocol. */
-#if LIBAVFORMAT_BUILD >= (52<<16 | 31<<8)
-    av_register_protocol(&mpeg1_file_protocol);
-#else
-    register_protocol(&mpeg1_file_protocol);
-#endif
 }
 
-/* Obtains the output format used for the specified codec. For mpeg4 codecs,
- * the format is avi; for mpeg1 codec, the format is mpeg. The filename has
- * to be passed, because it gets the appropriate extension appended onto it.
+/**
+ * get_oformat
+ *      Obtains the output format used for the specified codec. For mpeg4 codecs,
+ *      the format is avi; for mpeg1 codec, the format is mpeg. The filename has
+ *      to be passed, because it gets the appropriate extension appended onto it.
+ *
+ *  Returns
+ *      AVOutputFormat pointer or NULL if any error happens.
  */
 static AVOutputFormat *get_oformat(const char *codec, char *filename)
 {
     const char *ext;
     AVOutputFormat *of = NULL;
-
-    /* Here, we use guess_format to automatically setup the codec information.
+    /*
+     * Here, we use guess_format to automatically setup the codec information.
      * If we are using msmpeg4, manually set that codec here.
      * We also dynamically add the file extension to the filename here. This was
      * done to support both mpeg1 and mpeg4 codecs since they have different extensions.
@@ -252,70 +241,118 @@ static AVOutputFormat *get_oformat(const
     if ((strcmp(codec, TIMELAPSE_CODEC) == 0)
 #ifndef FFMPEG_NO_NONSTD_MPEG1
         || (strcmp(codec, "mpeg1") == 0)
-#endif 
+#endif
     ) {
         ext = ".mpg";
-        /* We use "mpeg1video" for raw mpeg1 format. Using "mpeg" would
+        /*
+         * We use "mpeg1video" for raw mpeg1 format. Using "mpeg" would
          * result in a muxed output file, which isn't appropriate here.
          */
-        of = guess_format("mpeg1video", NULL, NULL);
-        if (of) {
-            /* But we want the trailer to be correctly written. */
+#ifdef GUESS_NO_DEPRECATED
+        of = guess_format("mpeg1video", NULL, NULL);        
+#else
+        of = av_guess_format("mpeg1video", NULL, NULL);
+#endif 
+        /* But we want the trailer to be correctly written. */
+        if (of)
             of->write_trailer = mpeg1_write_trailer;
-        }
+
 #ifdef FFMPEG_NO_NONSTD_MPEG1
     } else if (strcmp(codec, "mpeg1") == 0) {
-        motion_log(LOG_ERR, 0, "*** mpeg1 support for normal videos has been disabled ***");
+        MOTION_LOG(WRN, TYPE_ENCODER, NO_ERRNO, "%s: *** mpeg1 support for normal"
+                   " videos has been disabled ***");
         return NULL;
 #endif
     } else if (strcmp(codec, "mpeg4") == 0) {
         ext = ".avi";
-        of = guess_format("avi", NULL, NULL);
+#ifdef GUESS_NO_DEPRECATED
+        of = guess_format("mpeg1video", NULL, NULL);
+#else        
+        of = av_guess_format("avi", NULL, NULL);
+#endif        
     } else if (strcmp(codec, "msmpeg4") == 0) {
         ext = ".avi";
-        of = guess_format("avi", NULL, NULL);
-        if (of) {
-            /* Manually override the codec id. */
+#ifdef GUESS_NO_DEPRECATED
+        of = guess_format("mpeg1video", NULL, NULL);
+#else        
+        of = av_guess_format("avi", NULL, NULL);
+#endif
+        /* Manually override the codec id. */
+        if (of)
             of->video_codec = CODEC_ID_MSMPEG4V2;
-        }
+
     } else if (strcmp(codec, "swf") == 0) {
         ext = ".swf";
-        of = guess_format("swf", NULL, NULL);
+#ifdef GUESS_NO_DEPRECATED
+        of = guess_format("mpeg1video", NULL, NULL);
+#else        
+        of = av_guess_format("swf", NULL, NULL);
+#endif        
     } else if (strcmp(codec, "flv") == 0) {
         ext = ".flv";
-        of = guess_format("flv", NULL, NULL);
+#ifdef GUESS_NO_DEPRECATED
+        of = guess_format("mpeg1video", NULL, NULL);
+#else        
+        of = av_guess_format("flv", NULL, NULL);
+#endif        
         of->video_codec = CODEC_ID_FLV1;
     } else if (strcmp(codec, "ffv1") == 0) {
         ext = ".avi";
-        of = guess_format("avi", NULL, NULL);
-        if (of) {
-            /* Use the FFMPEG Lossless Video codec (experimental!).
-               Requires strict_std_compliance to be <= -2 */
+#ifdef GUESS_NO_DEPRECATED
+        of = guess_format("mpeg1video", NULL, NULL);
+#else
+        of = av_guess_format("avi", NULL, NULL);
+#endif
+        /*
+         * Use the FFMPEG Lossless Video codec (experimental!).
+         * Requires strict_std_compliance to be <= -2
+         */
+        if (of)
             of->video_codec = CODEC_ID_FFV1;
-        }
+
     } else if (strcmp(codec, "mov") == 0) {
         ext = ".mov";
-        of = guess_format("mov", NULL, NULL);        
+#ifdef GUESS_NO_DEPRECATED
+        of = guess_format("mpeg1video", NULL, NULL);
+#else        
+        of = av_guess_format("mov", NULL, NULL);
+#endif
+	    }
+  else if (strcmp (codec, "ogg") == 0)
+    {
+      ext = ".ogg";
+#ifdef GUESS_NO_DEPRECATED
+      of = guess_format ("ogg", NULL, NULL);
+#else
+      of = av_guess_format ("ogg", NULL, NULL);
+#endif
     } else {
-        motion_log(LOG_ERR, 0, "ffmpeg_video_codec option value %s is not supported", codec);
+        MOTION_LOG(ERR, TYPE_ENCODER, NO_ERRNO, "%s: ffmpeg_video_codec option value"
+                   " %s is not supported", codec);
         return NULL;
     }
 
     if (!of) {
-        motion_log(LOG_ERR, 0, "Could not guess format for %s", codec);
+        MOTION_LOG(ERR, TYPE_ENCODER, NO_ERRNO, "%s: Could not guess format for %s",
+                   codec);
         return NULL;
     }
 
-    /* The 4 allows for ".avi" or ".mpg" to be appended */
+    /* The 4 allows for ".avi" or ".mpg" to be appended. */
     strncat(filename, ext, 4);
 
     return of;
 }
 
-/* This function opens an mpeg file using the new libavformat method. Both mpeg1
- * and mpeg4 are supported. However, if the current ffmpeg version doesn't allow
- * mpeg1 with non-standard framerate, the open will fail. Timelapse is a special
- * case and is tested separately.
+/**
+ * ffmpeg_open
+ *      Opens an mpeg file using the new libavformat method. Both mpeg1
+ *      and mpeg4 are supported. However, if the current ffmpeg version doesn't allow
+ *      mpeg1 with non-standard framerate, the open will fail. Timelapse is a special
+ *      case and is tested separately.
+ *
+ *  Returns
+ *      A new allocated ffmpeg struct or NULL if any error happens.
  */
 struct ffmpeg *ffmpeg_open(char *ffmpeg_video_codec, char *filename,
                            unsigned char *y, unsigned char *u, unsigned char *v,
@@ -325,8 +362,9 @@ struct ffmpeg *ffmpeg_open(char *ffmpeg_
     AVCodec *codec;
     struct ffmpeg *ffmpeg;
     int is_mpeg1;
-
-    /* Allocate space for our ffmpeg structure. This structure contains all the 
+    int ret;
+    /*
+     * Allocate space for our ffmpeg structure. This structure contains all the
      * codec and image information we need to generate movies.
      * FIXME when motion exits we should close the movie to ensure that
      * ffmpeg is freed.
@@ -335,22 +373,26 @@ struct ffmpeg *ffmpeg_open(char *ffmpeg_
     memset(ffmpeg, 0, sizeof(struct ffmpeg));
 
     ffmpeg->vbr = vbr;
-    
-    /* store codec name in ffmpeg->codec, with buffer overflow check */
+
+    /* Store codec name in ffmpeg->codec, with buffer overflow check. */
     snprintf(ffmpeg->codec, sizeof(ffmpeg->codec), "%s", ffmpeg_video_codec);
 
-    /* allocation the output media context */
-    ffmpeg->oc = av_mallocz(sizeof(AVFormatContext));
+    /* Allocation the output media context. */
+#if (LIBAVFORMAT_VERSION_MAJOR >= 53)
+    ffmpeg->oc = avformat_alloc_context();
+#else
+    ffmpeg->oc = av_alloc_format_context();
+#endif
 
     if (!ffmpeg->oc) {
-        motion_log(LOG_ERR, 1, "Memory error while allocating output media context");
+        MOTION_LOG(ERR, TYPE_ENCODER, SHOW_ERRNO, "%s: Memory error while allocating"
+                   " output media context");
         ffmpeg_cleanups(ffmpeg);
         return NULL;
     }
 
     /* Setup output format */
     ffmpeg->oc->oformat = get_oformat(ffmpeg_video_codec, filename);
-
     if (!ffmpeg->oc->oformat) {
         ffmpeg_cleanups(ffmpeg);
         return NULL;
@@ -358,30 +400,35 @@ struct ffmpeg *ffmpeg_open(char *ffmpeg_
 
     snprintf(ffmpeg->oc->filename, sizeof(ffmpeg->oc->filename), "%s", filename);
 
-    /* Create a new video stream and initialize the codecs */
+    /* Create a new video stream and initialize the codecs. */
     ffmpeg->video_st = NULL;
-
     if (ffmpeg->oc->oformat->video_codec != CODEC_ID_NONE) {
-        ffmpeg->video_st = av_new_stream(ffmpeg->oc, 0);
+        ffmpeg->video_st = avformat_new_stream(ffmpeg->oc, NULL /* Codec */);
         if (!ffmpeg->video_st) {
-            motion_log(LOG_ERR, 1, "av_new_stream - could not alloc stream");
+            MOTION_LOG(ERR, TYPE_ENCODER, SHOW_ERRNO, "%s: av_new_stream - could"
+                       " not alloc stream");
             ffmpeg_cleanups(ffmpeg);
             return NULL;
         }
     } else {
         /* We did not get a proper video codec. */
-        motion_log(LOG_ERR, 0, "Failed to obtain a proper video codec");
+        MOTION_LOG(ERR, TYPE_ENCODER, NO_ERRNO, "%s: Failed to obtain a proper"
+                   " video codec");
         ffmpeg_cleanups(ffmpeg);
         return NULL;
     }
 
     ffmpeg->c     = c = AVSTREAM_CODEC_PTR(ffmpeg->video_st);
     c->codec_id   = ffmpeg->oc->oformat->video_codec;
+#if (LIBAVFORMAT_VERSION_MAJOR >= 53)
+    c->codec_type = AVMEDIA_TYPE_VIDEO;
+#else
     c->codec_type = CODEC_TYPE_VIDEO;
+#endif    
     is_mpeg1      = c->codec_id == CODEC_ID_MPEG1VIDEO;
 
     if (strcmp(ffmpeg_video_codec, "ffv1") == 0)
-        c->strict_std_compliance = -2; 
+        c->strict_std_compliance = -2;
 
     /* Uncomment to allow non-standard framerates. */
     //c->strict_std_compliance = -1;
@@ -391,7 +438,7 @@ struct ffmpeg *ffmpeg_open(char *ffmpeg_
     c->width    = width;
     c->height   = height;
 #if LIBAVCODEC_BUILD >= 4754
-    /* frame rate = 1/time_base, so we set 1/rate, not rate/1 */
+    /* Frame rate = 1/time_base, so we set 1/rate, not rate/1 */
     c->time_base.num = 1;
     c->time_base.den = rate;
 #else
@@ -399,54 +446,55 @@ struct ffmpeg *ffmpeg_open(char *ffmpeg_
     c->frame_rate_base = 1;
 #endif /* LIBAVCODEC_BUILD >= 4754 */
 
-    if (debug_level >= CAMERA_DEBUG)
-        motion_log(LOG_DEBUG, 0, "%s FPS %d",__FUNCTION__,rate);    
+    MOTION_LOG(INF, TYPE_ENCODER, NO_ERRNO, "%s FPS %d",
+               rate);
 
     if (vbr)
         c->flags |= CODEC_FLAG_QSCALE;
 
-    /* Set codec specific parameters. */
-    /* set intra frame distance in frames depending on codec */
+    /*
+     * Set codec specific parameters.
+     * Set intra frame distance in frames depending on codec.
+     */
     c->gop_size = is_mpeg1 ? 10 : 12;
-    
-    /* some formats want stream headers to be separate */
-    if (!strcmp(ffmpeg->oc->oformat->name, "mp4") || 
-       !strcmp(ffmpeg->oc->oformat->name, "mov") ||
-       !strcmp(ffmpeg->oc->oformat->name, "3gp")) {
-        c->flags |= CODEC_FLAG_GLOBAL_HEADER;
-    }
 
-    /* set the output parameters (must be done even if no parameters). */
-    if (av_set_parameters(ffmpeg->oc, NULL) < 0) {
-        motion_log(LOG_ERR, 0, "ffmpeg av_set_parameters error: Invalid output format parameters");
-        ffmpeg_cleanups(ffmpeg);
-        return NULL;
+    /* Some formats want stream headers to be separate. */
+    if (!strcmp(ffmpeg->oc->oformat->name, "mp4") ||
+        !strcmp(ffmpeg->oc->oformat->name, "mov") ||
+        !strcmp(ffmpeg->oc->oformat->name, "3gp")) {
+        c->flags |= CODEC_FLAG_GLOBAL_HEADER;
     }
 
-    /* Dump the format settings.  This shows how the various streams relate to each other */
+    /* Dump the format settings.  This shows how the various streams relate to each other. */
     //dump_format(ffmpeg->oc, 0, filename, 1);
 
-    /* Now that all the parameters are set, we can open the video
-        codec and allocate the necessary encode buffers */
+    /*
+     * Now that all the parameters are set, we can open the video
+     * codec and allocate the necessary encode buffers.
+     */
     codec = avcodec_find_encoder(c->codec_id);
 
     if (!codec) {
-        motion_log(LOG_ERR, 1, "Codec not found");
+        MOTION_LOG(ERR, TYPE_ENCODER, NO_ERRNO, "%s: Codec %s not found",
+                   ffmpeg_video_codec);
         ffmpeg_cleanups(ffmpeg);
         return NULL;
     }
-    
+
     /* Set the picture format - need in ffmpeg starting round April-May 2005 */
     c->pix_fmt = PIX_FMT_YUV420P;
 
     /* Get a mutex lock. */
     pthread_mutex_lock(&global_lock);
 
-    /* open the codec */
-    if (avcodec_open(c, codec) < 0) {
+    /* Open the codec */
+    ret = avcodec_open2(c, codec, NULL /* options */ );
+
+    if (ret < 0) {
         /* Release the lock. */
         pthread_mutex_unlock(&global_lock);
-        motion_log(LOG_ERR, 1, "avcodec_open - could not open codec");
+        MOTION_LOG(ERR, TYPE_ENCODER, NO_ERRNO, "%s: avcodec_open - could not open codec %s",
+                   ffmpeg_video_codec);
         ffmpeg_cleanups(ffmpeg);
         return NULL;
     }
@@ -454,30 +502,34 @@ struct ffmpeg *ffmpeg_open(char *ffmpeg_
     /* Release the lock. */
     pthread_mutex_unlock(&global_lock);
 
-
     ffmpeg->video_outbuf = NULL;
+
     if (!(ffmpeg->oc->oformat->flags & AVFMT_RAWPICTURE)) {
-        /* allocate output buffer */
-        /* XXX: API change will be done */
-        /* ffmpeg->video_outbuf_size = 20000; */
-        ffmpeg->video_outbuf_size = ffmpeg->c->width * 256; 
+        /*
+         * Allocate output buffer
+         * XXX: API change will be done
+         * ffmpeg->video_outbuf_size = 200000
+         */
+        ffmpeg->video_outbuf_size = ffmpeg->c->width * 512;
         ffmpeg->video_outbuf = mymalloc(ffmpeg->video_outbuf_size);
     }
 
-    /* allocate the encoded raw picture */
-    ffmpeg->picture = avcodec_alloc_frame();
+    /* Allocate the encoded raw picture. */
+    ffmpeg->picture = my_frame_alloc();
+
     if (!ffmpeg->picture) {
-        motion_log(LOG_ERR, 1, "avcodec_alloc_frame - could not alloc frame");
+        MOTION_LOG(ERR, TYPE_ENCODER, NO_ERRNO, "%s: avcodec_alloc_frame -"
+                   " could not alloc frame");
         ffmpeg_cleanups(ffmpeg);
         return NULL;
     }
 
-    /* set variable bitrate if requested */
-    if (ffmpeg->vbr) 
+    /* Set variable bitrate if requested. */
+    if (ffmpeg->vbr)
         ffmpeg->picture->quality = ffmpeg->vbr;
-    
 
-    /* set the frame data */
+
+    /* Set the frame data. */
     ffmpeg->picture->data[0] = y;
     ffmpeg->picture->data[1] = u;
     ffmpeg->picture->data[2] = v;
@@ -485,85 +537,89 @@ struct ffmpeg *ffmpeg_open(char *ffmpeg_
     ffmpeg->picture->linesize[1] = ffmpeg->c->width / 2;
     ffmpeg->picture->linesize[2] = ffmpeg->c->width / 2;
 
-    /* open the output file, if needed */
+    /* Open the output file, if needed. */
     if (!(ffmpeg->oc->oformat->flags & AVFMT_NOFILE)) {
         char file_proto[256];
 
-        /* Use append file protocol for mpeg1, to get the append behavior from 
+        /*
+         * Use append file protocol for mpeg1, to get the append behavior from
          * url_fopen, but no protocol (=> default) for other codecs.
          */
-        if (is_mpeg1) 
+        if (is_mpeg1)
+#if defined FF_API_NEW_AVIO
+            snprintf(file_proto, sizeof(file_proto), "%s", filename);
+#else
             snprintf(file_proto, sizeof(file_proto), APPEND_PROTO ":%s", filename);
-        else 
+#endif
+        else
             snprintf(file_proto, sizeof(file_proto), "%s", filename);
-        
 
-        if (url_fopen(&ffmpeg->oc->pb, file_proto, URL_WRONLY) < 0) {
-            /* path did not exist? */
+
+        if (avio_open(&ffmpeg->oc->pb, file_proto, URL_WRONLY) < 0) {
+            /* Path did not exist? */
             if (errno == ENOENT) {
-                /* create path for file (don't use file_proto)... */
+                /* Create path for file (don't use file_proto)... */
                 if (create_path(filename) == -1) {
                     ffmpeg_cleanups(ffmpeg);
                     return NULL;
                 }
 
-                /* and retry opening the file (use file_proto) */
-                if (url_fopen(&ffmpeg->oc->pb, file_proto, URL_WRONLY) < 0) {
-                    motion_log(LOG_ERR, 1, "url_fopen - error opening file %s",filename);
+                if (avio_open(&ffmpeg->oc->pb, file_proto, URL_WRONLY) < 0) {
+                    MOTION_LOG(ERR, TYPE_ENCODER, SHOW_ERRNO, "%s: url_fopen -"
+                               " error opening file %s", filename);
                     ffmpeg_cleanups(ffmpeg);
                     return NULL;
                 }
                 /* Permission denied */
             } else if (errno ==  EACCES) {
-                motion_log(LOG_ERR, 1,
-                           "url_fopen - error opening file %s"
-                           " ... check access rights to target directory", filename);
+                MOTION_LOG(ERR, TYPE_ENCODER, SHOW_ERRNO,
+                           "%s: url_fopen - error opening file %s"
+                           " ... check access rights to target directory",
+                           filename);
                 ffmpeg_cleanups(ffmpeg);
                 return NULL;
             } else {
-                motion_log(LOG_ERR, 1, "Error opening file %s", filename);
+                MOTION_LOG(ERR, TYPE_ENCODER, SHOW_ERRNO, "%s: Error opening file %s",
+                           filename);
                 ffmpeg_cleanups(ffmpeg);
                 return NULL;
             }
         }
     }
 
-    /* write the stream header, if any */
-    av_write_header(ffmpeg->oc);
-    
+    /* Write the stream header, if any. */
+    avformat_write_header(ffmpeg->oc, NULL);
     return ffmpeg;
 }
 
-/*
-  Clean up ffmpeg struct if something was wrong
-*/
+/**
+ * ffmpeg_cleanups
+ *      Clean up ffmpeg struct if something was wrong.
+ *
+ * Returns
+ *      Function returns nothing.
+ */
 void ffmpeg_cleanups(struct ffmpeg *ffmpeg)
 {
     unsigned int i;
 
-    /* close each codec */
+    /* Close each codec */
     if (ffmpeg->video_st) {
         pthread_mutex_lock(&global_lock);
 #if LIBAVCODEC_BUILD > 4680
         if (ffmpeg->video_st->codec->priv_data != NULL)
 #endif
             avcodec_close(AVSTREAM_CODEC_PTR(ffmpeg->video_st));
-        pthread_mutex_unlock(&global_lock);    
+        pthread_mutex_unlock(&global_lock);
         av_freep(&ffmpeg->picture);
         free(ffmpeg->video_outbuf);
     }
 
-    /* free the streams */
-    for (i = 0; i < ffmpeg->oc->nb_streams; i++) 
+    /* Free the streams */
+    for (i = 0; i < ffmpeg->oc->nb_streams; i++)
         av_freep(&ffmpeg->oc->streams[i]);
-    
-/*
-        if (!(ffmpeg->oc->oformat->flags & AVFMT_NOFILE)) {
-            // close the output file 
-            if (ffmpeg->oc->pb) url_fclose(&ffmpeg->oc->pb);
-        }
-*/
-    /* free the stream */
+
+    /* Free the stream */
     av_free(ffmpeg->oc);
 #if LIBAVFORMAT_BUILD >= 4629
     av_free(ffmpeg->c);
@@ -571,12 +627,18 @@ void ffmpeg_cleanups(struct ffmpeg *ffmp
     free(ffmpeg);
 }
 
-/* Closes a video file. */
+/**
+ * ffmpeg_close
+ *      Closes a video file.
+ *
+ * Returns
+ *      Function returns nothing.
+ */
 void ffmpeg_close(struct ffmpeg *ffmpeg)
 {
     unsigned int i;
 
-    /* close each codec */
+    /* Close each codec */
     if (ffmpeg->video_st) {
         pthread_mutex_lock(&global_lock);
         avcodec_close(AVSTREAM_CODEC_PTR(ffmpeg->video_st));
@@ -585,24 +647,20 @@ void ffmpeg_close(struct ffmpeg *ffmpeg)
         free(ffmpeg->video_outbuf);
     }
 
-    /* write the trailer, if any */
+    /* Write the trailer, if any. */
     av_write_trailer(ffmpeg->oc);
 
-    /* free the streams */
-    for (i = 0; i < ffmpeg->oc->nb_streams; i++) 
+    /* Free the streams. */
+    for (i = 0; i < ffmpeg->oc->nb_streams; i++)
         av_freep(&ffmpeg->oc->streams[i]);
-    
 
     if (!(ffmpeg->oc->oformat->flags & AVFMT_NOFILE)) {
-        /* close the output file */
-#if LIBAVFORMAT_BUILD >= (52<<16) 
-        url_fclose(ffmpeg->oc->pb);
-#else
-        url_fclose(&ffmpeg->oc->pb);
-#endif /* LIBAVFORMAT_BUILD >= (52<<16) */
+        /* Close the output file. */
+        avio_close(ffmpeg->oc->pb);
     }
 
-    /* free the stream */
+
+    /* Free the stream. */
     av_free(ffmpeg->oc);
 #if LIBAVFORMAT_BUILD >= 4629
     av_free(ffmpeg->c);
@@ -610,43 +668,72 @@ void ffmpeg_close(struct ffmpeg *ffmpeg)
     free(ffmpeg);
 }
 
-/* Puts the image pointed to by ffmpeg->picture. */
-void ffmpeg_put_image(struct ffmpeg *ffmpeg) 
+/**
+ * ffmpeg_put_image
+ *      Puts the image pointed to by ffmpeg->picture.
+ *
+ * Returns
+ *      value returned by ffmpeg_put_frame call.
+ */
+int ffmpeg_put_image(struct ffmpeg *ffmpeg)
 {
-    ffmpeg_put_frame(ffmpeg, ffmpeg->picture);
+    return ffmpeg_put_frame(ffmpeg, ffmpeg->picture);
 }
 
-/* Puts an arbitrary picture defined by y, u and v. */
-void ffmpeg_put_other_image(struct ffmpeg *ffmpeg, unsigned char *y,
+/**
+ * ffmpeg_put_other_image
+ *      Puts an arbitrary picture defined by y, u and v.
+ *
+ * Returns
+ *      Number of bytes written by ffmpeg_put_frame
+ *      -1 if any error happens in ffmpeg_put_frame
+ *       0 if error allocating picture.
+ */
+int ffmpeg_put_other_image(struct ffmpeg *ffmpeg, unsigned char *y,
                             unsigned char *u, unsigned char *v)
 {
     AVFrame *picture;
-    /* allocate the encoded raw picture */
+    int ret = 0;
+
+    /* Allocate the encoded raw picture. */
     picture = ffmpeg_prepare_frame(ffmpeg, y, u, v);
 
     if (picture) {
-        ffmpeg_put_frame(ffmpeg, picture);
-        av_free(picture);
+        ret = ffmpeg_put_frame(ffmpeg, picture);
+        if (!ret)
+            av_free(picture);
     }
+
+    return ret;
 }
 
-/* Encodes and writes a video frame using the av_write_frame API. This is
- * a helper function for ffmpeg_put_image and ffmpeg_put_other_image. 
+/**
+ * ffmpeg_put_frame
+ *      Encodes and writes a video frame using the av_write_frame API. This is
+ *      a helper function for ffmpeg_put_image and ffmpeg_put_other_image.
+ *
+ *  Returns
+ *      Number of bytes written or -1 if any error happens.
  */
-void ffmpeg_put_frame(struct ffmpeg *ffmpeg, AVFrame *pic)
+int ffmpeg_put_frame(struct ffmpeg *ffmpeg, AVFrame *pic)
 {
     int out_size, ret;
+
 #ifdef FFMPEG_AVWRITEFRAME_NEWAPI
     AVPacket pkt;
 
-    av_init_packet(&pkt); /* init static structure */
+    av_init_packet(&pkt); /* Init static structure. */
     pkt.stream_index = ffmpeg->video_st->index;
 #endif /* FFMPEG_AVWRITEFRAME_NEWAPI */
 
     if (ffmpeg->oc->oformat->flags & AVFMT_RAWPICTURE) {
-        /* raw video case. The API will change slightly in the near future for that */
+        /* Raw video case. The API will change slightly in the near future for that. */
 #ifdef FFMPEG_AVWRITEFRAME_NEWAPI
+#   if LIBAVCODEC_VERSION_MAJOR < 53        
         pkt.flags |= PKT_FLAG_KEY;
+#   else
+        pkt.flags |= AV_PKT_FLAG_KEY;  
+#   endif        
         pkt.data = (uint8_t *)pic;
         pkt.size = sizeof(AVPicture);
         ret = av_write_frame(ffmpeg->oc, &pkt);
@@ -655,62 +742,91 @@ void ffmpeg_put_frame(struct ffmpeg *ffm
             (uint8_t *)pic, sizeof(AVPicture));
 #endif /* FFMPEG_AVWRITEFRAME_NEWAPI */
     } else {
-        /* encode the image */
+        /* Encodes the image. */
+#if defined FF_API_NEW_AVIO
+
+        int got_packet_ptr;
+        pkt.data = ffmpeg->video_outbuf;
+        pkt.size = ffmpeg->video_outbuf_size;
+
+        out_size = avcodec_encode_video2(AVSTREAM_CODEC_PTR(ffmpeg->video_st), 
+                                        &pkt, pic, &got_packet_ptr);
+        if (out_size < 0)
+            // Error encondig 
+            out_size = 0;
+        else
+            out_size = pkt.size;
+#else
         out_size = avcodec_encode_video(AVSTREAM_CODEC_PTR(ffmpeg->video_st),
-                                        ffmpeg->video_outbuf, 
+                                        ffmpeg->video_outbuf,
                                         ffmpeg->video_outbuf_size, pic);
-
-        /* if zero size, it means the image was buffered */
+#endif
+        /* If zero size, it means the image was buffered. */
         if (out_size != 0) {
-            /* write the compressed frame in the media file */
-            /* XXX: in case of B frames, the pts is not yet valid */
+            /*
+             * Writes the compressed frame in the media file.
+             * XXX: in case of B frames, the pts is not yet valid.
+             */
 #ifdef FFMPEG_AVWRITEFRAME_NEWAPI
             pkt.pts = AVSTREAM_CODEC_PTR(ffmpeg->video_st)->coded_frame->pts;
-            if (AVSTREAM_CODEC_PTR(ffmpeg->video_st)->coded_frame->key_frame) {
+
+            if (AVSTREAM_CODEC_PTR(ffmpeg->video_st)->coded_frame->key_frame)
+#   if LIBAVCODEC_VERSION_MAJOR < 53                
                 pkt.flags |= PKT_FLAG_KEY;
-            }
+#   else
+                pkt.flags |= AV_PKT_FLAG_KEY;
+#   endif                
+
             pkt.data = ffmpeg->video_outbuf;
             pkt.size = out_size;
             ret = av_write_frame(ffmpeg->oc, &pkt);
 #else
-            ret = av_write_frame(ffmpeg->oc, ffmpeg->video_st->index, 
+            ret = av_write_frame(ffmpeg->oc, ffmpeg->video_st->index,
                                  ffmpeg->video_outbuf, out_size);
 #endif /* FFMPEG_AVWRITEFRAME_NEWAPI */
+
         } else {
             ret = 0;
         }
     }
-    
+
     if (ret != 0) {
-        motion_log(LOG_ERR, 1, "Error while writing video frame");
-        return;
+        MOTION_LOG(ERR, TYPE_ENCODER, SHOW_ERRNO, "%s: Error while writing"
+                   " video frame");
+        ffmpeg_cleanups(ffmpeg);
+        return -1;
     }
+
+    return ret;
 }
 
-/* Allocates and prepares a picture frame by setting up the U, Y and V pointers in
- * the frame according to the passed pointers.
+/**
+ * ffmpeg_prepare_frame
+ *      Allocates and prepares a picture frame by setting up the U, Y and V pointers in
+ *      the frame according to the passed pointers.
  *
- * Returns NULL If the allocation fails.
+ * Returns
+ *      NULL If the allocation fails.
  *
- * The returned AVFrame pointer must be freed after use.
+ *      The returned AVFrame pointer must be freed after use.
  */
 AVFrame *ffmpeg_prepare_frame(struct ffmpeg *ffmpeg, unsigned char *y,
                               unsigned char *u, unsigned char *v)
 {
     AVFrame *picture;
 
-    picture = avcodec_alloc_frame();
+    picture = my_frame_alloc();
+
     if (!picture) {
-        motion_log(LOG_ERR, 1, "Could not alloc frame");
+        MOTION_LOG(ERR, TYPE_ENCODER, SHOW_ERRNO, "%s: Could not alloc frame");
         return NULL;
     }
 
-    /* take care of variable bitrate setting */
-    if (ffmpeg->vbr) 
+    /* Take care of variable bitrate setting. */
+    if (ffmpeg->vbr)
         picture->quality = ffmpeg->vbr;
-    
-    
-    /* setup pointers and line widths */
+
+    /* Setup pointers and line widths. */
     picture->data[0] = y;
     picture->data[1] = u;
     picture->data[2] = v;
@@ -722,9 +838,10 @@ AVFrame *ffmpeg_prepare_frame(struct ffm
 }
 
 
-/** ffmpeg_deinterlace
+/**
+ * ffmpeg_deinterlace
  *      Make the image suitable for deinterlacing using ffmpeg, then deinterlace the picture.
- * 
+ *
  * Parameters
  *      img     image in YUV420P format
  *      width   image width in pixels
@@ -736,33 +853,35 @@ AVFrame *ffmpeg_prepare_frame(struct ffm
  */
 void ffmpeg_deinterlace(unsigned char *img, int width, int height)
 {
-    AVFrame *picture;
+    AVPicture picture;
     int width2 = width / 2;
-    
-    picture = avcodec_alloc_frame();
-    if (!picture) {
-        motion_log(LOG_ERR, 1, "Could not alloc frame");
-        return;
-    }
-    
-    picture->data[0] = img;
-    picture->data[1] = img+width*height;
-    picture->data[2] = picture->data[1]+(width*height)/4;
-    picture->linesize[0] = width;
-    picture->linesize[1] = width2;
-    picture->linesize[2] = width2;
-    
+
+    picture.data[0] = img;
+    picture.data[1] = img + width * height;
+    picture.data[2] = picture.data[1] + (width * height) / 4;
+    picture.linesize[0] = width;
+    picture.linesize[1] = width2;
+    picture.linesize[2] = width2;
+
     /* We assume using 'PIX_FMT_YUV420P' always */
-    avpicture_deinterlace((AVPicture *)picture, (AVPicture *)picture, PIX_FMT_YUV420P, width, height);
-    
-    av_free(picture);
-    
+#if (LIBAVFORMAT_VERSION_MAJOR >= 53)
+    MOTION_LOG(ALR, TYPE_NETCAM, NO_ERRNO, "%s: Deinterlace depreciated for recent versions of FFMPEG.");
+#else
+    avpicture_deinterlace(&picture, &picture, PIX_FMT_YUV420P, width, height);
+#endif
+
+
+#if !defined(__SSE_MATH__) && (defined(__i386__) || defined(__x86_64__))
+    __asm__ __volatile__ ( "emms");
+#endif
+
     return;
 }
 
-/** ffmpeg_avcodec_log
+/**
+ * ffmpeg_avcodec_log
  *      Handle any logging output from the ffmpeg library avcodec.
- * 
+ *
  * Parameters
  *      *ignoreme  A pointer we will ignore
  *      errno_flag The error number value
@@ -776,15 +895,12 @@ void ffmpeg_avcodec_log(void *ignoreme A
 {
     char buf[1024];
 
-    /* Do not log the message coming from avcodec if the debug_level is not set. */
-    if (debug_level) {
+    /* Flatten the message coming in from avcodec. */
+    vsnprintf(buf, sizeof(buf), fmt, vl);
 
-        /* Flatten the message coming in from avcodec */
-        vsnprintf(buf, sizeof(buf), fmt, vl);
-
-        /* If the debug_level is correct then send the message to the motion logging routine. */
-        motion_log(LOG_ERR, 0, "ffmpeg_avcodec_log: %s - flag %d", buf, errno_flag);
-    }
+    /* If the debug_level is correct then send the message to the motion logging routine. */
+    MOTION_LOG(INF, TYPE_ENCODER, NO_ERRNO, "%s: %s - flag %d",
+               buf, errno_flag);
 }
 
 #endif /* HAVE_FFMPEG */
--- motion-3.2.12.orig/ffmpeg.h
+++ motion-3.2.12/ffmpeg.h
@@ -29,7 +29,8 @@
 #include <stdio.h>
 #include <stdarg.h>
 
-/* Define a codec name/identifier for timelapse videos, so that we can
+/* 
+ * Define a codec name/identifier for timelapse videos, so that we can
  * differentiate between normal mpeg1 videos and timelapse videos.
  */
 #define TIMELAPSE_CODEC "mpeg1_tl"
@@ -55,7 +56,8 @@ struct ffmpeg {
 /* Initialize FFmpeg stuff. Needs to be called before ffmpeg_open. */
 void ffmpeg_init(void);
 
-/* Open an mpeg file. This is a generic interface for opening either an mpeg1 or
+/*
+ * Open an mpeg file. This is a generic interface for opening either an mpeg1 or
  * an mpeg4 video. If non-standard mpeg1 isn't supported (FFmpeg build > 4680), 
  * calling this function with "mpeg1" as codec results in an error. To create a
  * timelapse video, use TIMELAPSE_CODEC as codec name.
@@ -74,10 +76,10 @@ struct ffmpeg *ffmpeg_open(
     );
 
 /* Puts the image pointed to by the picture member of struct ffmpeg. */
-void ffmpeg_put_image(struct ffmpeg *);
+int ffmpeg_put_image(struct ffmpeg *);
 
 /* Puts the image defined by u, y and v (YUV420 format). */
-void ffmpeg_put_other_image(
+int ffmpeg_put_other_image(
     struct ffmpeg *ffmpeg, 
     unsigned char *y, 
     unsigned char *u, 
@@ -87,10 +89,15 @@ void ffmpeg_put_other_image(
 /* Closes the mpeg file. */
 void ffmpeg_close(struct ffmpeg *);
 
-/*Deinterlace the image. */
+/* Deinterlace the image. */
 void ffmpeg_deinterlace(unsigned char *, int, int);
 
-/*Setup an avcodec log handler. */
+/* Setup an avcodec log handler. */
 void ffmpeg_avcodec_log(void *, int, const char *, va_list);
 
+#ifdef HAVE_FFMPEG
+AVFrame *my_frame_alloc(void);
+void my_frame_free(AVFrame *frame);
+#endif
+
 #endif /* _INCLUDE_FFMPEG_H_ */
--- /dev/null
+++ motion-3.2.12/git-commit-version.sh
@@ -0,0 +1,5 @@
+#!/bin/sh
+
+SNV_VERSION=`git show -s --format=%H`
+echo -n "Git-$SNV_VERSION"
+
--- motion-3.2.12.orig/jpegutils.c
+++ motion-3.2.12/jpegutils.c
@@ -4,7 +4,7 @@
  *
  *  Copyright (C) 1999 Rainer Johanni <Rainer@Johanni.de>
  *  Copyright (C) 2001 pHilipp Zabel  <pzabel@gmx.de>
- *  Copyright (C) 2008 Angel Carpintero <ack@telefonica.net>
+ *  Copyright (C) 2008 Angel Carpintero <motiondevelop@gmail.com>
  *
  *  based on jdatasrc.c and jdatadst.c from the Independent
  *  JPEG Group's software by Thomas G. Lane
@@ -35,7 +35,7 @@
 #include <jerror.h>
 #include <assert.h>
 
- /*
+/*
  * jpeg_data:       buffer with input / output jpeg
  * len:             Length of jpeg buffer
  * itype:           0: Not interlaced
@@ -49,8 +49,6 @@
  * width            width of Y channel (width of U/V is width/2)
  * height           height of Y channel (height of U/V is height/2)
  */
-
-
 static void jpeg_buffer_src(j_decompress_ptr cinfo, unsigned char *buffer,
                             long num);
 static void jpeg_buffer_dest(j_compress_ptr cinfo, unsigned char *buffer,
@@ -70,13 +68,11 @@ static void jpeg_skip_ff(j_decompress_pt
  * Initialize source --- called by jpeg_read_header
  * before any data is actually read.
  */
-
 static void init_source(j_decompress_ptr cinfo ATTRIBUTE_UNUSED)
 {
-    /* no work necessary here */
+    /* No work necessary here */
 }
 
-
 /*
  * Fill the input buffer --- called whenever buffer is emptied.
  *
@@ -85,7 +81,6 @@ static void init_source(j_decompress_ptr
  * which is the JPEG EOI marker;
  *
  */
-
 static uint8_t EOI_data[2] = { 0xFF, 0xD9 };
 
 static boolean fill_input_buffer(j_decompress_ptr cinfo)
@@ -101,7 +96,6 @@ static boolean fill_input_buffer(j_decom
  * uninteresting data (such as an APPn marker).
  *
  */
-
 static void skip_input_data(j_decompress_ptr cinfo, long num_bytes)
 {
     if (num_bytes > 0) {
@@ -117,27 +111,25 @@ static void skip_input_data(j_decompress
  * Terminate source --- called by jpeg_finish_decompress
  * after all data has been read.  Often a no-op.
  */
-
 static void term_source(j_decompress_ptr cinfo ATTRIBUTE_UNUSED)
 {
-    /* no work necessary here */
+    /* No work necessary here */
 }
 
 
 /*
  * Prepare for input from a data buffer.
  */
-
 static void jpeg_buffer_src(j_decompress_ptr cinfo, unsigned char *buffer, long num)
 {
 /* The source object and input buffer are made permanent so that a series
-* of JPEG images can be read from the same buffer by calling jpeg_buffer_src
-* only before the first one.  (If we discarded the buffer at the end of
-* one image, we'd likely lose the start of the next one.)
-* This makes it unsafe to use this manager and a different source
-* manager serially with the same JPEG object.  Caveat programmer.
-*/
-    if (cinfo->src == NULL) {    /* first time for this JPEG object? */
+ * of JPEG images can be read from the same buffer by calling jpeg_buffer_src
+ * only before the first one.  (If we discarded the buffer at the end of
+ * one image, we'd likely lose the start of the next one.)
+ * This makes it unsafe to use this manager and a different source
+ * manager serially with the same JPEG object.  Caveat programmer.
+ */
+    if (cinfo->src == NULL) {    /* First time for this JPEG object? */
         cinfo->src = (struct jpeg_source_mgr *)
                      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
                      sizeof (struct jpeg_source_mgr));
@@ -146,7 +138,7 @@ static void jpeg_buffer_src(j_decompress
     cinfo->src->init_source = init_source;
     cinfo->src->fill_input_buffer = fill_input_buffer;
     cinfo->src->skip_input_data = skip_input_data;
-    cinfo->src->resync_to_restart = jpeg_resync_to_restart;	/* use default method */
+    cinfo->src->resync_to_restart = jpeg_resync_to_restart;    /* Use default method */
     cinfo->src->term_source = term_source;
     cinfo->src->bytes_in_buffer = num;
     cinfo->src->next_input_byte = (JOCTET *) buffer;
@@ -158,7 +150,6 @@ static void jpeg_buffer_src(j_decompress
  * particularly useful when reading several images from the same buffer:
  * It should be called to skip padding 0xff bytes beetween images.
  */
-
 static void jpeg_skip_ff(j_decompress_ptr cinfo)
 {
     while (cinfo->src->bytes_in_buffer > 1
@@ -183,7 +174,6 @@ static void jpeg_skip_ff(j_decompress_pt
  * Initialize destination --- called by jpeg_start_compress
  * before any data is actually written.
  */
-
 static void init_destination(j_compress_ptr cinfo ATTRIBUTE_UNUSED)
 {
     /* No work necessary here */
@@ -197,12 +187,11 @@ static void init_destination(j_compress_
  * If it gets called, the given jpeg buffer was too small.
  *
  */
-
 static boolean empty_output_buffer(j_compress_ptr cinfo)
 {
     /*FIXME: */
-    motion_log(LOG_ERR, 0, "%s: Given jpeg buffer was too small", __FUNCTION__);
-    ERREXIT (cinfo, JERR_BUFFER_SIZE);	/* shouldn't be FILE_WRITE but BUFFER_OVERRUN! */
+    MOTION_LOG(ERR, TYPE_ALL, NO_ERRNO, "%s: Given jpeg buffer was too small");
+    ERREXIT (cinfo, JERR_BUFFER_SIZE);  /* Shouldn't be FILE_WRITE but BUFFER_OVERRUN! */
     return TRUE;
 }
 
@@ -215,10 +204,9 @@ static boolean empty_output_buffer(j_com
  * application must deal with any cleanup that should happen even
  * for error exit.
  */
-
 static void term_destination(j_compress_ptr cinfo ATTRIBUTE_UNUSED)
 {
-    /* no work necessary here */
+    /* No work necessary here */
 }
 
 
@@ -231,13 +219,14 @@ static void term_destination(j_compress_
 static void jpeg_buffer_dest(j_compress_ptr cinfo, unsigned char *buf, long len)
 {
 
-    /* The destination object is made permanent so that multiple JPEG images
-     * can be written to the same file without re-executing jpeg_stdio_dest.
+   /*
+    * The destination object is made permanent so that multiple JPEG images
+    * can be written to the same file without re-executing jpeg_stdio_dest.
     * This makes it dangerous to use this manager and a different destination
     * manager serially with the same JPEG object, because their private object
     * sizes may be different.  Caveat programmer.
     */
-    if (cinfo->dest == NULL) {   /* first time for this JPEG object? */
+    if (cinfo->dest == NULL) {   /* First time for this JPEG object? */
         cinfo->dest = (struct jpeg_destination_mgr *)
                       (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
                       sizeof (struct jpeg_destination_mgr));
@@ -264,39 +253,40 @@ static void jpeg_buffer_dest(j_compress_
  *    The following kind of error handling is from the
  *    example.c file in the Independent JPEG Group's JPEG software
  */
-
 struct my_error_mgr {
     struct jpeg_error_mgr pub;   /* "public" fields */
-    jmp_buf setjmp_buffer;       /* for return to caller */
+    jmp_buf setjmp_buffer;       /* For return to caller */
 
-    /* original emit_message method */
+    /* Original emit_message method. */
     JMETHOD(void, original_emit_message, (j_common_ptr cinfo, int msg_level));
-    /* was a corrupt-data warning seen */
+    /* Was a corrupt-data warning seen. */
     int warning_seen;
 };
 
 static void my_error_exit(j_common_ptr cinfo)
 {
-    /* cinfo->err really points to a my_error_mgr struct, so coerce pointer */
+    /* cinfo->err really points to a my_error_mgr struct, so coerce pointer. */
     struct my_error_mgr *myerr = (struct my_error_mgr *) cinfo->err;
 
-    /* Always display the message. */
-    /* We could postpone this until after returning, if we chose. */
+    /*
+     * Always display the message.
+     * We could postpone this until after returning, if we chose.
+     */
     (*cinfo->err->output_message) (cinfo);
 
-    /* Return control to the setjmp point */
+    /* Return control to the setjmp point. */
     longjmp (myerr->setjmp_buffer, 1);
 }
 
 static void my_emit_message(j_common_ptr cinfo, int msg_level)
 {
-    /* cinfo->err really points to a my_error_mgr struct, so coerce pointer */
+    /* cinfo->err really points to a my_error_mgr struct, so coerce pointer. */
     struct my_error_mgr *myerr = (struct my_error_mgr *) cinfo->err;
 
-    if(msg_level < 0)
+    if (msg_level < 0)
         myerr->warning_seen = 1;
 
-    /* call original emit_message() */
+    /* Call original emit_message() */
     (myerr->original_emit_message)(cinfo, msg_level);
 }
 
@@ -311,9 +301,9 @@ static unsigned char chr2[8][MAX_CHROMA_
 
 
 
-#if 1  /* generation of 'std' Huffman tables... */
+#if 1  /* Generation of 'std' Huffman tables... */
 
-static void add_huff_table(j_decompress_ptr dinfo, JHUFF_TBL **htblptr, 
+static void add_huff_table(j_decompress_ptr dinfo, JHUFF_TBL **htblptr,
                            const UINT8 *bits, const UINT8 *val)
 /* Define a Huffman table */
 {
@@ -322,23 +312,23 @@ static void add_huff_table(j_decompress_
     if (*htblptr == NULL)
         *htblptr = jpeg_alloc_huff_table((j_common_ptr) dinfo);
 
-        /* Copy the number-of-symbols-of-each-code-length counts */
-        memcpy((*htblptr)->bits, bits, sizeof((*htblptr)->bits));
+    /* Copy the number-of-symbols-of-each-code-length counts. */
+    memcpy((*htblptr)->bits, bits, sizeof((*htblptr)->bits));
+
+    /*
+     * Validate the counts.  We do this here mainly so we can copy the right
+     * number of symbols from the val[] array, without risking marching off
+     * the end of memory.  jchuff.c will do a more thorough test later.
+     */
+    nsymbols = 0;
 
-        /* Validate the counts.  We do this here mainly so we can copy the right
-         * number of symbols from the val[] array, without risking marching off
-         * the end of memory.  jchuff.c will do a more thorough test later.
-         */
-        nsymbols = 0;
-
-        for (len = 1; len <= 16; len++)
-            nsymbols += bits[len];
-
-        if (nsymbols < 1 || nsymbols > 256)
-            motion_log(LOG_ERR, 0, "%s: Given jpeg buffer was too small", 
-                       __FUNCTION__);      
+    for (len = 1; len <= 16; len++)
+        nsymbols += bits[len];
 
-        memcpy((*htblptr)->huffval, val, nsymbols * sizeof(UINT8));
+    if (nsymbols < 1 || nsymbols > 256)
+        MOTION_LOG(ERR, TYPE_ALL, NO_ERRNO, "%s: Given jpeg buffer was too small");
+
+    memcpy((*htblptr)->huffval, val, nsymbols * sizeof(UINT8));
 }
 
 
@@ -351,12 +341,12 @@ static void std_huff_tables (j_decompres
     { /* 0-base */ 0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 };
     static const UINT8 val_dc_luminance[] =
     { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };
-  
+
     static const UINT8 bits_dc_chrominance[17] =
     { /* 0-base */ 0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 };
     static const UINT8 val_dc_chrominance[] =
     { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };
-  
+
     static const UINT8 bits_ac_luminance[17] =
     { /* 0-base */ 0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d };
     static const UINT8 val_ac_luminance[] =
@@ -381,7 +371,7 @@ static void std_huff_tables (j_decompres
       0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea,
       0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,
       0xf9, 0xfa };
-  
+
     static const UINT8 bits_ac_chrominance[17] =
     { /* 0-base */ 0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77 };
     static const UINT8 val_ac_chrominance[] =
@@ -406,7 +396,7 @@ static void std_huff_tables (j_decompres
       0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9,
       0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,
       0xf9, 0xfa };
-  
+
     add_huff_table(dinfo, &dinfo->dc_huff_tbl_ptrs[0],
                    bits_dc_luminance, val_dc_luminance);
     add_huff_table(dinfo, &dinfo->ac_huff_tbl_ptrs[0],
@@ -443,29 +433,28 @@ static void guarantee_huff_tables(j_deco
  * ctype            Chroma format for decompression.
  *                  Currently only Y4M_CHROMA_{420JPEG,422} are available
  * returns:
- *	-1 on fatal error
- *	0 on success
- *	1 if jpeg lib threw a "corrupt jpeg data" warning.  
- *		in this case, "a damaged output image is likely."
- *	
+ *    -1 on fatal error
+ *    0 on success
+ *    1 if jpeg lib threw a "corrupt jpeg data" warning.
+ *        in this case, "a damaged output image is likely."
+ *
  */
-
 int decode_jpeg_raw (unsigned char *jpeg_data, int len,
-                     int itype, int ctype, unsigned int width, 
-                     unsigned int height, unsigned char *raw0, 
+                     int itype, int ctype, unsigned int width,
+                     unsigned int height, unsigned char *raw0,
                      unsigned char *raw1, unsigned char *raw2)
 {
     int numfields, hsf[3], field, yl, yc;
     int i, xsl, xsc, xs, hdown;
     unsigned int x, y = 0, vsf[3], xd;
-    
+
     JSAMPROW row0[16] = { buf0[0], buf0[1], buf0[2], buf0[3],
                           buf0[4], buf0[5], buf0[6], buf0[7],
                           buf0[8], buf0[9], buf0[10], buf0[11],
                           buf0[12], buf0[13], buf0[14], buf0[15]};
 
     JSAMPROW row1[8] = { buf1[0], buf1[1], buf1[2], buf1[3],
-			             buf1[4], buf1[5], buf1[6], buf1[7]};
+                         buf1[4], buf1[5], buf1[6], buf1[7]};
 
     JSAMPROW row2[16] = { buf2[0], buf2[1], buf2[2], buf2[3],
                           buf2[4], buf2[5], buf2[6], buf2[7]};
@@ -480,7 +469,7 @@ int decode_jpeg_raw (unsigned char *jpeg
     /* We set up the normal JPEG error routines, then override error_exit. */
     dinfo.err = jpeg_std_error (&jerr.pub);
     jerr.pub.error_exit = my_error_exit;
-    /* also hook the emit_message routine to note corrupt-data warnings */
+    /* Also hook the emit_message routine to note corrupt-data warnings. */
     jerr.original_emit_message = jerr.pub.emit_message;
     jerr.pub.emit_message = my_emit_message;
     jerr.warning_seen = 0;
@@ -489,26 +478,30 @@ int decode_jpeg_raw (unsigned char *jpeg
     if (setjmp (jerr.setjmp_buffer)) {
         /* If we get here, the JPEG code has signaled an error. */
         jpeg_destroy_decompress (&dinfo);
-        return -1;
+        return 1;
     }
 
     jpeg_create_decompress (&dinfo);
 
     jpeg_buffer_src (&dinfo, jpeg_data, len);
 
-    /* Read header, make some checks and try to figure out what the
-       user really wants */
-
+    /*
+     * Read header, make some checks and try to figure out what the
+     * user really wants.
+     */
     jpeg_read_header (&dinfo, TRUE);
     dinfo.raw_data_out = TRUE;
+#if JPEG_LIB_VERSION >= 70
+    dinfo.do_fancy_upsampling = FALSE;
+#endif
     dinfo.out_color_space = JCS_YCbCr;
     dinfo.dct_method = JDCT_IFAST;
     guarantee_huff_tables(&dinfo);
     jpeg_start_decompress (&dinfo);
 
     if (dinfo.output_components != 3) {
-        motion_log(LOG_ERR, 0, "%s: Output components of JPEG image = %d, must be 3", 
-                   __FUNCTION__, dinfo.output_components);
+        MOTION_LOG(ERR, TYPE_ALL, NO_ERRNO, "%s: Output components of JPEG image"
+                   " = %d, must be 3", dinfo.output_components);
         goto ERR_EXIT;
     }
 
@@ -519,43 +512,44 @@ int decode_jpeg_raw (unsigned char *jpeg
 
     if ((hsf[0] != 2 && hsf[0] != 1) || hsf[1] != 1 || hsf[2] != 1 ||
         (vsf[0] != 1 && vsf[0] != 2) || vsf[1] != 1 || vsf[2] != 1) {
-        motion_log(LOG_ERR, 0, "%s: Unsupported sampling factors, hsf=(%d, %d, %d) "
-                   "vsf=(%d, %d, %d) !", __FUNCTION__, hsf[0], hsf[1], hsf[2], vsf[0], vsf[1], vsf[2]);
+        MOTION_LOG(ERR, TYPE_ALL, NO_ERRNO, "%s: Unsupported sampling factors,"
+                   " hsf=(%d, %d, %d) vsf=(%d, %d, %d) !", hsf[0], hsf[1],
+                   hsf[2], vsf[0], vsf[1], vsf[2]);
         goto ERR_EXIT;
     }
 
     if (hsf[0] == 1) {
         if (height % 8 != 0) {
-            motion_log(LOG_ERR, 0, "%s: YUV 4:4:4 sampling, but image height %d "
-                       "not dividable by 8 !", __FUNCTION__, height);
-            goto ERR_EXIT;	   
+            MOTION_LOG(ERR, TYPE_ALL, NO_ERRNO, "%s: YUV 4:4:4 sampling, but image"
+                       " height %d not dividable by 8 !", height);
+            goto ERR_EXIT;
         }
 
-        for (y = 0; y < 16; y++) { // allocate a special buffer for the extra sampling depth
+        for (y = 0; y < 16; y++) { // Allocate a special buffer for the extra sampling depth.
             row1_444[y] = (unsigned char *)malloc(dinfo.output_width * sizeof(char));
             row2_444[y] = (unsigned char *)malloc(dinfo.output_width * sizeof(char));
         }
-        scanarray[1] = row1_444; 
-        scanarray[2] = row2_444; 
+        scanarray[1] = row1_444;
+        scanarray[2] = row2_444;
     }
 
-    /* Height match image height or be exact twice the image height */
+    /* Height match image height or be exact twice the image height. */
 
     if (dinfo.output_height == height) {
         numfields = 1;
     } else if (2 * dinfo.output_height == height) {
         numfields = 2;
     } else {
-        motion_log(LOG_ERR, 0, "%s: Read JPEG: requested height = %d, "
-                   "height of image = %d", __FUNCTION__, height, dinfo.output_height);
+        MOTION_LOG(ERR, TYPE_ALL, NO_ERRNO, "%s: Read JPEG: requested height = %d, "
+                   "height of image = %d", height, dinfo.output_height);
         goto ERR_EXIT;
     }
 
     /* Width is more flexible */
 
     if (dinfo.output_width > MAX_LUMA_WIDTH) {
-        motion_log(LOG_ERR, 0, "%s: Image width of %d exceeds max", 
-                   __FUNCTION__, dinfo.output_width);
+        MOTION_LOG(ERR, TYPE_ALL, NO_ERRNO, "%s: Image width of %d exceeds max",
+                   dinfo.output_width);
         goto ERR_EXIT;
     }
 
@@ -567,7 +561,7 @@ int decode_jpeg_raw (unsigned char *jpeg
         else
             xsl = 0;
     } else if (width == 2 * dinfo.output_width / 3) {
-        /* special case of 3:2 downsampling */
+        /* Special case of 3:2 downsampling */
       hdown = 2;
       xsl = 0;
     } else {
@@ -590,6 +584,9 @@ int decode_jpeg_raw (unsigned char *jpeg
         if (field > 0) {
             jpeg_read_header (&dinfo, TRUE);
             dinfo.raw_data_out = TRUE;
+#if JPEG_LIB_VERSION >= 70
+            dinfo.do_fancy_upsampling = FALSE;
+#endif
             dinfo.out_color_space = JCS_YCbCr;
             dinfo.dct_method = JDCT_IFAST;
             jpeg_start_decompress (&dinfo);
@@ -604,16 +601,16 @@ int decode_jpeg_raw (unsigned char *jpeg
                 yl = yc = (1 - field);
                 break;
             default:
-                motion_log(LOG_ERR, 0, "%s: Input is interlaced but no interlacing set", 
-                           __FUNCTION__);
+                MOTION_LOG(ERR, TYPE_ALL, NO_ERRNO, "%s: Input is interlaced but"
+                           " no interlacing set");
                 goto ERR_EXIT;
             }
         } else {
             yl = yc = 0;
-        }         
+        }
 
         while (dinfo.output_scanline < dinfo.output_height) {
-            /* read raw data */
+            /* Read raw data */
             jpeg_read_raw_data (&dinfo, scanarray, 8 * vsf[0]);
 
             for (y = 0; y < 8 * vsf[0]; yl += numfields, y++) {
@@ -631,7 +628,7 @@ int decode_jpeg_raw (unsigned char *jpeg
                         raw0[xd] = (2 * row0[y][xs] + row0[y][xs + 1]) / 3;
                         raw0[xd + 1] = (2 * row0[y][xs + 2] + row0[y][xs + 1]) / 3;
                     }
-                }    
+                }
             }
 
             /* Horizontal downsampling of chroma */
@@ -639,23 +636,23 @@ int decode_jpeg_raw (unsigned char *jpeg
             for (y = 0; y < 8; y++) {
                 xs = xsc;
 
-	            if (hsf[0] == 1)
-	                for (x = 0; x < width / 2; x++, xs++) { 		  
-		                row1[y][xs] = (row1_444[y][2*x] + row1_444[y][2*x + 1]) >> 1;
-		                row2[y][xs] = (row2_444[y][2*x] + row2_444[y][2*x + 1]) >> 1;
-		            }
+                if (hsf[0] == 1)
+                    for (x = 0; x < width / 2; x++, xs++) {
+                        row1[y][xs] = (row1_444[y][2*x] + row1_444[y][2*x + 1]) >> 1;
+                        row2[y][xs] = (row2_444[y][2*x] + row2_444[y][2*x + 1]) >> 1;
+                    }
 
                 xs = xsc;
                 if (hdown == 0) {
                     for (x = 0; x < width / 2; x++, xs++) {
-		                chr1[y][x] = row1[y][xs];
-		                chr2[y][x] = row2[y][xs];
-                    } 
+                        chr1[y][x] = row1[y][xs];
+                        chr2[y][x] = row2[y][xs];
+                    }
                 } else if (hdown == 1) {
                     for (x = 0; x < width / 2; x++, xs += 2) {
                         chr1[y][x] = (row1[y][xs] + row1[y][xs + 1]) >> 1;
                         chr2[y][x] = (row2[y][xs] + row2[y][xs + 1]) >> 1;
-                    } 
+                    }
                 } else {
                     for (x = 0; x < width / 2; x += 2, xs += 3) {
                         chr1[y][x] = (2 * row1[y][xs] + row1[y][xs + 1]) / 3;
@@ -663,7 +660,7 @@ int decode_jpeg_raw (unsigned char *jpeg
                         chr2[y][x] = (2 * row2[y][xs] + row2[y][xs + 1]) / 3;
                         chr2[y][x + 1] = (2 * row2[y][xs + 2] + row2[y][xs + 1]) / 3;
                     }
-                }    
+                }
             }
 
             /* Vertical resampling of chroma */
@@ -671,68 +668,68 @@ int decode_jpeg_raw (unsigned char *jpeg
             switch (ctype) {
             case Y4M_CHROMA_422:
                 if (vsf[0] == 1) {
-	                /* Just copy */
-	                for (y = 0; y < 8 /*&& yc < height */; y++, yc += numfields) {
-	                    xd = yc * width / 2;
-
-	                    for (x = 0; x < width / 2; x++, xd++) {
-		                    raw1[xd] = chr1[y][x];
-		                    raw2[xd] = chr2[y][x];
-	                    }
-	                }
-	            } else {
-	                /* upsample */
-	                for (y = 0; y < 8 /*&& yc < height */; y++) {
-	                    xd = yc * width / 2;
-	                
+                    /* Just copy */
+                    for (y = 0; y < 8 /*&& yc < height */; y++, yc += numfields) {
+                        xd = yc * width / 2;
+
+                        for (x = 0; x < width / 2; x++, xd++) {
+                            raw1[xd] = chr1[y][x];
+                            raw2[xd] = chr2[y][x];
+                        }
+                    }
+                } else {
+                    /* upsample */
+                    for (y = 0; y < 8 /*&& yc < height */; y++) {
+                        xd = yc * width / 2;
+
+                        for (x = 0; x < width / 2; x++, xd++) {
+                            raw1[xd] = chr1[y][x];
+                            raw2[xd] = chr2[y][x];
+                        }
+
+                        yc += numfields;
+                        xd = yc * width / 2;
+
                         for (x = 0; x < width / 2; x++, xd++) {
-		                    raw1[xd] = chr1[y][x];
-		                    raw2[xd] = chr2[y][x];
-	                    }
-
-	                    yc += numfields;
-	                    xd = yc * width / 2;
-
-	                    for (x = 0; x < width / 2; x++, xd++) {
-		                    raw1[xd] = chr1[y][x];
-		                    raw2[xd] = chr2[y][x];
-	                    }
-
-	                    yc += numfields;
-	                }
-	            }
-	            break;
-	        default:
+                            raw1[xd] = chr1[y][x];
+                            raw2[xd] = chr2[y][x];
+                        }
+
+                        yc += numfields;
+                    }
+                }
+                break;
+            default:
             /*
-            * should be case Y4M_CHROMA_420JPEG: but use default: for compatibility. Some
-            * pass things like '420' in with the expectation that anything other than
-            * Y4M_CHROMA_422 will default to 420JPEG.
-            */
+             * Should be case Y4M_CHROMA_420JPEG: but use default: for compatibility. Some
+             * pass things like '420' in with the expectation that anything other than
+             * Y4M_CHROMA_422 will default to 420JPEG.
+             */
                 if (vsf[0] == 1) {
-	                /* Really downsample */
-	                for (y = 0; y < 8 /*&& yc < height/2*/; y += 2, yc += numfields) {
-	                    xd = yc * width / 2;
-
-	                    for (x = 0; x < width / 2; x++, xd++) {
-		                    assert(xd < (width * height / 4));
-		                    raw1[xd] = (chr1[y][x] + chr1[y + 1][x]) >> 1;
-		                    raw2[xd] = (chr2[y][x] + chr2[y + 1][x]) >> 1;
-	                    }
-	                }
-
-	            } else {
-	                /* Just copy */
-	                for (y = 0; y < 8 /*&& yc < height/2 */; y++, yc += numfields) {
-	                    xd = yc * width / 2;
-	       
+                    /* Really downsample */
+                    for (y = 0; y < 8 /*&& yc < height/2*/; y += 2, yc += numfields) {
+                        xd = yc * width / 2;
+
                         for (x = 0; x < width / 2; x++, xd++) {
-		                    raw1[xd] = chr1[y][x];
-		                    raw2[xd] = chr2[y][x];
-	                    }
-	                }
-	            }
-	            break;
-	        }
+                            assert(xd < (width * height / 4));
+                            raw1[xd] = (chr1[y][x] + chr1[y + 1][x]) >> 1;
+                            raw2[xd] = (chr2[y][x] + chr2[y + 1][x]) >> 1;
+                        }
+                    }
+
+                } else {
+                    /* Just copy */
+                    for (y = 0; y < 8 /* && yc < height / 2 */; y++, yc += numfields) {
+                        xd = yc * width / 2;
+
+                        for (x = 0; x < width / 2; x++, xd++) {
+                            raw1[xd] = chr1[y][x];
+                            raw2[xd] = chr2[y][x];
+                        }
+                    }
+                }
+                break;
+            }
         }
 
         (void) jpeg_finish_decompress (&dinfo);
@@ -741,10 +738,10 @@ int decode_jpeg_raw (unsigned char *jpeg
     }
 
     if (hsf[0] == 1) {
-        for (y = 0; y < 16; y++) { // allocate a special buffer for the extra sampling depth
+        for (y = 0; y < 16; y++) { // Allocate a special buffer for the extra sampling depth.
             free(row1_444[y]);
-	        free(row2_444[y]);
-	    }
+            free(row2_444[y]);
+        }
     }
 
     jpeg_destroy_decompress (&dinfo);
@@ -768,13 +765,12 @@ ERR_EXIT:
  * ctype            Chroma format for decompression.
  *                  Currently only Y4M_CHROMA_{420JPEG,422} are available
  */
-
 int decode_jpeg_gray_raw(unsigned char *jpeg_data, int len,
-			             int itype, int ctype, unsigned int width, 
-                         unsigned int height, unsigned char *raw0, 
+                         int itype, int ctype, unsigned int width,
+                         unsigned int height, unsigned char *raw0,
                          unsigned char *raw1, unsigned char *raw2)
 {
-    int numfields, hsf[3], field, yl, yc, xsl, xsc, xs, xd, hdown;
+    int numfields, field, yl, yc, xsl, xsc, xs, xd, hdown;
     unsigned int x, y, vsf[3];
 
     JSAMPROW row0[16] = { buf0[0], buf0[1], buf0[2], buf0[3],
@@ -801,43 +797,46 @@ int decode_jpeg_gray_raw(unsigned char *
 
     jpeg_buffer_src (&dinfo, jpeg_data, len);
 
-    /* Read header, make some checks and try to figure out what the
-      user really wants */
-
+    /*
+     * Read header, make some checks and try to figure out what the
+     * user really wants.
+     */
     jpeg_read_header (&dinfo, TRUE);
     dinfo.raw_data_out = TRUE;
+#if JPEG_LIB_VERSION >= 70
+    dinfo.do_fancy_upsampling = FALSE;
+#endif
     dinfo.out_color_space = JCS_GRAYSCALE;
     dinfo.dct_method = JDCT_IFAST;
-    
-    if (dinfo.jpeg_color_space != JCS_GRAYSCALE) { 
-        motion_log(LOG_ERR, 0, "%s: Expected grayscale colorspace for JPEG raw decoding", 
-                   __FUNCTION__);
+
+    if (dinfo.jpeg_color_space != JCS_GRAYSCALE) {
+        MOTION_LOG(ERR, TYPE_ALL, NO_ERRNO, "%s: Expected grayscale colorspace"
+                   " for JPEG raw decoding");
         goto ERR_EXIT;
     }
 
     guarantee_huff_tables(&dinfo);
     jpeg_start_decompress (&dinfo);
 
-    hsf[0] = 1; hsf[1] = 1; hsf[2] = 1;
     vsf[0]= 1; vsf[1] = 1; vsf[2] = 1;
 
-    /* Height match image height or be exact twice the image height */
+    /* Height match image height or be exact twice the image height. */
 
     if (dinfo.output_height == height) {
         numfields = 1;
     } else if (2 * dinfo.output_height == height) {
         numfields = 2;
     } else {
-        motion_log(LOG_ERR, 0, "%s: Read JPEG: requested height = %d, "
-                   "height of image = %d", __FUNCTION__, height, dinfo.output_height);
+        MOTION_LOG(ERR, TYPE_ALL, NO_ERRNO, "%s: Read JPEG: requested height = %d, "
+                   "height of image = %d", height, dinfo.output_height);
         goto ERR_EXIT;
     }
 
     /* Width is more flexible */
 
     if (dinfo.output_width > MAX_LUMA_WIDTH) {
-        motion_log(LOG_ERR, 0, "%s: Image width of %d exceeds max", 
-                   __FUNCTION__, dinfo.output_width);
+        MOTION_LOG(ERR, TYPE_ALL, NO_ERRNO, "%s: Image width of %d exceeds max",
+                    dinfo.output_width);
         goto ERR_EXIT;
     }
 
@@ -872,6 +871,9 @@ int decode_jpeg_gray_raw(unsigned char *
         if (field > 0) {
             jpeg_read_header (&dinfo, TRUE);
             dinfo.raw_data_out = TRUE;
+#if JPEG_LIB_VERSION >= 70
+            dinfo.do_fancy_upsampling = FALSE;
+#endif
             dinfo.out_color_space = JCS_GRAYSCALE;
             dinfo.dct_method = JDCT_IFAST;
             jpeg_start_decompress (&dinfo);
@@ -886,13 +888,13 @@ int decode_jpeg_gray_raw(unsigned char *
                 yl = yc = (1 - field);
                 break;
             default:
-                motion_log(LOG_ERR, 0, "%s: Input is interlaced but no interlacing set", 
-                           __FUNCTION__);
+                MOTION_LOG(ERR, TYPE_ALL, NO_ERRNO, "%s: Input is interlaced"
+                           " but no interlacing set");
                 goto ERR_EXIT;
             }
         } else {
             yl = yc = 0;
-        }    
+        }
 
         while (dinfo.output_scanline < dinfo.output_height) {
             jpeg_read_raw_data (&dinfo, scanarray, 16);
@@ -901,10 +903,10 @@ int decode_jpeg_gray_raw(unsigned char *
                 xd = yl * width;
                 xs = xsl;
 
-                if (hdown == 0) { // no horiz downsampling
+                if (hdown == 0) { // No horiz downsampling
                     for (x = 0; x < width; x++)
                         raw0[xd++] = row0[y][xs++];
-                } else if (hdown == 1) { // half the res
+                } else if (hdown == 1) { // Half the res
                     for (x = 0; x < width; x++, xs += 2)
                         raw0[xd++] = (row0[y][xs] + row0[y][xs + 1]) >> 1;
                 } else { // 2:3 downsampling
@@ -912,7 +914,7 @@ int decode_jpeg_gray_raw(unsigned char *
                         raw0[xd] = (2 * row0[y][xs] + row0[y][xs + 1]) / 3;
                         raw0[xd + 1] = (2 * row0[y][xs + 2] + row0[y][xs + 1]) / 3;
                     }
-                }    
+                }
             }
 
 
@@ -923,21 +925,21 @@ int decode_jpeg_gray_raw(unsigned char *
                     for (x = 0; x < width / 2; x++, xs++) {
                         chr1[y][x] = 0; //row1[y][xs];
                         chr2[y][x] = 0; //row2[y][xs];
-                    } 
+                    }
                 } else if (hdown == 1) {
                     for (x = 0; x < width / 2; x++, xs += 2) {
-		                chr1[y][x] = 0; //(row1[y][xs] + row1[y][xs + 1]) >> 1;
-		                chr2[y][x] = 0; //(row2[y][xs] + row2[y][xs + 1]) >> 1;
-                    } 
+                        chr1[y][x] = 0; //(row1[y][xs] + row1[y][xs + 1]) >> 1;
+                        chr2[y][x] = 0; //(row2[y][xs] + row2[y][xs + 1]) >> 1;
+                    }
                 } else {
                     for (x = 0; x < width / 2; x += 2, xs += 3) {
-		                chr1[y][x] = 0; //(2 * row1[y][xs] + row1[y][xs + 1]) / 3;
-		                chr1[y][x + 1] = 0;
-		                //(2 * row1[y][xs + 2] + row1[y][xs + 1]) / 3;
-		                chr2[y][x] = 0; // (2 * row2[y][xs] + row2[y][xs + 1]) / 3;
-		                chr2[y][x + 1] = 0;
-		                //(2 * row2[y][xs + 2] + row2[y][xs + 1]) / 3;
-                    }   
+                        chr1[y][x] = 0; //(2 * row1[y][xs] + row1[y][xs + 1]) / 3;
+                        chr1[y][x + 1] = 0;
+                        //(2 * row1[y][xs + 2] + row1[y][xs + 1]) / 3;
+                        chr2[y][x] = 0; // (2 * row2[y][xs] + row2[y][xs + 1]) / 3;
+                        chr2[y][x + 1] = 0;
+                        //(2 * row2[y][xs + 2] + row2[y][xs + 1]) / 3;
+                    }
                 }
             }
 
@@ -945,7 +947,7 @@ int decode_jpeg_gray_raw(unsigned char *
             case Y4M_CHROMA_422:
                 if (vsf[0] == 1) {
                     /* Just copy */
-                    for (y = 0; y < 8 /*&& yc < height */; y++, yc += numfields) {
+                    for (y = 0; y < 8 /* && yc < height */; y++, yc += numfields) {
                         xd = yc * width / 2;
 
                         for (x = 0; x < width / 2; x++, xd++) {
@@ -955,9 +957,9 @@ int decode_jpeg_gray_raw(unsigned char *
                     }
                 } else {
                     /* upsample */
-                    for (y = 0; y < 8 /*&& yc < height */; y++) {
+                    for (y = 0; y < 8 /* && yc < height */; y++) {
                         xd = yc * width / 2;
-                        
+
                         for (x = 0; x < width / 2; x++, xd++) {
                             raw1[xd] = 127; //chr1[y][x];
                             raw2[xd] = 127; //chr2[y][x];
@@ -965,22 +967,22 @@ int decode_jpeg_gray_raw(unsigned char *
 
                         yc += numfields;
                         xd = yc * width / 2;
-                        
+
                         for (x = 0; x < width / 2; x++, xd++) {
                             raw1[xd] = 127; //chr1[y][x];
                             raw2[xd] = 127; //chr2[y][x];
                         }
 
                         yc += numfields;
-	                }
-	            }
-	            break;
+                    }
+                }
+                break;
                /*
-                * should be case Y4M_CHROMA_420JPEG: but use default: for compatibility. Some
+                * Should be case Y4M_CHROMA_420JPEG: but use default: for compatibility. Some
                 * pass things like '420' in with the expectation that anything other than
                 * Y4M_CHROMA_422 will default to 420JPEG.
                 */
-	        default:
+            default:
                 if (vsf[0] == 1) {
                     /* Really downsample */
                     for (y = 0; y < 8; y += 2, yc += numfields) {
@@ -988,11 +990,11 @@ int decode_jpeg_gray_raw(unsigned char *
 
                         for (x = 0; x < width / 2; x++, xd++) {
                             raw1[xd] = 127; //(chr1[y][x] + chr1[y + 1][x]) >> 1;
-		                    raw2[xd] = 127; //(chr2[y][x] + chr2[y + 1][x]) >> 1;
+                            raw2[xd] = 127; //(chr2[y][x] + chr2[y + 1][x]) >> 1;
                         }
-	                }
-	            } else {
-	                /* Just copy */
+                    }
+                } else {
+                    /* Just copy */
 
                     for (y = 0; y < 8; y++, yc += numfields) {
                         xd = yc * width / 2;
@@ -1000,11 +1002,11 @@ int decode_jpeg_gray_raw(unsigned char *
                         for (x = 0; x < width / 2; x++, xd++) {
                             raw1[xd] = 127; //chr1[y][x];
                             raw2[xd] = 127; //chr2[y][x];
-	                    }
-	                }
-	            }
-	            break;
-	        }
+                        }
+                    }
+                }
+                break;
+            }
         }
 
         (void) jpeg_finish_decompress (&dinfo);
@@ -1028,8 +1030,8 @@ ERR_EXIT:
  *                      may be interlaced                          *
  *                                                                 *
  *******************************************************************/
- 
- /*
+
+/*
  * jpeg_data:       Buffer to hold output jpeg
  * len:             Length of buffer
  * itype:           0: Not interlaced
@@ -1038,10 +1040,9 @@ ERR_EXIT:
  * ctype            Chroma format for decompression.
  *                  Currently only Y4M_CHROMA_{420JPEG,422} are available
  */
-
 int encode_jpeg_raw(unsigned char *jpeg_data, int len, int quality,
-                    int itype, int ctype, unsigned int width, 
-                    unsigned int height, unsigned char *raw0, 
+                    int itype, int ctype, unsigned int width,
+                    unsigned int height, unsigned char *raw0,
                     unsigned char *raw1, unsigned char *raw2)
 {
     int numfields, field, yl, yc, y, i;
@@ -1090,22 +1091,22 @@ int encode_jpeg_raw(unsigned char *jpeg_
     cinfo.input_gamma = 1.0;
 
     cinfo.comp_info[0].h_samp_factor = 2;
-    cinfo.comp_info[0].v_samp_factor = 1;	/*1||2 */
+    cinfo.comp_info[0].v_samp_factor = 1;    /*1||2 */
     cinfo.comp_info[1].h_samp_factor = 1;
     cinfo.comp_info[1].v_samp_factor = 1;
-    cinfo.comp_info[2].h_samp_factor = 1;	/*1||2 */
+    cinfo.comp_info[2].h_samp_factor = 1;    /*1||2 */
     cinfo.comp_info[2].v_samp_factor = 1;
 
 
     if ((width > 4096) || (height > 4096)) {
-        motion_log(LOG_ERR, 0, "%s: Image dimensions (%dx%d) exceed lavtools' max "
-                   "(4096x4096)", __FUNCTION__, width, height);
+        MOTION_LOG(ERR, TYPE_ALL, NO_ERRNO, "%s: Image dimensions (%dx%d) exceed"
+                  " lavtools' max (4096x4096)", width, height);
         goto ERR_EXIT;
     }
 
     if ((width % 16) || (height % 16)) {
-        motion_log(LOG_ERR, 0, "%s: Image dimensions (%dx%d) not multiples of 16", 
-                   __FUNCTION__, width, height);
+        MOTION_LOG(ERR, TYPE_ALL, NO_ERRNO, "%s: Image dimensions (%dx%d) not"
+                   " multiples of 16", width, height);
         goto ERR_EXIT;
     }
 
@@ -1113,14 +1114,14 @@ int encode_jpeg_raw(unsigned char *jpeg_
 
     switch (itype) {
     case Y4M_ILACE_TOP_FIRST:
-    case Y4M_ILACE_BOTTOM_FIRST: /* interlaced */
+    case Y4M_ILACE_BOTTOM_FIRST: /* Interlaced */
         numfields = 2;
         break;
     default:
         numfields = 1;
         if (height > 2048) {
-            motion_log(LOG_ERR, 0, "%s: Image height (%d) exceeds lavtools max "
-                       "for non-interlaced frames", __FUNCTION__, height);
+            MOTION_LOG(ERR, TYPE_ALL, NO_ERRNO, "%s: Image height (%d) exceeds"
+                       " lavtools max for non-interlaced frames", height);
             goto ERR_EXIT;
         }
     }
@@ -1131,7 +1132,7 @@ int encode_jpeg_raw(unsigned char *jpeg_
 
     for (field = 0; field < numfields; field++) {
         jpeg_start_compress (&cinfo, FALSE);
-      
+
         if (numfields == 2) {
             static const JOCTET marker0[40];
 
@@ -1139,22 +1140,22 @@ int encode_jpeg_raw(unsigned char *jpeg_
             jpeg_write_marker(&cinfo, JPEG_APP0 + 1, marker0, 40);
 
             switch (itype) {
-            case Y4M_ILACE_TOP_FIRST: /* top field first */
+            case Y4M_ILACE_TOP_FIRST: /* Top field first */
                 yl = yc = field;
                 break;
-            case Y4M_ILACE_BOTTOM_FIRST: /* bottom field first */
+            case Y4M_ILACE_BOTTOM_FIRST: /* Bottom field first */
                 yl = yc = (1 - field);
                 break;
             default:
-                motion_log(LOG_ERR, 0, "%s: Input is interlaced but no interlacing set", 
-                           __FUNCTION__);
+                MOTION_LOG(ERR, TYPE_ALL, NO_ERRNO, "%s: Input is interlaced"
+                           " but no interlacing set");
                 goto ERR_EXIT;
             }
 
         } else {
             yl = yc = 0;
         }
-        
+
         while (cinfo.next_scanline < cinfo.image_height) {
 
             for (y = 0; y < 8 * cinfo.comp_info[0].v_samp_factor;
@@ -1177,12 +1178,12 @@ int encode_jpeg_raw(unsigned char *jpeg_
 
         (void) jpeg_finish_compress (&cinfo);
     }
-   
+
     /* FIXME */
     i = len - cinfo.dest->free_in_buffer;
 
     jpeg_destroy_compress (&cinfo);
-    return i;   /* size of jpeg */
+    return i;   /* Size of jpeg */
 
 ERR_EXIT:
     jpeg_destroy_compress (&cinfo);
--- motion-3.2.12.orig/jpegutils.h
+++ motion-3.2.12/jpegutils.h
@@ -1,10 +1,10 @@
-/* 
+/*
  * jpegutils.h: Some Utility programs for dealing with
  *               JPEG encoded images
  *
  *  Copyright (C) 1999 Rainer Johanni <Rainer@Johanni.de>
  *  Copyright (C) 2001 pHilipp Zabel  <pzabel@gmx.de>
- *  Copyright (C) 2008 Angel Carpintero <ack@telenfonica.net>
+ *  Copyright (C) 2008 Angel Carpintero <motiondevelop@gmail.com>
  *
  */
 
@@ -44,17 +44,17 @@
 
 
 int decode_jpeg_raw(unsigned char *jpeg_data, int len,
-                    int itype, int ctype, unsigned int width, 
-                    unsigned int height, unsigned char *raw0, 
+                    int itype, int ctype, unsigned int width,
+                    unsigned int height, unsigned char *raw0,
                     unsigned char *raw1, unsigned char *raw2);
 
 int decode_jpeg_gray_raw(unsigned char *jpeg_data, int len,
-                         int itype, int ctype, unsigned int width, 
-                         unsigned int height, unsigned char *raw0, 
+                         int itype, int ctype, unsigned int width,
+                         unsigned int height, unsigned char *raw0,
                          unsigned char *raw1, unsigned char *raw2);
 
 int encode_jpeg_raw(unsigned char *jpeg_data, int len, int quality,
-                    int itype, int ctype, unsigned int width, 
-                    unsigned int height, unsigned char *raw0, 
+                    int itype, int ctype, unsigned int width,
+                    unsigned int height, unsigned char *raw0,
                     unsigned char *raw1, unsigned char *raw2);
 #endif
--- /dev/null
+++ motion-3.2.12/logger.c
@@ -0,0 +1,259 @@
+/*
+ *      logger.c
+ *
+ *      Logger for motion
+ *
+ *      Copyright 2005, William M. Brack
+ *      Copyright 2008 by Angel Carpintero  (motiondevelop@gmail.com)
+ *      This software is distributed under the GNU Public License Version 2
+ *      See also the file 'COPYING'.
+ *
+ */
+
+#include "logger.h"   /* already includes motion.h */
+#include <stdarg.h>
+
+static int log_mode = LOGMODE_SYSLOG;
+static FILE *logfile;
+static unsigned int log_level = LEVEL_DEFAULT;
+static unsigned int log_type = TYPE_DEFAULT;
+
+static const char *log_type_str[] = {NULL, "COR", "STR", "ENC", "NET", "DBL", "EVT", "TRK", "VID", "ALL"};
+static const char *log_level_str[] = {"EMG", "ALR", "CRT", "ERR", "WRN", "NTC", "INF", "DBG", "ALL", NULL};
+
+
+/**
+ * get_log_type
+ *
+ *
+ * Returns: index of log type or 0 if not valid type.
+ */
+int get_log_type(const char *type)
+{
+    unsigned int i, ret = 0;
+    unsigned int maxtype = sizeof(log_type_str)/sizeof(const char *);
+
+    for (i = 1;i < maxtype; i++) {
+        if (!strncasecmp(type, log_type_str[i], 3)) {
+            ret = i;
+            break;
+        }
+    }
+
+    return ret;
+}
+
+/**
+ * get_log_type_str
+ *      Gets string value for type log level.
+ *
+ * Returns: name of type log level.
+ */
+const char* get_log_type_str(unsigned int type)
+{
+    return log_type_str[type];
+}
+
+/**
+ * set_log_type
+ *      Sets log type level.
+ *
+ * Returns: nothing.
+ */
+void set_log_type(unsigned int type)
+{
+    log_type = type;
+    //printf("set log type %d\n", type);
+}
+
+/**
+ * get_log_level_str
+ *      Gets string value for log level.
+ *
+ * Returns: name of log level.
+ */
+const char* get_log_level_str(unsigned int level)
+{
+    return log_level_str[level];
+}
+
+/**
+ * set_log_level
+ *      Sets log level.
+ *
+ * Returns nothing.
+ */
+void set_log_level(unsigned int level)
+{
+    log_level = level;
+    //printf("set log level %d\n", level);
+}
+
+/**
+ * set_log_mode
+ *      Sets mode of logging , could be using syslog or files.
+ *
+ * Returns: nothing.
+ */
+void set_log_mode(int mode)
+{
+    log_mode = mode;
+    //printf("set log mode %d\n", mode);
+}
+
+/**
+ * set_logfile
+ *      Sets logfile to be used instead of syslog.
+ *
+ * Returns: pointer to log file.
+ */
+FILE * set_logfile(const char *logfile_name)
+{
+    log_mode = LOGMODE_SYSLOG;  /* Setup temporary to let log if myfopen fails */
+    logfile = myfopen(logfile_name, "a", 0);
+
+    /* If logfile was opened correctly */
+    if (logfile)
+        log_mode = LOGMODE_FILE;
+
+    return logfile;
+}
+
+/**
+ * str_time
+ *
+ * Return: string with human readable time
+ */
+static char *str_time(void)
+{
+    static char buffer[16];
+    time_t now = 0;
+
+    now = time(0);
+    strftime(buffer, 16, "%b %d %H:%M:%S", localtime(&now));
+    return buffer;
+}
+
+/**
+ * MOTION_LOG
+ *
+ *    This routine is used for printing all informational, debug or error
+ *    messages produced by any of the other motion functions.  It always
+ *    produces a message of the form "[n] {message}", and (if the param
+ *    'errno_flag' is set) follows the message with the associated error
+ *    message from the library.
+ *
+ * Parameters:
+ *
+ *     level           logging level for the 'syslog' function
+ *
+ *     type            logging type.
+ *
+ *     errno_flag      if set, the log message should be followed by the
+ *                     error message.
+ *     fmt             the format string for producing the message
+ *     ap              variable-length argument list
+ *
+ * Returns:
+ *                     Nothing
+ */
+void motion_log(int level, unsigned int type, int errno_flag, const char *fmt, ...)
+{
+    int errno_save, n;
+    char buf[1024];
+/* GNU-specific strerror_r() */
+#if (!defined(XSI_STRERROR_R))
+    char msg_buf[100];
+#endif
+    va_list ap;
+    int threadnr;
+
+    /* Exit if level is greater than log_level */
+    if ((unsigned int)level > log_level)
+        return;
+
+    /* Exit if type is not equal to log_type and not TYPE_ALL */
+    if ((log_type != TYPE_ALL) && (type != log_type))
+        return;
+
+    //printf("log_type %d, type %d level %d\n", log_type, type, level);
+
+    /*
+     * If pthread_getspecific fails (e.g., because the thread's TLS doesn't
+     * contain anything for thread number, it returns NULL which casts to zero,
+     * which is nice because that's what we want in that case.
+     */
+    threadnr = (unsigned long)pthread_getspecific(tls_key_threadnr);
+
+    /*
+     * First we save the current 'error' value.  This is required because
+     * the subsequent calls to vsnprintf could conceivably change it!
+     */
+    errno_save = errno;
+
+    /*
+     * Prefix the message with the log level string, log type string,
+     * time and thread number. e.g. [1] [ERR] [ENC] [Apr 03 00:08:44] blah
+     *
+     */
+    if (!log_mode) {
+        n = snprintf(buf, sizeof(buf), "[%d] [%s] [%s] [%s] ",
+                     threadnr, get_log_level_str(level), get_log_type_str(type),
+                     str_time());
+    } else {
+    /*
+     * Prefix the message with the log level string, log type string
+     * and thread number. e.g. [1] [DBG] [TRK] blah
+     */
+        n = snprintf(buf, sizeof(buf), "[%d] [%s] [%s] ",
+                     threadnr, get_log_level_str(level), get_log_type_str(type));
+    }
+
+    /* Next add the user's message. */
+    va_start(ap, fmt);
+    n += vsnprintf(buf + n, sizeof(buf) - n, fmt, ap);
+    buf[1023] = '\0';
+
+    /* If errno_flag is set, add on the library error message. */
+    if (errno_flag) {
+      size_t buf_len = strlen(buf);
+
+      // just knock off 10 characters if we're that close...
+      if (buf_len + 10 > 1024) {
+	buf[1024 - 10] = '\0';
+	buf_len = 1024 - 10;
+      }
+
+      strncat(buf, ": ", 1024 - buf_len);
+      n += 2;
+        /*
+         * This is bad - apparently gcc/libc wants to use the non-standard GNU
+         * version of strerror_r, which doesn't actually put the message into
+         * my buffer :-(.  I have put in a 'hack' to get around this.
+         */
+#if defined(XSI_STRERROR_R)
+        /* XSI-compliant strerror_r() */
+        strerror_r(errno_save, buf + n, sizeof(buf) - n);    /* 2 for the ': ' */
+#else
+        /* GNU-specific strerror_r() */
+        strncat(buf, strerror_r(errno_save, msg_buf, sizeof(msg_buf)), 1024 - strlen(buf));
+#endif
+    }
+
+    if (!log_mode) {
+        strncat(buf, "\n", 1024 - strlen(buf));
+        fputs(buf, logfile);
+        fflush(logfile);
+
+    /* If log_mode, send the message to the syslog. */
+    } else {
+        syslog(level, "%s", buf);
+        strncat(buf, "\n", 1024 - strlen(buf));
+        fputs(buf, stderr);
+        fflush(stderr);
+    }
+
+    /* Clean up the argument list routine. */
+    va_end(ap);
+}
+
--- /dev/null
+++ motion-3.2.12/logger.h
@@ -0,0 +1,63 @@
+/*
+ *      logger.h
+ *
+ *      Include file for logger.c
+ *
+ *      Copyright 2005, William M. Brack
+ *      Copyright 2008 by Angel Carpintero  (motiondevelop@gmail.com)
+ *      This software is distributed under the GNU Public License Version 2
+ *      See also the file 'COPYING'.
+ *
+ */
+#ifndef _INCLUDE_LOGGER_H_
+#define _INCLUDE_LOGGER_H_
+
+#include "motion.h"
+#include <syslog.h>
+
+/* Logging mode */
+#define LOGMODE_FILE            0   /* Log messages to file   */
+#define LOGMODE_SYSLOG          1   /* Log messages to syslog */
+
+#define NO_ERRNO                0   /* Flag to avoid how message associated to errno */
+#define SHOW_ERRNO              1   /* Flag to show message associated to errno */
+
+/* Log levels */
+#define LOG_ALL                 9
+#define EMG                     LOG_EMERG     /* syslog 0 motion 1 */
+#define ALR                     LOG_ALERT     /* syslog 1 motion 2 */
+#define CRT                     LOG_CRIT      /* syslog 2 motion 3 */
+#define ERR                     LOG_ERR       /* syslog 3 motion 4 */
+#define WRN                     LOG_WARNING   /* syslog 4 motion 5 */
+#define NTC                     LOG_NOTICE    /* syslog 5 motion 6 */
+#define INF                     LOG_INFO      /* syslog 6 motion 7 */
+#define DBG                     LOG_DEBUG     /* syslog 7 motion 8 */
+#define ALL                     LOG_ALL       /* syslog 8 motion 9 */
+#define LEVEL_DEFAULT           NTC           /* syslog 5 motion 6 default */
+#define SHOW_LEVEL_VALUE(x)     (x+1)
+
+/* Log types */
+#define TYPE_CORE               1             /* Core logs         */
+#define TYPE_STREAM             2             /* Stream logs       */
+#define TYPE_ENCODER            3             /* Encoder logs      */
+#define TYPE_NETCAM             4             /* Netcam logs       */
+#define TYPE_DB                 5             /* Database logs     */
+#define TYPE_EVENTS             6             /* Events logs       */
+#define TYPE_TRACK              7             /* Track logs        */
+#define TYPE_VIDEO              8             /* V4L1/2 Bktr logs  */
+#define TYPE_ALL                9             /* All type logs     */
+#define TYPE_DEFAULT            TYPE_ALL      /* Default type      */
+#define TYPE_DEFAULT_STR        "ALL"         /* Default name logs */
+
+#define MOTION_LOG(x, y, z, format, args...)  motion_log(x, y, z, format, __FUNCTION__, ##args)
+
+int get_log_type(const char* type);
+const char* get_log_type_str(unsigned int type);
+void set_log_type(unsigned int type);
+const char* get_log_level_str(unsigned int level);
+void set_log_level(unsigned int level);
+void set_log_mode(int mode);
+FILE * set_logfile(const char *logfile_name);
+void motion_log(int, unsigned int, int, const char *, ...);
+
+#endif
--- /dev/null
+++ motion-3.2.12/md5.c
@@ -0,0 +1,348 @@
+/*
+ * MD5C.C - RSA Data Security, Inc., MD5 message-digest algorithm
+ * taken from RFC 1321
+ */
+
+/*
+ Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
+rights reserved.
+
+License to copy and use this software is granted provided that it
+is identified as the "RSA Data Security, Inc. MD5 Message-Digest
+Algorithm" in all material mentioning or referencing this software
+or this function.
+
+License is also granted to make and use derivative works provided
+that such works are identified as "derived from the RSA Data
+Security, Inc. MD5 Message-Digest Algorithm" in all material
+mentioning or referencing the derived work.
+
+RSA Data Security, Inc. makes no representations concerning either
+the merchantability of this software or the suitability of this
+software for any particular purpose. It is provided "as is"
+without express or implied warranty of any kind.
+
+These notices must be retained in any copies of any part of this
+documentation and/or software.
+*/
+
+#include "md5.h"
+
+/*
+ * Constants for MD5Transform routine.
+ */
+
+#define S11 7
+#define S12 12
+#define S13 17
+#define S14 22
+#define S21 5
+#define S22 9
+#define S23 14
+#define S24 20
+#define S31 4
+#define S32 11
+#define S33 16
+#define S34 23
+#define S41 6
+#define S42 10
+#define S43 15
+#define S44 21
+
+static void MD5Transform(UINT4 [4], unsigned char [64]);
+static void Encode(unsigned char *, UINT4 *, unsigned int);
+static void Decode(UINT4 *, unsigned char *, unsigned int);
+static void MD5_memcpy(POINTER, POINTER, unsigned int);
+static void MD5_memset(POINTER, int, unsigned int);
+
+static unsigned char PADDING[64] = {
+  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+};
+
+/*
+ * F, G, H and I are basic MD5 functions.
+ */
+#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
+#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
+#define H(x, y, z) ((x) ^ (y) ^ (z))
+#define I(x, y, z) ((y) ^ ((x) | (~z)))
+
+/*
+ * ROTATE_LEFT rotates x left n bits.
+ */
+#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))
+
+/*
+ * FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
+ * Rotation is separate from addition to prevent recomputation.
+ */
+#define FF(a, b, c, d, x, s, ac) { \
+ (a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \
+ (a) = ROTATE_LEFT ((a), (s)); \
+ (a) += (b); \
+  }
+#define GG(a, b, c, d, x, s, ac) { \
+ (a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \
+ (a) = ROTATE_LEFT ((a), (s)); \
+ (a) += (b); \
+  }
+#define HH(a, b, c, d, x, s, ac) { \
+ (a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \
+ (a) = ROTATE_LEFT ((a), (s)); \
+ (a) += (b); \
+  }
+#define II(a, b, c, d, x, s, ac) { \
+ (a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \
+ (a) = ROTATE_LEFT ((a), (s)); \
+ (a) += (b); \
+  }
+
+/*
+ * MD5 initialization. Begins an MD5 operation, writing a new context.
+ */
+void MD5Init(MD5_CTX *context)
+{
+  context->count[0] = context->count[1] = 0;
+  /* Load magic initialization constants. */
+  context->state[0] = 0x67452301;
+  context->state[1] = 0xefcdab89;
+  context->state[2] = 0x98badcfe;
+  context->state[3] = 0x10325476;
+}
+
+/*
+ * MD5 block update operation. Continues an MD5 message-digest
+ * operation, processing another message block, and updating the
+ * context.
+ */
+void MD5Update (
+    MD5_CTX *context,                                        /* context */
+    unsigned char *input,                                /* input block */
+    unsigned int inputLen)                     /* length of input block */
+{
+  unsigned int i, index, partLen;
+
+  /* Compute number of bytes mod 64 */
+  index = (unsigned int)((context->count[0] >> 3) & 0x3F);
+
+  /* Update number of bits */
+  if ((context->count[0] += ((UINT4)inputLen << 3))
+   < ((UINT4)inputLen << 3))
+ context->count[1]++;
+  context->count[1] += ((UINT4)inputLen >> 29);
+
+  partLen = 64 - index;
+
+  /* Transform as many times as possible. */
+  if (inputLen >= partLen) {
+ MD5_memcpy
+   ((POINTER)&context->buffer[index], (POINTER)input, partLen);
+ MD5Transform (context->state, context->buffer);
+
+ for (i = partLen; i + 63 < inputLen; i += 64)
+   MD5Transform (context->state, &input[i]);
+
+ index = 0;
+  }
+  else
+ i = 0;
+
+  /* Buffer remaining input */
+  MD5_memcpy
+ ((POINTER)&context->buffer[index], (POINTER)&input[i],
+  inputLen-i);
+}
+
+/*
+ * MD5 finalization. Ends an MD5 message-digest operation, writing the
+ * the message digest and zeroizing the context.
+ */
+void MD5Final (
+    unsigned char digest[16],                         /* message digest */
+    MD5_CTX *context)                                       /* context */
+{
+  unsigned char bits[8];
+  unsigned int index, padLen;
+
+  /* Save number of bits */
+  Encode (bits, context->count, 8);
+
+  /* Pad out to 56 mod 64. */
+  index = (unsigned int)((context->count[0] >> 3) & 0x3f);
+  padLen = (index < 56) ? (56 - index) : (120 - index);
+  MD5Update (context, PADDING, padLen);
+
+  /* Append length (before padding) */
+  MD5Update (context, bits, 8);
+
+  /* Store state in digest */
+  Encode (digest, context->state, 16);
+
+  /* Zeroize sensitive information. */
+  MD5_memset ((POINTER)context, 0, sizeof (*context));
+}
+
+/*
+ * MD5 basic transformation. Transforms state based on block.
+ */
+static void MD5Transform (state, block)
+UINT4 state[4];
+unsigned char block[64];
+{
+  UINT4 a = state[0], b = state[1], c = state[2], d = state[3], x[16];
+
+  Decode (x, block, 64);
+
+  /* Round 1 */
+  FF (a, b, c, d, x[ 0], S11, 0xd76aa478); /* 1 */
+  FF (d, a, b, c, x[ 1], S12, 0xe8c7b756); /* 2 */
+  FF (c, d, a, b, x[ 2], S13, 0x242070db); /* 3 */
+  FF (b, c, d, a, x[ 3], S14, 0xc1bdceee); /* 4 */
+  FF (a, b, c, d, x[ 4], S11, 0xf57c0faf); /* 5 */
+  FF (d, a, b, c, x[ 5], S12, 0x4787c62a); /* 6 */
+  FF (c, d, a, b, x[ 6], S13, 0xa8304613); /* 7 */
+  FF (b, c, d, a, x[ 7], S14, 0xfd469501); /* 8 */
+  FF (a, b, c, d, x[ 8], S11, 0x698098d8); /* 9 */
+  FF (d, a, b, c, x[ 9], S12, 0x8b44f7af); /* 10 */
+  FF (c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */
+  FF (b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */
+  FF (a, b, c, d, x[12], S11, 0x6b901122); /* 13 */
+  FF (d, a, b, c, x[13], S12, 0xfd987193); /* 14 */
+  FF (c, d, a, b, x[14], S13, 0xa679438e); /* 15 */
+  FF (b, c, d, a, x[15], S14, 0x49b40821); /* 16 */
+
+ /* Round 2 */
+  GG (a, b, c, d, x[ 1], S21, 0xf61e2562); /* 17 */
+  GG (d, a, b, c, x[ 6], S22, 0xc040b340); /* 18 */
+  GG (c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */
+  GG (b, c, d, a, x[ 0], S24, 0xe9b6c7aa); /* 20 */
+  GG (a, b, c, d, x[ 5], S21, 0xd62f105d); /* 21 */
+  GG (d, a, b, c, x[10], S22,  0x2441453); /* 22 */
+  GG (c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */
+  GG (b, c, d, a, x[ 4], S24, 0xe7d3fbc8); /* 24 */
+  GG (a, b, c, d, x[ 9], S21, 0x21e1cde6); /* 25 */
+  GG (d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */
+  GG (c, d, a, b, x[ 3], S23, 0xf4d50d87); /* 27 */
+  GG (b, c, d, a, x[ 8], S24, 0x455a14ed); /* 28 */
+  GG (a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
+  GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */
+  GG (c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */
+  GG (b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */
+
+  /* Round 3 */
+  HH (a, b, c, d, x[ 5], S31, 0xfffa3942); /* 33 */
+  HH (d, a, b, c, x[ 8], S32, 0x8771f681); /* 34 */
+  HH (c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */
+  HH (b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */
+  HH (a, b, c, d, x[ 1], S31, 0xa4beea44); /* 37 */
+  HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */
+  HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */
+  HH (b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
+  HH (a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
+  HH (d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */
+  HH (c, d, a, b, x[ 3], S33, 0xd4ef3085); /* 43 */
+  HH (b, c, d, a, x[ 6], S34,  0x4881d05); /* 44 */
+  HH (a, b, c, d, x[ 9], S31, 0xd9d4d039); /* 45 */
+  HH (d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */
+  HH (c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */
+  HH (b, c, d, a, x[ 2], S34, 0xc4ac5665); /* 48 */
+
+  /* Round 4 */
+  II (a, b, c, d, x[ 0], S41, 0xf4292244); /* 49 */
+  II (d, a, b, c, x[ 7], S42, 0x432aff97); /* 50 */
+  II (c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */
+  II (b, c, d, a, x[ 5], S44, 0xfc93a039); /* 52 */
+  II (a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */
+  II (d, a, b, c, x[ 3], S42, 0x8f0ccc92); /* 54 */
+  II (c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */
+  II (b, c, d, a, x[ 1], S44, 0x85845dd1); /* 56 */
+  II (a, b, c, d, x[ 8], S41, 0x6fa87e4f); /* 57 */
+  II (d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */
+  II (c, d, a, b, x[ 6], S43, 0xa3014314); /* 59 */
+  II (b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */
+  II (a, b, c, d, x[ 4], S41, 0xf7537e82); /* 61 */
+  II (d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */
+  II (c, d, a, b, x[ 2], S43, 0x2ad7d2bb); /* 63 */
+  II (b, c, d, a, x[ 9], S44, 0xeb86d391); /* 64 */
+
+  state[0] += a;
+  state[1] += b;
+  state[2] += c;
+  state[3] += d;
+
+  /* Zeroize sensitive information. */
+  MD5_memset ((POINTER)x, 0, sizeof (x));
+}
+
+/*
+ * Encodes input (UINT4) into output (unsigned char). Assumes len is
+ * a multiple of 4.
+ */
+static void Encode (output, input, len)
+unsigned char *output;
+UINT4 *input;
+unsigned int len;
+{
+  unsigned int i, j;
+
+  for (i = 0, j = 0; j < len; i++, j += 4) {
+ output[j] = (unsigned char)(input[i] & 0xff);
+ output[j+1] = (unsigned char)((input[i] >> 8) & 0xff);
+ output[j+2] = (unsigned char)((input[i] >> 16) & 0xff);
+ output[j+3] = (unsigned char)((input[i] >> 24) & 0xff);
+  }
+}
+
+/*
+ * Decodes input (unsigned char) into output (UINT4). Assumes len is
+ * a multiple of 4.
+ */
+static void Decode (output, input, len)
+UINT4 *output;
+unsigned char *input;
+unsigned int len;
+{
+  unsigned int i, j;
+
+  for (i = 0, j = 0; j < len; i++, j += 4)
+ output[i] = ((UINT4)input[j]) | (((UINT4)input[j+1]) << 8) |
+   (((UINT4)input[j+2]) << 16) | (((UINT4)input[j+3]) << 24);
+}
+
+/* Note: Replace "for loop" with standard memcpy if possible. */
+
+static void MD5_memcpy (output, input, len)
+POINTER output;
+POINTER input;
+unsigned int len;
+{
+  unsigned int i;
+
+  for (i = 0; i < len; i++)
+ output[i] = input[i];
+}
+
+/* Note: Replace "for loop" with standard memset if possible. */
+static void MD5_memset (output, value, len)
+POINTER output;
+int value;
+unsigned int len;
+{
+  unsigned int i;
+
+  for (i = 0; i < len; i++)
+ ((char *)output)[i] = (char)value;
+}
+
+void MD5(unsigned char *message,unsigned long message_length,unsigned char *md)
+{
+  MD5_CTX state;
+
+  MD5Init(&state);
+  MD5Update(&state,message,message_length);
+  MD5Final(md,&state);
+
+  return;
+}
--- /dev/null
+++ motion-3.2.12/md5.h
@@ -0,0 +1,77 @@
+/*
+ *  MD5.H - header file for MD5C.C
+ *  taken from RFC 1321
+ */
+
+#ifndef MD5_H
+#define MD5_H
+
+/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
+rights reserved.
+
+License to copy and use this software is granted provided that it
+is identified as the "RSA Data Security, Inc. MD5 Message-Digest
+Algorithm" in all material mentioning or referencing this software
+or this function.
+
+License is also granted to make and use derivative works provided
+that such works are identified as "derived from the RSA Data
+Security, Inc. MD5 Message-Digest Algorithm" in all material
+mentioning or referencing the derived work.
+
+RSA Data Security, Inc. makes no representations concerning either
+the merchantability of this software or the suitability of this
+software for any particular purpose. It is provided "as is"
+without express or implied warranty of any kind.
+
+These notices must be retained in any copies of any part of this
+documentation and/or software.
+ */
+
+/* GLOBAL.H - RSAREF types and constants
+ */
+
+/*
+ * PROTOTYPES should be set to one if and only if the compiler supports
+ * function argument prototyping.
+ * The following makes PROTOTYPES default to 0 if it has not already
+ * been defined with C compiler flags.
+ */
+
+#ifndef PROTOTYPES
+#define PROTOTYPES 0
+#endif
+
+/* POINTER defines a generic pointer type */
+typedef unsigned char *POINTER;
+
+/* UINT2 defines a two byte word */
+typedef unsigned short int UINT2;
+
+/* UINT4 defines a four byte word */
+typedef unsigned int UINT4;
+
+/*
+ * PROTO_LIST is defined depending on how PROTOTYPES is defined above.
+ * If using PROTOTYPES, then PROTO_LIST returns the list, otherwise it
+ * returns an empty list.
+ */
+#if PROTOTYPES
+#define PROTO_LIST(list) list
+#else
+#define PROTO_LIST(list) ()
+#endif
+
+/* MD5 context. */
+typedef struct {
+  UINT4 state[4];                                   /* state (ABCD) */
+  UINT4 count[2];        /* number of bits, modulo 2^64 (lsb first) */
+  unsigned char buffer[64];                         /* input buffer */
+} MD5_CTX;
+
+void MD5Init(MD5_CTX *);
+void MD5Update(MD5_CTX *, unsigned char *, unsigned int);
+void MD5Final(unsigned char [16], MD5_CTX *);
+void MD5(unsigned char *message, unsigned long message_length, unsigned char *md);
+
+#endif // MD5_H
--- motion-3.2.12.orig/mmx.h
+++ motion-3.2.12/mmx.h
@@ -12,22 +12,22 @@
  */
 
 typedef    union {
-    long long              q;    /* Quadword (64-bit) value */
-    unsigned long long    uq;    /* Unsigned Quadword */
-    int                 d[2];    /* 2 Doubleword (32-bit) values */
-    unsigned int       ud[2];    /* 2 Unsigned Doubleword */
-    short               w[4];    /* 4 Word (16-bit) values */
-    unsigned short     uw[4];    /* 4 Unsigned Word */
-    char                b[8];    /* 8 Byte (8-bit) values */
-    unsigned char      ub[8];    /* 8 Unsigned Byte */
-    float               s[2];    /* Single-precision (32-bit) value */
+    long long             q;    /* Quadword (64-bit) value */
+    unsigned long long   uq;    /* Unsigned Quadword */
+    int                d[2];    /* 2 Doubleword (32-bit) values */
+    unsigned int      ud[2];    /* 2 Unsigned Doubleword */
+    short              w[4];    /* 4 Word (16-bit) values */
+    unsigned short    uw[4];    /* 4 Unsigned Word */
+    char               b[8];    /* 8 Byte (8-bit) values */
+    unsigned char     ub[8];    /* 8 Unsigned Byte */
+    float              s[2];    /* Single-precision (32-bit) value */
 } mmx_t;    /* On an 8-byte (64-bit) boundary */
 
 
 #define    mmx_i2r(op,imm,reg) \
     __asm__ __volatile__ (#op " %0, %%" #reg \
                   : /* nothing */ \
-                  : "i" (imm) )
+                  : "i" (imm))
 
 #define    mmx_m2r(op,mem,reg) \
     __asm__ __volatile__ (#op " %0, %%" #reg \
@@ -188,7 +188,7 @@ typedef    union {
 #define mmx_r2ri(op,regs,regd,imm) \
         __asm__ __volatile__ (#op " %0, %%" #regs ", %%" #regd \
                               : /* nothing */ \
-                              : "X" (imm) )
+                              : "X" (imm))
 
 #define    mmx_fetch(mem,hint) \
     __asm__ __volatile__ ("prefetch" #hint " %0" \
--- /dev/null
+++ motion-3.2.12/motion-dist.conf
@@ -0,0 +1,736 @@
+# Rename this distribution example file to motion.conf
+#
+# This config file was generated by motion 3.2.12-4ppa01
+
+
+############################################################
+# Daemon
+############################################################
+
+# Start in daemon (background) mode and release terminal (default: off)
+daemon off
+
+# File to store the process ID, also called pid file. (default: not defined)
+process_id_file /var/run/motion/motion.pid
+
+############################################################
+# Basic Setup Mode
+############################################################
+
+# Start in Setup-Mode, daemon disabled. (default: off)
+setup_mode off
+
+
+# Use a file to save logs messages, if not defined stderr and syslog is used. (default: not defined)
+;logfile /tmp/motion.log
+
+# Level of log messages [1..9] (EMR, ALR, CRT, ERR, WRN, NTC, INF, DBG, ALL). (default: 6 / NTC)
+log_level 6
+
+# Filter to log messages by type (COR, STR, ENC, NET, DBL, EVT, TRK, VID, ALL). (default: ALL)
+log_type all
+
+###########################################################
+# Capture device options
+############################################################
+
+# Videodevice to be used for capturing  (default /dev/video0)
+# for FreeBSD default is /dev/bktr0
+videodevice /dev/video0
+
+# v4l2_palette allows to choose preferable palette to be use by motion
+# to capture from those supported by your videodevice. (default: 17)
+# E.g. if your videodevice supports both V4L2_PIX_FMT_SBGGR8 and
+# V4L2_PIX_FMT_MJPEG then motion will by default use V4L2_PIX_FMT_MJPEG.
+# Setting v4l2_palette to 2 forces motion to use V4L2_PIX_FMT_SBGGR8
+# instead.
+#
+# Values :
+# V4L2_PIX_FMT_SN9C10X : 0  'S910'
+# V4L2_PIX_FMT_SBGGR16 : 1  'BYR2'
+# V4L2_PIX_FMT_SBGGR8  : 2  'BA81'
+# V4L2_PIX_FMT_SPCA561 : 3  'S561'
+# V4L2_PIX_FMT_SGBRG8  : 4  'GBRG'
+# V4L2_PIX_FMT_SGRBG8  : 5  'GRBG'
+# V4L2_PIX_FMT_PAC207  : 6  'P207'
+# V4L2_PIX_FMT_PJPG    : 7  'PJPG'
+# V4L2_PIX_FMT_MJPEG   : 8  'MJPEG'
+# V4L2_PIX_FMT_JPEG    : 9  'JPEG'
+# V4L2_PIX_FMT_RGB24   : 10 'RGB3'
+# V4L2_PIX_FMT_SPCA501 : 11 'S501'
+# V4L2_PIX_FMT_SPCA505 : 12 'S505'
+# V4L2_PIX_FMT_SPCA508 : 13 'S508'
+# V4L2_PIX_FMT_UYVY    : 14 'UYVY'
+# V4L2_PIX_FMT_YUYV    : 15 'YUYV'
+# V4L2_PIX_FMT_YUV422P : 16 '422P'
+# V4L2_PIX_FMT_YUV420  : 17 'YU12'
+#
+v4l2_palette 17
+
+# Tuner device to be used for capturing using tuner as source (default /dev/tuner0)
+# This is ONLY used for FreeBSD. Leave it commented out for Linux
+; tunerdevice /dev/tuner0
+
+# The video input to be used (default: -1)
+# Should normally be set to 0 or 1 for video/TV cards, and -1 for USB cameras
+input -1
+
+# The video norm to use (only for video capture and TV tuner cards)
+# Values: 0 (PAL), 1 (NTSC), 2 (SECAM), 3 (PAL NC no colour). Default: 0 (PAL)
+norm 0
+
+# The frequency to set the tuner to (kHz) (only for TV tuner cards) (default: 0)
+frequency 0
+
+# Rotate image this number of degrees. The rotation affects all saved images as
+# well as movies. Valid values: 0 (default = no rotation), 90, 180 and 270.
+rotate 0
+
+# Image width (pixels). Valid range: Camera dependent, default: 352
+width 320
+
+# Image height (pixels). Valid range: Camera dependent, default: 288
+height 240
+
+# Maximum number of frames to be captured per second.
+# Valid range: 2-100. Default: 100 (almost no limit).
+framerate 2
+
+# Minimum time in seconds between capturing picture frames from the camera.
+# Default: 0 = disabled - the capture rate is given by the camera framerate.
+# This option is used when you want to capture images at a rate lower than 2 per second.
+minimum_frame_time 0
+
+# URL to use if you are using a network camera, size will be autodetected (incl http:// ftp:// mjpg:// rtsp:// mjpeg:// or file:///)
+# Must be a URL that returns single jpeg pictures or a raw mjpeg stream. Default: Not defined
+; netcam_url value
+
+# Username and password for network camera (only if required). Default: not defined
+# Syntax is user:password
+; netcam_userpass value
+
+# The setting for keep-alive of network socket, should improve performance on compatible net cameras.
+# off:   The historical implementation using HTTP/1.0, closing the socket after each http request.
+# force: Use HTTP/1.0 requests with keep alive header to reuse the same connection.
+# on:    Use HTTP/1.1 requests that support keep alive as default.
+# Default: off
+netcam_keepalive off
+
+# URL to use for a netcam proxy server, if required, e.g. "http://myproxy".
+# If a port number other than 80 is needed, use "http://myproxy:1234".
+# Default: not defined
+; netcam_proxy value
+
+# Set less strict jpeg checks for network cameras with a poor/buggy firmware.
+# Default: off
+netcam_tolerant_check off
+
+# RTSP connection uses TCP to communicate to the camera. Can prevent image corruption.
+# Default: on
+rtsp_uses_tcp on
+
+# Let motion regulate the brightness of a video device (default: off).
+# The auto_brightness feature uses the brightness option as its target value.
+# If brightness is zero auto_brightness will adjust to average brightness value 128.
+# Only recommended for cameras without auto brightness
+auto_brightness off
+
+# Set the initial brightness of a video device.
+# If auto_brightness is enabled, this value defines the average brightness level
+# which Motion will try and adjust to.
+# Valid range 0-255, default 0 = disabled
+brightness 0
+
+# Set the contrast of a video device.
+# Valid range 0-255, default 0 = disabled
+contrast 0
+
+# Set the saturation of a video device.
+# Valid range 0-255, default 0 = disabled
+saturation 0
+
+# Set the hue of a video device (NTSC feature).
+# Valid range 0-255, default 0 = disabled
+hue 0
+
+
+############################################################
+# Round Robin (multiple inputs on same video device name)
+############################################################
+
+# Number of frames to capture in each roundrobin step (default: 1)
+roundrobin_frames 1
+
+# Number of frames to skip before each roundrobin step (default: 1)
+roundrobin_skip 1
+
+# Try to filter out noise generated by roundrobin (default: off)
+switchfilter off
+
+
+############################################################
+# Motion Detection Settings:
+############################################################
+
+# Threshold for number of changed pixels in an image that
+# triggers motion detection (default: 1500)
+threshold 1500
+
+# Automatically tune the threshold down if possible (default: off)
+threshold_tune off
+
+# Noise threshold for the motion detection (default: 32)
+noise_level 32
+
+# Automatically tune the noise threshold (default: on)
+noise_tune on
+
+# Despeckle motion image using (e)rode or (d)ilate or (l)abel (Default: not defined)
+# Recommended value is EedDl. Any combination (and number of) of E, e, d, and D is valid.
+# (l)abeling must only be used once and the 'l' must be the last letter.
+# Comment out to disable
+despeckle_filter EedDl
+
+# Detect motion in predefined areas (1 - 9). Areas are numbered like that:  1 2 3
+# A script (on_area_detected) is started immediately when motion is         4 5 6
+# detected in one of the given areas, but only once during an event.        7 8 9
+# One or more areas can be specified with this option. Take care: This option
+# does NOT restrict detection to these areas! (Default: not defined)
+; area_detect value
+
+# PGM file to use as a sensitivity mask.
+# Full path name to. (Default: not defined)
+; mask_file value
+
+# Dynamically create a mask file during operation (default: 0)
+# Adjust speed of mask changes from 0 (off) to 10 (fast)
+smart_mask_speed 0
+
+# Ignore sudden massive light intensity changes given as a percentage of the picture
+# area that changed intensity. Valid range: 0 - 100 , default: 0 = disabled
+lightswitch 0
+
+# Picture frames must contain motion at least the specified number of frames
+# in a row before they are detected as true motion. At the default of 1, all
+# motion is detected. Valid range: 1 to thousands, recommended 1-5
+minimum_motion_frames 1
+
+# Specifies the number of pre-captured (buffered) pictures from before motion
+# was detected that will be output at motion detection.
+# Recommended range: 0 to 5 (default: 0)
+# Do not use large values! Large values will cause Motion to skip video frames and
+# cause unsmooth movies. To smooth movies use larger values of post_capture instead.
+pre_capture 0
+
+# Number of frames to capture after motion is no longer detected (default: 0)
+post_capture 0
+
+# Event Gap is the seconds of no motion detection that triggers the end of an event.
+# An event is defined as a series of motion images taken within a short timeframe.
+# Recommended value is 60 seconds (Default). The value -1 is allowed and disables
+# events causing all Motion to be written to one single movie file and no pre_capture.
+# If set to 0, motion is running in gapless mode. Movies don't have gaps anymore. An
+# event ends right after no more motion is detected and post_capture is over.
+event_gap 60
+
+# Maximum length in seconds of a movie
+# When value is exceeded a new movie file is created. (Default: 0 = infinite)
+max_movie_time 0
+
+# Always save images even if there was no motion (default: off)
+emulate_motion off
+
+
+############################################################
+# Image File Output
+############################################################
+
+# Output 'normal' pictures when motion is detected (default: on)
+# Valid values: on, off, first, best, center
+# When set to 'first', only the first picture of an event is saved.
+# Picture with most motion of an event is saved when set to 'best'.
+# Picture with motion nearest center of picture is saved when set to 'center'.
+# Can be used as preview shot for the corresponding movie.
+output_pictures on
+
+# Output pictures with only the pixels moving object (ghost images) (default: off)
+output_debug_pictures off
+
+# The quality (in percent) to be used by the jpeg compression (default: 75)
+quality 75
+
+# Type of output images
+# Valid values: jpeg, ppm (default: jpeg)
+picture_type jpeg
+
+############################################################
+# FFMPEG related options
+# Film (movies) file output, and deinterlacing of the video input
+# The options movie_filename and timelapse_filename are also used
+# by the ffmpeg feature
+############################################################
+
+# Use ffmpeg to encode movies in realtime (default: off)
+ffmpeg_output_movies on
+
+# Use ffmpeg to make movies with only the pixels moving
+# object (ghost images) (default: off)
+ffmpeg_output_debug_movies off
+
+# Use ffmpeg to encode a timelapse movie
+# Default value 0 = off - else save frame every Nth second
+ffmpeg_timelapse 0
+
+# The file rollover mode of the timelapse video
+# Valid values: hourly, daily (default), weekly-sunday, weekly-monday, monthly, manual
+ffmpeg_timelapse_mode daily
+
+# Bitrate to be used by the ffmpeg encoder (default: 400000)
+# This option is ignored if ffmpeg_variable_bitrate is not 0 (disabled)
+ffmpeg_bps 500000
+
+# Enables and defines variable bitrate for the ffmpeg encoder.
+# ffmpeg_bps is ignored if variable bitrate is enabled.
+# Valid values: 0 (default) = fixed bitrate defined by ffmpeg_bps,
+# or the range 2 - 31 where 2 means best quality and 31 is worst.
+ffmpeg_variable_bitrate 0
+
+# Codec to used by ffmpeg for the video compression.
+# Timelapse mpegs are always made in mpeg1 format independent from this option.
+# Supported formats are: mpeg1 (ffmpeg-0.4.8 only), mpeg4 (default), and msmpeg4.
+# mpeg1 - gives you files with extension .mpg
+# mpeg4 or msmpeg4 - gives you files with extension .avi
+# msmpeg4 is recommended for use with Windows Media Player because
+# it requires no installation of codec on the Windows client.
+# swf - gives you a flash film with extension .swf
+# flv - gives you a flash video with extension .flv
+# ffv1 - FF video codec 1 for Lossless Encoding ( experimental )
+# mov - QuickTime ( testing )
+# ogg - Ogg/Theora ( testing )
+ffmpeg_video_codec mpeg4
+
+# Use ffmpeg to deinterlace video. Necessary if you use an analog camera
+# and see horizontal combing on moving objects in video or pictures.
+# (default: off)
+ffmpeg_deinterlace off
+
+############################################################
+# SDL Window
+############################################################
+
+# Number of motion thread to show in SDL Window (default: 0 = disabled)
+#sdl_threadnr 0
+
+############################################################
+# External pipe to video encoder
+# Replacement for FFMPEG builtin encoder for ffmpeg_output_movies only.
+# The options movie_filename and timelapse_filename are also used
+# by the ffmpeg feature
+#############################################################
+
+# Bool to enable or disable extpipe (default: off)
+use_extpipe off
+
+# External program (full path and opts) to pipe raw video to
+# Generally, use '-' for STDIN...
+;extpipe mencoder -demuxer rawvideo -rawvideo w=320:h=240:i420 -ovc x264 -x264encopts bframes=4:frameref=1:subq=1:scenecut=-1:nob_adapt:threads=1:keyint=1000:8x8dct:vbv_bufsize=4000:crf=24:partitions=i8x8,i4x4:vbv_maxrate=800:no-chroma-me -vf denoise3d=16:12:48:4,pp=lb -of   avi -o %f.avi - -fps %fps
+
+
+
+############################################################
+# Snapshots (Traditional Periodic Webcam File Output)
+############################################################
+
+# Make automated snapshot every N seconds (default: 0 = disabled)
+snapshot_interval 0
+
+
+############################################################
+# Text Display
+# %Y = year, %m = month, %d = date,
+# %H = hour, %M = minute, %S = second, %T = HH:MM:SS,
+# %v = event, %q = frame number, %t = thread (camera) number,
+# %D = changed pixels, %N = noise level, \n = new line,
+# %i and %J = width and height of motion area,
+# %K and %L = X and Y coordinates of motion center
+# %C = value defined by text_event - do not use with text_event!
+# You can put quotation marks around the text to allow
+# leading spaces
+############################################################
+
+# Locate and draw a box around the moving object.
+# Valid values: on, off, preview (default: off)
+# Set to 'preview' will only draw a box in preview_shot pictures.
+locate_motion_mode off
+
+# Set the look and style of the locate box if enabled.
+# Valid values: box, redbox, cross, redcross (default: box)
+# Set to 'box' will draw the traditional box.
+# Set to 'redbox' will draw a red box.
+# Set to 'cross' will draw a little cross to mark center.
+# Set to 'redcross' will draw a little red cross to mark center.
+locate_motion_style box
+
+# Draws the timestamp using same options as C function strftime(3)
+# Default: %Y-%m-%d\n%T = date in ISO format and time in 24 hour clock
+# Text is placed in lower right corner
+text_right %Y-%m-%d\n%T-%q
+
+# Draw a user defined text on the images using same options as C function strftime(3)
+# Default: Not defined = no text
+# Text is placed in lower left corner
+; text_left CAMERA %t
+
+# Draw the number of changed pixed on the images (default: off)
+# Will normally be set to off except when you setup and adjust the motion settings
+# Text is placed in upper right corner
+text_changes off
+
+# This option defines the value of the special event conversion specifier %C
+# You can use any conversion specifier in this option except %C. Date and time
+# values are from the timestamp of the first image in the current event.
+# Default: %Y%m%d%H%M%S
+# The idea is that %C can be used filenames and text_left/right for creating
+# a unique identifier for each event.
+text_event %Y%m%d%H%M%S
+
+# Draw characters at twice normal size on images. (default: off)
+text_double off
+
+
+# Text to include in a JPEG EXIF comment
+# May be any text, including conversion specifiers.
+# The EXIF timestamp is included independent of this text.
+;exif_text %i%J/%K%L
+
+############################################################
+# Target Directories and filenames For Images And Films
+# For the options snapshot_, picture_, movie_ and timelapse_filename
+# you can use conversion specifiers
+# %Y = year, %m = month, %d = date,
+# %H = hour, %M = minute, %S = second,
+# %v = event, %q = frame number, %t = thread (camera) number,
+# %D = changed pixels, %N = noise level,
+# %i and %J = width and height of motion area,
+# %K and %L = X and Y coordinates of motion center
+# %C = value defined by text_event
+# Quotation marks round string are allowed.
+############################################################
+
+# Target base directory for pictures and films
+# Recommended to use absolute path. (Default: current working directory)
+target_dir /tmp/motion
+
+# File path for snapshots (jpeg or ppm) relative to target_dir
+# Default: %v-%Y%m%d%H%M%S-snapshot
+# Default value is equivalent to legacy oldlayout option
+# For Motion 3.0 compatible mode choose: %Y/%m/%d/%H/%M/%S-snapshot
+# File extension .jpg or .ppm is automatically added so do not include this.
+# Note: A symbolic link called lastsnap.jpg created in the target_dir will always
+# point to the latest snapshot, unless snapshot_filename is exactly 'lastsnap'
+snapshot_filename %v-%Y%m%d%H%M%S-snapshot
+
+# File path for motion triggered images (jpeg or ppm) relative to target_dir
+# Default: %v-%Y%m%d%H%M%S-%q
+# Default value is equivalent to legacy oldlayout option
+# For Motion 3.0 compatible mode choose: %Y/%m/%d/%H/%M/%S-%q
+# File extension .jpg or .ppm is automatically added so do not include this
+# Set to 'preview' together with best-preview feature enables special naming
+# convention for preview shots. See motion guide for details
+picture_filename %v-%Y%m%d%H%M%S-%q
+
+# File path for motion triggered ffmpeg films (movies) relative to target_dir
+# Default: %v-%Y%m%d%H%M%S
+# Default value is equivalent to legacy oldlayout option
+# For Motion 3.0 compatible mode choose: %Y/%m/%d/%H%M%S
+# File extension .mpg or .avi is automatically added so do not include this
+# This option was previously called ffmpeg_filename
+movie_filename %v-%Y%m%d%H%M%S
+
+# File path for timelapse movies relative to target_dir
+# Default: %Y%m%d-timelapse
+# Default value is near equivalent to legacy oldlayout option
+# For Motion 3.0 compatible mode choose: %Y/%m/%d-timelapse
+# File extension .mpg is automatically added so do not include this
+timelapse_filename %Y%m%d-timelapse
+
+############################################################
+# Global Network Options
+############################################################
+# Enable or disable IPV6 for http control and stream (default: off )
+ipv6_enabled off
+
+############################################################
+# Live Stream Server
+############################################################
+
+# The mini-http server listens to this port for requests (default: 0 = disabled)
+stream_port 8081
+
+# Quality of the jpeg (in percent) images produced (default: 50)
+stream_quality 50
+
+# Output frames at 1 fps when no motion is detected and increase to the
+# rate given by stream_maxrate when motion is detected (default: off)
+stream_motion off
+
+# Maximum framerate for stream streams (default: 1)
+stream_maxrate 1
+
+# Restrict stream connections to localhost only (default: on)
+stream_localhost on
+
+# Limits the number of images per connection (default: 0 = unlimited)
+# Number can be defined by multiplying actual stream rate by desired number of seconds
+# Actual stream rate is the smallest of the numbers framerate and stream_maxrate
+stream_limit 0
+
+# Set the authentication method (default: 0)
+# 0 = disabled
+# 1 = Basic authentication
+# 2 = MD5 digest (the safer authentication)
+stream_auth_method 0
+
+# Authentication for the stream. Syntax username:password
+# Default: not defined (Disabled)
+; stream_authentication username:password
+
+
+############################################################
+# HTTP Based Control
+############################################################
+
+# TCP/IP port for the http server to listen on (default: 0 = disabled)
+webcontrol_port 8080
+
+# Restrict control connections to localhost only (default: on)
+webcontrol_localhost on
+
+# Output for http server, select off to choose raw text plain (default: on)
+webcontrol_html_output on
+
+# Authentication for the http based control. Syntax username:password
+# Default: not defined (Disabled)
+; webcontrol_authentication username:password
+
+
+############################################################
+# Tracking (Pan/Tilt)
+#############################################################
+
+# Type of tracker (0=none (default), 1=stepper, 2=iomojo, 3=pwc, 4=generic, 5=uvcvideo, 6=servo)
+# The generic type enables the definition of motion center and motion size to
+# be used with the conversion specifiers for options like on_motion_detected
+track_type 0
+
+# Enable auto tracking (default: off)
+track_auto off
+
+# Serial port of motor (default: none)
+;track_port /dev/ttyS0
+
+# Motor number for x-axis (default: 0)
+;track_motorx 0
+
+# Set motorx reverse (default: 0)
+;track_motorx_reverse 0
+
+# Motor number for y-axis (default: 0)
+;track_motory 1
+
+# Set motory reverse (default: 0)
+;track_motory_reverse 0
+
+# Maximum value on x-axis (default: 0)
+;track_maxx 200
+
+# Minimum value on x-axis (default: 0)
+;track_minx 50
+
+# Maximum value on y-axis (default: 0)
+;track_maxy 200
+
+# Minimum value on y-axis (default: 0)
+;track_miny 50
+
+# Center value on x-axis (default: 0)
+;track_homex 128
+
+# Center value on y-axis (default: 0)
+;track_homey 128
+
+# ID of an iomojo camera if used (default: 0)
+track_iomojo_id 0
+
+# Angle in degrees the camera moves per step on the X-axis
+# with auto-track (default: 10)
+# Currently only used with pwc type cameras
+track_step_angle_x 10
+
+# Angle in degrees the camera moves per step on the Y-axis
+# with auto-track (default: 10)
+# Currently only used with pwc type cameras
+track_step_angle_y 10
+
+# Delay to wait for after tracking movement as number
+# of picture frames (default: 10)
+track_move_wait 10
+
+# Speed to set the motor to (stepper motor option) (default: 255)
+track_speed 255
+
+# Number of steps to make (stepper motor option) (default: 40)
+track_stepsize 40
+
+
+############################################################
+# External Commands, Warnings and Logging:
+# You can use conversion specifiers for the on_xxxx commands
+# %Y = year, %m = month, %d = date,
+# %H = hour, %M = minute, %S = second,
+# %v = event, %q = frame number, %t = thread (camera) number,
+# %D = changed pixels, %N = noise level,
+# %i and %J = width and height of motion area,
+# %K and %L = X and Y coordinates of motion center
+# %C = value defined by text_event
+# %f = filename with full path
+# %n = number indicating filetype
+# Both %f and %n are only defined for on_picture_save,
+# on_movie_start and on_movie_end
+# Quotation marks round string are allowed.
+############################################################
+
+# Do not sound beeps when detecting motion (default: on)
+# Note: Motion never beeps when running in daemon mode.
+quiet on
+
+# Command to be executed when an event starts. (default: none)
+# An event starts at first motion detected after a period of no motion defined by event_gap
+; on_event_start value
+
+# Command to be executed when an event ends after a period of no motion
+# (default: none). The period of no motion is defined by option event_gap.
+; on_event_end value
+
+# Command to be executed when a picture (.ppm|.jpg) is saved (default: none)
+# To give the filename as an argument to a command append it with %f
+; on_picture_save value
+
+# Command to be executed when a motion frame is detected (default: none)
+; on_motion_detected value
+
+# Command to be executed when motion in a predefined area is detected
+# Check option 'area_detect'.   (default: none)
+; on_area_detected value
+
+# Command to be executed when a movie file (.mpg|.avi) is created. (default: none)
+# To give the filename as an argument to a command append it with %f
+; on_movie_start value
+
+# Command to be executed when a movie file (.mpg|.avi) is closed. (default: none)
+# To give the filename as an argument to a command append it with %f
+; on_movie_end value
+
+# Command to be executed when a camera can't be opened or if it is lost
+# NOTE: There is situations when motion don't detect a lost camera!
+# It depends on the driver, some drivers dosn't detect a lost camera at all
+# Some hangs the motion thread. Some even hangs the PC! (default: none)
+; on_camera_lost value
+
+#####################################################################
+# Common Options for database features.
+# Options require database options to be active also.
+#####################################################################
+
+# Log to the database when creating motion triggered picture file  (default: on)
+; sql_log_picture on
+
+# Log to the database when creating a snapshot image file (default: on)
+; sql_log_snapshot on
+
+# Log to the database when creating motion triggered movie file (default: off)
+; sql_log_movie off
+
+# Log to the database when creating timelapse movies file (default: off)
+; sql_log_timelapse off
+
+# SQL query string that is sent to the database
+# Use same conversion specifiers has for text features
+# Additional special conversion specifiers are
+# %n = the number representing the file_type
+# %f = filename with full path
+# Default value:
+# Create tables :
+## 
+# Mysql
+# CREATE TABLE security (camera int, filename char(80) not null, frame int, file_type int, time_stamp timestamp(14), event_time_stamp timestamp(14));
+#
+# Postgresql
+# CREATE TABLE security (camera int, filename char(80) not null, frame int, file_type int, time_stamp timestamp without time zone, event_time_stamp timestamp without time zone);
+#
+# insert into security(camera, filename, frame, file_type, time_stamp, text_event) values('%t', '%f', '%q', '%n', '%Y-%m-%d %T', '%C')
+; sql_query insert into security(camera, filename, frame, file_type, time_stamp, event_time_stamp) values('%t', '%f', '%q', '%n', '%Y-%m-%d %T', '%C')
+
+
+############################################################
+# Database Options
+############################################################
+
+# database type : mysql, postgresql, sqlite3 (default : not defined)
+; database_type value
+
+# database to log to (default: not defined)
+; database_dbname value
+
+# The host on which the database is located (default: localhost)
+; database_host value
+
+# User account name for database (default: not defined)
+; database_user value
+
+# User password for database (default: not defined)
+; database_password value
+
+# Port on which the database is located
+#  mysql 3306 , postgresql 5432 (default: not defined)
+; database_port value
+
+############################################################
+# Database Options For SQLite3
+############################################################
+
+# SQLite3 database (file path) (default: not defined)
+; sqlite3_db value
+
+
+
+############################################################
+# Video Loopback Device (vloopback project)
+############################################################
+
+# Output images to a video4linux loopback device
+# The value '-' means next available (default: not defined)
+; video_pipe value
+
+# Output motion images to a video4linux loopback device
+# The value '-' means next available (default: not defined)
+; motion_video_pipe value
+
+
+##############################################################
+# Thread config files - One for each camera.
+# Except if only one camera - You only need this config file.
+# If you have more than one camera you MUST define one thread
+# config file for each camera in addition to this config file.
+##############################################################
+
+# Remember: If you have more than one camera you must have one
+# thread file for each camera. E.g. 2 cameras requires 3 files:
+# This motion.conf file AND thread1.conf and thread2.conf.
+# Only put the options that are unique to each camera in the
+# thread config files.
+; thread /usr/local/etc/thread1.conf
+; thread /usr/local/etc/thread2.conf
+; thread /usr/local/etc/thread3.conf
+; thread /usr/local/etc/thread4.conf
+
--- motion-3.2.12.orig/motion-dist.conf.in
+++ motion-3.2.12/motion-dist.conf.in
@@ -8,10 +8,10 @@
 ############################################################
 
 # Start in daemon (background) mode and release terminal (default: off)
-daemon on
+daemon off
 
 # File to store the process ID, also called pid file. (default: not defined)
-process_id_file /var/run/motion/motion.pid 
+process_id_file /var/run/motion/motion.pid
 
 ############################################################
 # Basic Setup Mode
@@ -20,6 +20,16 @@ process_id_file /var/run/motion/motion.p
 # Start in Setup-Mode, daemon disabled. (default: off)
 setup_mode off
 
+
+# Use a file to save logs messages, if not defined stderr and syslog is used. (default: not defined)
+;logfile /tmp/motion.log
+
+# Level of log messages [1..9] (EMR, ALR, CRT, ERR, WRN, NTC, INF, DBG, ALL). (default: 6 / NTC)
+log_level 6
+
+# Filter to log messages by type (COR, STR, ENC, NET, DBL, EVT, TRK, VID, ALL). (default: ALL)
+log_type all
+
 ###########################################################
 # Capture device options
 ############################################################
@@ -29,31 +39,41 @@ setup_mode off
 videodevice /dev/video0
 
 # v4l2_palette allows to choose preferable palette to be use by motion
-# to capture from those supported by your videodevice. (default: 8)
+# to capture from those supported by your videodevice. (default: 17)
 # E.g. if your videodevice supports both V4L2_PIX_FMT_SBGGR8 and
 # V4L2_PIX_FMT_MJPEG then motion will by default use V4L2_PIX_FMT_MJPEG.
-# Setting v4l2_palette to 1 forces motion to use V4L2_PIX_FMT_SBGGR8
+# Setting v4l2_palette to 2 forces motion to use V4L2_PIX_FMT_SBGGR8
 # instead.
 #
 # Values :
 # V4L2_PIX_FMT_SN9C10X : 0  'S910'
-# V4L2_PIX_FMT_SBGGR8  : 1  'BA81'
-# V4L2_PIX_FMT_MJPEG   : 2  'MJPEG'
-# V4L2_PIX_FMT_JPEG    : 3  'JPEG'
-# V4L2_PIX_FMT_RGB24   : 4  'RGB3'
-# V4L2_PIX_FMT_UYVY    : 5  'UYVY'
-# V4L2_PIX_FMT_YUYV    : 6  'YUYV'
-# V4L2_PIX_FMT_YUV422P : 7  '422P'
-# V4L2_PIX_FMT_YUV420  : 8  'YU12'
-v4l2_palette 8
+# V4L2_PIX_FMT_SBGGR16 : 1  'BYR2'
+# V4L2_PIX_FMT_SBGGR8  : 2  'BA81'
+# V4L2_PIX_FMT_SPCA561 : 3  'S561'
+# V4L2_PIX_FMT_SGBRG8  : 4  'GBRG'
+# V4L2_PIX_FMT_SGRBG8  : 5  'GRBG'
+# V4L2_PIX_FMT_PAC207  : 6  'P207'
+# V4L2_PIX_FMT_PJPG    : 7  'PJPG'
+# V4L2_PIX_FMT_MJPEG   : 8  'MJPEG'
+# V4L2_PIX_FMT_JPEG    : 9  'JPEG'
+# V4L2_PIX_FMT_RGB24   : 10 'RGB3'
+# V4L2_PIX_FMT_SPCA501 : 11 'S501'
+# V4L2_PIX_FMT_SPCA505 : 12 'S505'
+# V4L2_PIX_FMT_SPCA508 : 13 'S508'
+# V4L2_PIX_FMT_UYVY    : 14 'UYVY'
+# V4L2_PIX_FMT_YUYV    : 15 'YUYV'
+# V4L2_PIX_FMT_YUV422P : 16 '422P'
+# V4L2_PIX_FMT_YUV420  : 17 'YU12'
+#
+v4l2_palette 17
 
 # Tuner device to be used for capturing using tuner as source (default /dev/tuner0)
 # This is ONLY used for FreeBSD. Leave it commented out for Linux
 ; tunerdevice /dev/tuner0
 
-# The video input to be used (default: 8)
-# Should normally be set to 0 or 1 for video/TV cards, and 8 for USB cameras
-input 8
+# The video input to be used (default: -1)
+# Should normally be set to 0 or 1 for video/TV cards, and -1 for USB cameras
+input -1
 
 # The video norm to use (only for video capture and TV tuner cards)
 # Values: 0 (PAL), 1 (NTSC), 2 (SECAM), 3 (PAL NC no colour). Default: 0 (PAL)
@@ -63,7 +83,7 @@ norm 0
 frequency 0
 
 # Rotate image this number of degrees. The rotation affects all saved images as
-# well as mpeg movies. Valid values: 0 (default = no rotation), 90, 180 and 270.
+# well as movies. Valid values: 0 (default = no rotation), 90, 180 and 270.
 rotate 0
 
 # Image width (pixels). Valid range: Camera dependent, default: 352
@@ -81,7 +101,7 @@ framerate 2
 # This option is used when you want to capture images at a rate lower than 2 per second.
 minimum_frame_time 0
 
-# URL to use if you are using a network camera, size will be autodetected (incl http:// ftp:// or file:///)
+# URL to use if you are using a network camera, size will be autodetected (incl http:// ftp:// mjpg:// rtsp:// mjpeg:// or file:///)
 # Must be a URL that returns single jpeg pictures or a raw mjpeg stream. Default: Not defined
 ; netcam_url value
 
@@ -90,21 +110,25 @@ minimum_frame_time 0
 ; netcam_userpass value
 
 # The setting for keep-alive of network socket, should improve performance on compatible net cameras.
-# 1.0:         The historical implementation using HTTP/1.0, closing the socket after each http request.
-# keep_alive:  Use HTTP/1.0 requests with keep alive header to reuse the same connection.
-# 1.1:         Use HTTP/1.1 requests that support keep alive as default.
-# Default: 1.0
-; netcam_http 1.0
+# off:   The historical implementation using HTTP/1.0, closing the socket after each http request.
+# force: Use HTTP/1.0 requests with keep alive header to reuse the same connection.
+# on:    Use HTTP/1.1 requests that support keep alive as default.
+# Default: off
+netcam_keepalive off
 
 # URL to use for a netcam proxy server, if required, e.g. "http://myproxy".
 # If a port number other than 80 is needed, use "http://myproxy:1234".
 # Default: not defined
-; netcam_proxy value 
+; netcam_proxy value
 
 # Set less strict jpeg checks for network cameras with a poor/buggy firmware.
 # Default: off
 netcam_tolerant_check off
 
+# RTSP connection uses TCP to communicate to the camera. Can prevent image corruption.
+# Default: on
+rtsp_uses_tcp on
+
 # Let motion regulate the brightness of a video device (default: off).
 # The auto_brightness feature uses the brightness option as its target value.
 # If brightness is zero auto_brightness will adjust to average brightness value 128.
@@ -165,12 +189,13 @@ noise_tune on
 # Recommended value is EedDl. Any combination (and number of) of E, e, d, and D is valid.
 # (l)abeling must only be used once and the 'l' must be the last letter.
 # Comment out to disable
-despeckle EedDl
+despeckle_filter EedDl
 
 # Detect motion in predefined areas (1 - 9). Areas are numbered like that:  1 2 3
 # A script (on_area_detected) is started immediately when motion is         4 5 6
 # detected in one of the given areas, but only once during an event.        7 8 9
-# One or more areas can be specified with this option. (Default: not defined)
+# One or more areas can be specified with this option. Take care: This option
+# does NOT restrict detection to these areas! (Default: not defined)
 ; area_detect value
 
 # PGM file to use as a sensitivity mask.
@@ -194,24 +219,26 @@ minimum_motion_frames 1
 # was detected that will be output at motion detection.
 # Recommended range: 0 to 5 (default: 0)
 # Do not use large values! Large values will cause Motion to skip video frames and
-# cause unsmooth mpegs. To smooth mpegs use larger values of post_capture instead.
+# cause unsmooth movies. To smooth movies use larger values of post_capture instead.
 pre_capture 0
 
 # Number of frames to capture after motion is no longer detected (default: 0)
 post_capture 0
 
-# Gap is the seconds of no motion detection that triggers the end of an event
+# Event Gap is the seconds of no motion detection that triggers the end of an event.
 # An event is defined as a series of motion images taken within a short timeframe.
-# Recommended value is 60 seconds (Default). The value 0 is allowed and disables
-# events causing all Motion to be written to one single mpeg file and no pre_capture.
-gap 60
-
-# Maximum length in seconds of an mpeg movie
-# When value is exceeded a new mpeg file is created. (Default: 0 = infinite)
-max_mpeg_time 0
+# Recommended value is 60 seconds (Default). The value -1 is allowed and disables
+# events causing all Motion to be written to one single movie file and no pre_capture.
+# If set to 0, motion is running in gapless mode. Movies don't have gaps anymore. An
+# event ends right after no more motion is detected and post_capture is over.
+event_gap 60
+
+# Maximum length in seconds of a movie
+# When value is exceeded a new movie file is created. (Default: 0 = infinite)
+max_movie_time 0
 
 # Always save images even if there was no motion (default: off)
-output_all off
+emulate_motion off
 
 
 ############################################################
@@ -224,33 +251,33 @@ output_all off
 # Picture with most motion of an event is saved when set to 'best'.
 # Picture with motion nearest center of picture is saved when set to 'center'.
 # Can be used as preview shot for the corresponding movie.
-output_normal on
+output_pictures on
 
 # Output pictures with only the pixels moving object (ghost images) (default: off)
-output_motion off
+output_debug_pictures off
 
 # The quality (in percent) to be used by the jpeg compression (default: 75)
 quality 75
 
-# Output ppm images instead of jpeg (default: off)
-ppm off
-
+# Type of output images
+# Valid values: jpeg, ppm (default: jpeg)
+picture_type jpeg
 
 ############################################################
 # FFMPEG related options
-# Film (mpeg) file output, and deinterlacing of the video input
+# Film (movies) file output, and deinterlacing of the video input
 # The options movie_filename and timelapse_filename are also used
 # by the ffmpeg feature
 ############################################################
 
-# Use ffmpeg to encode mpeg movies in realtime (default: off)
-ffmpeg_cap_new on
+# Use ffmpeg to encode movies in realtime (default: off)
+ffmpeg_output_movies on
 
 # Use ffmpeg to make movies with only the pixels moving
 # object (ghost images) (default: off)
-ffmpeg_cap_motion off
+ffmpeg_output_debug_movies off
 
-# Use ffmpeg to encode a timelapse movie 
+# Use ffmpeg to encode a timelapse movie
 # Default value 0 = off - else save frame every Nth second
 ffmpeg_timelapse 0
 
@@ -279,6 +306,7 @@ ffmpeg_variable_bitrate 0
 # flv - gives you a flash video with extension .flv
 # ffv1 - FF video codec 1 for Lossless Encoding ( experimental )
 # mov - QuickTime ( testing )
+# ogg - Ogg/Theora ( testing )
 ffmpeg_video_codec mpeg4
 
 # Use ffmpeg to deinterlace video. Necessary if you use an analog camera
@@ -286,6 +314,28 @@ ffmpeg_video_codec mpeg4
 # (default: off)
 ffmpeg_deinterlace off
 
+############################################################
+# SDL Window
+############################################################
+
+# Number of motion thread to show in SDL Window (default: 0 = disabled)
+#sdl_threadnr 0
+
+############################################################
+# External pipe to video encoder
+# Replacement for FFMPEG builtin encoder for ffmpeg_output_movies only.
+# The options movie_filename and timelapse_filename are also used
+# by the ffmpeg feature
+#############################################################
+
+# Bool to enable or disable extpipe (default: off)
+use_extpipe off
+
+# External program (full path and opts) to pipe raw video to
+# Generally, use '-' for STDIN...
+;extpipe mencoder -demuxer rawvideo -rawvideo w=320:h=240:i420 -ovc x264 -x264encopts bframes=4:frameref=1:subq=1:scenecut=-1:nob_adapt:threads=1:keyint=1000:8x8dct:vbv_bufsize=4000:crf=24:partitions=i8x8,i4x4:vbv_maxrate=800:no-chroma-me -vf denoise3d=16:12:48:4,pp=lb -of   avi -o %f.avi - -fps %fps
+
+
 
 ############################################################
 # Snapshots (Traditional Periodic Webcam File Output)
@@ -309,9 +359,17 @@ snapshot_interval 0
 ############################################################
 
 # Locate and draw a box around the moving object.
-# Valid values: on, off and preview (default: off)
+# Valid values: on, off, preview (default: off)
 # Set to 'preview' will only draw a box in preview_shot pictures.
-locate off
+locate_motion_mode off
+
+# Set the look and style of the locate box if enabled.
+# Valid values: box, redbox, cross, redcross (default: box)
+# Set to 'box' will draw the traditional box.
+# Set to 'redbox' will draw a red box.
+# Set to 'cross' will draw a little cross to mark center.
+# Set to 'redcross' will draw a little red cross to mark center.
+locate_motion_style box
 
 # Draws the timestamp using same options as C function strftime(3)
 # Default: %Y-%m-%d\n%T = date in ISO format and time in 24 hour clock
@@ -340,9 +398,14 @@ text_event %Y%m%d%H%M%S
 text_double off
 
 
+# Text to include in a JPEG EXIF comment
+# May be any text, including conversion specifiers.
+# The EXIF timestamp is included independent of this text.
+;exif_text %i%J/%K%L
+
 ############################################################
 # Target Directories and filenames For Images And Films
-# For the options snapshot_, jpeg_, mpeg_ and timelapse_filename
+# For the options snapshot_, picture_, movie_ and timelapse_filename
 # you can use conversion specifiers
 # %Y = year, %m = month, %d = date,
 # %H = hour, %M = minute, %S = second,
@@ -356,7 +419,7 @@ text_double off
 
 # Target base directory for pictures and films
 # Recommended to use absolute path. (Default: current working directory)
-target_dir /usr/local/apache2/htdocs/cam1
+target_dir /tmp/motion
 
 # File path for snapshots (jpeg or ppm) relative to target_dir
 # Default: %v-%Y%m%d%H%M%S-snapshot
@@ -374,9 +437,9 @@ snapshot_filename %v-%Y%m%d%H%M%S-snapsh
 # File extension .jpg or .ppm is automatically added so do not include this
 # Set to 'preview' together with best-preview feature enables special naming
 # convention for preview shots. See motion guide for details
-jpeg_filename %v-%Y%m%d%H%M%S-%q
+picture_filename %v-%Y%m%d%H%M%S-%q
 
-# File path for motion triggered ffmpeg films (mpeg) relative to target_dir
+# File path for motion triggered ffmpeg films (movies) relative to target_dir
 # Default: %v-%Y%m%d%H%M%S
 # Default value is equivalent to legacy oldlayout option
 # For Motion 3.0 compatible mode choose: %Y/%m/%d/%H%M%S
@@ -384,38 +447,53 @@ jpeg_filename %v-%Y%m%d%H%M%S-%q
 # This option was previously called ffmpeg_filename
 movie_filename %v-%Y%m%d%H%M%S
 
-# File path for timelapse mpegs relative to target_dir
+# File path for timelapse movies relative to target_dir
 # Default: %Y%m%d-timelapse
 # Default value is near equivalent to legacy oldlayout option
 # For Motion 3.0 compatible mode choose: %Y/%m/%d-timelapse
 # File extension .mpg is automatically added so do not include this
 timelapse_filename %Y%m%d-timelapse
 
+############################################################
+# Global Network Options
+############################################################
+# Enable or disable IPV6 for http control and stream (default: off )
+ipv6_enabled off
 
 ############################################################
-# Live Webcam Server
+# Live Stream Server
 ############################################################
 
 # The mini-http server listens to this port for requests (default: 0 = disabled)
-webcam_port 8081
+stream_port 8081
 
-# Quality of the jpeg (in percent) images produced (default: 50) 
-webcam_quality 50
+# Quality of the jpeg (in percent) images produced (default: 50)
+stream_quality 50
 
 # Output frames at 1 fps when no motion is detected and increase to the
-# rate given by webcam_maxrate when motion is detected (default: off)
-webcam_motion off
+# rate given by stream_maxrate when motion is detected (default: off)
+stream_motion off
 
-# Maximum framerate for webcam streams (default: 1)
-webcam_maxrate 1
+# Maximum framerate for stream streams (default: 1)
+stream_maxrate 1
 
-# Restrict webcam connections to localhost only (default: on)
-webcam_localhost on
+# Restrict stream connections to localhost only (default: on)
+stream_localhost on
 
 # Limits the number of images per connection (default: 0 = unlimited)
-# Number can be defined by multiplying actual webcam rate by desired number of seconds
-# Actual webcam rate is the smallest of the numbers framerate and webcam_maxrate
-webcam_limit 0
+# Number can be defined by multiplying actual stream rate by desired number of seconds
+# Actual stream rate is the smallest of the numbers framerate and stream_maxrate
+stream_limit 0
+
+# Set the authentication method (default: 0)
+# 0 = disabled
+# 1 = Basic authentication
+# 2 = MD5 digest (the safer authentication)
+stream_auth_method 0
+
+# Authentication for the stream. Syntax username:password
+# Default: not defined (Disabled)
+; stream_authentication username:password
 
 
 ############################################################
@@ -423,24 +501,24 @@ webcam_limit 0
 ############################################################
 
 # TCP/IP port for the http server to listen on (default: 0 = disabled)
-control_port 8080
+webcontrol_port 8080
 
 # Restrict control connections to localhost only (default: on)
-control_localhost on
+webcontrol_localhost on
 
 # Output for http server, select off to choose raw text plain (default: on)
-control_html_output on
+webcontrol_html_output on
 
 # Authentication for the http based control. Syntax username:password
 # Default: not defined (Disabled)
-; control_authentication username:password
+; webcontrol_authentication username:password
 
 
 ############################################################
 # Tracking (Pan/Tilt)
-############################################################
+#############################################################
 
-# Type of tracker (0=none (default), 1=stepper, 2=iomojo, 3=pwc, 4=generic, 5=uvcvideo)
+# Type of tracker (0=none (default), 1=stepper, 2=iomojo, 3=pwc, 4=generic, 5=uvcvideo, 6=servo)
 # The generic type enables the definition of motion center and motion size to
 # be used with the conversion specifiers for options like on_motion_detected
 track_type 0
@@ -449,19 +527,37 @@ track_type 0
 track_auto off
 
 # Serial port of motor (default: none)
-; track_port value
+;track_port /dev/ttyS0
 
 # Motor number for x-axis (default: 0)
-track_motorx 0
+;track_motorx 0
+
+# Set motorx reverse (default: 0)
+;track_motorx_reverse 0
 
 # Motor number for y-axis (default: 0)
-track_motory 0
+;track_motory 1
+
+# Set motory reverse (default: 0)
+;track_motory_reverse 0
 
 # Maximum value on x-axis (default: 0)
-track_maxx 0
+;track_maxx 200
+
+# Minimum value on x-axis (default: 0)
+;track_minx 50
 
 # Maximum value on y-axis (default: 0)
-track_maxy 0
+;track_maxy 200
+
+# Minimum value on y-axis (default: 0)
+;track_miny 50
+
+# Center value on x-axis (default: 0)
+;track_homex 128
+
+# Center value on y-axis (default: 0)
+;track_homey 128
 
 # ID of an iomojo camera if used (default: 0)
 track_iomojo_id 0
@@ -509,11 +605,11 @@ track_stepsize 40
 quiet on
 
 # Command to be executed when an event starts. (default: none)
-# An event starts at first motion detected after a period of no motion defined by gap 
+# An event starts at first motion detected after a period of no motion defined by event_gap
 ; on_event_start value
 
 # Command to be executed when an event ends after a period of no motion
-# (default: none). The period of no motion is defined by option gap.
+# (default: none). The period of no motion is defined by option event_gap.
 ; on_event_end value
 
 # Command to be executed when a picture (.ppm|.jpg) is saved (default: none)
@@ -536,27 +632,27 @@ quiet on
 ; on_movie_end value
 
 # Command to be executed when a camera can't be opened or if it is lost
-# NOTE: There is situations when motion doesn't detect a lost camera!
-# It depends on the driver, some drivers don't detect a lost camera at all
-# Some hang the motion thread. Some even hang the PC! (default: none)
+# NOTE: There is situations when motion don't detect a lost camera!
+# It depends on the driver, some drivers dosn't detect a lost camera at all
+# Some hangs the motion thread. Some even hangs the PC! (default: none)
 ; on_camera_lost value
 
-############################################################
-# Common Options For MySQL and PostgreSQL database features.
-# Options require the MySQL/PostgreSQL options to be active also.
-############################################################
+#####################################################################
+# Common Options for database features.
+# Options require database options to be active also.
+#####################################################################
 
-# Log to the database when creating motion triggered image file  (default: on)
-sql_log_image on
+# Log to the database when creating motion triggered picture file  (default: on)
+; sql_log_picture on
 
 # Log to the database when creating a snapshot image file (default: on)
-sql_log_snapshot on
+; sql_log_snapshot on
 
-# Log to the database when creating motion triggered mpeg file (default: off)
-sql_log_mpeg off
+# Log to the database when creating motion triggered movie file (default: off)
+; sql_log_movie off
 
-# Log to the database when creating timelapse mpeg file (default: off)
-sql_log_timelapse off
+# Log to the database when creating timelapse movies file (default: off)
+; sql_log_timelapse off
 
 # SQL query string that is sent to the database
 # Use same conversion specifiers has for text features
@@ -564,45 +660,48 @@ sql_log_timelapse off
 # %n = the number representing the file_type
 # %f = filename with full path
 # Default value:
+# Create tables :
+## 
+# Mysql
+# CREATE TABLE security (camera int, filename char(80) not null, frame int, file_type int, time_stamp timestamp(14), event_time_stamp timestamp(14));
+#
+# Postgresql
+# CREATE TABLE security (camera int, filename char(80) not null, frame int, file_type int, time_stamp timestamp without time zone, event_time_stamp timestamp without time zone);
+#
 # insert into security(camera, filename, frame, file_type, time_stamp, text_event) values('%t', '%f', '%q', '%n', '%Y-%m-%d %T', '%C')
-sql_query insert into security(camera, filename, frame, file_type, time_stamp, event_time_stamp) values('%t', '%f', '%q', '%n', '%Y-%m-%d %T', '%C')
+; sql_query insert into security(camera, filename, frame, file_type, time_stamp, event_time_stamp) values('%t', '%f', '%q', '%n', '%Y-%m-%d %T', '%C')
 
 
 ############################################################
-# Database Options For MySQL
+# Database Options
 ############################################################
 
-# Mysql database to log to (default: not defined)
-; mysql_db value
+# database type : mysql, postgresql, sqlite3 (default : not defined)
+; database_type value
+
+# database to log to (default: not defined)
+; database_dbname value
 
 # The host on which the database is located (default: localhost)
-; mysql_host value
+; database_host value
 
-# User account name for MySQL database (default: not defined)
-; mysql_user value
+# User account name for database (default: not defined)
+; database_user value
 
-# User password for MySQL database (default: not defined)
-; mysql_password value
+# User password for database (default: not defined)
+; database_password value
 
+# Port on which the database is located
+#  mysql 3306 , postgresql 5432 (default: not defined)
+; database_port value
 
 ############################################################
-# Database Options For PostgreSQL
+# Database Options For SQLite3
 ############################################################
 
-# PostgreSQL database to log to (default: not defined)
-; pgsql_db value
-
-# The host on which the database is located (default: localhost)
-; pgsql_host value
-
-# User account name for PostgreSQL database (default: not defined)
-; pgsql_user value
-
-# User password for PostgreSQL database (default: not defined)
-; pgsql_password value
+# SQLite3 database (file path) (default: not defined)
+; sqlite3_db value
 
-# Port on which the PostgreSQL database is located (default: 5432)
-; pgsql_port 5432
 
 
 ############################################################
@@ -629,7 +728,7 @@ sql_query insert into security(camera, f
 # thread file for each camera. E.g. 2 cameras requires 3 files:
 # This motion.conf file AND thread1.conf and thread2.conf.
 # Only put the options that are unique to each camera in the
-# thread config files. 
+# thread config files.
 ; thread /usr/local/etc/thread1.conf
 ; thread /usr/local/etc/thread2.conf
 ; thread /usr/local/etc/thread3.conf
--- motion-3.2.12.orig/motion.1
+++ motion-3.2.12/motion.1
@@ -1,9 +1,9 @@
-.TH MOTION 1 2008-09-20 "Motion" "Motion Options and Config Files"
+.TH MOTION 1 2011-12-12 "Motion" "Motion Options and Config Files"
 .SH NAME
 motion \-   Detect motion using a video4linux device
 .SH SYNOPSIS
 .B motion
-[ -hns ] [ -c config file path ] [ -d level ] [ -p process_id_file ]
+[ -hmns ] [ -c config file path ] [ -d log level ] [ -k log type ] [ -p process_id_file ] [ -l logfile ]
 .SH DESCRIPTION
 .I  Motion
 uses a video4linux device to detect motion. If motion is detected both normal
@@ -17,28 +17,43 @@ Full path and filename of config file. E
 .B \-h
 Show help screen.
 .TP
+.B \-m
+Disable motion detection at startup.
+.TP
 .B \-n
 Run in non-daemon mode.
 .TP
 .B \-s
 Run in setup mode. Also forces non-daemon mode
 .TP
-.B \-d level
-Run in debug mode, level 1-9.
+.B \-d log level
+Set log level [1..9] (EMR, ALR, CRT, ERR, WRN, NTC, INF, DBG, ALL). (default: 6 / NTC)
+.TP
+.B \-k log type
+Set type of log (COR, STR, ENC, NET, DBL, EVT, TRK, VID, ALL). (default: ALL)
 .TP
 .B \-p
 Full path and filename for process id file (pid file). E.g /var/run/motion.pid. Default is not defined. Pid file is only created when Motion is started in daemon mode.
 .TP
+.B \-l
+Full path and filename of log file. ( use -l syslog to log to stderr and syslog )
+.TP
 .SH "CONFIG FILE OPTIONS"
 These are the options that can be used in the config file.
 .I They are overridden by the commandline!
 All number values are integer numbers (no decimals allowed).
 Boolean options can be on or off (values "1", "yes" and "on" all means true and any other value means false).
 .TP
-.B area_detect string
-Values: 1 - 999999999 / Default: Not defined
+.B area_detect integer
+Values: 0 - 999999999 / Default: Not defined
+.br
+Detect motion in predefined areas (1 - 9). Areas are numbered like that:  1 2 3
+.br
+A script (on_area_detected) is started immediately when motion is         4 5 6
 .br
-Detect motion center in predefined areas. A script (on_area_detected) is started immediately when motion center is detected in one of the given areas, but only once during an event even if there is motion in a different configured area.
+detected in one of the given areas, but only once during an event.        7 8 9
+.br
+One or more areas can be specified with this option. Take care: This option does NOT restrict detection to these areas! (Default: not defined)
 .TP
 .B auto_brightness boolean
 Values: on, off / Default: off
@@ -55,57 +70,91 @@ Values: 0 - 255 / Default: 0 (disabled)
 .br
 The contrast level for the video device.
 .TP
-.B control_authentication string
-Values: Max 4096 characters / Default: Not defined
+.B daemon boolean
+Values: on, off / Default: off
 .br
-To protect HTTP Control by username and password, use this option for HTTP 1.1 Basic authentication. The string is specified as username:password. Do not specify this option for no authentication. This option must be placed in motion.conf and not in a thread config file.
+Start in daemon (background) mode and release terminal. This option must be placed in motion.conf and not in a thread config file.
 .TP
-.B control_html_output boolean
-Values: on, off / Default: on
+.B database_dbname string
+Values: Max 4095 characters / Default: Not defined
 .br
-Enable HTML in the answer sent back to a browser connecting to the control_port. This option must be placed in motion.conf and not in a thread config file.
+Name of the database.
 .TP
-.B control_localhost boolean
-Values: on, off / Default: on
+.B database_host string
+Values: Max 4095 characters / Default: localhost
 .br
-Limits the http (html) control to the localhost. This option must be placed in motion.conf and not in a thread config file.
+IP address or domain name for the database server. Use "localhost" if motion and database runs on the same server.
 .TP
-.B control_port integer
-Values: 0 - 65535 / Default: 0 (disabled)
+.B database_password string
+Values: Max 4095 characters / Default: Not defined
 .br
-Sets the port number for the http (html using browser) based remote control. This option must be placed in motion.conf and not in a thread config file.
+The database password.
 .TP
-.B daemon boolean
-Values: on, off / Default: off
+.B database_port integer
+Values: 0 - 65535 / Default: Not defined
 .br
-Start in daemon (background) mode and release terminal. This option must be placed in motion.conf and not in a thread config file.
+The database server port number.
+.TP
+.B database_type discrete strings
+Values: mysql, postgresql / Default: Not defined
+.br
+The database type ( mysql , postgresql ).
 .TP
-.B despeckle string
+.B database_user string
+Values: Max 4095 characters / Default: Not defined
+.br
+The database user name.
+.TP
+.B despeckle_filter string
 Values: EedDl / Default: Not defined
 .br
 Despeckle motion image using combinations of (E/e)rode or (D/d)ilate. And ending with optional (l)abeling.
 .TP
+.B emulate_motion boolean
+Values: on, off / Default: off
+.br
+Picture are saved continuously as if motion was detected all the time.
+.TP
+.B event_gap integer
+Values: 0 - 2147483647 / Default: 60
+.br
+Event Gap is the seconds of no motion detection that triggers the end of an event. An event is defined as a series of motion images taken   within a short timeframe.
+.TP
+.B exif_text string 
+Values:  Max 4095 characters /  Default: Not defined
+.br
+Text to include in a JPEG EXIF comment , may be any text, including conversion specifiers. The EXIF timestamp is included independent of this text.
+.TP
+.B extpipe string
+Values: Max 4095 characters / Default: Not defined
+.br
+pipe raw video to generally - 'STDIN', allowing to use an external video encoder.
+.br
+e.g. using memcoder :
+.br
+extpipe mencoder -demuxer rawvideo -rawvideo w=320:h=240:i420 -ovc x264 -x264encopts bframes=4:frameref=1:subq=1:scenecut=-1:nob_adapt:     threads=1:keyint=1000:8x8dct:vbv_bufsize=4000:crf=24:partitions=i8x8,i4x4:vbv_maxrate=800:no-chroma-me -vf denoise3d=16:12:48:4,pp=lb -of   avi -o %f.avi - -fps %fps
+.TP
 .B ffmpeg_bps integer
 Values: 0 - 9999999 / Default: 400000
 .br
-Bitrate of mpegs produced by ffmpeg. Bitrate is bits per second. Default: 400000 (400kbps). Higher value mans better quality and larger files. Option requires that ffmpeg libraries are installed.
+Bitrate of movies produced by ffmpeg. Bitrate is bits per second. Default: 400000 (400kbps). Higher value mans better quality and larger files. Option requires that ffmpeg libraries are installed.
 .TP
-.B ffmpeg_cap_motion boolean
+.B ffmpeg_output_debug_movies boolean
 Values: on, off / Default: off
 .br
-Use ffmpeg libraries to encode motion type mpeg movies where you only see the pixels that changes.
+Use ffmpeg libraries to encode motion type movies where you only see the pixels that changes.
 .TP
-.B ffmpeg_cap_new boolean
+.B ffmpeg_output_movies boolean
 Values: on, off / Default: off
 .br
-Use ffmpeg libraries to encode mpeg movies in realtime.
+Use ffmpeg libraries to encode movies in realtime.
 .TP
 .B ffmpeg_deinterlace boolean
 Values: on, off / Default: off
 .br
-Use ffmpeg to deinterlace video. Necessary if you use an analog camera and see horizontal combing on moving objects in video or pictures. 
+Use ffmpeg to deinterlace video. Necessary if you use an analog camera and see horizontal combing on moving objects in video or pictures.
 .TP
-.B ffmpeg_timelapse boolean
+.B ffmpeg_timelapse integer
 Values: 0 - 2147483647 / Default: 0 (disabled)
 .br
 Create a timelapse movie saving a picture frame at the interval in seconds set by this parameter. Set it to 0 if not used.
@@ -121,26 +170,21 @@ Values: 0, 2 - 31 / Default: 0 (disabled
 Enables and defines variable bitrate for the ffmpeg encoder. ffmpeg_bps is ignored if variable bitrate is enabled. Valid values: 0 (default) = fixed bitrate defined by ffmpeg_bps, or the range 2 - 31 where 2 means best quality and 31 is worst.
 .TP
 .B ffmpeg_video_codec discrete strings
-Values: mpeg1 (ffmpeg-0.4.8 only), mpeg4, msmpeg4, swf, flv, ffv1, mov / Default: mpeg4
+Values: mpeg1 (ffmpeg-0.4.8 only), mpeg4, msmpeg4, swf , flv , ffv1, mov, ogg / Default: mpeg4
 .br
-Codec to be used by ffmpeg for the video compression. Timelapse mpegs are always made in mpeg1 format independent from this option.
+Codec to be used by ffmpeg for the video compression. Timelapse movies are always made in mpeg1 format independent from this option.
 .TP
 .B framerate integer
 Values: 2 - 100 / Default: 100 (no limit)
 .br
 Maximum number of frames to be captured from the camera per second.
 .TP
-.B frequency boolean
+.B frequency integer
 Values: 0 - 999999 / Default: 0 (Not set)
 .br
 The frequency to set the tuner to (kHz). Valid range: per tuner spec, default: 0 (Don't set it)
 .TP
-.B gap integer
-Values: 0 - 2147483647 / Default: 60
-.br
-Gap is the seconds of no motion detection that triggers the end of an event. An event is defined as a series of motion images taken within a short timeframe.
-.TP
-.B height  integer
+.B height integer
 Values: Device Dependent / Default: 288
 .br
 The height of each frame in pixels.
@@ -150,42 +194,62 @@ Values: 0 - 255 / Default: 0 (disabled)
 .br
 The hue level for the video device.
 .TP
-.B input  integer
-Values: 0 - 7, 8 = disabled / Default: 8 (disabled)
+.B input integer
+Values: -1 - 64, -1 = disabled / Default: -1 (disabled)
 .br
-Input channel to use expressed as an integer number starting from 0. Should normally be set to 1 for video/TV cards, and 8 for USB cameras.
+Input channel to use expressed as an integer number starting from -1. Should normally be set to 1 for video/TV cards, and -1 for USB cameras.
 .TP
-.B jpeg_filename string
-Values: Max 4095 characters / Default: %v-%Y%m%d%H%M%S-%q
+.B ipv6_enabled boolean
+Values: on, off / Default: off
 .br
-File path for motion triggered images (jpeg or ppm) relative to target_dir. Value 'preview' makes a jpeg filename with the same name body as the associated saved mpeg movie file.
+Enable or disable IPV6 for http control and stream.
 .TP
-.B lightswitch  integer
+.B lightswitch integer
 Values: 0 - 100 / Default: 0 (disabled)
 .br
 Ignore sudden massive light intensity changes given as a percentage of the picture area that changed intensity.
 .TP
-.B locate boolean
-Values: on, off, preview / Default: off
+.B locate_motion discrete strings
+Values: on, off, redbox, center, redcross, preview / Default: off
+.br
+Locate and draw a box around the moving object. Value 'preview' makes Motion only draw a box on a saved preview jpeg image and not on the saved movie.
+.TP
+.B logfile string
+Values: Max 4095 characters / Default: Not defined
 .br
-Locate and draw a box around the moving object. Value 'preview' makes Motion only draw a box on a saved preview jpeg image and not on the saved mpeg movie. 
+Use a file to save logs messages, if not defined stderr and syslog is used.
+.TP
+.B logfile string
+Values: Max 4095 characters / Default: Not defined
+.br
+Use a file to save logs messages, if not defined stderr and syslog is used. ( if syslog is set then will log to stderr and syslog )
+.TP
+.B log_level integer
+Values: 1 - 9 / Default: 6
+.br
+Level of log messages [1..9] (EMR, ALR, CRT, ERR, WRN, NTC, ERR, DBG, ALL). (default: 6 / NTC).
+.TP
+.B log_type discrete strings
+Values: STR, ENC, NET, DBL, EVT, TRK, VID, ALL / Default: ALL
+.br
+Filter to log messages by type (STR, ENC, NET, DBL, EVT, TRK, VID, ALL).
 .TP
 .B mask_file string
 Values: Max 4095 characters / Default: Not defined
 .br
-PGM file to use as a sensitivity mask. This picture MUST have the same width and height as the frames being captured and be in binary format. 
+PGM file to use as a sensitivity mask. This picture MUST have the same width and height as the frames being captured and be in binary format.
 .TP
-.B max_mpeg_time integer
+.B max_movie_time integer
 Values: 0 (infinite) - 2147483647 / Default: 3600
 .br
-The maximum length of an mpeg movie in seconds. Set this to zero for unlimited length.
+The maximum length of a movie in seconds. Set this to zero for unlimited length.
 .TP
 .B minimum_frame_time integer
 Values: 0 - 2147483647 / Default: 0
 .br
 Minimum time in seconds between the capturing picture frames from the camera. Default: 0 = disabled - the capture rate is given by the camera framerate.
 .TP
-.B minimum_motion_frames boolean
+.B minimum_motion_frames integer
 Values: 1 - 1000s / Default: 1
 .br
 Picture frames must contain motion at least the specified number of frames in a row before they are detected as true motion. At the default of 1, all motion is detected. Valid range is 1 to thousands, but it is recommended to keep it within 1-5.
@@ -198,47 +262,29 @@ The video4linux video loopback input dev
 .B movie_filename string
 Values: Max 4095 characters / Default: %v-%Y%m%d%H%M%S
 .br
-File path for motion triggered ffmpeg movies (mpeg) relative to target_dir. This was previously called ffmpeg_filename.
+File path for motion triggered ffmpeg movies relative to target_dir. This was previously called ffmpeg_filename.
 .TP
-.B mysql_db string
-Values: Max 4095 characters / Default: Not defined
-.br
-Name of the MySQL database.
-.TP
-.B mysql_host string
-Values: Max 4095 characters / Default: localhost
-.br
-IP address or domain name for the MySQL server. Use "localhost" if motion and MySQL runs on the same server.
-.TP
-.B mysql_password string
-Values: Max 4095 characters / Default: Not defined
-.br
-The MySQL password.
-.TP
-.B mysql_user string
-Values: Max 4095 characters / Default: Not defined
+.B netcam_tolerant_check boolean
+Values: on, off / Default: off
 .br
-The MySQL user name.
+Set less strict jpeg checks for network cameras with a poor/buggy firmware.
 .TP
-.B netcam_http discrete strings
-Values: 1.0, keep_alive, 1.1 / Default: 1.0
+.B netcam_keepalive discrete string
+Values: off , force, on / Default: off
 .br
-The setting for keep-alive of network socket, should improve performance on compatible net cameras. ( new in 3.2.10 ) <br />
+The setting for keep-alive of network socket, should improve performance on compatible net cameras.
 .TP
 .B netcam_proxy string
 Values: Max 4095 characters / Default: Not defined
 .br
 URL to use for a netcam proxy server, if required. The syntax is http://myproxy:portnumber
 .TP
-.B netcam_tolerant_check boolean
-Values: on, off  / Default: off
-.br
-Set less strict jpeg checks for network cameras with a poor/buggy firmware.
-.TP
 .B netcam_url string
 Values: Max 4095 characters / Default: Not defined
 .br
 Specify an url to a downloadable jpeg file or raw mjpeg stream to use as input device. Such as an AXIS 2100 network camera.
+.br
+http:// ftp:// mjpg:// or file:/// ( mjpg:// is for network cameras with codec mjpeg ).
 .TP
 .B netcam_userpass string
 Values: Max 4095 characters / Default: Not defined
@@ -255,7 +301,7 @@ Values: on, off / Default: on
 .br
 Activates the automatic tuning of noise level.
 .TP
-.B norm discrete strings
+.B norm integer
 Values: 0 (PAL), 1 (NTSC), 2 (SECAM), 3 (PAL NC no colour) / Default: 0 (PAL)
 .br
 Select the norm of the video device. Values: 0 (PAL), 1 (NTSC), 2 (SECAM), 3 (PAL NC no colour). Default: 0 (PAL)
@@ -263,22 +309,22 @@ Select the norm of the video device. Val
 .B on_area_detected string
 Values: Max 4095 characters / Default: Not defined
 .br
-Command to be executed when motion in a predefined area is detected. Check option area_detect.
+Command to be executed when motion in a predefined area is detected, check option area_detect.
 .TP
-.B on_camera_lost string
+.B on_camera_lost
 Values: Max 4095 characters / Default: Not defined
 .br
-Command to be executed when a camera can't be opened or if it is lost. You can use Conversion Specifiers and spaces as part of the command. Use %f for passing filename (with full path) to the command. (new in 3.2.10)
+Command to be executed when a camera can't be opened or if it is lost. You can use Conversion Specifiers and spaces as part of the command. Use %f for passing filename (with full path) to the command.
 .TP
 .B on_event_end string
 Values: Max 4095 characters / Default: Not defined
 .br
-Command to be executed when an event ends after a period of no motion. The period of no motion is defined by option gap. You can use Conversion Specifiers and spaces as part of the command.
+Command to be executed when an event ends after a period of no motion. The period of no motion is defined by option event_gap. You can use Conversion Specifiers and spaces as part of the command.
 .TP
 .B on_event_start string
 Values: Max 4095 characters / Default: Not defined
 .br
-Command to be executed when an event starts. An event starts at first motion detected after a period of no motion defined by gap. You can use ConversionSpecifiers and spaces as part of the command.
+Command to be executed when an event starts. An event starts at first motion detected after a period of no motion defined by event_gap. You can use ConversionSpecifiers and spaces as part of the command.
 .TP
 .B on_motion_detected string
 Values: Max 4095 characters / Default: Not defined
@@ -293,67 +339,42 @@ Command to be executed when an ffmpeg mo
 .B on_movie_start string
 Values: Max 4095 characters / Default: Not defined
 .br
-Command to be executed when an mpeg movie is created. You can use Conversion Specifiers and spaces as part of the command. Use %f for passing filename (with full path) to the command.
+Command to be executed when a movie is created. You can use Conversion Specifiers and spaces as part of the command. Use %f for passing filename (with full path) to the command.
 .TP
 .B on_picture_save string
 Values: Max 4095 characters / Default: Not defined
 .br
 Command to be executed when an image is saved. You can use Conversion Specifiers and spaces as part of the command. Use %f for passing filename (with full path) to the command.
 .TP
-.B output_all boolean
-Values: on, off / Default: off
-.br
-Picture are saved continuously as if motion was detected all the time.
-.TP
-.B output_motion boolean
+.B output_debug_pictures boolean
 Values: on, off / Default: off
 .br
 Output pictures with only the moving object. This feature generates the special motion type movies where you only see the pixels that changes as a graytone image. If labelling is enabled you see the largest area in blue. Smartmask is shown in red.
 .TP
-.B output_normal discrete strings
-Values: on, off, first, best, center (since 3.2.10) / Default: on
+.B output_pictures discrete strings
+Values: on, off, first, best, center / Default: on
 .br
 Normal image is an image that is stored when motion is detected. It is the same image that was taken by the camera. I.e. not a motion image like defined by output_motion. Default is that normal images are stored.
 .TP
-.B pgsql_db string
-Values: Max 4095 characters / Default: Not defined
-.br
-Name of the PostgreSQL database.
-.TP
-.B pgsql_host string
-Values: Max 4095 characters / Default: localhost
-.br
-IP address or domain name for the PostgreSQL server. Use "localhost" if motion and PostgreSQL runs on the same server.
-.TP
-.B pgsql_password string
-Values: Max 4095 characters / Default: Not defined
+.B picture_filename string
+Values: Max 4095 characters / Default: %v-%Y%m%d%H%M%S-%q
 .br
-The PostgreSQL password. 
+File path for motion triggered images (jpeg or ppm) relative to target_dir. Value 'preview' makes a jpeg filename with the same name body   as the associated saved movie file.
 .TP
-.B pgsql_port integer
-Values: 0 - 65535 / Default: 5432
+.B picture_type discrete strings
+Values: jpeg , ppm / Default: jpeg
 .br
-The PostgreSQL server port number.
-.TP
-.B pgsql_user string
-Values: Max 4095 characters / Default: Not defined
-.br
-The PostgreSQL user name. 
+Type of images motion will trigger when motion is detected.
 .TP
 .B post_capture integer
-Values: 0 - 2147483647  / Default: 0 (disabled)
+Values: 0 - 2147483647 / Default: 0 (disabled)
 .br
 Specifies the number of frames to be captured after motion has been detected.
 .TP
-.B ppm boolean
-Values: on, off / Default: off
-.br
-Output ppm images instead of jpeg. This uses less CPU time, but causes a LOT of hard disk I/O, and it is generally slower than jpeg.
-.TP
 .B pre_capture integer
 Values: 0 - 100s / Default: 0 (disabled)
 .br
-Specifies the number of previous frames to be outputted at motion detection. Recommended range: 0 to 5, default=0. Do not use large values! Large values will cause Motion to skip video frames and cause unsmooth mpegs. To smooth mpegs use larger values of post_capture instead.
+Specifies the number of previous frames to be outputted at motion detection. Recommended range: 0 to 5, default=0. Do not use large values! Large values will cause Motion to skip video frames and cause unsmooth movies. To smooth movies use larger values of post_capture instead.
 .TP
 .B process_id_file string
 Values: Max 4095 characters / Default: Not defined
@@ -373,7 +394,7 @@ Be quiet, don't output beeps when detect
 .B rotate discrete strings
 Values: 0, 90, 180, 270 / Default: 0 (not rotated)
 .br
-Rotate image the given number of degrees. The rotation affects all saved images as well as mpeg movies.
+Rotate image the given number of degrees. The rotation affects all saved images as well as movies.
 .TP
 .B roundrobin_frames integer
 Values: 1 - 2147483647 / Default: 1
@@ -390,10 +411,15 @@ Values: 0 - 255 / Default: 0 (disabled)
 .br
 The colour saturation level for the video device.
 .TP
+.B sdl_threadnr
+Values: 0 - 2147483647 / Default: 0 (disabled)
+.br
+Number of motion thread to show in SDL Window (default: 0 = disabled)
+.TP
 .B setup_mode boolean
 Values: on, off / Default: off
 .br
-Run Motion in setup mode. 
+Run Motion in setup mode.
 .TP
 .B smart_mask_speed integer
 Values: 0 - 10 / Default: 0 (disabled)
@@ -410,15 +436,15 @@ Values: 0 - 2147483647 / Default: 0 (dis
 .br
 Make automated snapshots every 'snapshot_interval' seconds.
 .TP
-.B sql_log_image boolean
+.B sql_log_picture boolean
 Values: on, off / Default: on
 .br
 Log to the database when creating motion triggered image file.
 .TP
-.B sql_log_mpeg boolean
+.B sql_log_movie boolean
 Values: on, off / Default: off
 .br
-Log to the database when creating motion triggered mpeg file.
+Log to the database when creating motion triggered movie file.
 .TP
 .B sql_log_snapshot boolean
 Values: on, off / Default: on
@@ -428,13 +454,53 @@ Log to the database when creating a snap
 .B sql_log_timelapse boolean
 Values: on, off / Default: off
 .br
-Log to the database when creating timelapse mpeg file
+Log to the database when creating timelapse movie file
 .TP
 .B sql_query string
-Values: Max 4095 characters / Default: insert into security(camera, filename, frame, file_type, time_stamp, text_event) values('%t', '%f', '%q', '%n', '%Y-%m-%d %T', '%C') 
+Values: Max 4095 characters / Default: insert into security(camera, filename, frame, file_type, time_stamp, text_event) values('%t', '%f', '%q', '%n', '%Y-%m-%d %T', '%C')
 .br
 SQL query string that is sent to the database. The values for each field are given by using convertion specifiers
 .TP
+.B stream_auth_method integer
+Values: 0 = disabled , 1 = Basic authentication ,2 = MD5 digest (the safer authentication). / Default: 0 (disabled)
+.br
+Set the authentication method for stream.
+.TP
+.B stream_authentication string
+Values: username:password / Default: not defined (disabled)
+.br
+Authentication for the stream.
+.TP
+.B stream_limit integer
+Values: 0 - 2147483647 / Default: 0 (unlimited)
+.br
+Limit the number of frames to number frames. After 'stream_limit' number of frames the connection will be closed by motion. The value 0 means unlimited.
+.TP
+.B stream_localhost boolean
+Values: on, off / Default: on
+.br
+Limits the access to the stream to the localhost.
+.TP
+.B stream_maxrate integer
+Values: 1 - 100 / Default: 1
+.br
+Limit the framerate of the stream in frames per second. Default is 1. Set the value to 100 for practically unlimited.
+.TP
+.B stream_motion boolean
+Values: on, off / Default: off
+.br
+If set to 'on' Motion sends slows down the stream to 1 picture per second when no motion is detected. When motion is detected the stream runs as defined by stream_maxrate. When 'off' the stream always runs as defined by stream_maxrate.
+.TP
+.B stream_port integer
+Values: 0 - 65535 / Default: 0 (disabled)
+.br
+TCP port on which motion will listen for incoming connects with its stream server.
+.TP
+.B stream_quality integer
+Values: 1 - 100 / Default: 50
+.br
+Quality setting in percent for the mjpeg picture frames transferred over the stream connection. Keep it low to restrict needed bandwidth.
+.TP
 .B switchfilter boolean
 Values: on, off / Default: off
 .br
@@ -458,17 +524,17 @@ Draw characters at twice normal size on
 .B text_event string
 Values: Max 4095 characters / Default: %Y%m%d%H%M%S
 .br
-This option defines the value of the speciel event conversion specifier %C. You can use any conversion specifier in this option except %C. Date and time values are from the timestamp of the first image in the current event.
+This option defines the value of the special event conversion specifier %C. You can use any conversion specifier in this option except %C. Date and time values are from the timestamp of the first image in the current event.
 .TP
 .B text_left string
 Values: Max 4095 characters / Default: Not defined
 .br
-User defined text overlayed on each in the lower left corner. Use A-Z, a-z, 0-9, " / ( ) @ ~ # < > , . : - + _ \n and vertical bar and conversion specifiers (codes starting by a %).
+User defined text overlayed on each in the lower left corner. Use A-Z, a-z, 0-9, " / ( ) @ ~ # < > | , . : - + _ \n and conversion specifiers (codes starting by a %).
 .TP
 .B text_right string
 Values: Max 4095 characters / Default: %Y-%m-%d\n%T
 .br
-User defined text overlayed on each in the lower right corner. Use A-Z, a-z, 0-9, " / ( ) @ ~ # < > , . : - + _ \n and vertical bar and conversion specifiers (codes starting by a %). Default: %Y-%m-%d\n%T = date in ISO format and time in 24 hour clock
+User defined text overlayed on each in the lower right corner. Use A-Z, a-z, 0-9, " / ( ) @ ~ # < > | , . : - + _ \n and conversion specifiers (codes starting by a %). Default: %Y-%m-%d\n%T = date in ISO format and time in 24 hour clock
 .TP
 .B thread string
 Values: Max 4095 characters / Default: Not defined
@@ -483,12 +549,12 @@ Threshold for declaring motion. The thre
 .B threshold_tune boolean
 Values: on, off / Default: off
 .br
-Activates the automatic tuning of threshold level. ( It's broken )
+Activates the automatic tuning of threshold level.
 .TP
 .B timelapse_filename string
 Values: Max 4095 characters / Default: %v-%Y%m%d-timelapse
 .br
-File path for timelapse mpegs relative to target_dir (ffmpeg only).
+File path for timelapse movies relative to target_dir (ffmpeg only).
 .TP
 .B track_auto boolean
 Values: on, off / Default: off
@@ -496,17 +562,17 @@ Values: on, off / Default: off
 Enable auto tracking
 .TP
 .B track_iomojo_id integer
-Values: 0 - 65535 / Default: 0 
+Values: 0 - 65535 / Default: 0
 .br
 Use this option if you have an iomojo smilecam connected to the serial port instead of a general stepper motor controller.
 .TP
 .B track_maxx integer
-Values: 0 - 65535 / Default: 0 
+Values: 0 - 65535 / Default: 0
 .br
 The maximum position for servo x.
 .TP
 .B track_maxy integer
-Values: 0 - 65535 / Default: 0 
+Values: 0 - 65535 / Default: 0
 .br
 The maximum position for servo y.
 .TP
@@ -551,7 +617,7 @@ Values: 0 - 255 / Default: 40
 Number of steps to make.
 .TP
 .B track_type discrete strings
-Values: 0 (none), 1 (stepper), 2 (iomojo), 3 (pwc), 4 (generic), 5 (uvcvideo) / Default: 0 (None)
+Values: 0 (none), 1 (stepper), 2 (iomojo), 3 (pwc), 4 (generic), 5 (uvcvideo)  / Default: 0 (None)
 .br
 Type of tracker.
 .TP
@@ -560,55 +626,52 @@ Values: Max 4095 characters / Default: /
 .br
 The tuner device used for controlling the tuner in a tuner card. This option is only used when Motion is compiled for FreeBSD.
 .TP
-.B v4l2_palette integer
-Values: 0 - 8 / Default: 8
+.B use_extpipe boolean
+Values: on, off / Default: off
 .br
-Allow to choose preferable palette to be use by motion<br /> to capture from those supported by your videodevice. ( new in 3.2.10 )
+Enables extpipe to use an external video encoder feeding with YUV420 using a pipe .
 .TP
-.B videodevice string
-Values: Max 4095 characters / Default: /dev/video0 (FreeBSD: /dev/bktr0)
+.B v4l2_palette discrete strings
+Values: 0 - 8 / Default: 8
 .br
-The video device to be used for capturing. Default for Linux is /dev/video0. for FreeBSD the default is /dev/bktr0.
+Allow to choose preferable palette to be use by motion to capture from those supported by your videodevice.
 .TP
 .B video_pipe string
 Values: Max 4095 characters / Default: Not defined
 .br
 The video4linux video loopback input device for normal images. If a particular pipe is to be used then use the device filename of this pipe. If a dash '-' is given motion will use /proc/video/vloopback/vloopbacks to locate a free pipe.
 .TP
-.B webcam_limit integer
-Values: 0 - 2147483647 / Default: 0 (unlimited)
+.B videodevice string
+Values: Max 4095 characters / Default: /dev/video0 (FreeBSD: /dev/bktr0)
 .br
-Limit the number of frames to number frames. After 'webcam_limit' number of frames the connection will be closed by motion. The value 0 means unlimited.
+The video device to be used for capturing. Default for Linux is /dev/video0. for FreeBSD the default is /dev/bktr0.
 .TP
-.B webcam_localhost boolean
-Values: on, off / Default: on
+.B webcontrol_authentication string
+Values: Max 4096 characters / Default: Not defined
 .br
-Limits the access to the webcam to the localhost.
+To protect HTTP Control by username and password, use this option for HTTP 1.1 Basic authentication. The string is specified as username:   password. Do not specify this option for no authentication. This option must be placed in motion.conf and not in a thread config file.
 .TP
-.B webcam_maxrate integer
-Values: 1 - 100 / Default: 1
+.B webcontrol_html_output boolean
+Values: on, off / Default: on
 .br
-Limit the framerate of the webcam in frames per second. Default is 1. Set the value to 100 for practically unlimited.
+Enable HTML in the answer sent back to a browser connecting to the webcontrol_port. This option must be placed in motion.conf and not in a  thread config file.
 .TP
-.B webcam_motion boolean
-Values: on, off / Default: off
+.B webcontrol_localhost boolean
+Values: on, off / Default: on
 .br
-If set to 'on' Motion sends slows down the webcam stream to 1 picture per second when no motion is detected. When motion is detected the stream runs as defined by webcam_maxrate. When 'off' the webcam stream always runs as defined by webcam_maxrate.
+Limits the webcontrol to the localhost. This option must be placed in motion.conf and not in a thread config file.
 .TP
-.B webcam_port integer
+.B webcontrol_port integer
 Values: 0 - 65535 / Default: 0 (disabled)
 .br
-TCP port on which motion will listen for incoming connects with its webcam server.
-.TP
-.B webcam_quality integer
-Values: 1 - 100 / Default: 50
-.br
-Quality setting in percent for the mjpeg picture frames transferred over the webcam connection. Keep it low to restrict needed bandwidth.
+Sets the port number for the http (html using browser) based remote webcontrol. This option must be placed in motion.conf and not in a thread config file.
+
 .TP
 .B width integer
 Values: Device Dependent / Default: 352
 .br
 The width in pixels of each frame. Valid range is camera dependent.
+
 .SH SIGNALS
 Motion responds to the following signals:
 .TP
@@ -616,17 +679,17 @@ Motion responds to the following signals
 The config file will be reread.
 .TP
 .B SIGTERM
-If needed motion will create an mpeg file of the last event and exit
+If needed motion will create a movie file of the last event and exit
 .TP
 .B SIGUSR1
-Motion will create an mpeg file of the current event.
+Motion will create a movie file of the current event.
 .SH NOTES
 .TP
 .B Snapshot
 A snapshot is a picture taken at regular intervals independently of any movement in the picture.
 .TP
 .B Motion image
-A "motion" image/mpeg shows the pixels that have actually changed during the last frames. These pictures are not very useful for normal presentation to the public but they are quite useful for testing and tuning and making mask files as you can see exactly where motion sees something moving. Motion is shown in greytones. If labelling is enabled the largest area is marked as blue. Smart mask is shown in read.
+A "motion" image/movie shows the pixels that have actually changed during the last frames. These pictures are not very useful for normal presentation to the public but they are quite useful for testing and tuning and making mask files as you can see exactly where motion sees something moving. Motion is shown in greytones. If labelling is enabled the largest area is marked as blue. Smart mask is shown in read.
 .TP
 .B Normal image
 A "normal" image is the real image taken by the camera with text overlayed.
@@ -674,13 +737,13 @@ So always call the thread config files i
 .br
 If motion is built without specific features such as ffmpeg, mysql etc it will ignore the options that belongs to these features. You do not have to remove them or comment them out.
 .br
-If you run the http control command http://host:port/0/config/writeyes, motion will overwrite motion.conf and all the thread.conf files by autogenerated config files neatly formatted and only with the features included that Motion was built with. If you later re-build Motion with more features or upgrade to a new version, you can use your old config files, run the motion.conf.write command, and you will have new config files with the new options included all set to their default values. This makes upgrading very easy to do. 
+If you run the webcontrol command http://host:port/0/config/writeyes, motion will overwrite motion.conf and all the thread.conf files by autogenerated config files neatly formatted and only with the features included that Motion was built with. If you later re-build Motion with more features or upgrade to a new version, you can use your old config files, run the motion.conf.write command, and you will have new config files with the new options included all set to their default values. This makes upgrading very easy to do.
 .TP
 .B Conversion Specifiers for Advanced Filename and Text Features
-The table below shows all the supported Conversion Specifiers you can use in the options text_left, text_right, snapshot_filename, jpeg_filename, ffmpeg_filename, timelapse_filename, on_area_detected, on_camera_lost, on_event_start, on_event_end, on_picture_save, on_movie_start, on_movie_end, and on_motion_detected.
-
+The table below shows all the supported Conversion Specifiers you can use in the options text_left, text_right, snapshot_filename, picture_filename, movie_filename, timelapse_filename, on_area_detected, on_camera_lost, on_event_start, on_event_end, on_picture_save, on_movie_start, on_movie_end, and on_motion_detected.
 .br
 In text_left and text_right you can additionally use '\n' for new line.
+
 .TP
 .B %a
 The abbreviated weekday name according to the current locale.
@@ -719,7 +782,7 @@ Equivalent to %Y-%m-%d (the ISO 8601 dat
 The hour as a decimal number using a 24-hour clock (range 00 to 23).
 .TP
 .B %i
-Width of the rectangle containing the motion pixels (the rectangle that is shown on the image when locate is on).
+Width of the rectangle containing the motion pixels (the rectangle that is shown on the image when locate_motion is on).
 .TP
 .B %I
 The hour as a decimal number using a 12-hour clock (range 01 to 12).
@@ -728,7 +791,7 @@ The hour as a decimal number using a 12-
 The day of the year as a decimal number (range 001 to 366).
 .TP
 .B %J
-Height of the rectangle containing the motion pixels (the rectangle that is shown on the image when locate is on).
+Height of the rectangle containing the motion pixels (the rectangle that is shown on the image when locate_motion is on).
 .TP
 .B %k
 The hour (24-hour clock) as a decimal number (range 0 to 23); single digits are preceded by a blank. (See also %H.)
@@ -764,7 +827,7 @@ Either 'AM' or 'PM' according to the giv
 Like %p but in lowercase: `am' or `pm' or a corresponding string for the current locale.
 .TP
 .B %q
-Picture frame number within current second. For jpeg filenames this should always be included in the filename if you save more then 1 picture per second to ensure unique filenames. It is not needed in filenames for mpegs.
+Picture frame number within current second. For jpeg filenames this should always be included in the filename if you save more then 1 picture per second to ensure unique filenames. It is not needed in filenames for movies.
 .TP
 .B %Q
 Number of detected labels found by the despeckle feature
@@ -822,16 +885,17 @@ The time-zone as hour offset from GMT.
 .TP
 .B %Z
 The time zone or name or abbreviation.
+
 .TP
 .B More information
 Motion homepage: http://motion.sourceforge.net/
 
 Motion Guide (user and installation guide):
 .br
-http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuide
+http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuide
 .br
-http://www.lavrsen.dk/foswiki/bin/view/Motion/VideoFourLinuxLoopbackDevice
+http://www.lavrsen.dk/twiki/bin/view/Motion/VideoFourLinuxLoopbackDevice
 .SH AUTHORS
 Jeroen Vreeken (pe1rxq@amsat.org),
 Folkert van Heusden,
-Kenneth Lavrsen (kenneth@lavrsen.dk)
\ No newline at end of file
+Kenneth Lavrsen (kenneth@lavrsen.dk)
--- motion-3.2.12.orig/motion.c
+++ motion-3.2.12/motion.c
@@ -9,7 +9,7 @@
 #include "ffmpeg.h"
 #include "motion.h"
 
-#if (defined(BSD) && !defined(PWCBSD))
+#if (defined(BSD) && !defined(PWCBSD)) 
 #include "video_freebsd.h"
 #else
 #include "video.h"
@@ -58,15 +58,11 @@ struct context **cnt_list = NULL;
  */
 volatile int threads_running = 0;
 
-/*
- * debug_level is for developers, normally used to control which
- * types of messages get output.
- */
-unsigned short int debug_level;
+/* Set this when we want main to end or restart */
+volatile unsigned int finish = 0;
 
-/* Set this when we want main to end or restart
- */
-volatile unsigned short int finish = 0;
+/* Log file used instead of stderr and syslog */ 
+FILE *ptr_logfile = NULL;
 
 /**
  * restart
@@ -75,7 +71,7 @@ volatile unsigned short int finish = 0;
  *   finished running, 'main' checks if 'restart' is true and if so starts
  *   up again (instead of just quitting).
  */
-unsigned short int restart = 0;
+unsigned int restart = 0;
 
 /**
  * image_ring_resize
@@ -92,29 +88,33 @@ unsigned short int restart = 0;
  */
 static void image_ring_resize(struct context *cnt, int new_size)
 {
-    /* Only resize if :
+    /* 
+     * Only resize if :
      * Not in an event and
      * decreasing at last position in new buffer
      * increasing at last position in old buffer 
-     * e.g. at end of smallest buffer */
+     * e.g. at end of smallest buffer 
+     */
     if (cnt->event_nr != cnt->prev_event) {
         int smallest;
-        
-        if (new_size < cnt->imgs.image_ring_size) { /* Decreasing */
+
+        if (new_size < cnt->imgs.image_ring_size)  /* Decreasing */
             smallest = new_size;
-        } else { /* Increasing */
+        else  /* Increasing */
             smallest = cnt->imgs.image_ring_size;
-        }
-
+        
         if (cnt->imgs.image_ring_in == smallest - 1 || smallest == 0) {
-            motion_log(LOG_INFO, 0, "Resizing pre_capture buffer to %d items", new_size);
+            MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Resizing pre_capture buffer to %d items",
+                       new_size);
 
             /* Create memory for new ring buffer */
             struct image_data *tmp;
             tmp = mymalloc(new_size * sizeof(struct image_data));
 
-            /* Copy all information from old to new 
-             * Smallest is 0 at initial init */
+            /* 
+             * Copy all information from old to new 
+             * Smallest is 0 at initial init 
+             */
             if (smallest > 0) 
                 memcpy(tmp, cnt->imgs.image_ring, sizeof(struct image_data) * smallest);
             
@@ -152,7 +152,7 @@ static void image_ring_resize(struct con
  */
 static void image_ring_destroy(struct context *cnt)
 {
-    unsigned short int i;
+    int i;
     
     /* Exit if don't have any ring */
     if (cnt->imgs.image_ring == NULL)
@@ -195,16 +195,30 @@ static void image_save_as_preview(struct
     /* Copy image */
     memcpy(cnt->imgs.preview_image.image, img->image, cnt->imgs.size);
 
-    /* If we set output_all to yes and during the event
-     * there is no image with motion, diffs is 0, we are not going to save the preview event */
+    /* 
+     * If we set output_all to yes and during the event
+     * there is no image with motion, diffs is 0, we are not going to save the preview event 
+     */
     if (cnt->imgs.preview_image.diffs == 0)
         cnt->imgs.preview_image.diffs = 1;
 
-    /* If we have locate on it is already done */
-    if (cnt->locate == LOCATE_PREVIEW) 
-        alg_draw_location(&img->location, &cnt->imgs, cnt->imgs.width, 
-                          cnt->imgs.preview_image.image, LOCATE_NORMAL);
-    
+    /* draw locate box here when mode = LOCATE_PREVIEW */
+    if (cnt->locate_motion_mode == LOCATE_PREVIEW) {
+
+        if (cnt->locate_motion_style == LOCATE_BOX) {
+            alg_draw_location(&img->location, &cnt->imgs, cnt->imgs.width, cnt->imgs.preview_image.image,
+                              LOCATE_BOX, LOCATE_NORMAL, cnt->process_thisframe);
+        } else if (cnt->locate_motion_style == LOCATE_REDBOX) {
+            alg_draw_red_location(&img->location, &cnt->imgs, cnt->imgs.width, cnt->imgs.preview_image.image,
+                                  LOCATE_REDBOX, LOCATE_NORMAL, cnt->process_thisframe);
+        } else if (cnt->locate_motion_style == LOCATE_CROSS) {
+            alg_draw_location(&img->location, &cnt->imgs, cnt->imgs.width, cnt->imgs.preview_image.image,
+                              LOCATE_CROSS, LOCATE_NORMAL, cnt->process_thisframe);
+        } else if (cnt->locate_motion_style == LOCATE_REDCROSS) {
+            alg_draw_red_location(&img->location, &cnt->imgs, cnt->imgs.width, cnt->imgs.preview_image.image,
+                                  LOCATE_REDCROSS, LOCATE_NORMAL, cnt->process_thisframe);
+        }     
+    }
 }
 
 /**
@@ -219,9 +233,9 @@ static void image_save_as_preview(struct
  *
  * Returns: nothing
  */
-static void context_init (struct context *cnt)
+static void context_init(struct context *cnt)
 {
-    /*
+   /*
     * We first clear the entire structure to zero, then fill in any
     * values which have non-zero default values.  Note that this
     * assumes that a NULL address pointer has a value of binary 0
@@ -255,7 +269,7 @@ static void context_init (struct context
  */
 static void context_destroy(struct context *cnt)
 {
-    unsigned short int j;
+    unsigned int j;
 
     /* Free memory allocated for config parameters */
     for (j = 0; config_params[j].param_name != NULL; j++) {
@@ -279,11 +293,12 @@ static void context_destroy(struct conte
  */
 static void sig_handler(int signo)
 {
-    short int i;
+    int i;
 
     switch(signo) {
     case SIGALRM:
-        /* Somebody (maybe we ourself) wants us to make a snapshot
+        /* 
+         * Somebody (maybe we ourself) wants us to make a snapshot
          * This feature triggers snapshots on ALL threads that have
          * snapshot_interval different from 0.
          */
@@ -292,13 +307,15 @@ static void sig_handler(int signo)
             while (cnt_list[++i]) {
                 if (cnt_list[i]->conf.snapshot_interval) 
                     cnt_list[i]->snapshot = 1;
-                    
+                
             }
         }
         break;
     case SIGUSR1:
-        /* Ouch! We have been hit from the outside! Someone wants us to
-           make a movie! */
+        /* 
+         * Ouch! We have been hit from the outside! Someone wants us to
+         * make a movie! 
+         */
         if (cnt_list) {
             i = -1;
             while (cnt_list[++i])
@@ -307,27 +324,33 @@ static void sig_handler(int signo)
         break;
     case SIGHUP:
         restart = 1;
-        /* Fall through, as the value of 'restart' is the only difference
+        /* 
+         * Fall through, as the value of 'restart' is the only difference
          * between SIGHUP and the ones below.
          */
     case SIGINT:
     case SIGQUIT:
     case SIGTERM:
-        /* Somebody wants us to quit! We should better finish the actual
-           movie and end up! */
+        /* 
+         * Somebody wants us to quit! We should better finish the actual
+         * movie and end up! 
+         */
         if (cnt_list) {
             i = -1;
             while (cnt_list[++i]) {
                 cnt_list[i]->makemovie = 1;
                 cnt_list[i]->finish = 1;
-                /* don't restart thread when it ends, 
+                /* 
+                 * Don't restart thread when it ends, 
                  * all threads restarts if global restart is set 
                  */
-                cnt_list[i]->restart = 0;
+                 cnt_list[i]->restart = 0;
             }
         }
-        /* Set flag we want to quit main check threads loop
-         * if restart is set (above) we start up again */
+        /*
+         * Set flag we want to quit main check threads loop
+         * if restart is set (above) we start up again 
+         */
         finish = 1;
         break;
     case SIGSEGV:
@@ -350,26 +373,34 @@ static void sigchild_handler(int signo A
 }
 
 /**
- *  motion_remove_pid
- *
- *  This function remove the process id file ( pid file ) before motion exit.
+ * motion_remove_pid
  *
+ *   This function remove the process id file ( pid file ) before motion exit.
  */
 static void motion_remove_pid(void)
 {
     if ((cnt_list[0]->daemon) && (cnt_list[0]->conf.pid_file) && (restart == 0)) {
         if (!unlink(cnt_list[0]->conf.pid_file)) 
-            motion_log(LOG_INFO, 0, "Removed process id file (pid file).");
+            MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Removed process id file (pid file).");
         else 
-            motion_log(LOG_INFO, 1, "Error removing pid file");
+            MOTION_LOG(ERR, TYPE_ALL, SHOW_ERRNO, "%s: Error removing pid file");
     }
+
+    if (ptr_logfile) { 
+        MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Closing logfile (%s).",  
+                   cnt_list[0]->conf.log_file);
+        myfclose(ptr_logfile);
+        set_log_mode(LOGMODE_SYSLOG);
+        ptr_logfile = NULL;
+    }        
+
 }
 
 /**
  * motion_detected
  *
  *   Called from 'motion_loop' when motion is detected
- *   Can be called when no motion if output_all is set!
+ *   Can be called when no motion if emulate_motion is set!
  *
  * Parameters:
  *
@@ -384,14 +415,29 @@ static void motion_detected(struct conte
     struct coord *location = &img->location;
 
     /* Draw location */
-    if (cnt->locate == LOCATE_ON)
-        alg_draw_location(location, imgs, imgs->width, img->image, LOCATE_BOTH);
+    if (cnt->locate_motion_mode == LOCATE_ON) {
+
+        if (cnt->locate_motion_style == LOCATE_BOX) {
+            alg_draw_location(location, imgs, imgs->width, img->image, LOCATE_BOX,
+                              LOCATE_BOTH, cnt->process_thisframe);
+        } else if (cnt->locate_motion_style == LOCATE_REDBOX) {
+            alg_draw_red_location(location, imgs, imgs->width, img->image, LOCATE_REDBOX,
+                                  LOCATE_BOTH, cnt->process_thisframe);
+        } else if (cnt->locate_motion_style == LOCATE_CROSS) {
+            alg_draw_location(location, imgs, imgs->width, img->image, LOCATE_CROSS, 
+                              LOCATE_BOTH, cnt->process_thisframe);
+        } else if (cnt->locate_motion_style == LOCATE_REDCROSS) {
+            alg_draw_red_location(location, imgs, imgs->width, img->image, LOCATE_REDCROSS, 
+                                  LOCATE_BOTH, cnt->process_thisframe);
+        }    
+    }
 
     /* Calculate how centric motion is if configured preview center*/
     if (cnt->new_img & NEWIMG_CENTER) {
-        unsigned int distX = abs((imgs->width/2) - location->x);
-        unsigned int distY = abs((imgs->height/2) - location->y);
-        img->cent_dist = distX*distX + distY*distY;
+        unsigned int distX = abs((imgs->width / 2) - location->x);
+        unsigned int distY = abs((imgs->height / 2) - location->y);
+
+        img->cent_dist = distX * distX + distY * distY;
     }
 
 
@@ -399,14 +445,16 @@ static void motion_detected(struct conte
     if (img->flags & IMAGE_TRIGGER) {
         /* Take action if this is a new event and we have a trigger image */
         if (cnt->event_nr != cnt->prev_event) {
-            /* Reset prev_event number to current event and save event time
+            /* 
+             * Reset prev_event number to current event and save event time
              * in both time_t and struct tm format.
              */
             cnt->prev_event = cnt->event_nr;
             cnt->eventtime = img->timestamp;
             localtime_r(&cnt->eventtime, cnt->eventtime_tm);
 
-            /* Since this is a new event we create the event_text_string used for
+            /* 
+             * Since this is a new event we create the event_text_string used for
              * the %C conversion specifier. We may already need it for
              * on_motion_detected_commend so it must be done now.
              */
@@ -416,8 +464,8 @@ static void motion_detected(struct conte
             /* EVENT_FIRSTMOTION triggers on_event_start_command and event_ffmpeg_newfile */
             event(cnt, EVENT_FIRSTMOTION, img->image, NULL, NULL, &img->timestamp_tm);
 
-            if (cnt->conf.setup_mode)
-                motion_log(-1, 0, "Motion detected - starting event %d", cnt->event_nr);
+            MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Motion detected - starting event %d", 
+                       cnt->event_nr);
 
             /* always save first motion frame as preview-shot, may be changed to an other one later */
             if (cnt->new_img & (NEWIMG_FIRST | NEWIMG_BEST | NEWIMG_CENTER)) 
@@ -431,23 +479,25 @@ static void motion_detected(struct conte
 
     /* Limit framerate */
     if (img->shot < conf->frame_limit) {
-        /* If config option webcam_motion is enabled, send the latest motion detected image
-         * to the webcam but only if it is not the first shot within a second. This is to
-         * avoid double frames since we already have sent a frame to the webcam.
+        /* 
+         * If config option stream_motion is enabled, send the latest motion detected image
+         * to the stream but only if it is not the first shot within a second. This is to
+         * avoid double frames since we already have sent a frame to the stream.
          * We also disable this in setup_mode.
          */
-        if (conf->webcam_motion && !conf->setup_mode && img->shot != 1) 
-            event(cnt, EVENT_WEBCAM, img->image, NULL, NULL, &img->timestamp_tm);
-        
+        if (conf->stream_motion && !conf->setup_mode && img->shot != 1) 
+            event(cnt, EVENT_STREAM, img->image, NULL, NULL, &img->timestamp_tm);
 
-        /* Save motion jpeg, if configured */
-        /* Output the image_out (motion) picture. */
+        /* 
+         * Save motion jpeg, if configured 
+         * Output the image_out (motion) picture. 
+         */
         if (conf->motion_img) 
             event(cnt, EVENT_IMAGEM_DETECTED, NULL, NULL, NULL, &img->timestamp_tm);
-        
     }
 
-    if (cnt->track.type) 
+    /* if track enabled and auto track on */
+    if (cnt->track.type && cnt->track.active) 
         cnt->moved = track_move(cnt, dev, location, imgs, 0);
     
 }
@@ -466,26 +516,99 @@ static void motion_detected(struct conte
 #define IMAGE_BUFFER_FLUSH ((unsigned int)-1)
 static void process_image_ring(struct context *cnt, unsigned int max_images)
 {
-    /* we are going to send an event, in the events there is still
+    /* 
+     * We are going to send an event, in the events there is still
      * some code that use cnt->current_image
-     * so set it temporary to our image */
+     * so set it temporary to our image 
+     */
     struct image_data *saved_current_image = cnt->current_image;
 
     /* If image is flaged to be saved and not saved yet, process it */
     do {
         /* Check if we should save/send this image, breakout if not */
-        if ((cnt->imgs.image_ring[cnt->imgs.image_ring_out].flags & 
-            (IMAGE_SAVE | IMAGE_SAVED)) != IMAGE_SAVE)
+        if ((cnt->imgs.image_ring[cnt->imgs.image_ring_out].flags & (IMAGE_SAVE | IMAGE_SAVED)) != IMAGE_SAVE)
             break;
 
         /* Set inte global cotext that we are working with this image */
         cnt->current_image = &cnt->imgs.image_ring[cnt->imgs.image_ring_out];
 
         if (cnt->imgs.image_ring[cnt->imgs.image_ring_out].shot < cnt->conf.frame_limit) {
+            if (cnt->log_level >= DBG) {
+                char tmp[32];
+                const char *t;
+
+                if (cnt->imgs.image_ring[cnt->imgs.image_ring_out].flags & IMAGE_TRIGGER)
+                    t = "Trigger";
+                else if (cnt->imgs.image_ring[cnt->imgs.image_ring_out].flags & IMAGE_MOTION)
+                    t = "Motion";
+                else if (cnt->imgs.image_ring[cnt->imgs.image_ring_out].flags & IMAGE_PRECAP)
+                    t = "Precap";
+                else if (cnt->imgs.image_ring[cnt->imgs.image_ring_out].flags & IMAGE_POSTCAP)
+                    t = "Postcap";
+                else
+                    t = "Other";
+
+                mystrftime(cnt, tmp, sizeof(tmp), "%H%M%S-%q", 
+                           &cnt->imgs.image_ring[cnt->imgs.image_ring_out].timestamp_tm, NULL, 0);
+                draw_text(cnt->imgs.image_ring[cnt->imgs.image_ring_out].image, 10, 20, 
+                          cnt->imgs.width, tmp, cnt->conf.text_double);
+                draw_text(cnt->imgs.image_ring[cnt->imgs.image_ring_out].image, 10, 30, 
+                          cnt->imgs.width, t, cnt->conf.text_double);
+            }
+
             /* Output the picture to jpegs and ffmpeg */
             event(cnt, EVENT_IMAGE_DETECTED,
                   cnt->imgs.image_ring[cnt->imgs.image_ring_out].image, NULL, NULL, 
                   &cnt->imgs.image_ring[cnt->imgs.image_ring_out].timestamp_tm);
+
+            /* 
+             * Check if we must add any "filler" frames into movie to keep up fps 
+             * Only if we are recording videos ( ffmpeg or extenal pipe )         
+             */
+            if ((cnt->imgs.image_ring[cnt->imgs.image_ring_out].shot == 0) &&
+#ifdef HAVE_FFMPEG
+                (cnt->ffmpeg_output || (cnt->conf.useextpipe && cnt->extpipe))) {
+#else
+                (cnt->conf.useextpipe && cnt->extpipe)) {
+#endif
+                /* 
+                 * movie_last_shoot is -1 when file is created,
+                 * we don't know how many frames there is in first sec 
+                 */
+                if (cnt->movie_last_shot >= 0) {
+                    if (cnt_list[0]->log_level >= DBG) {
+                        int frames = cnt->movie_fps - (cnt->movie_last_shot + 1);
+                        if (frames > 0) {
+                            char tmp[15];
+                            MOTION_LOG(DBG, TYPE_ALL, NO_ERRNO, "%s: Added %d fillerframes into movie", 
+                                       frames);
+                            sprintf(tmp, "Fillerframes %d", frames);
+                            draw_text(cnt->imgs.image_ring[cnt->imgs.image_ring_out].image, 10, 40, 
+                                      cnt->imgs.width, tmp, cnt->conf.text_double);
+                        }
+                    }
+                    /* Check how many frames it was last sec */
+                    while ((cnt->movie_last_shot + 1) < cnt->movie_fps) {
+                        /* Add a filler frame into encoder */
+                        event(cnt, EVENT_FFMPEG_PUT,
+                              cnt->imgs.image_ring[cnt->imgs.image_ring_out].image, NULL, NULL, 
+                              &cnt->imgs.image_ring[cnt->imgs.image_ring_out].timestamp_tm);
+
+                        cnt->movie_last_shot++;
+                    }
+                }
+                cnt->movie_last_shot = 0;
+            } else if (cnt->imgs.image_ring[cnt->imgs.image_ring_out].shot != (cnt->movie_last_shot + 1)) {
+                /* We are out of sync! Propably we got motion - no motion - motion */
+                cnt->movie_last_shot = -1;
+            }
+
+            /* 
+             * Save last shot added to movie
+             * only when we not are within first sec 
+             */
+            if (cnt->movie_last_shot >= 0)
+                cnt->movie_last_shot = cnt->imgs.image_ring[cnt->imgs.image_ring_out].shot;
         }
 
         /* Mark the image as saved */
@@ -493,17 +616,17 @@ static void process_image_ring(struct co
 
         /* Store it as a preview image, only if it have motion */
         if (cnt->imgs.image_ring[cnt->imgs.image_ring_out].flags & IMAGE_MOTION) {
-        
-            /* Check for most significant preview-shot when output_normal=best */
+            /* Check for most significant preview-shot when output_pictures=best */
             if (cnt->new_img & NEWIMG_BEST) {
-                if (cnt->imgs.image_ring[cnt->imgs.image_ring_out].diffs > cnt->imgs.preview_image.diffs) 
+                if (cnt->imgs.image_ring[cnt->imgs.image_ring_out].diffs > cnt->imgs.preview_image.diffs) {
                     image_save_as_preview(cnt, &cnt->imgs.image_ring[cnt->imgs.image_ring_out]);
+                }
             }
-
-            /* Check for most significant preview-shot when output_normal=center */
+            /* Check for most significant preview-shot when output_pictures=center */
             if (cnt->new_img & NEWIMG_CENTER) {
-                if (cnt->imgs.image_ring[cnt->imgs.image_ring_out].cent_dist < cnt->imgs.preview_image.cent_dist) 
+                if (cnt->imgs.image_ring[cnt->imgs.image_ring_out].cent_dist < cnt->imgs.preview_image.cent_dist) {
                     image_save_as_preview(cnt, &cnt->imgs.image_ring[cnt->imgs.image_ring_out]);
+                }
             }
         }
 
@@ -538,10 +661,10 @@ static void process_image_ring(struct co
  * Returns:     0 OK
  *             -1 Fatal error, open loopback error
  *             -2 Fatal error, open SQL database error
+ *             -3 Fatal error, image dimensions are not modulo 16
  */
 static int motion_init(struct context *cnt)
 {
-    int i;
     FILE *picture;
 
     /* Store thread number in TLS. */
@@ -555,34 +678,42 @@ static int motion_init(struct context *c
 
     cnt->smartmask_speed = 0;
 
-    /* We initialize cnt->event_nr to 1 and cnt->prev_event to 0 (not really needed) so
-     * that certain code below does not run until motion has been detected the first time */
+    /* 
+     * We initialize cnt->event_nr to 1 and cnt->prev_event to 0 (not really needed) so
+     * that certain code below does not run until motion has been detected the first time 
+     */
     cnt->event_nr = 1;
     cnt->prev_event = 0;
     cnt->lightswitch_framecounter = 0;
     cnt->detecting_motion = 0;
     cnt->makemovie = 0;
 
-    motion_log(LOG_DEBUG, 0, "Thread %d started", (unsigned long)pthread_getspecific(tls_key_threadnr));
+    MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Thread %d started , motion detection %s", 
+               (unsigned long)pthread_getspecific(tls_key_threadnr), cnt->pause ? "Disabled":"Enabled");
 
     if (!cnt->conf.filepath)
-        cnt->conf.filepath = strdup(".");
+        cnt->conf.filepath = mystrdup(".");
 
     /* set the device settings */
     cnt->video_dev = vid_start(cnt);
 
-    /* We failed to get an initial image from a camera
+    /* 
+     * We failed to get an initial image from a camera
      * So we need to guess height and width based on the config
      * file options.
      */
-    if (cnt->video_dev < 0) {
-        motion_log(LOG_ERR, 0, "Could not fetch initial image from camera");
-        motion_log(LOG_ERR, 0, "Motion continues using width and height from config file(s)");
+    if (cnt->video_dev == -1) {
+        MOTION_LOG(WRN, TYPE_ALL, NO_ERRNO, "%s: Could not fetch initial image from camera " 
+                   "Motion continues using width and height from config file(s)");
         cnt->imgs.width = cnt->conf.width;
         cnt->imgs.height = cnt->conf.height;
         cnt->imgs.size = cnt->conf.width * cnt->conf.height * 3 / 2;
         cnt->imgs.motionsize = cnt->conf.width * cnt->conf.height;
         cnt->imgs.type = VIDEO_PALETTE_YUV420P;
+    } else if (cnt->video_dev == -2) {
+        MOTION_LOG(WRN, TYPE_ALL, NO_ERRNO, "%s: Could not fetch initial image from camera "
+                   "Motion only supports width and height modulo 16");
+        return -3;
     }
 
     image_ring_resize(cnt, 1); /* Create a initial precapture ring buffer with 1 frame */
@@ -590,6 +721,7 @@ static int motion_init(struct context *c
     cnt->imgs.ref = mymalloc(cnt->imgs.size);
     cnt->imgs.out = mymalloc(cnt->imgs.size);
     memset(cnt->imgs.out, 0, cnt->imgs.size);
+
     /* contains the moving objects of ref. frame */
     cnt->imgs.ref_dyn = mymalloc(cnt->imgs.motionsize * sizeof(cnt->imgs.ref_dyn));
     cnt->imgs.image_virgin = mymalloc(cnt->imgs.size);
@@ -599,14 +731,23 @@ static int motion_init(struct context *c
     cnt->imgs.labels = mymalloc(cnt->imgs.motionsize * sizeof(cnt->imgs.labels));
     cnt->imgs.labelsize = mymalloc((cnt->imgs.motionsize/2+1) * sizeof(cnt->imgs.labelsize));
 
+    /* Set output picture type */
+    if (!strcmp(cnt->conf.picture_type, "ppm"))
+        cnt->imgs.picture_type = IMAGE_TYPE_PPM;
+    else
+        cnt->imgs.picture_type = IMAGE_TYPE_JPEG;
+
     /* allocate buffer here for preview buffer */
     cnt->imgs.preview_image.image = mymalloc(cnt->imgs.size);
 
-    /* Allocate a buffer for temp. usage in some places */
-    /* Only despeckle & bayer2rgb24() for now for now... */
+    /* 
+     * Allocate a buffer for temp. usage in some places 
+     * Only despeckle & bayer2rgb24() for now for now... 
+     */
     cnt->imgs.common_buffer = mymalloc(3 * cnt->imgs.width * cnt->imgs.height);
 
-    /* Now is a good time to init rotation data. Since vid_start has been
+    /* 
+     * Now is a good time to init rotation data. Since vid_start has been
      * called, we know that we have imgs.width and imgs.height. When capturing
      * from a V4L device, these are copied from the corresponding conf values
      * in vid_start. When capturing from a netcam, they get set in netcam_start,
@@ -618,130 +759,160 @@ static int motion_init(struct context *c
 
     /* Capture first image, or we will get an alarm on start */
     if (cnt->video_dev > 0) {
+        int i;
+
         for (i = 0; i < 5; i++) {
             if (vid_next(cnt, cnt->imgs.image_virgin) == 0)
                 break;
-            SLEEP(2,0);
+            SLEEP(2, 0);
         }
+
         if (i >= 5) {
             memset(cnt->imgs.image_virgin, 0x80, cnt->imgs.size);       /* initialize to grey */
             draw_text(cnt->imgs.image_virgin, 10, 20, cnt->imgs.width,
                       "Error capturing first image", cnt->conf.text_double);
-            motion_log(LOG_ERR, 0, "Error capturing first image");
+            MOTION_LOG(ERR, TYPE_ALL, NO_ERRNO, "%s: Error capturing first image");
         }
     }
 
     /* create a reference frame */
     alg_update_reference_frame(cnt, RESET_REF_FRAME);
 
-#if !defined(WITHOUT_V4L) && !defined(BSD)
+#if defined(HAVE_LINUX_VIDEODEV_H) && !defined(WITHOUT_V4L) && !defined(BSD)    
     /* open video loopback devices if enabled */
     if (cnt->conf.vidpipe) {
-        if (cnt->conf.setup_mode)
-            motion_log(-1, 0, "Opening video loopback device for normal pictures");
+        MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Opening video loopback device for normal pictures");
 
         /* vid_startpipe should get the output dimensions */
         cnt->pipe = vid_startpipe(cnt->conf.vidpipe, cnt->imgs.width, cnt->imgs.height, cnt->imgs.type);
 
         if (cnt->pipe < 0) {
-            motion_log(LOG_ERR, 0, "Failed to open video loopback");
+            MOTION_LOG(ERR, TYPE_ALL, NO_ERRNO, "%s: Failed to open video loopback for normal pictures"); 
             return -1;
         }
     }
+
     if (cnt->conf.motionvidpipe) {
-        if (cnt->conf.setup_mode)
-            motion_log(-1, 0, "Opening video loopback device for motion pictures");
+        MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Opening video loopback device for motion pictures"); 
 
         /* vid_startpipe should get the output dimensions */
         cnt->mpipe = vid_startpipe(cnt->conf.motionvidpipe, cnt->imgs.width, cnt->imgs.height, cnt->imgs.type);
 
         if (cnt->mpipe < 0) {
-            motion_log(LOG_ERR, 0, "Failed to open video loopback");
+            MOTION_LOG(ERR, TYPE_ALL, NO_ERRNO, "%s: Failed to open video loopback for motion pictures"); 
             return -1;
         }
     }
-#endif /*WITHOUT_V4L && !BSD */
+#endif /* !WITHOUT_V4L && !BSD */
 
-#ifdef HAVE_MYSQL
-    if (cnt->conf.mysql_db) {
-        cnt->database = (MYSQL *) mymalloc(sizeof(MYSQL));
-        mysql_init(cnt->database);
-
-        if (!mysql_real_connect(cnt->database, cnt->conf.mysql_host, cnt->conf.mysql_user,
-            cnt->conf.mysql_password, cnt->conf.mysql_db, 0, NULL, 0)) {
-            motion_log(LOG_ERR, 0, "Cannot connect to MySQL database %s on host %s with user %s",
-                       cnt->conf.mysql_db, cnt->conf.mysql_host, cnt->conf.mysql_user);
-            motion_log(LOG_ERR, 0, "MySQL error was %s", mysql_error(cnt->database));
-            return -2;
-        }
-        #if (defined(MYSQL_VERSION_ID)) && (MYSQL_VERSION_ID > 50012)
-        my_bool my_true = TRUE;
-        mysql_options(cnt->database,MYSQL_OPT_RECONNECT,&my_true);
-        #endif
+#if defined(HAVE_MYSQL) || defined(HAVE_PGSQL) || defined(HAVE_SQLITE3)
+    if (cnt->conf.database_type) {
+        MOTION_LOG(NTC, TYPE_DB, NO_ERRNO, "%s: Database backend %s",  
+                   cnt->conf.database_type);
+        
+#ifdef HAVE_SQLITE3
+    if ((!strcmp(cnt->conf.database_type, "sqlite3")) && cnt->conf.sqlite3_db) {
+        MOTION_LOG(NTC, TYPE_DB, NO_ERRNO, "%s: DB %s", 
+                   cnt->conf.sqlite3_db);
+
+        if (sqlite3_open(cnt->conf.sqlite3_db, &cnt->database_sqlite3) != SQLITE_OK) {
+            MOTION_LOG(ERR, TYPE_DB, NO_ERRNO, "%s: Can't open database %s : %s\n",  
+                       cnt->conf.sqlite3_db, sqlite3_errmsg(cnt->database_sqlite3));
+            sqlite3_close(cnt->database_sqlite3);
+            exit(1);
+        }
     }
+#endif /* HAVE_SQLITE3 */
+
+#ifdef HAVE_MYSQL
+        if ((!strcmp(cnt->conf.database_type, "mysql")) && (cnt->conf.database_dbname)) { 
+            // close database to be sure that we are not leaking
+            mysql_close(cnt->database);
+
+            cnt->database = (MYSQL *) mymalloc(sizeof(MYSQL));
+            mysql_init(cnt->database);
+
+            if (!mysql_real_connect(cnt->database, cnt->conf.database_host, cnt->conf.database_user,
+                cnt->conf.database_password, cnt->conf.database_dbname, 0, NULL, 0)) {
+                MOTION_LOG(ERR, TYPE_DB, NO_ERRNO, "%s: Cannot connect to MySQL database %s on host %s with user %s",
+                           cnt->conf.database_dbname, cnt->conf.database_host, 
+                           cnt->conf.database_user);
+                MOTION_LOG(ERR, TYPE_DB, NO_ERRNO, "%s: MySQL error was %s", mysql_error(cnt->database));
+                return -2;
+            }
+#if (defined(MYSQL_VERSION_ID)) && (MYSQL_VERSION_ID > 50012)
+            my_bool my_true = TRUE;
+            mysql_options(cnt->database, MYSQL_OPT_RECONNECT, &my_true);
+#endif
+        }
 #endif /* HAVE_MYSQL */
 
 #ifdef HAVE_PGSQL
-    if (cnt->conf.pgsql_db) {
-        char connstring[255];
+        if ((!strcmp(cnt->conf.database_type, "postgresql")) && (cnt->conf.database_dbname)) {
+            char connstring[255];
 
-        /* create the connection string.
-           Quote the values so we can have null values (blank)*/
-        snprintf(connstring, 255,
-                 "dbname='%s' host='%s' user='%s' password='%s' port='%d'",
-                 cnt->conf.pgsql_db, /* dbname */
-                 (cnt->conf.pgsql_host ? cnt->conf.pgsql_host : ""), /* host (may be blank) */
-                 (cnt->conf.pgsql_user ? cnt->conf.pgsql_user : ""), /* user (may be blank) */
-                 (cnt->conf.pgsql_password ? cnt->conf.pgsql_password : ""), /* password (may be blank) */
-                  cnt->conf.pgsql_port
-        );
-
-        cnt->database_pg = PQconnectdb(connstring);
-
-        if (PQstatus(cnt->database_pg) == CONNECTION_BAD) {
-            motion_log(LOG_ERR, 0, "Connection to PostgreSQL database '%s' failed: %s",
-                       cnt->conf.pgsql_db, PQerrorMessage(cnt->database_pg));
-            return -2;
+            /* 
+             * Create the connection string.
+             * Quote the values so we can have null values (blank)
+             */
+            snprintf(connstring, 255,
+                     "dbname='%s' host='%s' user='%s' password='%s' port='%d'",
+                      cnt->conf.database_dbname, /* dbname */
+                      (cnt->conf.database_host ? cnt->conf.database_host : ""), /* host (may be blank) */
+                      (cnt->conf.database_user ? cnt->conf.database_user : ""), /* user (may be blank) */
+                      (cnt->conf.database_password ? cnt->conf.database_password : ""), /* password (may be blank) */
+                      cnt->conf.database_port
+            );
+
+            cnt->database_pg = PQconnectdb(connstring);
+            if (PQstatus(cnt->database_pg) == CONNECTION_BAD) {
+                MOTION_LOG(ERR, TYPE_DB, NO_ERRNO, "%s: Connection to PostgreSQL database '%s' failed: %s",
+                           cnt->conf.database_dbname, PQerrorMessage(cnt->database_pg));
+                return -2;
+            }
         }
-    }
 #endif /* HAVE_PGSQL */
+    
 
+        /* Set the sql mask file according to the SQL config options*/
 
-#if defined(HAVE_MYSQL) || defined(HAVE_PGSQL)
-    /* Set the sql mask file according to the SQL config options*/
+        cnt->sql_mask = cnt->conf.sql_log_image * (FTYPE_IMAGE + FTYPE_IMAGE_MOTION) +
+                        cnt->conf.sql_log_snapshot * FTYPE_IMAGE_SNAPSHOT +
+                        cnt->conf.sql_log_movie * (FTYPE_MPEG + FTYPE_MPEG_MOTION) +
+                        cnt->conf.sql_log_timelapse * FTYPE_MPEG_TIMELAPSE;
+    }
 
-    cnt->sql_mask = cnt->conf.sql_log_image * (FTYPE_IMAGE + FTYPE_IMAGE_MOTION) +
-                    cnt->conf.sql_log_snapshot * FTYPE_IMAGE_SNAPSHOT +
-                    cnt->conf.sql_log_mpeg * (FTYPE_MPEG + FTYPE_MPEG_MOTION) +
-                    cnt->conf.sql_log_timelapse * FTYPE_MPEG_TIMELAPSE;
-#endif /* defined(HAVE_MYSQL) || defined(HAVE_PGSQL) */
+#endif /* defined(HAVE_MYSQL) || defined(HAVE_PGSQL) || defined(HAVE_SQLITE3) */
 
     /* Load the mask file if any */
     if (cnt->conf.mask_file) {
-        if ((picture = fopen(cnt->conf.mask_file, "r"))) {
-            /* NOTE: The mask is expected to have the output dimensions. I.e., the mask
+        if ((picture = myfopen(cnt->conf.mask_file, "r", 0))) {
+            /* 
+             * NOTE: The mask is expected to have the output dimensions. I.e., the mask
              * applies to the already rotated image, not the capture image. Thus, use
              * width and height from imgs.
              */
             cnt->imgs.mask = get_pgm(picture, cnt->imgs.width, cnt->imgs.height);
-            fclose(picture);
+            myfclose(picture);
         } else {
-            motion_log(LOG_ERR, 1, "Error opening mask file %s", cnt->conf.mask_file);
-            /* Try to write an empty mask file to make it easier
-               for the user to edit it */
+            MOTION_LOG(ERR, TYPE_ALL, SHOW_ERRNO, "%s: Error opening mask file %s", 
+                       cnt->conf.mask_file);
+            /* 
+             * Try to write an empty mask file to make it easier
+             * for the user to edit it 
+             */
             put_fixed_mask(cnt, cnt->conf.mask_file);
         }
 
         if (!cnt->imgs.mask) {
-            motion_log(LOG_ERR, 0, "Failed to read mask image. Mask feature disabled.");
+            MOTION_LOG(ERR, TYPE_ALL, NO_ERRNO, "%s: Failed to read mask image. Mask feature disabled."); 
         } else {
-            if (cnt->conf.setup_mode)
-                motion_log(-1, 0, "Maskfile \"%s\" loaded.",cnt->conf.mask_file);
+            MOTION_LOG(INF, TYPE_ALL, NO_ERRNO, "%s: Maskfile \"%s\" loaded.", 
+                       cnt->conf.mask_file);
         }
-
     } else {
         cnt->imgs.mask = NULL;
-    }    
+    }
 
     /* Always initialize smart_mask - someone could turn it on later... */
     memset(cnt->imgs.smartmask, 0, cnt->imgs.motionsize);
@@ -754,13 +925,15 @@ static int motion_init(struct context *c
     /* Set threshold value */
     cnt->threshold = cnt->conf.max_changes;
 
-    /* Initialize webcam server if webcam port is specified to not 0 */
-    if (cnt->conf.webcam_port) {
-        if (webcam_init(cnt) == -1) {
-            motion_log(LOG_ERR, 1, "Problem enabling stream server in port %d", cnt->conf.webcam_port);
+    /* Initialize stream server if stream port is specified to not 0 */
+    if (cnt->conf.stream_port) {
+        if (stream_init(cnt) == -1) {
+            MOTION_LOG(ERR, TYPE_ALL, SHOW_ERRNO, "%s: Problem enabling motion-stream server in port %d", 
+                       cnt->conf.stream_port);
             cnt->finish = 1;
-        } else {    
-            motion_log(LOG_DEBUG, 0, "Started stream webcam server in port %d", cnt->conf.webcam_port);
+        } else {  
+            MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Started motion-stream server in port %d auth %s", 
+                       cnt->conf.stream_port, cnt->conf.stream_auth_method ? "Enabled":"Disabled");
         }    
     }
 
@@ -786,11 +959,11 @@ static int motion_init(struct context *c
  */
 static void motion_cleanup(struct context *cnt)
 {
-    /* Stop webcam */
+    /* Stop stream */
     event(cnt, EVENT_STOP, NULL, NULL, NULL, NULL);
 
     if (cnt->video_dev >= 0) {
-        motion_log(LOG_DEBUG, 0, "Calling vid_close() from motion_cleanup");        
+        MOTION_LOG(INF, TYPE_ALL, NO_ERRNO, "%s: Calling vid_close() from motion_cleanup");        
         vid_close(cnt);
     }
 
@@ -874,6 +1047,26 @@ static void motion_cleanup(struct contex
         free(cnt->eventtime_tm);
         cnt->eventtime_tm = NULL;
     }
+
+    if (cnt->conf.database_type) {
+#ifdef HAVE_MYSQL
+        if ( (!strcmp(cnt->conf.database_type, "mysql")) && (cnt->conf.database_dbname)) {    
+            mysql_close(cnt->database); 
+        }
+#endif /* HAVE_MYSQL */
+
+#ifdef HAVE_PGSQL
+        if ((!strcmp(cnt->conf.database_type, "postgresql")) && (cnt->conf.database_dbname)) {
+            PQfinish(cnt->database_pg);
+        }
+#endif /* HAVE_PGSQL */ 
+
+#ifdef HAVE_SQLITE3    
+        /* Close the SQLite database */
+        if (cnt->conf.sqlite3_db)
+            sqlite3_close(cnt->database_sqlite3);
+#endif /* HAVE_SQLITE3 */
+    }
 }
 
 /**
@@ -888,34 +1081,33 @@ static void *motion_loop(void *arg)
     int i, j, z = 0;
     time_t lastframetime = 0;
     int frame_buffer_size;
-    unsigned short int ref_frame_limit = 0;
+    unsigned int rate_limit = 0;
     int area_once = 0;
     int area_minx[9], area_miny[9], area_maxx[9], area_maxy[9];
     int smartmask_ratio = 0;
     int smartmask_count = 20;
-    int smartmask_lastrate = 0;
+    unsigned int smartmask_lastrate = 0;
     int olddiffs = 0;
     int previous_diffs = 0, previous_location_x = 0, previous_location_y = 0;
-    unsigned short int text_size_factor;
-    unsigned short int passflag = 0;
+    unsigned int text_size_factor;
+    unsigned int passflag = 0;
     long int *rolling_average_data = NULL;
     long int rolling_average_limit, required_frame_time, frame_delay, delay_time_nsec;
     int rolling_frame = 0;
     struct timeval tv1, tv2;
     unsigned long int rolling_average, elapsedtime;
     unsigned long long int timenow = 0, timebefore = 0;
-    /* Return code used when calling vid_next */
-    int vid_return_code = 0;       
-    /* time in seconds to skip between capturing images */
-    int minimum_frame_time_downcounter = cnt->conf.minimum_frame_time;
-    /* Flag used to signal that we capture new image when we run the loop */
-    unsigned short int get_image = 1;
+    int vid_return_code = 0;        /* Return code used when calling vid_next */
+    int minimum_frame_time_downcounter = cnt->conf.minimum_frame_time; /* time in seconds to skip between capturing images */
+    unsigned int get_image = 1;    /* Flag used to signal that we capture new image when we run the loop */
+    struct image_data *old_image;
 
-    /* Next two variables are used for snapshot and timelapse feature
-     * time_last_frame is set to 1 so that first coming timelapse or second=0
+    /* 
+     * Next two variables are used for snapshot and timelapse feature
+     * time_last_frame is set to 1 so that first coming timelapse or second = 0
      * is acted upon.
      */
-    unsigned long int time_last_frame=1, time_current_frame;
+    unsigned long int time_last_frame = 1, time_current_frame;
 
     cnt->running = 1;
     
@@ -967,6 +1159,10 @@ static void *motion_loop(void *arg)
     for (j = 0; j < rolling_average_limit; j++)
         rolling_average_data[j] = required_frame_time;
 
+
+    if (cnt->track.type)
+        cnt->moved = track_center(cnt, cnt->video_dev, 0, 0, 0);
+
 #ifdef __OpenBSD__
     /* 
      * FIXMARK 
@@ -977,8 +1173,10 @@ static void *motion_loop(void *arg)
     setup_signals(&sig_handler_action, &sigchild_action);
 #endif
 
-    /* MAIN MOTION LOOP BEGINS HERE */
-    /* Should go on forever... unless you bought vaporware :) */
+    /*
+     * MAIN MOTION LOOP BEGINS HERE 
+     * Should go on forever... unless you bought vaporware :) 
+     */
 
     while (!cnt->finish || cnt->makemovie) {
 
@@ -990,34 +1188,49 @@ static void *motion_loop(void *arg)
         gettimeofday(&tv1, NULL);
         timenow = tv1.tv_usec + 1000000L * tv1.tv_sec;
 
-        /* since we don't have sanity checks done when options are set,
+        /* 
+         * Calculate detection rate limit. Above 5fps we limit the detection
+         * rate to 3fps to reduce load at higher framerates. 
+         */
+        cnt->process_thisframe = 0;
+        rate_limit++;
+        if (rate_limit >= (cnt->lastrate / 3)) {
+            rate_limit = 0;
+            cnt->process_thisframe = 1;
+        }
+
+        /* 
+         * Since we don't have sanity checks done when options are set,
          * this sanity check must go in the main loop :(, before pre_captures
-         * are attempted. */
+         * are attempted. 
+         */
         if (cnt->conf.minimum_motion_frames < 1)
             cnt->conf.minimum_motion_frames = 1;
-        
+
         if (cnt->conf.pre_capture < 0)
             cnt->conf.pre_capture = 0;
 
-        /* Check if our buffer is still the right size
+        /* 
+         * Check if our buffer is still the right size
          * If pre_capture or minimum_motion_frames has been changed
          * via the http remote control we need to re-size the ring buffer
          */
         frame_buffer_size = cnt->conf.pre_capture + cnt->conf.minimum_motion_frames;
-        
+
         if (cnt->imgs.image_ring_size != frame_buffer_size) 
             image_ring_resize(cnt, frame_buffer_size);
         
-
         /* Get time for current frame */
         cnt->currenttime = time(NULL);
 
-        /* localtime returns static data and is not threadsafe
+        /* 
+         * localtime returns static data and is not threadsafe
          * so we use localtime_r which is reentrant and threadsafe
          */
         localtime_r(&cnt->currenttime, cnt->currenttime_tm);
 
-        /* If we have started on a new second we reset the shots variable
+        /* 
+         * If we have started on a new second we reset the shots variable
          * lastrate is updated to be the number of the last frame. last rate
          * is used as the ffmpeg framerate when motion is detected.
          */
@@ -1025,6 +1238,7 @@ static void *motion_loop(void *arg)
             cnt->lastrate = cnt->shots + 1;
             cnt->shots = -1;
             lastframetime = cnt->currenttime;
+            
             if (cnt->conf.minimum_frame_time) {
                 minimum_frame_time_downcounter--;
                 if (minimum_frame_time_downcounter == 0)
@@ -1041,7 +1255,7 @@ static void *motion_loop(void *arg)
         if (cnt->startup_frames > 0)
             cnt->startup_frames--;
 
-        if (get_image){
+        if (get_image) {
             if (cnt->conf.minimum_frame_time) {
                 minimum_frame_time_downcounter = cnt->conf.minimum_frame_time;
                 get_image = 0;
@@ -1058,17 +1272,11 @@ static void *motion_loop(void *arg)
             }
 
             /* cnt->current_image points to position in ring where to store image, diffs etc. */
+            old_image = cnt->current_image;
             cnt->current_image = &cnt->imgs.image_ring[cnt->imgs.image_ring_in];
 
             /* Init/clear current_image */
-            {
-                /* Store time with pre_captured image */
-                cnt->current_image->timestamp = cnt->currenttime;
-                localtime_r(&cnt->current_image->timestamp, &cnt->current_image->timestamp_tm);
-
-                /* Store shot number with pre_captured image */
-                cnt->current_image->shot = cnt->shots;
-
+            if (cnt->process_thisframe) {
                 /* set diffs to 0 now, will be written after we calculated diffs in new image */
                 cnt->current_image->diffs = 0;
 
@@ -1079,31 +1287,52 @@ static void *motion_loop(void *arg)
                 /* Clear location data */
                 memset(&cnt->current_image->location, 0, sizeof(cnt->current_image->location));
                 cnt->current_image->total_labels = 0;
-            }
+            } else if (cnt->current_image && old_image) {
+                /* not processing this frame: save some important values for next image */
+                cnt->current_image->diffs = old_image->diffs;
+                cnt->current_image->timestamp = old_image->timestamp;
+                cnt->current_image->timestamp_tm = old_image->timestamp_tm;
+                cnt->current_image->shot = old_image->shot;
+                cnt->current_image->cent_dist = old_image->cent_dist;
+                cnt->current_image->flags = old_image->flags & (~IMAGE_SAVED);
+                cnt->current_image->location = old_image->location;
+                cnt->current_image->total_labels = old_image->total_labels;
+            }
+
+            /* Store time with pre_captured image */
+            cnt->current_image->timestamp = cnt->currenttime;
+            localtime_r(&cnt->current_image->timestamp, &cnt->current_image->timestamp_tm);
+
+            /* Store shot number with pre_captured image */
+            cnt->current_image->shot = cnt->shots;
 
         /***** MOTION LOOP - RETRY INITIALIZING SECTION *****/
-            /* If a camera is not available we keep on retrying every 10 seconds
+            /* 
+             * If a camera is not available we keep on retrying every 10 seconds
              * until it shows up.
              */
             if (cnt->video_dev < 0 &&
                 cnt->currenttime % 10 == 0 && cnt->shots == 0) {
-                motion_log(LOG_ERR, 0,
-                           "Retrying until successful connection with camera");
+                MOTION_LOG(WRN, TYPE_ALL, NO_ERRNO,
+                           "%s: Retrying until successful connection with camera");
                 cnt->video_dev = vid_start(cnt);
 
-                /* if the netcam has different dimensions than in the config file
+                /* 
+                 * If the netcam has different dimensions than in the config file
                  * we need to restart Motion to re-allocate all the buffers
                  */
                 if (cnt->imgs.width != cnt->conf.width || cnt->imgs.height != cnt->conf.height) {
-                    motion_log(LOG_ERR, 0, "Camera has finally become available");
-                    motion_log(LOG_ERR, 0, "Camera image has different width and height "
-                                           "from what is in the config file. You should fix that");
-                    motion_log(LOG_ERR, 0, "Restarting Motion thread to reinitialize all "
-                                           "image buffers to new picture dimensions");
+                    MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Camera has finally become available\n"
+                               "Camera image has different width and height"
+                               "from what is in the config file. You should fix that\n"
+                               "Restarting Motion thread to reinitialize all "
+                               "image buffers to new picture dimensions");
                     cnt->conf.width = cnt->imgs.width;
                     cnt->conf.height = cnt->imgs.height;
-                    /* Break out of main loop terminating thread 
-                     * watchdog will start us again */
+                    /* 
+                     * Break out of main loop terminating thread 
+                     * watchdog will start us again 
+                     */
                     break;
                 }
             }
@@ -1111,7 +1340,8 @@ static void *motion_loop(void *arg)
 
         /***** MOTION LOOP - IMAGE CAPTURE SECTION *****/
 
-            /* Fetch next frame from camera
+            /* 
+             * Fetch next frame from camera
              * If vid_next returns 0 all is well and we got a new picture
              * Any non zero value is an error.
              * 0 = OK, valid picture
@@ -1129,27 +1359,27 @@ static void *motion_loop(void *arg)
                 cnt->connectionlosttime = 0;
 
                 /* If all is well reset missing_frame_counter */
-                if (cnt->missing_frame_counter >= MISSING_FRAMES_TIMEOUT * cnt->conf.frame_limit) 
+                if (cnt->missing_frame_counter >= MISSING_FRAMES_TIMEOUT * cnt->conf.frame_limit) {
                     /* If we previously logged starting a grey image, now log video re-start */
-                    motion_log(LOG_ERR, 0, "Video signal re-acquired");
+                    MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Video signal re-acquired");
                     // event for re-acquired video signal can be called here
-                
-
+                }
                 cnt->missing_frame_counter = 0;
 
 #ifdef HAVE_FFMPEG
                 /* Deinterlace the image with ffmpeg, before the image is modified. */
                 if (cnt->conf.ffmpeg_deinterlace) 
                     ffmpeg_deinterlace(cnt->current_image->image, cnt->imgs.width, cnt->imgs.height);
-                
 #endif
 
-                /* save the newly captured still virgin image to a buffer
+                /* 
+                 * Save the newly captured still virgin image to a buffer
                  * which we will not alter with text and location graphics
                  */
                 memcpy(cnt->imgs.image_virgin, cnt->current_image->image, cnt->imgs.size);
 
-                /* If the camera is a netcam we let the camera decide the pace.
+                /* 
+                 * If the camera is a netcam we let the camera decide the pace.
                  * Otherwise we will keep on adding duplicate frames.
                  * By resetting the timer the framerate becomes maximum the rate
                  * of the Netcam.
@@ -1161,9 +1391,10 @@ static void *motion_loop(void *arg)
             // FATAL ERROR - leave the thread by breaking out of the main loop    
             } else if (vid_return_code < 0) {
                 /* Fatal error - Close video device */
-                motion_log(LOG_ERR, 0, "Video device fatal error - Closing video device");
+                MOTION_LOG(ERR, TYPE_ALL, NO_ERRNO, "%s: Video device fatal error - Closing video device"); 
                 vid_close(cnt);
-                /* Use virgin image, if we are not able to open it again next loop
+                /* 
+                 * Use virgin image, if we are not able to open it again next loop
                  * a gray image with message is applied
                  * flag lost_connection
                  */
@@ -1178,37 +1409,44 @@ static void *motion_loop(void *arg)
             */            
             } else { 
 
-                if (debug_level >= CAMERA_VERBOSE)
-                    motion_log(-1, 0, "vid_return_code %d", vid_return_code);
+                MOTION_LOG(DBG, TYPE_ALL, NO_ERRNO, "%s: vid_return_code %d", 
+                           vid_return_code);
 
-                /* Netcams that change dimensions while Motion is running will
+                /* 
+                 * Netcams that change dimensions while Motion is running will
                  * require that Motion restarts to reinitialize all the many
                  * buffers inside Motion. It will be a mess to try and recover any
                  * other way
                  */
                 if (vid_return_code == NETCAM_RESTART_ERROR) {
-                    motion_log(LOG_ERR, 0, "Restarting Motion thread to reinitialize all "
-                                           "image buffers");
-                    /* Break out of main loop terminating thread 
+                    MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Restarting Motion thread to reinitialize all "
+                               "image buffers");
+                    /* 
+                     * Break out of main loop terminating thread 
                      * watchdog will start us again 
-                     * Set lost_connection flag on */
+                     * Set lost_connection flag on 
+                     */
 
                     cnt->lost_connection = 1;
                     break;
                 }
 
-                /* First missed frame - store timestamp 
-                 * Don't reset time when thread restarts*/
+                /* 
+                 * First missed frame - store timestamp 
+                 * Don't reset time when thread restarts
+                 */
                 if (cnt->connectionlosttime == 0)
                     cnt->connectionlosttime = cnt->currenttime;
 
-                /* Increase missing_frame_counter
+                /* 
+                 * Increase missing_frame_counter
                  * The first MISSING_FRAMES_TIMEOUT seconds we copy previous virgin image
                  * After MISSING_FRAMES_TIMEOUT seconds we put a grey error image in the buffer
                  * If we still have not yet received the initial image from a camera
                  * we go straight for the grey error image.
                  */
                 ++cnt->missing_frame_counter;
+
                 if (cnt->video_dev >= 0 &&
                     cnt->missing_frame_counter < (MISSING_FRAMES_TIMEOUT * cnt->conf.frame_limit)) {
                     memcpy(cnt->current_image->image, cnt->imgs.image_virgin, cnt->imgs.size);
@@ -1231,17 +1469,20 @@ static void *motion_loop(void *arg)
 
                     /* Write error message only once */
                     if (cnt->missing_frame_counter == MISSING_FRAMES_TIMEOUT * cnt->conf.frame_limit) {
-                        motion_log(LOG_ERR, 0, "Video signal lost - Adding grey image");
+                        MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Video signal lost - Adding grey image"); 
                         // Event for lost video signal can be called from here
                         event(cnt, EVENT_CAMERA_LOST, NULL, NULL,
                               NULL, cnt->currenttime_tm);
                     }
 
-                    /* If we don't get a valid frame for a long time, try to close/reopen device 
-                     * Only try this when a device is open */
+                    /* 
+                     * If we don't get a valid frame for a long time, try to close/reopen device 
+                     * Only try this when a device is open 
+                     */
                     if ((cnt->video_dev > 0) && 
                         (cnt->missing_frame_counter == (MISSING_FRAMES_TIMEOUT * 4) * cnt->conf.frame_limit)) {
-                        motion_log(LOG_ERR, 0, "Video signal still lost - Trying to close video device");
+                        MOTION_LOG(ERR, TYPE_ALL, NO_ERRNO, "%s: Video signal still lost - "
+                                   "Trying to close video device");
                         vid_close(cnt);
                     }
                 }
@@ -1249,95 +1490,99 @@ static void *motion_loop(void *arg)
 
         /***** MOTION LOOP - MOTION DETECTION SECTION *****/
 
-            /* The actual motion detection takes place in the following
+            /* 
+             * The actual motion detection takes place in the following
              * diffs is the number of pixels detected as changed
              * Make a differences picture in image_out
              *
              * alg_diff_standard is the slower full feature motion detection algorithm
              * alg_diff first calls a fast detection algorithm which only looks at a
-             *   fraction of the pixels. If this detects possible motion alg_diff_standard
-             *   is called.
+             * fraction of the pixels. If this detects possible motion alg_diff_standard
+             * is called.
              */
-            if (cnt->threshold && !cnt->pause) {
-                /* if we've already detected motion and we want to see if there's
-                 * still motion, don't bother trying the fast one first. IF there's
-                 * motion, the alg_diff will trigger alg_diff_standard
-                 * anyway
-                 */
-                if (cnt->detecting_motion || cnt->conf.setup_mode)
-                    cnt->current_image->diffs = alg_diff_standard(cnt, cnt->imgs.image_virgin);
-                else
-                    cnt->current_image->diffs = alg_diff(cnt, cnt->imgs.image_virgin);
+            if (cnt->process_thisframe) {
+                if (cnt->threshold && !cnt->pause) {
+                    /* 
+                     * If we've already detected motion and we want to see if there's
+                     * still motion, don't bother trying the fast one first. IF there's
+                     * motion, the alg_diff will trigger alg_diff_standard
+                     * anyway
+                     */
+                    if (cnt->detecting_motion || cnt->conf.setup_mode)
+                        cnt->current_image->diffs = alg_diff_standard(cnt, cnt->imgs.image_virgin);
+                    else
+                        cnt->current_image->diffs = alg_diff(cnt, cnt->imgs.image_virgin);
 
-                /* Lightswitch feature - has light intensity changed?
-                 * This can happen due to change of light conditions or due to a sudden change of the camera
-                 * sensitivity. If alg_lightswitch detects lightswitch we suspend motion detection the next
-                 * 5 frames to allow the camera to settle.
-                 * Don't check if we have lost connection, we detect "Lost signal" frame as lightswitch
-                 */
-                if (cnt->conf.lightswitch && !cnt->lost_connection) {
-                    if (alg_lightswitch(cnt, cnt->current_image->diffs)) {
-                        if (cnt->conf.setup_mode)
-                            motion_log(-1, 0, "Lightswitch detected");
+                    /* Lightswitch feature - has light intensity changed?
+                     * This can happen due to change of light conditions or due to a sudden change of the camera
+                     * sensitivity. If alg_lightswitch detects lightswitch we suspend motion detection the next
+                     * 5 frames to allow the camera to settle.
+                     * Don't check if we have lost connection, we detect "Lost signal" frame as lightswitch
+                     */
+                    if (cnt->conf.lightswitch > 1 && !cnt->lost_connection) {
+                        if (alg_lightswitch(cnt, cnt->current_image->diffs)) {
+                            MOTION_LOG(INF, TYPE_ALL, NO_ERRNO, "%s: Lightswitch detected"); 
 
-                        if (cnt->moved < 5)
-                            cnt->moved = 5;
+                            if (cnt->moved < 5)
+                                cnt->moved = 5;
 
-                        cnt->current_image->diffs = 0;
-                        alg_update_reference_frame(cnt, RESET_REF_FRAME);
+                            cnt->current_image->diffs = 0;
+                            alg_update_reference_frame(cnt, RESET_REF_FRAME);
+                        }
                     }
-                }
 
-                /* Switchfilter feature tries to detect a change in the video signal
-                 * from one camera to the next. This is normally used in the Round
-                 * Robin feature. The algorithm is not very safe.
-                 * The algorithm takes a little time so we only call it when needed
-                 * ie. when feature is enabled and diffs>threshold.
-                 * We do not suspend motion detection like we did for lightswitch
-                 * because with Round Robin this is controlled by roundrobin_skip.
-                 */
-                if (cnt->conf.switchfilter && cnt->current_image->diffs > cnt->threshold) {
-                    cnt->current_image->diffs = alg_switchfilter(cnt, cnt->current_image->diffs, 
-                                                                 cnt->current_image->image);
+                    /* 
+                     * Switchfilter feature tries to detect a change in the video signal
+                     * from one camera to the next. This is normally used in the Round
+                     * Robin feature. The algorithm is not very safe.
+                     * The algorithm takes a little time so we only call it when needed
+                     * ie. when feature is enabled and diffs>threshold.
+                     * We do not suspend motion detection like we did for lightswitch
+                     * because with Round Robin this is controlled by roundrobin_skip.
+                     */
+                    if (cnt->conf.switchfilter && cnt->current_image->diffs > cnt->threshold) {
+                        cnt->current_image->diffs = alg_switchfilter(cnt, cnt->current_image->diffs, 
+                                                                     cnt->current_image->image);
                     
-                    if (cnt->current_image->diffs <= cnt->threshold) {
-                        cnt->current_image->diffs = 0;
-
-                        if (cnt->conf.setup_mode)
-                            motion_log(-1, 0, "Switchfilter detected");
+                        if (cnt->current_image->diffs <= cnt->threshold) {
+                            cnt->current_image->diffs = 0;
+                        
+                            MOTION_LOG(INF, TYPE_ALL, NO_ERRNO, "%s: Switchfilter detected");
+                        }
                     }
-                }
 
-                /* Despeckle feature
-                 * First we run (as given by the despeckle option iterations
-                 * of erode and dilate algorithms.
-                 * Finally we run the labelling feature.
-                 * All this is done in the alg_despeckle code.
-                 */
-                cnt->current_image->total_labels = 0;
-                cnt->imgs.largest_label = 0;
-                olddiffs = 0;
-
-                if (cnt->conf.despeckle && cnt->current_image->diffs > 0) {
-                    olddiffs = cnt->current_image->diffs;
-                    cnt->current_image->diffs = alg_despeckle(cnt, olddiffs);
-                } else if (cnt->imgs.labelsize_max) {
-                    cnt->imgs.labelsize_max = 0; /* Disable labeling if enabled */
-                }    
+                    /* 
+                     * Despeckle feature
+                     * First we run (as given by the despeckle_filter option iterations
+                     * of erode and dilate algorithms.
+                     * Finally we run the labelling feature.
+                     * All this is done in the alg_despeckle code.
+                     */
+                    cnt->current_image->total_labels = 0;
+                    cnt->imgs.largest_label = 0;
+                    olddiffs = 0;
+                
+                    if (cnt->conf.despeckle_filter && cnt->current_image->diffs > 0) {
+                        olddiffs = cnt->current_image->diffs;
+                        cnt->current_image->diffs = alg_despeckle(cnt, olddiffs);
+                    } else if (cnt->imgs.labelsize_max) {
+                        cnt->imgs.labelsize_max = 0; /* Disable labeling if enabled */
+                    }
 
-            } else if (!cnt->conf.setup_mode) {
-                cnt->current_image->diffs = 0;
+                } else if (!cnt->conf.setup_mode) {
+                    cnt->current_image->diffs = 0;
+                }
             }
 
             /* Manipulate smart_mask sensitivity (only every smartmask_ratio seconds) */
-            if (cnt->smartmask_speed && (cnt->event_nr != cnt->prev_event)) {
-                if (!--smartmask_count) {
-                    alg_tune_smartmask(cnt);
-                    smartmask_count = smartmask_ratio;
-                }
+            if ((cnt->smartmask_speed && (cnt->event_nr != cnt->prev_event)) && 
+                (!--smartmask_count)) {
+                alg_tune_smartmask(cnt);
+                smartmask_count = smartmask_ratio;
             }
 
-            /* cnt->moved is set by the tracking code when camera has been asked to move.
+            /* 
+             * cnt->moved is set by the tracking code when camera has been asked to move.
              * When camera is moving we do not want motion to detect motion or we will
              * get our camera chasing itself like crazy and we will get motion detected
              * which is not really motion. So we pretend there is no motion by setting
@@ -1352,57 +1597,61 @@ static void *motion_loop(void *arg)
 
         /***** MOTION LOOP - TUNING SECTION *****/
 
-            /* if noise tuning was selected, do it now. but only when
+            /* 
+             * If noise tuning was selected, do it now. but only when
              * no frames have been recorded and only once per second
              */
-            if (cnt->conf.noise_tune && cnt->shots == 0) {
-                if (!cnt->detecting_motion && (cnt->current_image->diffs <= cnt->threshold))
-                    alg_noise_tune(cnt, cnt->imgs.image_virgin);
-            }
+            if ((cnt->conf.noise_tune && cnt->shots == 0) &&
+                 (!cnt->detecting_motion && (cnt->current_image->diffs <= cnt->threshold)))
+                alg_noise_tune(cnt, cnt->imgs.image_virgin);
+            
 
-            /* if we are not noise tuning lets make sure that remote controlled
+            /* 
+             * If we are not noise tuning lets make sure that remote controlled
              * changes of noise_level are used.
              */
-            if (!cnt->conf.noise_tune)
-                cnt->noise = cnt->conf.noise;
+            if (cnt->process_thisframe) {
+                if (!cnt->conf.noise_tune)
+                    cnt->noise = cnt->conf.noise;
+
+                /* 
+                 * threshold tuning if enabled
+                 * if we are not threshold tuning lets make sure that remote controlled
+                 * changes of threshold are used.
+                 */
+                if (cnt->conf.threshold_tune)
+                    alg_threshold_tune(cnt, cnt->current_image->diffs, cnt->detecting_motion);
+                else
+                    cnt->threshold = cnt->conf.max_changes;
 
-            /* threshold tuning if enabled
-             * if we are not threshold tuning lets make sure that remote controlled
-             * changes of threshold are used.
-             */
-            if (cnt->conf.threshold_tune)
-                alg_threshold_tune(cnt, cnt->current_image->diffs, cnt->detecting_motion);
-            else
-                cnt->threshold = cnt->conf.max_changes;
+                /* 
+                 * If motion is detected (cnt->current_image->diffs > cnt->threshold) and before we add text to the pictures
+                 * we find the center and size coordinates of the motion to be used for text overlays and later
+                 * for adding the locate rectangle 
+                 */
+                if (cnt->current_image->diffs > cnt->threshold)
+                    alg_locate_center_size(&cnt->imgs, cnt->imgs.width, cnt->imgs.height, &cnt->current_image->location);
 
-            /* If motion is detected (cnt->current_image->diffs > cnt->threshold) and before we add text to the pictures
-               we find the center and size coordinates of the motion to be used for text overlays and later
-               for adding the locate rectangle */
-            if (cnt->current_image->diffs > cnt->threshold)
-                 alg_locate_center_size(&cnt->imgs, cnt->imgs.width, cnt->imgs.height, 
-                                        &cnt->current_image->location);
-
-            /* Update reference frame. */
-            /* micro-lighswitch: e.g. neighbors cat switched on the motion sensitive *
-             * frontdoor illumination. Updates are rate-limited to 3 per second at   *
-             * framerates above 5fps to save CPU resources and to keep sensitivity   *
-             * at a constant level.                                                  *
-             */
-            ref_frame_limit++;
-            if (ref_frame_limit >= (cnt->lastrate / 3)) {
-                ref_frame_limit = 0;
+                /* 
+                 * Update reference frame. 
+                 * micro-lighswitch: trying to auto-detect lightswitch events. 
+                 * frontdoor illumination. Updates are rate-limited to 3 per second at   
+                 * framerates above 5fps to save CPU resources and to keep sensitivity   
+                 * at a constant level.                                                  
+                 */
 
-                if ((cnt->current_image->diffs > cnt->threshold) && 
-                    (cnt->lightswitch_framecounter < (cnt->lastrate * 2)) && /* two seconds window */
+                if ((cnt->current_image->diffs > cnt->threshold) && (cnt->conf.lightswitch == 1) &&
+                    (cnt->lightswitch_framecounter < (cnt->lastrate * 2)) && /* two seconds window only */
+                    /* number of changed pixels almost the same in two consecutive frames and */
                     ((abs(previous_diffs - cnt->current_image->diffs)) < (previous_diffs / 15)) &&
+                    /* center of motion in about the same place ? */
                     ((abs(cnt->current_image->location.x - previous_location_x)) <= (cnt->imgs.width / 150)) &&
                     ((abs(cnt->current_image->location.y - previous_location_y)) <= (cnt->imgs.height / 150))) {
                     alg_update_reference_frame(cnt, RESET_REF_FRAME);
                     cnt->current_image->diffs = 0;
                     cnt->lightswitch_framecounter = 0;
-                    if (cnt->conf.setup_mode)
-                        motion_log(-1, 0, "micro-lightswitch!");
 
+                    MOTION_LOG(INF, TYPE_ALL, NO_ERRNO, "%s: micro-lightswitch!"); 
                 } else {
                     alg_update_reference_frame(cnt, UPDATE_REF_FRAME);
                 }
@@ -1414,23 +1663,26 @@ static void *motion_loop(void *arg)
 
         /***** MOTION LOOP - TEXT AND GRAPHICS OVERLAY SECTION *****/
 
-            /* Some overlays on top of the motion image
+            /* 
+             * Some overlays on top of the motion image
              * Note that these now modifies the cnt->imgs.out so this buffer
              * can no longer be used for motion detection features until next
              * picture frame is captured.
              */
 
             /* Smartmask overlay */
-            if (cnt->smartmask_speed && (cnt->conf.motion_img || cnt->conf.ffmpeg_cap_motion || cnt->conf.setup_mode))
+            if (cnt->smartmask_speed && (cnt->conf.motion_img || cnt->conf.ffmpeg_output_debug || 
+                cnt->conf.setup_mode))
                 overlay_smartmask(cnt, cnt->imgs.out);
 
             /* Largest labels overlay */
-            if (cnt->imgs.largest_label && (cnt->conf.motion_img || cnt->conf.ffmpeg_cap_motion || cnt->conf.setup_mode))
+            if (cnt->imgs.largest_label && (cnt->conf.motion_img || cnt->conf.ffmpeg_output_debug || 
+                cnt->conf.setup_mode))
                 overlay_largest_label(cnt, cnt->imgs.out);
 
-
             /* Fixed mask overlay */
-            if (cnt->imgs.mask && (cnt->conf.motion_img || cnt->conf.ffmpeg_cap_motion || cnt->conf.setup_mode))
+            if (cnt->imgs.mask && (cnt->conf.motion_img || cnt->conf.ffmpeg_output_debug || 
+                cnt->conf.setup_mode))
                 overlay_fixed_mask(cnt, cnt->imgs.out);
 
             /* Initialize the double sized characters if needed. */
@@ -1450,15 +1702,18 @@ static void *motion_loop(void *arg)
                 else
                     sprintf(tmp, "-");
 
-                draw_text(cnt->current_image->image, cnt->imgs.width - 10, 10, cnt->imgs.width, 
-                          tmp, cnt->conf.text_double);
+                draw_text(cnt->current_image->image, cnt->imgs.width - 10, 10, 
+                          cnt->imgs.width, tmp, cnt->conf.text_double);
             }
 
-            /* Add changed pixels to motion-images (for webcam) in setup_mode
-               and always overlay smartmask (not only when motion is detected) */
+            /* 
+             * Add changed pixels to motion-images (for stream) in setup_mode
+             * and always overlay smartmask (not only when motion is detected) 
+             */
             if (cnt->conf.setup_mode) {
                 char tmp[PATH_MAX];
-                sprintf(tmp, "D:%5d L:%3d N:%3d", cnt->current_image->diffs, cnt->current_image->total_labels, cnt->noise);
+                sprintf(tmp, "D:%5d L:%3d N:%3d", cnt->current_image->diffs, 
+                        cnt->current_image->total_labels, cnt->noise);
                 draw_text(cnt->imgs.out, cnt->imgs.width - 10, cnt->imgs.height - 30 * text_size_factor,
                           cnt->imgs.width, tmp, cnt->conf.text_double);
                 sprintf(tmp, "THREAD %d SETUP", cnt->threadnr);
@@ -1469,16 +1724,19 @@ static void *motion_loop(void *arg)
             /* Add text in lower left corner of the pictures */
             if (cnt->conf.text_left) {
                 char tmp[PATH_MAX];
-                mystrftime(cnt, tmp, sizeof(tmp), cnt->conf.text_left, &cnt->current_image->timestamp_tm, NULL, 0);
-                draw_text(cnt->current_image->image, 10, cnt->imgs.height - 10 * text_size_factor, cnt->imgs.width,
-                          tmp, cnt->conf.text_double);
+                mystrftime(cnt, tmp, sizeof(tmp), cnt->conf.text_left, 
+                           &cnt->current_image->timestamp_tm, NULL, 0);
+                draw_text(cnt->current_image->image, 10, cnt->imgs.height - 10 * text_size_factor, 
+                          cnt->imgs.width, tmp, cnt->conf.text_double);
             }
 
             /* Add text in lower right corner of the pictures */
             if (cnt->conf.text_right) {
                 char tmp[PATH_MAX];
-                mystrftime(cnt, tmp, sizeof(tmp), cnt->conf.text_right, &cnt->current_image->timestamp_tm, NULL, 0);
-                draw_text(cnt->current_image->image, cnt->imgs.width - 10, cnt->imgs.height - 10 * text_size_factor,
+                mystrftime(cnt, tmp, sizeof(tmp), cnt->conf.text_right, 
+                           &cnt->current_image->timestamp_tm, NULL, 0);
+                draw_text(cnt->current_image->image, cnt->imgs.width - 10, 
+                          cnt->imgs.height - 10 * text_size_factor,
                           cnt->imgs.width, tmp, cnt->conf.text_double);
             }
 
@@ -1489,24 +1747,36 @@ static void *motion_loop(void *arg)
                 /* flag this image, it have motion */
                 cnt->current_image->flags |= IMAGE_MOTION;
                 cnt->lightswitch_framecounter++; /* micro lightswitch */
-            } else {
+            } else { 
                 cnt->lightswitch_framecounter = 0;
             }    
 
-            /* If motion has been detected we take action and start saving
+            /* 
+             * If motion has been detected we take action and start saving
              * pictures and movies etc by calling motion_detected().
-             * Is output_all enabled we always call motion_detected()
+             * Is emulate_motion enabled we always call motion_detected()
              * If post_capture is enabled we also take care of this in the this
              * code section.
              */
-            if (cnt->conf.output_all && (cnt->startup_frames == 0)) {
+            if (cnt->conf.emulate_motion && (cnt->startup_frames == 0)) {
                 cnt->detecting_motion = 1;
-                /* Setup the postcap counter */
-                cnt->postcap = cnt->conf.post_capture;
+                MOTION_LOG(INF, TYPE_ALL, NO_ERRNO, "%s: Emulating motion");
+#ifdef HAVE_FFMPEG
+                if (cnt->ffmpeg_output || (cnt->conf.useextpipe && cnt->extpipe)) {
+#else
+                if (cnt->conf.useextpipe && cnt->extpipe) {
+#endif
+                    /* Setup the postcap counter */
+                    cnt->postcap = cnt->conf.post_capture;
+                    MOTION_LOG(DBG, TYPE_ALL, NO_ERRNO, "%s: (Em) Init post capture %d", 
+                               cnt->postcap);
+                }
+
                 cnt->current_image->flags |= (IMAGE_TRIGGER | IMAGE_SAVE);
                 motion_detected(cnt, cnt->video_dev, cnt->current_image);
             } else if ((cnt->current_image->flags & IMAGE_MOTION) && (cnt->startup_frames == 0)) {
-                /* Did we detect motion (like the cat just walked in :) )?
+                /* 
+                 * Did we detect motion (like the cat just walked in :) )?
                  * If so, ensure the motion is sustained if minimum_motion_frames
                  */
 
@@ -1514,7 +1784,8 @@ static void *motion_loop(void *arg)
                 int frame_count = 0;
                 int pos = cnt->imgs.image_ring_in;
 
-                for(i = 0; i < cnt->conf.minimum_motion_frames; i++) {
+                for (i = 0; i < cnt->conf.minimum_motion_frames; i++) {
+                
                     if (cnt->imgs.image_ring[pos].flags & IMAGE_MOTION)
                         frame_count++;
 
@@ -1522,34 +1793,56 @@ static void *motion_loop(void *arg)
                         pos = cnt->imgs.image_ring_size-1;
                     else 
                         pos--;
-                    
                 }
 
                 if (frame_count >= cnt->conf.minimum_motion_frames) {
+
                     cnt->current_image->flags |= (IMAGE_TRIGGER | IMAGE_SAVE);
                     cnt->detecting_motion = 1;
+
                     /* Setup the postcap counter */
                     cnt->postcap = cnt->conf.post_capture;
+                    MOTION_LOG(DBG, TYPE_ALL, NO_ERRNO, "%s: Setup post capture %d", 
+                               cnt->postcap);
+
                     /* Mark all images in image_ring to be saved */
-                    for(i = 0; i < cnt->imgs.image_ring_size; i++) 
+                    for (i = 0; i < cnt->imgs.image_ring_size; i++) 
                         cnt->imgs.image_ring[i].flags |= IMAGE_SAVE;
                     
-                } else if (cnt->postcap) { /* we have motion in this frame, but not enought frames for trigger. Check postcap */
+                } else if ((cnt->postcap) && 
+#ifdef HAVE_FFMPEG
+                           (cnt->ffmpeg_output || (cnt->conf.useextpipe && cnt->extpipe))) {
+#else
+                           (cnt->conf.useextpipe && cnt->extpipe)) {			
+#endif 
+                   /* we have motion in this frame, but not enought frames for trigger. Check postcap */
                     cnt->current_image->flags |= (IMAGE_POSTCAP | IMAGE_SAVE);
                     cnt->postcap--;
+                    MOTION_LOG(DBG, TYPE_ALL, NO_ERRNO, "%s: post capture %d", 
+                               cnt->postcap);
                 } else {
                     cnt->current_image->flags |= IMAGE_PRECAP;
                 }
 
                 /* Always call motion_detected when we have a motion image */
                 motion_detected(cnt, cnt->video_dev, cnt->current_image);
-            } else if (cnt->postcap) {
+            } else if ((cnt->postcap) && 
+#ifdef HAVE_FFMPEG
+                      (cnt->ffmpeg_output || (cnt->conf.useextpipe && cnt->extpipe))) {
+#else
+                      (cnt->conf.useextpipe && cnt->extpipe)) {	
+#endif
                 /* No motion, doing postcap */
                 cnt->current_image->flags |= (IMAGE_POSTCAP | IMAGE_SAVE);
                 cnt->postcap--;
+                MOTION_LOG(DBG, TYPE_ALL, NO_ERRNO, "%s: post capture %d", 
+                           cnt->postcap);
             } else {
                 /* Done with postcap, so just have the image in the precap buffer */
                 cnt->current_image->flags |= IMAGE_PRECAP;
+                /* gapless movie feature */
+                if ((cnt->conf.event_gap == 0) && (cnt->detecting_motion == 1))
+                    cnt->makemovie = 1;
                 cnt->detecting_motion = 0;
             }
 
@@ -1558,16 +1851,16 @@ static void *motion_loop(void *arg)
                 cnt->lasttime = cnt->current_image->timestamp;
             
 
-            /* Simple hack to recognize motion in a specific area */
-            /* Do we need a new coversion specifier as well?? */
+            /* 
+             * Simple hack to recognize motion in a specific area 
+             * Do we need a new coversion specifier as well?? 
+             */
             if ((cnt->conf.area_detect) && (cnt->event_nr != area_once) && 
                 (cnt->current_image->flags & IMAGE_TRIGGER)) {
-
                 j = strlen(cnt->conf.area_detect);
-
+                
                 for (i = 0; i < j; i++) {
                     z = cnt->conf.area_detect[i] - 49; /* 1 becomes 0 */
-
                     if ((z >= 0) && (z < 9)) {
                         if (cnt->current_image->location.x > area_minx[z] &&
                             cnt->current_image->location.x < area_maxx[z] &&
@@ -1576,27 +1869,29 @@ static void *motion_loop(void *arg)
                             event(cnt, EVENT_AREA_DETECTED, NULL, NULL,
                                   NULL, cnt->currenttime_tm);
                             area_once = cnt->event_nr; /* Fire script only once per event */
-                            
-                            if (cnt->conf.setup_mode)
-                                motion_log(-1, 0, "Motion in area %d detected.\n", z+1);
 
+                            MOTION_LOG(DBG, TYPE_ALL, NO_ERRNO, "%s: Motion in area %d detected.",
+                                       z + 1);
                             break;
                         }
                     }
                 }
             }
             
-            /* Is the mpeg movie to long? Then make movies
-             * First test for max mpegtime
-             */
-            if (cnt->conf.maxmpegtime && cnt->event_nr == cnt->prev_event)
-                if (cnt->currenttime - cnt->eventtime >= cnt->conf.maxmpegtime)
-                    cnt->makemovie = 1;
+            /* 
+             * Is the movie too long? Then make movies
+             * First test for max_movie_time
+             */
+            if ((cnt->conf.max_movie_time && cnt->event_nr == cnt->prev_event) &&
+                (cnt->currenttime - cnt->eventtime >= cnt->conf.max_movie_time))
+                cnt->makemovie = 1;
 
-            /* Now test for quiet longer than 'gap' OR make movie as decided in
+            /* 
+             * Now test for quiet longer than 'gap' OR make movie as decided in
              * previous statement.
              */
-            if (((cnt->currenttime - cnt->lasttime >= cnt->conf.gap) && cnt->conf.gap > 0) || cnt->makemovie) {
+            if (((cnt->currenttime - cnt->lasttime >= cnt->conf.event_gap) && cnt->conf.event_gap > 0) || 
+                  cnt->makemovie) {
                 if (cnt->event_nr == cnt->prev_event || cnt->makemovie) {
 
                     /* Flush image buffer */
@@ -1610,14 +1905,15 @@ static void *motion_loop(void *arg)
 
                     event(cnt, EVENT_ENDMOTION, NULL, NULL, NULL, cnt->currenttime_tm);
 
-                    /* if tracking is enabled we center our camera so it does not
+                    /* 
+                     * If tracking is enabled we center our camera so it does not
                      * point to a place where it will miss the next action
                      */
                     if (cnt->track.type)
                         cnt->moved = track_center(cnt, cnt->video_dev, 0, 0, 0);
 
-                    if (cnt->conf.setup_mode)
-                        motion_log(-1, 0, "End of event %d", cnt->event_nr);
+                    MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: End of event %d", 
+                               cnt->event_nr);
 
                     cnt->makemovie = 0;
                     /* Reset post capture */
@@ -1627,7 +1923,8 @@ static void *motion_loop(void *arg)
                     cnt->event_nr++;
                     cnt->lightswitch_framecounter = 0;
 
-                    /* And we unset the text_event_string to avoid that buffered
+                    /* 
+                     * And we unset the text_event_string to avoid that buffered
                      * images get a timestamp from previous event.
                      */
                     cnt->text_event_string[0] = '\0';
@@ -1639,17 +1936,16 @@ static void *motion_loop(void *arg)
 
         /***** MOTION LOOP - SETUP MODE CONSOLE OUTPUT SECTION *****/
 
-            /* If setup_mode enabled output some numbers to console */
+            /* If CAMERA_VERBOSE enabled output some numbers to console */
             if (cnt->conf.setup_mode) {
                 char msg[1024] = "\0";
                 char part[100];
 
-                if (cnt->conf.despeckle) {
+                if (cnt->conf.despeckle_filter) {
                     snprintf(part, 99, "Raw changes: %5d - changes after '%s': %5d",
-                             olddiffs, cnt->conf.despeckle, cnt->current_image->diffs);
+                             olddiffs, cnt->conf.despeckle_filter, cnt->current_image->diffs);
                     strcat(msg, part);
-
-                    if (strchr(cnt->conf.despeckle, 'l')){
+                    if (strchr(cnt->conf.despeckle_filter, 'l')) {
                         sprintf(part, " - labels: %3d", cnt->current_image->total_labels);
                         strcat(msg, part);
                     }
@@ -1668,14 +1964,15 @@ static void *motion_loop(void *arg)
                     strcat(msg, part);
                 }
 
-                motion_log(-1, 0, "%s", msg);
+                MOTION_LOG(INF, TYPE_ALL, NO_ERRNO, "%s: %s", msg);
             }
 
         } /* get_image end */
 
     /***** MOTION LOOP - SNAPSHOT FEATURE SECTION *****/
 
-        /* Did we get triggered to make a snapshot from control http? Then shoot a snap
+        /* 
+         * Did we get triggered to make a snapshot from control http? Then shoot a snap
          * If snapshot_interval is not zero and time since epoch MOD snapshot_interval = 0 then snap
          * We actually allow the time to run over the interval in case we have a delay
          * from slow camera.
@@ -1687,10 +1984,9 @@ static void *motion_loop(void *arg)
         time_current_frame = cnt->currenttime;
 
         if ((cnt->conf.snapshot_interval > 0 && cnt->shots == 0 &&
-            time_current_frame % cnt->conf.snapshot_interval <= time_last_frame % cnt->conf.snapshot_interval) ||
-            cnt->snapshot) {
-            event(cnt, EVENT_IMAGE_SNAPSHOT, cnt->current_image->image, NULL, NULL, 
-                  &cnt->current_image->timestamp_tm);
+             time_current_frame % cnt->conf.snapshot_interval <= time_last_frame % cnt->conf.snapshot_interval) ||
+             cnt->snapshot) {
+            event(cnt, EVENT_IMAGE_SNAPSHOT, cnt->current_image->image, NULL, NULL, &cnt->current_image->timestamp_tm);
             cnt->snapshot = 0;
         }
 
@@ -1699,11 +1995,10 @@ static void *motion_loop(void *arg)
 
 #ifdef HAVE_FFMPEG
 
-
-
         if (cnt->conf.timelapse) {
 
-            /* Check to see if we should start a new timelapse file. We start one when
+            /* 
+             * Check to see if we should start a new timelapse file. We start one when
              * we are on the first shot, and and the seconds are zero. We must use the seconds
              * to prevent the timelapse file from getting reset multiple times during the minute.
              */
@@ -1711,53 +2006,56 @@ static void *motion_loop(void *arg)
                 (time_current_frame % 60 < time_last_frame % 60) &&
                 cnt->shots == 0) {
 
-                if (strcasecmp(cnt->conf.timelapse_mode,"manual") == 0) {
+                if (strcasecmp(cnt->conf.timelapse_mode, "manual") == 0) {
                     ;/* No action */
 
                 /* If we are daily, raise timelapseend event at midnight */
                 } else if (strcasecmp(cnt->conf.timelapse_mode, "daily") == 0) {
                     if (cnt->current_image->timestamp_tm.tm_hour == 0)
-                        event(cnt, EVENT_TIMELAPSEEND, NULL, NULL, NULL, 
-                              &cnt->current_image->timestamp_tm);
+                        event(cnt, EVENT_TIMELAPSEEND, NULL, NULL, NULL, &cnt->current_image->timestamp_tm);
 
                 /* handle the hourly case */
                 } else if (strcasecmp(cnt->conf.timelapse_mode, "hourly") == 0) {
-                    event(cnt, EVENT_TIMELAPSEEND, NULL, NULL, NULL, 
-                          &cnt->current_image->timestamp_tm);
-
-                /* If we are weekly-sunday, raise timelapseend event at midnight on sunday */
+                    event(cnt, EVENT_TIMELAPSEEND, NULL, NULL, NULL, &cnt->current_image->timestamp_tm);
+                
+                /* If we are weekly-sunday, raise timelapseend event at midnight on sunday */    
                 } else if (strcasecmp(cnt->conf.timelapse_mode, "weekly-sunday") == 0) {
-                    if (cnt->current_image->timestamp_tm.tm_wday == 0 && cnt->current_image->timestamp_tm.tm_hour == 0)
-                        event(cnt, EVENT_TIMELAPSEEND, NULL, NULL, NULL, &cnt->current_image->timestamp_tm);
-
+                    if (cnt->current_image->timestamp_tm.tm_wday == 0 && 
+                        cnt->current_image->timestamp_tm.tm_hour == 0)
+                        event(cnt, EVENT_TIMELAPSEEND, NULL, NULL, NULL, 
+                              &cnt->current_image->timestamp_tm);
                 /* If we are weekly-monday, raise timelapseend event at midnight on monday */    
                 } else if (strcasecmp(cnt->conf.timelapse_mode, "weekly-monday") == 0) {
-                    if (cnt->current_image->timestamp_tm.tm_wday == 1 && cnt->current_image->timestamp_tm.tm_hour == 0)
-                        event(cnt, EVENT_TIMELAPSEEND, NULL, NULL, NULL, &cnt->current_image->timestamp_tm);
-
+                    if (cnt->current_image->timestamp_tm.tm_wday == 1 && 
+                        cnt->current_image->timestamp_tm.tm_hour == 0)
+                        event(cnt, EVENT_TIMELAPSEEND, NULL, NULL, NULL, 
+                              &cnt->current_image->timestamp_tm);
                 /* If we are monthly, raise timelapseend event at midnight on first day of month */    
                 } else if (strcasecmp(cnt->conf.timelapse_mode, "monthly") == 0) {
-                    if (cnt->current_image->timestamp_tm.tm_mday == 1 && cnt->current_image->timestamp_tm.tm_hour == 0)
-                        event(cnt, EVENT_TIMELAPSEEND, NULL, NULL, NULL, &cnt->current_image->timestamp_tm);
-
+                    if (cnt->current_image->timestamp_tm.tm_mday == 1 && 
+                        cnt->current_image->timestamp_tm.tm_hour == 0)
+                        event(cnt, EVENT_TIMELAPSEEND, NULL, NULL, NULL, 
+                              &cnt->current_image->timestamp_tm);
                 /* If invalid we report in syslog once and continue in manual mode */    
                 } else {
-                    motion_log(LOG_ERR, 0, "Invalid timelapse_mode argument '%s'",
+                    MOTION_LOG(ERR, TYPE_ALL, NO_ERRNO, "%s: Invalid timelapse_mode argument '%s'",
                                cnt->conf.timelapse_mode);
-                    motion_log(LOG_ERR, 0, "Defaulting to manual timelapse mode");
+                    MOTION_LOG(WRN, TYPE_ALL, NO_ERRNO, "%:s Defaulting to manual timelapse mode"); 
                     conf_cmdparse(&cnt, (char *)"ffmpeg_timelapse_mode",(char *)"manual");
                 }
             }
 
-            /* If ffmpeg timelapse is enabled and time since epoch MOD ffmpeg_timelaps = 0
-             * add a timelapse frame to the timelapse mpeg.
+            /* 
+             * If ffmpeg timelapse is enabled and time since epoch MOD ffmpeg_timelaps = 0
+             * add a timelapse frame to the timelapse movie.
              */
-            if (cnt->shots == 0 &&
-                time_current_frame % cnt->conf.timelapse <= time_last_frame % cnt->conf.timelapse)
+            if (cnt->shots == 0 && time_current_frame % cnt->conf.timelapse <= 
+                time_last_frame % cnt->conf.timelapse)
                 event(cnt, EVENT_TIMELAPSE, cnt->current_image->image, NULL, NULL, 
                       &cnt->current_image->timestamp_tm);
         } else if (cnt->ffmpeg_timelapse) {
-        /* if timelapse mpeg is in progress but conf.timelapse is zero then close timelapse file
+        /* 
+         * If timelapse movie is in progress but conf.timelapse is zero then close timelapse file
          * This is an important feature that allows manual roll-over of timelapse file using the http
          * remote control via a cron job.
          */
@@ -1771,25 +2069,35 @@ static void *motion_loop(void *arg)
 
     /***** MOTION LOOP - VIDEO LOOPBACK SECTION *****/
 
-        /* feed last image and motion image to video device pipes and the webcam clients
-         * In setup mode we send the special setup mode image to both webcam and vloopback pipe
+        /* 
+         * Feed last image and motion image to video device pipes and the stream clients
+         * In setup mode we send the special setup mode image to both stream and vloopback pipe
          * In normal mode we feed the latest image to vloopback device and we send
-         * the image to the webcam. We always send the first image in a second to the webcam.
-         * Other image are sent only when the config option webcam_motion is off
-         * The result is that with webcam_motion on the webcam stream is normally at the minimal
+         * the image to the stream. We always send the first image in a second to the stream.
+         * Other image are sent only when the config option stream_motion is off
+         * The result is that with stream_motion on the stream stream is normally at the minimal
          * 1 frame per second but the minute motion is detected the motion_detected() function
-         * sends all detected pictures to the webcam except the 1st per second which is already sent.
+         * sends all detected pictures to the stream except the 1st per second which is already sent.
          */
         if (cnt->conf.setup_mode) {
             event(cnt, EVENT_IMAGE, cnt->imgs.out, NULL, &cnt->pipe, cnt->currenttime_tm);
-            event(cnt, EVENT_WEBCAM, cnt->imgs.out, NULL, NULL, cnt->currenttime_tm);
+            event(cnt, EVENT_STREAM, cnt->imgs.out, NULL, NULL, cnt->currenttime_tm);
+#ifdef HAVE_SDL
+            if (cnt_list[0]->conf.sdl_threadnr == cnt->threadnr)
+                event(cnt, EVENT_SDL_PUT, cnt->imgs.out, NULL, NULL, cnt->currenttime_tm);
+#endif
         } else {
-            event(cnt, EVENT_IMAGE, cnt->current_image->image, NULL, &cnt->pipe, 
-                  &cnt->current_image->timestamp_tm);
+            event(cnt, EVENT_IMAGE, cnt->current_image->image, NULL, 
+                  &cnt->pipe, &cnt->current_image->timestamp_tm);
 
-            if (!cnt->conf.webcam_motion || cnt->shots == 1)
-                event(cnt, EVENT_WEBCAM, cnt->current_image->image, NULL, NULL, 
+            if (!cnt->conf.stream_motion || cnt->shots == 1)
+                event(cnt, EVENT_STREAM, cnt->current_image->image, NULL, NULL, 
+                      &cnt->current_image->timestamp_tm);
+#ifdef HAVE_SDL
+            if (cnt_list[0]->conf.sdl_threadnr == cnt->threadnr)
+                event(cnt, EVENT_SDL_PUT, cnt->current_image->image, NULL, NULL,
                       &cnt->current_image->timestamp_tm);
+#endif
         }
 
         event(cnt, EVENT_IMAGEM, cnt->imgs.out, NULL, &cnt->mpipe, cnt->currenttime_tm);
@@ -1798,52 +2106,69 @@ static void *motion_loop(void *arg)
     /***** MOTION LOOP - ONCE PER SECOND PARAMETER UPDATE SECTION *****/
 
         /* Check for some config parameter changes but only every second */
-        if (cnt->shots == 0){
-            if (strcasecmp(cnt->conf.output_normal, "on") == 0)
+        if (cnt->shots == 0) {
+            if (strcasecmp(cnt->conf.output_pictures, "on") == 0)
                 cnt->new_img = NEWIMG_ON;
-            else if (strcasecmp(cnt->conf.output_normal, "first") == 0)
+            else if (strcasecmp(cnt->conf.output_pictures, "first") == 0)
                 cnt->new_img = NEWIMG_FIRST;
-            else if (strcasecmp(cnt->conf.output_normal, "best") == 0)
+            else if (strcasecmp(cnt->conf.output_pictures, "best") == 0)
                 cnt->new_img = NEWIMG_BEST;
-            else if (strcasecmp(cnt->conf.output_normal, "center") == 0)
+            else if (strcasecmp(cnt->conf.output_pictures, "center") == 0)
                 cnt->new_img = NEWIMG_CENTER;
             else
                 cnt->new_img = NEWIMG_OFF;
 
-            if (strcasecmp(cnt->conf.locate, "on") == 0)
-                cnt->locate = LOCATE_ON;
-            else if (strcasecmp(cnt->conf.locate, "preview") == 0)
-                cnt->locate = LOCATE_PREVIEW;
+            if (strcasecmp(cnt->conf.locate_motion_mode, "on") == 0)
+                cnt->locate_motion_mode = LOCATE_ON;
+            else if (strcasecmp(cnt->conf.locate_motion_mode, "preview") == 0)
+                cnt->locate_motion_mode = LOCATE_PREVIEW;
             else
-                cnt->locate = LOCATE_OFF;
+                cnt->locate_motion_mode = LOCATE_OFF;
+
+            if (strcasecmp(cnt->conf.locate_motion_style, "box") == 0)
+                cnt->locate_motion_style = LOCATE_BOX;
+            else if (strcasecmp(cnt->conf.locate_motion_style, "redbox") == 0)
+                cnt->locate_motion_style = LOCATE_REDBOX;
+            else if (strcasecmp(cnt->conf.locate_motion_style, "cross") == 0)
+                cnt->locate_motion_style = LOCATE_CROSS;
+            else if (strcasecmp(cnt->conf.locate_motion_style, "redcross") == 0)
+                cnt->locate_motion_style = LOCATE_REDCROSS;
+            else
+                cnt->locate_motion_style = LOCATE_BOX;
 
             /* Sanity check for smart_mask_speed, silly value disables smart mask */
             if (cnt->conf.smart_mask_speed < 0 || cnt->conf.smart_mask_speed > 10)
                 cnt->conf.smart_mask_speed = 0;
 
             /* Has someone changed smart_mask_speed or framerate? */
-            if (cnt->conf.smart_mask_speed != cnt->smartmask_speed || smartmask_lastrate != cnt->lastrate){
-                if (cnt->conf.smart_mask_speed == 0){
+            if (cnt->conf.smart_mask_speed != cnt->smartmask_speed || 
+                smartmask_lastrate != cnt->lastrate) {
+                if (cnt->conf.smart_mask_speed == 0) {
                     memset(cnt->imgs.smartmask, 0, cnt->imgs.motionsize);
                     memset(cnt->imgs.smartmask_final, 255, cnt->imgs.motionsize);
                 }
+
                 smartmask_lastrate = cnt->lastrate;
                 cnt->smartmask_speed = cnt->conf.smart_mask_speed;
-                /* Decay delay - based on smart_mask_speed (framerate independent)
-                   This is always 5*smartmask_speed seconds */
+                /* 
+                 * Decay delay - based on smart_mask_speed (framerate independent)
+                 * This is always 5*smartmask_speed seconds 
+                 */
                 smartmask_ratio = 5 * cnt->lastrate * (11 - cnt->smartmask_speed);
             }
 
-#if defined(HAVE_MYSQL) || defined(HAVE_PGSQL)
-            /* Set the sql mask file according to the SQL config options
+#if defined(HAVE_MYSQL) || defined(HAVE_PGSQL) || defined(HAVE_SQLITE3)
+
+            /* 
+             * Set the sql mask file according to the SQL config options
              * We update it for every frame in case the config was updated
              * via remote control.
              */
             cnt->sql_mask = cnt->conf.sql_log_image * (FTYPE_IMAGE + FTYPE_IMAGE_MOTION) +
                             cnt->conf.sql_log_snapshot * FTYPE_IMAGE_SNAPSHOT +
-                            cnt->conf.sql_log_mpeg * (FTYPE_MPEG + FTYPE_MPEG_MOTION) +
+                            cnt->conf.sql_log_movie * (FTYPE_MPEG + FTYPE_MPEG_MOTION) +
                             cnt->conf.sql_log_timelapse * FTYPE_MPEG_TIMELAPSE;
-#endif /* defined(HAVE_MYSQL) || defined(HAVE_PGSQL) */
+#endif /* defined(HAVE_MYSQL) || defined(HAVE_PGSQL) || defined(HAVE_SQLITE3) */
 
         }
 
@@ -1851,8 +2176,10 @@ static void *motion_loop(void *arg)
     /***** MOTION LOOP - FRAMERATE TIMING AND SLEEPING SECTION *****/
 
 
-        /* Work out expected frame rate based on config setting which may
-           have changed from http-control */
+        /* 
+         * Work out expected frame rate based on config setting which may
+         * have changed from http-control 
+         */
         if (cnt->conf.frame_limit)
             required_frame_time = 1000000L / cnt->conf.frame_limit;
         else
@@ -1862,8 +2189,9 @@ static void *motion_loop(void *arg)
         gettimeofday(&tv2, NULL);
         elapsedtime = (tv2.tv_usec + 1000000L * tv2.tv_sec) - timenow;
 
-        /* Update history buffer but ignore first pass as timebefore
-           variable will be inaccurate
+        /* 
+         * Update history buffer but ignore first pass as timebefore
+         * variable will be inaccurate
          */
         if (passflag)
             rolling_average_data[rolling_frame] = timenow-timebefore;
@@ -1899,7 +2227,8 @@ static void *motion_loop(void *arg)
         }
     }
 
-    /* END OF MOTION MAIN LOOP
+    /* 
+     * END OF MOTION MAIN LOOP
      * If code continues here it is because the thread is exiting or restarting
      */
 err:
@@ -1907,7 +2236,7 @@ err:
         free(rolling_average_data);
 
     cnt->lost_connection = 1;
-    motion_log(-1, 0, "Thread exiting");
+    MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Thread exiting");
 
     motion_cleanup(cnt);
 
@@ -1916,7 +2245,7 @@ err:
     pthread_mutex_unlock(&global_lock);
 
     if (!cnt->restart)
-        cnt->watchdog=WATCHDOG_OFF;
+        cnt->watchdog = WATCHDOG_OFF;
 
     cnt->running = 0;
     cnt->finish = 0;
@@ -1956,33 +2285,38 @@ static void become_daemon(void)
 
     /* fork */
     if (fork()) {
-        motion_log(-1, 0, "Motion going to daemon mode");
+        MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Motion going to daemon mode");
         exit(0);
     }
     
-    /* Create the pid file if defined, if failed exit
+    /* 
+     * Create the pid file if defined, if failed exit
      * If we fail we report it. If we succeed we postpone the log entry till
      * later when we have closed stdout. Otherwise Motion hangs in the terminal waiting
      * for an enter.
      */
     if (cnt_list[0]->conf.pid_file) {
-        pidf = fopen(cnt_list[0]->conf.pid_file, "w+");
+        pidf = myfopen(cnt_list[0]->conf.pid_file, "w+", 0);
     
-        if (pidf ) {
+        if (pidf) {
             (void)fprintf(pidf, "%d\n", getpid());
-            fclose(pidf);
+            myfclose(pidf);
         } else {
-            motion_log(LOG_ERR, 1, "Exit motion, cannot create process id file (pid file) %s",
-                       cnt_list[0]->conf.pid_file);    
+            MOTION_LOG(EMG, TYPE_ALL, SHOW_ERRNO, "%s: Exit motion, cannot create process"
+                       " id file (pid file) %s", cnt_list[0]->conf.pid_file);
+            if (ptr_logfile) 
+                myfclose(ptr_logfile);    
             exit(0);    
         }
     }
 
-    /* changing dir to root enables people to unmount a disk
-       without having to stop Motion */
-    if (chdir("/")) {
-        motion_log(LOG_ERR, 1, "Could not change directory");
-    }
+    /* 
+     * Changing dir to root enables people to unmount a disk
+     * without having to stop Motion 
+     */
+    if (chdir("/")) 
+        MOTION_LOG(ERR, TYPE_ALL, SHOW_ERRNO, "%s: Could not change directory");
+    
 
 #if (defined(BSD))
     setpgrp(0, getpid());
@@ -2013,8 +2347,8 @@ static void become_daemon(void)
     }
     
     /* Now it is safe to add the PID creation to the logs */
-    if (pidf )
-        motion_log(LOG_INFO, 0, "Created process id file %s. Process ID is %d",
+    if (pidf)
+        MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Created process id file %s. Process ID is %d",
                    cnt_list[0]->conf.pid_file, getpid());
     
     sigaction(SIGTTOU, &sig_ign_action, NULL);
@@ -2037,7 +2371,8 @@ static void become_daemon(void)
  */
 static void cntlist_create(int argc, char *argv[])
 {
-    /* cnt_list is an array of pointers to the context structures cnt for each thread.
+    /* 
+     * cnt_list is an array of pointers to the context structures cnt for each thread.
      * First we reserve room for a pointer to thread 0's context structure
      * and a NULL pointer which indicates that end of the array of pointers to
      * thread context structures.
@@ -2053,7 +2388,8 @@ static void cntlist_create(int argc, cha
     /* cnt_list[1] pointing to zero indicates no more thread context structures - they get added later */
     cnt_list[1] = NULL;
 
-    /* Command line arguments are being pointed to from cnt_list[0] and we call conf_load which loads
+    /* 
+     * Command line arguments are being pointed to from cnt_list[0] and we call conf_load which loads
      * the config options from motion.conf, thread config files and the command line.
      */
     cnt_list[0]->conf.argv = argv;
@@ -2078,8 +2414,8 @@ static void motion_shutdown(void)
     int i = -1;
 
     motion_remove_pid();
-    
-    while (cnt_list[++i])
+
+    while (cnt_list[++i]) 
         context_destroy(cnt_list[i]);
     
     free(cnt_list);
@@ -2109,22 +2445,72 @@ static void motion_startup(int daemonize
     /* Initialize our global mutex */
     pthread_mutex_init(&global_lock, NULL);
 
-    /* Create the list of context structures and load the
+    /* 
+     * Create the list of context structures and load the
      * configuration.
      */
     cntlist_create(argc, argv);
 
-    motion_log(LOG_INFO, 0, "Motion "VERSION" Started");
+    if ((cnt_list[0]->conf.log_level > ALL) ||
+        (cnt_list[0]->conf.log_level == 0)) { 
+        cnt_list[0]->conf.log_level = LEVEL_DEFAULT;
+        cnt_list[0]->log_level = cnt_list[0]->conf.log_level;
+        MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Using default log level (%s) (%d)", 
+                   get_log_level_str(cnt_list[0]->log_level), SHOW_LEVEL_VALUE(cnt_list[0]->log_level));
+    } else {
+        cnt_list[0]->log_level = cnt_list[0]->conf.log_level - 1; // Let's make syslog compatible
+    }
+
+    //set_log_level(cnt_list[0]->log_level);   
+
+#ifdef HAVE_SDL
+     MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Motion "VERSION" Started with SDL support");
+#else
+     MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Motion "VERSION" Started");
+#endif
+
+    if ((cnt_list[0]->conf.log_file) && (strncmp(cnt_list[0]->conf.log_file, "syslog", 6))) {
+        set_log_mode(LOGMODE_FILE);
+        ptr_logfile = set_logfile(cnt_list[0]->conf.log_file);
+
+        if (ptr_logfile) {
+            set_log_mode(LOGMODE_SYSLOG);
+            MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Logging to file (%s)",  
+                       cnt_list[0]->conf.log_file);
+            set_log_mode(LOGMODE_FILE);
+        } else {
+            MOTION_LOG(EMG, TYPE_ALL, SHOW_ERRNO, "%s: Exit motion, cannot create log file %s",
+                       cnt_list[0]->conf.log_file);
+            exit(0);
+        }
+    } else {
+        MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Logging to syslog");
+    }
+
+    if ((cnt_list[0]->conf.log_type_str == NULL) || 
+        !(cnt_list[0]->log_type = get_log_type(cnt_list[0]->conf.log_type_str))) {
+        cnt_list[0]->log_type = TYPE_DEFAULT;
+        cnt_list[0]->conf.log_type_str = mystrcpy(cnt_list[0]->conf.log_type_str, "ALL");
+        MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Using default log type (%s)",  
+                   get_log_type_str(cnt_list[0]->log_type));
+    }
+
+    MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Using log type (%s) log level (%s)", 
+               get_log_type_str(cnt_list[0]->log_type), get_log_level_str(cnt_list[0]->log_level));
+
+    set_log_level(cnt_list[0]->log_level);
+    set_log_type(cnt_list[0]->log_type);
 
     initialize_chars();
 
     if (daemonize) {
-        /* If daemon mode is requested, and we're not going into setup mode,
+        /* 
+         * If daemon mode is requested, and we're not going into setup mode,
          * become daemon.
          */
         if (cnt_list[0]->daemon && cnt_list[0]->conf.setup_mode == 0) {
             become_daemon();
-            motion_log(LOG_INFO, 0, "Motion running as daemon process");
+            MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Motion running as daemon process");
         }
     }
 
@@ -2163,8 +2549,8 @@ static void setup_signals(struct sigacti
     sigaction(SIGCHLD, sigchild_action, NULL);
     sigaction(SIGPIPE, sigchild_action, NULL);
     sigaction(SIGALRM, sig_handler_action, NULL);
-    sigaction(SIGHUP,  sig_handler_action, NULL);
-    sigaction(SIGINT,  sig_handler_action, NULL);
+    sigaction(SIGHUP, sig_handler_action, NULL);
+    sigaction(SIGINT, sig_handler_action, NULL);
     sigaction(SIGQUIT, sig_handler_action, NULL);
     sigaction(SIGTERM, sig_handler_action, NULL);
     sigaction(SIGUSR1, sig_handler_action, NULL);
@@ -2186,40 +2572,44 @@ static void start_motion_thread(struct c
 {
     int i;
 
-    /* Check the webcam port number for conflicts.
+    /* 
+     * Check the stream port number for conflicts.
      * First we check for conflict with the control port.
      * Second we check for that two threads does not use the same port number
-     * for the webcam. If a duplicate port is found the webcam feature gets disabled (port =0)
+     * for the stream. If a duplicate port is found the stream feature gets disabled (port = 0)
      * for this thread and a warning is written to console and syslog.
      */
 
-    if (cnt->conf.webcam_port != 0) {
+    if (cnt->conf.stream_port != 0) {
         /* Compare against the control port. */
-        if (cnt_list[0]->conf.control_port == cnt->conf.webcam_port) {
-            motion_log(LOG_ERR, 0,
-                       "Webcam port number %d for thread %d conflicts with the control port",
-                       cnt->conf.webcam_port, cnt->threadnr);
-            motion_log(LOG_ERR, 0, "Webcam feature for thread %d is disabled.", cnt->threadnr);
-            cnt->conf.webcam_port = 0;
+        if (cnt_list[0]->conf.webcontrol_port == cnt->conf.stream_port) {
+            MOTION_LOG(ERR, TYPE_ALL, NO_ERRNO,
+                       "%s: Stream port number %d for thread %d conflicts with the control port",
+                       cnt->conf.stream_port, cnt->threadnr);
+            MOTION_LOG(WRN, TYPE_ALL, NO_ERRNO, "%s: Stream feature for thread %d is disabled.", 
+                       cnt->threadnr);
+            cnt->conf.stream_port = 0;
         }
 
-        /* Compare against webcam ports of other threads. */
+        /* Compare against stream ports of other threads. */
         for (i = 1; cnt_list[i]; i++) {
             if (cnt_list[i] == cnt)
                 continue;
 
-            if (cnt_list[i]->conf.webcam_port == cnt->conf.webcam_port) {
-                motion_log(LOG_ERR, 0,
-                           "Webcam port number %d for thread %d conflicts with thread %d",
-                           cnt->conf.webcam_port, cnt->threadnr, cnt_list[i]->threadnr);
-                motion_log(LOG_ERR, 0,
-                           "Webcam feature for thread %d is disabled.", cnt->threadnr);
-                cnt->conf.webcam_port = 0;
+            if (cnt_list[i]->conf.stream_port == cnt->conf.stream_port) {
+                MOTION_LOG(ERR, TYPE_ALL, NO_ERRNO,
+                           "%s: Stream port number %d for thread %d conflicts with thread %d",
+                           cnt->conf.stream_port, cnt->threadnr, cnt_list[i]->threadnr);
+                MOTION_LOG(WRN, TYPE_ALL, NO_ERRNO,
+                           "%s: Stream feature for thread %d is disabled.",  
+                           cnt->threadnr);
+                cnt->conf.stream_port = 0;
             }
         }
     }
 
-    /* Update how many threads we have running. This is done within a
+    /* 
+     * Update how many threads we have running. This is done within a
      * mutex lock to prevent multiple simultaneous updates to
      * 'threads_running'.
      */
@@ -2230,10 +2620,11 @@ static void start_motion_thread(struct c
     /* Set a flag that we want this thread running */
     cnt->restart = 1;
 
-    /* Give the thread WATCHDOG_TMO seconds to start */
+    /* Give the thread WATCHDOG_TMO to start */
     cnt->watchdog = WATCHDOG_TMO;
 
-    /* Create the actual thread. Use 'motion_loop' as the thread
+    /* 
+     * Create the actual thread. Use 'motion_loop' as the thread
      * function.
      */
     pthread_create(&cnt->thread_id, thread_attr, &motion_loop, cnt);
@@ -2258,7 +2649,8 @@ int main (int argc, char **argv)
     pthread_attr_t thread_attr;
     pthread_t thread_id;
 
-    /* Setup signals and do some initialization. 1 in the call to
+    /* 
+     * Setup signals and do some initialization. 1 in the call to
      * 'motion_startup' means that Motion will become a daemon if so has been
      * requested, and argc and argc are necessary for reading the command
      * line options.
@@ -2270,20 +2662,23 @@ int main (int argc, char **argv)
     motion_startup(1, argc, argv);
 
 #ifdef HAVE_FFMPEG
-    /* FFMpeg initialization is only performed if FFMpeg support was found
+    /* 
+     * FFMpeg initialization is only performed if FFMpeg support was found
      * and not disabled during the configure phase.
      */
     ffmpeg_init();
 #endif /* HAVE_FFMPEG */
 
-    /* In setup mode, Motion is very communicative towards the user, which
+    /* 
+     * In setup mode, Motion is very communicative towards the user, which
      * allows the user to experiment with the config parameters in order to
      * optimize motion detection and stuff.
      */
     if (cnt_list[0]->conf.setup_mode)
-        motion_log(-1, 0, "Motion running in setup mode.");
+        MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Motion running in setup mode.");
 
-    /* Create and a thread attribute for the threads we spawn later on.
+    /*
+     * Create and a thread attribute for the threads we spawn later on.
      * PTHREAD_CREATE_DETACHED means to create threads detached, i.e.
      * their termination cannot be synchronized through 'pthread_join'.
      */
@@ -2295,92 +2690,109 @@ int main (int argc, char **argv)
 
     do {
         if (restart) {
-            /* Handle the restart situation. Currently the approach is to
+            /*
+             * Handle the restart situation. Currently the approach is to
              * cleanup everything, and then initialize everything again
              * (including re-reading the config file(s)).
              */
+            MOTION_LOG(WRN, TYPE_ALL, NO_ERRNO, "%s: Restarting motion.");
             motion_shutdown();
             restart = 0; /* only one reset for now */
-            motion_log(LOG_INFO,0,"motion restarted");
 #ifndef WITHOUT_V4L
-            SLEEP(5,0); // maybe some cameras needs less time
+            SLEEP(5, 0); // maybe some cameras needs less time
 #endif
             motion_startup(0, argc, argv); /* 0 = skip daemon init */
+            MOTION_LOG(WRN, TYPE_ALL, NO_ERRNO, "%s: Motion restarted");
         }
 
-
-        /* Start the motion threads. First 'cnt_list' item is global if 'thread'
+        /* 
+         * Start the motion threads. First 'cnt_list' item is global if 'thread'
          * option is used, so start at 1 then and 0 otherwise.
          */
         for (i = cnt_list[1] != NULL ? 1 : 0; cnt_list[i]; i++) {
             /* If i is 0 it means no thread files and we then set the thread number to 1 */
             cnt_list[i]->threadnr = i ? i : 1;
 
-            if (strcmp(cnt_list[i]->conf_filename,"") )
-                motion_log(LOG_INFO, 0, "Thread %d is from %s", cnt_list[i]->threadnr, cnt_list[i]->conf_filename );
+            if (strcmp(cnt_list[i]->conf_filename, ""))
+            {
+                cnt_list[i]->conf_filename[sizeof(cnt_list[i]->conf_filename) - 1] = '\0';
 
-            if (cnt_list[0]->conf.setup_mode) {
-                motion_log(-1, 0, "Thread %d is device: %s input %d", cnt_list[i]->threadnr,
-                           cnt_list[i]->conf.netcam_url ? cnt_list[i]->conf.netcam_url : cnt_list[i]->conf.video_device,
-                           cnt_list[i]->conf.netcam_url ? -1 : cnt_list[i]->conf.input
-                          );
+                MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Thread %d is from %s", 
+                           cnt_list[i]->threadnr, cnt_list[i]->conf_filename);
             }
 
-            if (cnt_list[0]->conf.setup_mode)
-                motion_log(LOG_ERR, 0, "Webcam port %d", cnt_list[i]->conf.webcam_port);
+            MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Thread %d is device: %s input %d", 
+                       cnt_list[i]->threadnr, cnt_list[i]->conf.netcam_url ? 
+                       cnt_list[i]->conf.netcam_url : cnt_list[i]->conf.video_device,
+                       cnt_list[i]->conf.netcam_url ? -1 : cnt_list[i]->conf.input);
+            
+            MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Stream port %d",  
+                       cnt_list[i]->conf.stream_port);
 
             start_motion_thread(cnt_list[i], &thread_attr);
         }
 
-        /* Create a thread for the control interface if requested. Create it
+#ifdef HAVE_SDL
+        if (cnt_list[0]->conf.sdl_threadnr > 0)
+            sdl_start(cnt_list[cnt_list[1] != NULL ? cnt_list[0]->conf.sdl_threadnr : 0]->conf.width,
+                      cnt_list[cnt_list[1] != NULL ? cnt_list[0]->conf.sdl_threadnr : 0]->conf.height);
+#endif
+
+        /* 
+         * Create a thread for the control interface if requested. Create it
          * detached and with 'motion_web_control' as the thread function.
          */
-        if (cnt_list[0]->conf.control_port)
+        if (cnt_list[0]->conf.webcontrol_port)
             pthread_create(&thread_id, &thread_attr, &motion_web_control, cnt_list);
 
-        if (cnt_list[0]->conf.setup_mode)
-            motion_log(-1, 0,"Waiting for threads to finish, pid: %d", getpid());
+        MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Waiting for threads to finish, pid: %d", 
+                   getpid());
 
-        /* Crude way of waiting for all threads to finish - check the thread
+        /* 
+         * Crude way of waiting for all threads to finish - check the thread
          * counter (because we cannot do join on the detached threads).
          */
         while (1) {
-            SLEEP(1,0);
+            SLEEP(1, 0);
 
-            /* Calculate how many threads runnig or wants to run
+            /* 
+             * Calculate how many threads runnig or wants to run
              * if zero and we want to finish, break out
              */
             int motion_threads_running = 0;
+
             for (i = (cnt_list[1] != NULL ? 1 : 0); cnt_list[i]; i++) {
                 if (cnt_list[i]->running || cnt_list[i]->restart)
                     motion_threads_running++;
             }
 
-            if (((motion_threads_running == 0 ) && finish ) || 
-                 ((motion_threads_running == 0 ) && (threads_running == 0)) ){
-                if (debug_level >= CAMERA_DEBUG){
-                         motion_log(LOG_INFO, 0, "DEBUG-1 threads_running %d motion_threads_running %d , finish %d",
-                                            threads_running, motion_threads_running, finish); 
-                }
+            if (((motion_threads_running == 0) && finish) || 
+                ((motion_threads_running == 0) && (threads_running == 0))) {
+                MOTION_LOG(ALL, TYPE_ALL, NO_ERRNO, "%s: DEBUG-1 threads_running %d motion_threads_running %d "
+                           ", finish %d", threads_running, motion_threads_running, finish);                 
                 break;
-            }
+            }    
 
             for (i = (cnt_list[1] != NULL ? 1 : 0); cnt_list[i]; i++) {
                 /* Check if threads wants to be restarted */
-                if ((!cnt_list[i]->running) && (cnt_list[i]->restart) ) {
-                    motion_log(LOG_INFO, 0, "Motion thread %d restart", cnt_list[i]->threadnr);
+                if ((!cnt_list[i]->running) && (cnt_list[i]->restart)) {
+                    MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Motion thread %d restart", 
+                               cnt_list[i]->threadnr);
                     start_motion_thread(cnt_list[i], &thread_attr);
                 }
+
                 if (cnt_list[i]->watchdog > WATCHDOG_OFF) {
                     cnt_list[i]->watchdog--;
+                    
                     if (cnt_list[i]->watchdog == 0) {
-                        motion_log(LOG_ERR, 0, "Thread %d - Watchdog timeout, trying to do a graceful restart",
-                                                  cnt_list[i]->threadnr);
+                        MOTION_LOG(ERR, TYPE_ALL, NO_ERRNO, "%s: Thread %d - Watchdog timeout, trying to do "
+                                   "a graceful restart", cnt_list[i]->threadnr);
                         cnt_list[i]->finish = 1;
                     }
+
                     if (cnt_list[i]->watchdog == -60) {
-                        motion_log(LOG_ERR, 0, "Thread %d - Watchdog timeout, did NOT restart graceful," 
-                                               "killing it!", cnt_list[i]->threadnr);
+                        MOTION_LOG(ERR, TYPE_ALL, NO_ERRNO, "%s: Thread %d - Watchdog timeout, did NOT restart graceful," 
+                                   "killing it!", cnt_list[i]->threadnr);
                         pthread_cancel(cnt_list[i]->thread_id);
                         pthread_mutex_lock(&global_lock);
                         threads_running--;
@@ -2392,27 +2804,29 @@ int main (int argc, char **argv)
                 }
             }
 
-            if (debug_level >= CAMERA_DEBUG){
-                motion_log(LOG_INFO, 0, "DEBUG-2 threads_running %d motion_threads_running %d , finish %d",
-                                        threads_running, motion_threads_running, finish); 
-            }
+            MOTION_LOG(ALL, TYPE_ALL, NO_ERRNO, "%s: DEBUG-2 threads_running %d motion_threads_running %d finish %d", 
+                       threads_running, motion_threads_running, finish);
         }
         /* Reset end main loop flag */
         finish = 0;
 
-        if (cnt_list[0]->conf.setup_mode)
-            motion_log(LOG_DEBUG, 0, "Threads finished");
+        MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Threads finished");
 
         /* Rest for a while if we're supposed to restart. */
         if (restart)
-            SLEEP(2,0);
+            SLEEP(2, 0);
 
     } while (restart); /* loop if we're supposed to restart */
 
+#ifdef HAVE_SDL
+    sdl_stop();
+#endif
+
+
     // Be sure that http control exits fine
     cnt_list[0]->finish = 1;
-    SLEEP(1,0);
-    motion_log(LOG_INFO, 0, "Motion terminating");
+    SLEEP(1, 0);
+    MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: Motion terminating");
 
     /* Perform final cleanup. */
     pthread_key_delete(tls_key_threadnr);
@@ -2444,9 +2858,11 @@ int main (int argc, char **argv)
  */
 void * mymalloc(size_t nbytes)
 {
-    void *dummy = malloc(nbytes);
+    void *dummy = calloc(nbytes, 1);
+ 
     if (!dummy) {
-        motion_log(LOG_EMERG, 1, "Could not allocate %llu bytes of memory!", (unsigned long long)nbytes);
+        MOTION_LOG(EMG, TYPE_ALL, SHOW_ERRNO, "%s: Could not allocate %llu bytes of memory!", 
+                   (unsigned long long)nbytes);
         motion_remove_pid();
         exit(1);
     }
@@ -2476,14 +2892,14 @@ void *myrealloc(void *ptr, size_t size,
 
     if (size == 0) {
         free(ptr);
-        motion_log(LOG_WARNING, 0,
-                   "Warning! Function %s tries to resize memoryblock at %p to 0 bytes!",
-                   desc, ptr);
+        MOTION_LOG(WRN, TYPE_ALL, NO_ERRNO,
+                   "%s: Warning! Function %s tries to resize memoryblock at %p to 0 bytes!",
+                    desc, ptr);
     } else {
         dummy = realloc(ptr, size);
         if (!dummy) {
-            motion_log(LOG_EMERG, 0,
-                       "Could not resize memory-block at offset %p to %llu bytes (function %s)!",
+            MOTION_LOG(EMG, TYPE_ALL, NO_ERRNO,
+                       "%s: Could not resize memory-block at offset %p to %llu bytes (function %s)!",
                        ptr, (unsigned long long)size, desc);
             motion_remove_pid();
             exit(1);
@@ -2493,6 +2909,7 @@ void *myrealloc(void *ptr, size_t size,
     return dummy;
 }
 
+
 /**
  * create_path
  *
@@ -2519,23 +2936,34 @@ int create_path(const char *path)
         start = strchr(path, '/');
 
     while (start) {
-        char *buffer = strdup(path);
+        char *buffer = mystrdup(path);
         buffer[start-path] = 0x00;
 
         if (mkdir(buffer, mode) == -1 && errno != EEXIST) {
-            motion_log(LOG_ERR, 1, "Problem creating directory %s", buffer);
+            MOTION_LOG(ERR, TYPE_ALL, SHOW_ERRNO, "%s: Problem creating directory %s", 
+                       buffer);
             free(buffer);
             return -1;
         }
 
-        free(buffer);
-
         start = strchr(start + 1, '/');
+
+        if (!start)
+            MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: creating directory %s", buffer);
+        
+        free(buffer);
     }
 
     return 0;
 }
 
+#define MYBUFCOUNT 32
+struct MyBuffer {
+    FILE* fh;
+    char* buffer;
+    size_t bufsize;
+} buffers[MYBUFCOUNT];
+
 /**
  * myfopen
  *
@@ -2543,17 +2971,25 @@ int create_path(const char *path)
  *   (which is: path does not exist), the path is created and then things are
  *   tried again. This is faster then trying to create that path over and over
  *   again. If someone removes the path after it was created, myfopen will
- *   recreate the path automatically.
+ *   recreate the path automatically. If the bufsize is set to > 0, we will
+ *   allocate (or re-use) write buffers to use instead of the default ones.
+ *   This gives us much higher throughput in many cases.
  *
  * Parameters:
  *
  *   path - path to the file to open
  *   mode - open mode
+ *   bufsize - size of write buffers, 0 == OS default
  *
  * Returns: the file stream object
  */
-FILE * myfopen(const char *path, const char *mode)
+FILE * myfopen(const char *path, const char *mode, size_t bufsize)
 {
+    static int bufferInit = 0;
+    if (!bufferInit) {
+        bufferInit = 1;
+        memset(buffers, 0x00, sizeof(buffers));
+    }
     /* first, just try to open the file */
     FILE *dummy = fopen(path, mode);
 
@@ -2568,28 +3004,109 @@ FILE * myfopen(const char *path, const c
 
             /* and retry opening the file */
             dummy = fopen(path, mode);
-            if (dummy)
-                return dummy;
         }
+    }
+ 
+    if (dummy) {
+        if (bufsize > 0) {
+            int i = 0;
+            for (i = 0; i < MYBUFCOUNT; i++) {
+                int first = -1;
+                if (!buffers[i].fh) {
+                    if (first == -1)
+                        first = i;
+                    if (buffers[i].buffer == NULL ||
+                        buffers[i].bufsize >= bufsize ||
+                        (i == (MYBUFCOUNT - 1) && first >= 0)) {
+                        if (buffers[i].buffer == NULL) {
+                            /* We are allocating a new buffer */
+                            buffers[i].fh = dummy;
+                            buffers[i].buffer = mymalloc(bufsize);
+                            buffers[i].bufsize = bufsize;
+                        }
+                        else if (buffers[i].bufsize >= bufsize) {
+                            /* We are using an old buffer */
+                            buffers[i].fh = dummy;
+                        }
+                        else {
+                            /* 
+                             * We are reusing an old buffer, but it is too
+                             * small, realloc it 
+                             */
+                            i = first;
+                            buffers[i].fh = dummy;
+                            buffers[i].buffer = myrealloc(buffers[i].buffer,
+                                                          bufsize, "myfopen");
+                            buffers[i].bufsize = bufsize;
+                        }
 
-        /* two possibilities
-         * 1: there was an other error while trying to open the file for the first time
+                        if (buffers[i].buffer == NULL) {
+                            /* 
+                             * Our allocation failed, so just use the default
+                             * OS buffers 
+                             */
+                            buffers[i].fh = NULL;
+                            buffers[i].bufsize = 0;
+                        }
+                        else {
+                            setvbuf(buffers[i].fh, buffers[i].buffer,
+                                    _IOFBF, buffers[i].bufsize);
+                        }
+                        break;
+                    }
+                }
+            }
+        }
+    } else {
+        /*
+         * Two possibilities
+         * 1: there was an other error while trying to open the file for the
+         * first time
          * 2: could still not open the file after the path was created
          */
-        motion_log(LOG_ERR, 1, "Error opening file %s with mode %s", path, mode);
-
-        return NULL;
+        MOTION_LOG(ERR, TYPE_ALL, SHOW_ERRNO, "%s: Error opening file %s with mode %s",  
+                   path, mode);
     }
 
     return dummy;
 }
 
 /**
+ * myfclose
+ *
+ *  Motion-specific variant of fclose()   
+ *
+ * Returns: fclose() return value
+ */ 
+int myfclose(FILE* fh)
+{
+    int i = 0;
+    int rval = fclose(fh);
+
+    if (rval != 0) 
+        MOTION_LOG(ERR, TYPE_ALL, SHOW_ERRNO, "%s: Error closing file");
+
+    for (i = 0; i < MYBUFCOUNT; i++) {
+        if (buffers[i].fh == fh) {
+            buffers[i].fh = NULL;
+            if ( finish ) {
+                /* Free the buffers */
+                if (buffers[i].buffer)
+                    free(buffers[i].buffer);
+                buffers[i].buffer = NULL;
+                buffers[i].bufsize = 0;
+            }
+        }
+    }
+    return rval;
+}
+
+/**
  * mystrftime
  *
  *   Motion-specific variant of strftime(3) that supports additional format
  *   specifiers in the format string.
- *
+ *  
  * Parameters:
  *
  *   cnt        - current thread's context structure
@@ -2603,7 +3120,7 @@ FILE * myfopen(const char *path, const c
  *
  * Returns: number of bytes written to the string s
  */
-size_t mystrftime(struct context *cnt, char *s, size_t max, const char *userformat,
+size_t mystrftime(const struct context *cnt, char *s, size_t max, const char *userformat,
                   const struct tm *tm, const char *filename, int sqltype)
 {
     char formatstring[PATH_MAX] = "";
@@ -2622,85 +3139,107 @@ size_t mystrftime(struct context *cnt, c
     for (pos_userformat = userformat; *pos_userformat; ++pos_userformat) {
 
         if (*pos_userformat == '%') {
-            /* Reset 'tempstr' to point to the beginning of 'tempstring',
+            /* 
+             * Reset 'tempstr' to point to the beginning of 'tempstring',
              * otherwise we will eat up tempstring if there are many
              * format specifiers.
              */
             tempstr = tempstring;
             tempstr[0] = '\0';
+
             switch (*++pos_userformat) {
-                case '\0': // end of string
-                    --pos_userformat;
-                    break;
+            case '\0': // end of string
+                --pos_userformat;
+                break;
 
-                case 'v': // event
-                    sprintf(tempstr, "%02d", cnt->event_nr);
-                    break;
+            case 'v': // event
+                sprintf(tempstr, "%02d", cnt->event_nr);
+                break;
 
-                case 'q': // shots
-                    sprintf(tempstr, "%02d", cnt->current_image->shot);
-                    break;
+            case 'q': // shots
+                sprintf(tempstr, "%02d", cnt->current_image->shot);
+                break;
 
-                case 'D': // diffs
-                    sprintf(tempstr, "%d", cnt->current_image->diffs);
-                    break;
+            case 'D': // diffs
+                sprintf(tempstr, "%d", cnt->current_image->diffs);
+                break;
 
-                case 'N': // noise
-                    sprintf(tempstr, "%d", cnt->noise);
-                    break;
+            case 'N': // noise
+                sprintf(tempstr, "%d", cnt->noise);
+                break;
 
-                case 'i': // motion width
-                    sprintf(tempstr, "%d", cnt->current_image->location.width);
-                    break;
+            case 'i': // motion width
+                sprintf(tempstr, "%d", cnt->current_image->location.width);
+                break;
 
-                case 'J': // motion height
-                    sprintf(tempstr, "%d", cnt->current_image->location.height);
-                    break;
+            case 'J': // motion height
+                sprintf(tempstr, "%d", cnt->current_image->location.height);
+                break;
 
-                case 'K': // motion center x
-                    sprintf(tempstr, "%d", cnt->current_image->location.x);
-                    break;
+            case 'K': // motion center x
+                sprintf(tempstr, "%d", cnt->current_image->location.x);
+                break;
 
-                case 'L': // motion center y
-                    sprintf(tempstr, "%d", cnt->current_image->location.y);
-                    break;
+            case 'L': // motion center y
+                sprintf(tempstr, "%d", cnt->current_image->location.y);
+                break;
 
-                case 'o': // threshold
-                    sprintf(tempstr, "%d", cnt->threshold);
-                    break;
+            case 'o': // threshold
+                sprintf(tempstr, "%d", cnt->threshold);
+                break;
 
-                case 'Q': // number of labels
-                    sprintf(tempstr, "%d", cnt->current_image->total_labels);
-                    break;
-                case 't': // thread number
-                    sprintf(tempstr, "%d",(int)(unsigned long)
-                            pthread_getspecific(tls_key_threadnr));
-                    break;
-                case 'C': // text_event
-                    if (cnt->text_event_string && cnt->text_event_string[0])
-                        snprintf(tempstr, PATH_MAX, "%s", cnt->text_event_string);
-                    else
-                        ++pos_userformat;
-                    break;
-                case 'f': // filename
-                    if (filename)
-                        snprintf(tempstr, PATH_MAX, "%s", filename);
-                    else
-                        ++pos_userformat;
-                    break;
-                case 'n': // sqltype
-                    if (sqltype)
-                        sprintf(tempstr, "%d", sqltype);
-                    else
-                        ++pos_userformat;
+            case 'Q': // number of labels
+                sprintf(tempstr, "%d", cnt->current_image->total_labels);
+                break;
+
+            case 't': // thread number
+                sprintf(tempstr, "%d",(int)(unsigned long)
+                        pthread_getspecific(tls_key_threadnr));
+                break;
+
+            case 'C': // text_event
+                if (cnt->text_event_string && cnt->text_event_string[0])
+                    snprintf(tempstr, PATH_MAX, "%s", cnt->text_event_string);
+                else
+                    ++pos_userformat;
+                break;
+
+            case 'w': // picture width
+                sprintf(tempstr, "%d", cnt->imgs.width);
+                break;
+
+            case 'h': // picture height
+                sprintf(tempstr, "%d", cnt->imgs.height);
+                break;
+
+            case 'f': // filename -- or %fps
+                if ((*(pos_userformat+1) == 'p') && (*(pos_userformat+2) == 's')) {
+                    sprintf(tempstr, "%d", cnt->movie_fps);
+                    pos_userformat += 2;
                     break;
-                default: // Any other code is copied with the %-sign
-                    *format++ = '%';
-                    *format++ = *pos_userformat;
-                    continue;
+                }
+
+                if (filename)
+                    snprintf(tempstr, PATH_MAX, "%s", filename);
+                else
+                    ++pos_userformat;
+                break;
+
+            case 'n': // sqltype
+                if (sqltype)
+                    sprintf(tempstr, "%d", sqltype);
+                else
+                    ++pos_userformat;
+                break;
+
+            default: // Any other code is copied with the %-sign
+                *format++ = '%';
+                *format++ = *pos_userformat;
+                continue;
             }
 
-            /* If a format specifier was found and used, copy the result from
+            /* 
+             * If a format specifier was found and used, copy the result from
              * 'tempstr' to 'format'.
              */
             if (tempstr[0]) {
@@ -2720,86 +3259,3 @@ size_t mystrftime(struct context *cnt, c
     return strftime(s, max, format, tm);
 }
 
-/**
- * motion_log
- *
- *    This routine is used for printing all informational, debug or error
- *    messages produced by any of the other motion functions.  It always
- *    produces a message of the form "[n] {message}", and (if the param
- *    'errno_flag' is set) follows the message with the associated error
- *    message from the library.
- *
- * Parameters:
- *
- *     level           logging level for the 'syslog' function
- *                     (-1 implies no syslog message should be produced)
- *     errno_flag      if set, the log message should be followed by the
- *                     error message.
- *     fmt             the format string for producing the message
- *     ap              variable-length argument list
- *
- * Returns:
- *                     Nothing
- */
-void motion_log(int level, int errno_flag, const char *fmt, ...)
-{
-    int errno_save, n;
-    char buf[1024];
-#if (!defined(BSD)) && (!(_POSIX_C_SOURCE >= 200112L || _XOPEN_SOURCE >= 600) && ! _GNU_SOURCE)
-    char msg_buf[100];
-#endif
-    va_list ap;
-    int threadnr;
-
-    /* If pthread_getspecific fails (e.g., because the thread's TLS doesn't
-     * contain anything for thread number, it returns NULL which casts to zero,
-     * which is nice because that's what we want in that case.
-     */
-    threadnr = (unsigned long)pthread_getspecific(tls_key_threadnr);
-
-    /*
-     * First we save the current 'error' value.  This is required because
-     * the subsequent calls to vsnprintf could conceivably change it!
-     */
-    errno_save = errno;
-
-    /* Prefix the message with the thread number */
-    n = snprintf(buf, sizeof(buf), "[%d] ", threadnr);
-
-    /* Next add the user's message */
-    va_start(ap, fmt);
-    n += vsnprintf(buf + n, sizeof(buf) - n, fmt, ap);
-
-    /* If errno_flag is set, add on the library error message */
-    if (errno_flag) {
-        strncat(buf, ": ", 1024 - strlen(buf));
-        n += 2;
-
-        /*
-         * this is bad - apparently gcc/libc wants to use the non-standard GNU
-         * version of strerror_r, which doesn't actually put the message into
-         * my buffer :-(.  I have put in a 'hack' to get around this.
-         */
-#if (defined(BSD))
-        strerror_r(errno_save, buf + n, sizeof(buf) - n);    /* 2 for the ': ' */
-#elif (_POSIX_C_SOURCE >= 200112L || _XOPEN_SOURCE >= 600) && ! _GNU_SOURCE
-        strerror_r(errno_save, buf + n, sizeof(buf) - n);
-#else
-        strncat(buf, strerror_r(errno_save, msg_buf, sizeof(msg_buf)), 1024 - strlen(buf));
-#endif
-    }
-    /* If 'level' is not negative, send the message to the syslog */
-    if (level >= 0)
-        syslog(level, "%s", buf);
-
-    /* For printing to stderr we need to add a newline */
-    strcat(buf, "\n");
-    fputs(buf, stderr);
-    fflush(stderr);
-
-    /* Clean up the argument list routine */
-    va_end(ap);
-}
-
-
-
--- motion-3.2.12.orig/motion.h
+++ motion-3.2.12/motion.h
@@ -12,11 +12,24 @@
 
 #include "config.h"
 
+#if defined(__FreeBSD__) || defined(__NetBSD__)
+#define BSD
+#endif
+
 /* Includes */
 #ifdef HAVE_MYSQL
 #include <mysql.h>
 #endif
 
+#ifdef HAVE_SQLITE3
+#include <sqlite3.h>
+#endif
+
+#ifdef HAVE_PGSQL
+#include <libpq-fe.h>
+#endif
+
+
 #include <stdio.h>
 #include <stdlib.h>
 #ifndef __USE_GNU
@@ -27,7 +40,6 @@
 #include <fcntl.h>
 #include <time.h>
 #include <signal.h>
-#include <syslog.h>
 #include <limits.h>
 #include <errno.h>
 #include <sys/time.h>
@@ -39,20 +51,22 @@
 #include <stdint.h>
 
 #define _LINUX_TIME_H 1
-#if !defined(WITHOUT_V4L) && !defined(BSD)
+#if defined(HAVE_LINUX_VIDEODEV_H) && (!defined(WITHOUT_V4L)) && (!defined(BSD))
 #include <linux/videodev.h>
 #endif
 
 #include <pthread.h>
 
-#ifdef HAVE_PGSQL
-#include <libpq-fe.h>
-#endif
-
+#include "logger.h"
 #include "conf.h"
-#include "webcam.h"
+#include "stream.h"
 #include "webhttpd.h"
 
+#ifdef HAVE_SDL
+#include "sdl.h"
+#endif
+
+
 /**
  * ATTRIBUTE_UNUSED:
  *
@@ -69,7 +83,14 @@
 #define ATTRIBUTE_UNUSED
 #endif
 
-/* The macro below defines a version of sleep using nanosleep
+/* strerror_r() XSI vs GNU */
+#if (defined(BSD)) || ((_POSIX_C_SOURCE >= 200112L || _XOPEN_SOURCE >= 600) && ! _GNU_SOURCE)
+#define XSI_STRERROR_R
+#endif
+
+
+/* 
+ *  The macro below defines a version of sleep using nanosleep
  * If a signal such as SIG_CHLD interrupts the sleep we just continue sleeping
  */
 #define SLEEP(seconds, nanoseconds) {              \
@@ -79,9 +100,8 @@
                 while (nanosleep(&tv, &tv) == -1); \
         } 
 
+#define CLEAR(x) memset(&(x), 0, sizeof(x))
 
-#if defined(WITHOUT_V4L) || defined(BSD)
- 
 #define VIDEO_PALETTE_GREY      1       /* Linear greyscale */
 #define VIDEO_PALETTE_HI240     2       /* High 240 cube (BT848) */
 #define VIDEO_PALETTE_RGB565    3       /* 565 16 bit RGB */
@@ -100,17 +120,8 @@
 #define VIDEO_PALETTE_YUV410P   16      /* YUV 4:1:0 Planar */
 #define VIDEO_PALETTE_PLANAR    13      /* start of planar entries */
 #define VIDEO_PALETTE_COMPONENT 7       /* start of component entries */
-#endif
-
-
-/* Debug levels FIXME */
-#define CAMERA_WARNINGS         3   /* warnings only */
-#define CAMERA_INFO             5   /* info debug */
-#define CAMERA_VIDEO            6   /* video debug */
-#define CAMERA_DEBUG            7   /* debug but not verbose */
-#define CAMERA_VERBOSE          8   /* verbose level */
-#define CAMERA_ALL              9   /* everything */
 
+#define DEF_PALETTE             17
 
 /* Default picture settings */
 #define DEF_WIDTH              352
@@ -122,8 +133,8 @@
 #define DEF_NOISELEVEL          32
 
 /* Minimum time between two 'actions' (email, sms, external) */
-#define DEF_GAP                 60  /* 1 minutes */
-#define DEF_MAXMPEGTIME       3600  /* 60 minutes */
+#define DEF_EVENT_GAP            60  /* 1 minutes */
+#define DEF_MAXMOVIETIME       3600  /* 60 minutes */
 
 #define DEF_FFMPEG_BPS      400000
 #define DEF_FFMPEG_VBR           0
@@ -132,26 +143,26 @@
 #define THRESHOLD_TUNE_LENGTH  256
 
 #define MISSING_FRAMES_TIMEOUT  30  /* When failing to get picture frame from camera
-                                     * we reuse the previous frame until
-                                     * MISSING_FRAMES_TIMEOUT seconds has passed
-                                     * and then we show a grey image instead
+                                       we reuse the previous frame until
+                                       MISSING_FRAMES_TIMEOUT seconds has passed
+                                       and then we show a grey image instead
                                      */
 
-#define WATCHDOG_TMO            30  /* 10 sec max motion_loop interval */
-#define WATCHDOG_OFF          -127  /* Turn off watchdog, used when we wants to quit a thread */
+#define WATCHDOG_TMO            30   /* 30 sec max motion_loop interval */
+#define WATCHDOG_OFF          -127   /* Turn off watchdog, used when we wants to quit a thread */
 
-#define CONNECTION_KO "Lost connection"
-#define CONNECTION_OK "Connection OK"
+#define CONNECTION_KO           "Lost connection"
+#define CONNECTION_OK           "Connection OK"
 
-#define DEF_MAXSTREAMS          10  /* Maximum number of webcam clients per camera */
-#define DEF_MAXWEBQUEUE         10  /* Maximum number of webcam client in queue */
+#define DEF_MAXSTREAMS          10   /* Maximum number of stream clients per camera */
+#define DEF_MAXWEBQUEUE         10   /* Maximum number of stream client in queue */
 
 #define DEF_TIMESTAMP           "%Y-%m-%d\\n%T"
 #define DEF_EVENTSTAMP          "%Y%m%d%H%M%S"
 
 #define DEF_SNAPPATH            "%v-%Y%m%d%H%M%S-snapshot"
-#define DEF_JPEGPATH            "%v-%Y%m%d%H%M%S-%q"
-#define DEF_MPEGPATH            "%v-%Y%m%d%H%M%S"
+#define DEF_IMAGEPATH           "%v-%Y%m%d%H%M%S-%q"
+#define DEF_MOVIEPATH           "%v-%Y%m%d%H%M%S"
 #define DEF_TIMEPATH            "%Y%m%d-timelapse"
 
 #define DEF_TIMELAPSE_MODE      "daily"
@@ -159,33 +170,44 @@
 /* Do not break this line into two or more. Must be ONE line */
 #define DEF_SQL_QUERY "sql_query insert into security(camera, filename, frame, file_type, time_stamp, event_time_stamp) values('%t', '%f', '%q', '%n', '%Y-%m-%d %T', '%C')"
 
+
+/* OUTPUT Image types */
+#define IMAGE_TYPE_JPEG        0
+#define IMAGE_TYPE_PPM         1
+
 /* Filetype defines */
-#define FTYPE_IMAGE             1
-#define FTYPE_IMAGE_SNAPSHOT    2
-#define FTYPE_IMAGE_MOTION      4
-#define FTYPE_MPEG              8
-#define FTYPE_MPEG_MOTION      16
-#define FTYPE_MPEG_TIMELAPSE   32
+#define FTYPE_IMAGE            1
+#define FTYPE_IMAGE_SNAPSHOT   2
+#define FTYPE_IMAGE_MOTION     4
+#define FTYPE_MPEG             8
+#define FTYPE_MPEG_MOTION     16
+#define FTYPE_MPEG_TIMELAPSE  32
 
 #define FTYPE_MPEG_ANY    (FTYPE_MPEG | FTYPE_MPEG_MOTION | FTYPE_MPEG_TIMELAPSE)
 #define FTYPE_IMAGE_ANY   (FTYPE_IMAGE | FTYPE_IMAGE_SNAPSHOT | FTYPE_IMAGE_MOTION)
 
-/* What types of jpeg files do we want to have */
-#define NEWIMG_OFF              0
-#define NEWIMG_ON               1
-#define NEWIMG_FIRST            2
-#define NEWIMG_BEST             4
-#define NEWIMG_CENTER           8
-
-#define LOCATE_OFF              0
-#define LOCATE_ON               1
-#define LOCATE_PREVIEW          2
+/* What types of images files do we want to have */
+#define NEWIMG_OFF        0
+#define NEWIMG_ON         1
+#define NEWIMG_FIRST      2
+#define NEWIMG_BEST       4
+#define NEWIMG_CENTER     8
+
+#define LOCATE_OFF        0
+#define LOCATE_ON         1
+#define LOCATE_PREVIEW    2
+#define LOCATE_BOX        1
+#define LOCATE_REDBOX     2
+#define LOCATE_CROSS      4
+#define LOCATE_REDCROSS   8
+
+#define LOCATE_NORMAL     1
+#define LOCATE_BOTH       2
 
-#define LOCATE_NORMAL           0
-#define LOCATE_BOTH             1
+#define UPDATE_REF_FRAME  1
+#define RESET_REF_FRAME   2
 
-#define UPDATE_REF_FRAME        1
-#define RESET_REF_FRAME         2
+#define BUFSIZE_1MEG      (1024 * 1024)
 
 /* Forward declaration, used in track.h */
 struct images;
@@ -193,39 +215,44 @@ struct images;
 #include "track.h"
 #include "netcam.h"
 
-/* Structure to hold images information
+/* 
+ * Structure to hold images information
  * The idea is that this should have all information about a picture e.g. diffs, timestamp etc.
  * The exception is the label information, it uses a lot of memory
  * When the image is stored all texts motion marks etc. is written to the image
  * so we only have to send it out when/if we want.
  */
+
 /* A image can have detected motion in it, but dosn't trigger an event, if we use minimum_motion_frames */
-#define IMAGE_MOTION            1
-#define IMAGE_TRIGGER           2
-#define IMAGE_SAVE              4
-#define IMAGE_SAVED             8
-#define IMAGE_PRECAP           16
-#define IMAGE_POSTCAP          32
+#define IMAGE_MOTION     1
+#define IMAGE_TRIGGER    2
+#define IMAGE_SAVE       4
+#define IMAGE_SAVED      8
+#define IMAGE_PRECAP    16
+#define IMAGE_POSTCAP   32
 
 struct image_data {
     unsigned char *image;
     int diffs;
-    time_t timestamp;         /* Timestamp when image was captured */
+    time_t timestamp;           /* Timestamp when image was captured */
     struct tm timestamp_tm;
-    int shot;                 /* Sub second timestamp count */
+    int shot;                   /* Sub second timestamp count */
 
-    /* movement center to img center distance 
-     * Note Dist is calculated distX*distX + distY*distY */
+    /* 
+     * Movement center to img center distance 
+     * Note: Dist is calculated distX*distX + distY*distY 
+     */
     unsigned long cent_dist;
 
-    unsigned int flags;       /* Se IMAGE_* defines */
+    unsigned int flags;         /* Se IMAGE_* defines */
 
-    struct coord location;    /* coordinates for center and size of last motion detection*/
+    struct coord location;      /* coordinates for center and size of last motion detection*/
 
     int total_labels;
 };
 
-/* DIFFERENCES BETWEEN imgs.width, conf.width AND rotate_data.cap_width
+/* 
+ * DIFFERENCES BETWEEN imgs.width, conf.width AND rotate_data.cap_width
  * (and the corresponding height values, of course)
  * ===========================================================================
  * Location      Purpose
@@ -251,7 +278,7 @@ struct image_data {
  */
 
 /* date/time drawing, draw.c */
-int draw_text (unsigned char *image, int startx, int starty, int width, const char *text, unsigned short int factor);
+int draw_text(unsigned char *image, unsigned int startx, unsigned int starty, unsigned int width, const char *text, unsigned int factor);
 int initialize_chars(void);
 
 struct images {
@@ -275,6 +302,7 @@ struct images {
     int width;
     int height;
     int type;
+    int picture_type;                 /* Output picture type IMAGE_JPEG, IMAGE_PPM */        
     int size;
     int motionsize;
     int labelgroup_max;
@@ -287,36 +315,47 @@ struct images {
 struct rotdata {
     /* Temporary buffer for 90 and 270 degrees rotation. */
     unsigned char *temp_buf;
-    /* Degrees to rotate; copied from conf.rotate_deg. This is the value
+    /* 
+     * Degrees to rotate; copied from conf.rotate_deg. This is the value
      * that is actually used. The value of conf.rotate_deg cannot be used
      * because it can be changed by motion-control, and changing rotation
      * while Motion is running just causes problems.
      */
     int degrees;
-    /* Capture width and height - different from output width and height if 
-     * rotating 90 or 270 degrees. */
+    /*
+     * Capture width and height - different from output width and height if 
+     * rotating 90 or 270 degrees. 
+     */
     int cap_width;
     int cap_height;
 };
 
 /*
-    these used to be global variables but now each thread will have its
-    own context
+ *  These used to be global variables but now each thread will have its
+ *  own context
  */
 struct context {
+    FILE *extpipe;
+    int extpipe_open;
     char conf_filename[PATH_MAX];
     int threadnr;
-    unsigned short int daemon;
+    unsigned int daemon;
     char pid_file[PATH_MAX];
+    char log_file[PATH_MAX];
+    char log_type_str[6];
+    int log_level;
+    unsigned int log_type;
 
     struct config conf;
     struct images imgs;
     struct trackoptions track;
     struct netcam_context *netcam;
     struct image_data *current_image;        /* Pointer to a structure where the image, diffs etc is stored */
-    unsigned short int new_img;
+    unsigned int new_img;
 
-    int locate;
+    int locate_motion_mode;
+    int locate_motion_style;
+    int process_thisframe;
     struct rotdata rotate_data;              /* rotation data is thread-specific */
 
     int noise;
@@ -325,39 +364,39 @@ struct context {
     int smartmask_speed;
 
     /* Commands to the motion thread */
-    volatile unsigned short int snapshot;    /* Make a snapshot */
-    volatile unsigned short int makemovie;   /* End a movie */
-    volatile unsigned short int finish;      /* End the thread */
-    volatile unsigned short int restart;     /* Restart the thread when it ends */
+    volatile unsigned int snapshot;    /* Make a snapshot */
+    volatile unsigned int makemovie;   /* End a movie */
+    volatile unsigned int finish;      /* End the thread */
+    volatile unsigned int restart;     /* Restart the thread when it ends */
     /* Is the motion thread running */
-    volatile unsigned short int running;
+    volatile unsigned int running;
     volatile int watchdog;
 
     pthread_t thread_id;
 
     int event_nr;
     int prev_event;
-    int lightswitch_framecounter;
-    char text_event_string[PATH_MAX];       /* The text for conv. spec. %C -
-                                            we assume PATH_MAX normally 4096 characters is fine */
-    int postcap;                            /* downcounter, frames left to to send post event */
+    unsigned int lightswitch_framecounter;
+    char text_event_string[PATH_MAX];        /* The text for conv. spec. %C -
+                                                we assume PATH_MAX normally 4096 characters is fine */
+    int postcap;                             /* downcounter, frames left to to send post event */
 
-    short int shots;
-    unsigned short int detecting_motion;
+    int shots;
+    unsigned int detecting_motion;
     struct tm *currenttime_tm;
     struct tm *eventtime_tm;
 
     time_t currenttime;
     time_t lasttime;
     time_t eventtime;
-    time_t connectionlosttime;              /* timestamp from connection lost */
+    time_t connectionlosttime;               /* timestamp from connection lost */
 
-    int lastrate;
-    unsigned short int startup_frames;
-    unsigned short int moved;
-    unsigned short int pause;
-    int missing_frame_counter;              /* counts failed attempts to fetch picture frame from camera */
-    unsigned short int lost_connection;    
+    unsigned int lastrate;
+    unsigned int startup_frames;
+    unsigned int moved;
+    unsigned int pause;
+    int missing_frame_counter;               /* counts failed attempts to fetch picture frame from camera */
+    unsigned int lost_connection;    
 
 #if (defined(BSD))
     int tuner_dev;
@@ -366,13 +405,17 @@ struct context {
     int pipe;
     int mpipe;
 
-    struct webcam webcam;
+    struct stream stream;
     int stream_count;
     
-#if defined(HAVE_MYSQL) || defined(HAVE_PGSQL)
+#if defined(HAVE_MYSQL) || defined(HAVE_PGSQL) || defined(HAVE_SQLITE3)
     int sql_mask;
 #endif
 
+#ifdef HAVE_SQLITE3
+    sqlite3 *database_sqlite3;
+#endif
+
 #ifdef HAVE_MYSQL
     MYSQL *database;
 #endif
@@ -381,29 +424,33 @@ struct context {
     PGconn *database_pg;
 #endif
 
+    int movie_fps;
+    char newfilename[PATH_MAX];
+    char extpipefilename[PATH_MAX];
+    int movie_last_shot;
+
 #ifdef HAVE_FFMPEG
-    struct ffmpeg *ffmpeg_new;
-    struct ffmpeg *ffmpeg_motion;
+    struct ffmpeg *ffmpeg_output;
+    struct ffmpeg *ffmpeg_output_debug;
     struct ffmpeg *ffmpeg_timelapse;
     struct ffmpeg *ffmpeg_smartmask;
-    char newfilename[PATH_MAX];
-    char motionfilename[PATH_MAX];
     char timelapsefilename[PATH_MAX];
+    char motionfilename[PATH_MAX];
 #endif
 };
 
 extern pthread_mutex_t global_lock;
 extern volatile int threads_running;
-extern unsigned short int debug_level;
+extern FILE *ptr_logfile;
 
 /* TLS keys below */
 extern pthread_key_t tls_key_threadnr; /* key for thread number */
 
-int http_bindsock(int, int);
+int http_bindsock(int, int, int);
 void * mymalloc(size_t);
 void * myrealloc(void *, size_t, const char *);
-FILE * myfopen(const char *, const char *);
-size_t mystrftime(struct context *, char *, size_t, const char *, const struct tm *, const char *, int);
+FILE * myfopen(const char *, const char *, size_t);
+int myfclose(FILE *);
+size_t mystrftime(const struct context *, char *, size_t, const char *, const struct tm *, const char *, int);
 int create_path(const char *);
-void motion_log(int, int, const char *, ...);
 #endif /* _INCLUDE_MOTION_H */
--- /dev/null
+++ motion-3.2.12/motion.init-Debian
@@ -0,0 +1,69 @@
+#! /bin/bash
+#
+# motion 3.2.12-4ppa01	
+# Start the motion detection .
+#
+
+NAME=motion
+PATH=/bin:/usr/bin:/sbin:/usr/sbin
+DAEMON=/home/dave/motion_build/bin/motion
+PIDFILE=/var/run/motion/$NAME.pid
+
+
+trap "" 1
+export LANG=C
+export PATH
+
+test -f $DAEMON || exit 0
+
+
+case "$1" in
+  start)
+    echo "Starting motion detection : $NAME"
+    start-stop-daemon --start --pidfile $PIDFILE --exec $DAEMON --chuid motion
+    ;;
+
+  stop)
+    echo "Stopping motion detection : $NAME"
+    start-stop-daemon --stop --pidfile $PIDFILE --oknodo --exec $DAEMON --retry 30 
+    ;;
+
+  status)
+    echo "Status motion detection : $NAME"
+    if (test -f $PIDFILE); then
+        echo -n "Running process for $NAME : "
+    	pidof $NAME  
+    else
+    	echo "Stopped"
+    fi
+    ;;  
+    
+  reload-config)
+    echo "Reloading $NAME configuration"
+    start-stop-daemon --stop --pidfile $PIDFILE --signal HUP --exec $DAEMON
+    ;;
+
+  restart-motion)
+    echo "Restarting $NAME"
+    start-stop-daemon --stop --pidfile $PIDFILE --oknodo --exec $DAEMON  --retry 30
+    start-stop-daemon --start --pidfile $PIDFILE --exec $DAEMON --chuid motion
+    ;;
+
+  restart)
+    $0 restart-motion
+    exit $?
+    ;;
+
+  *)
+    echo "Usage: /etc/init.d/$NAME {start|stop|status|reload-config|restart}"
+    exit 1
+    ;;
+esac
+
+if [ $? == 0 ]; then
+	echo .
+	exit 0
+else
+	echo failed
+	exit 1
+fi
--- /dev/null
+++ motion-3.2.12/motion.init-Fedora
@@ -0,0 +1,118 @@
+#!/bin/bash
+#
+# motion        Startup script for the Motion Detection System 
+#
+# chkconfig:    - 85 15
+# description:  Motion detection system.  It is used to detect movement based \
+#               on compare images.
+# processname:  motion 
+# pidfile:      /var/run/motion.pid
+# config:       /etc/motion.conf
+#
+### BEGIN INIT INFO
+# Provides: motion
+# Required-Start: $local_fs
+# Required-Stop: $local_fs
+# Default-Start: 
+# Default-Stop: 
+# Short-Description: Start and stop motion detection system
+# Description: The Motion detection system is used to detect movement based
+#              on image comparison.
+### END INIT INFO
+
+# Source function library.
+. /etc/rc.d/init.d/functions
+
+motion=${MOTION-/usr/bin/motion}
+prog=motion
+pidfile=/var/run/motion.pid
+lockfile=/var/lock/subsys/motion
+
+start() {
+    [ -x $exec ] || exit 5
+    [ -f $config ] || exit 6
+    echo -n $"Starting $prog: "
+    # We try to determine which architecture we have so we can 
+    # load libv4l to support more USB cameras. x86_64 and ppc64
+    # are both supported by rpmfusion.
+    case $(uname -i) in
+        "x86_64" )
+            #We load libv4l for 64 Bit x86 architectures
+            LD_PRELOAD=/usr/lib64/libv4l/v4l2convert.so daemon $motion 2> /dev/null ;;
+        "ppc64" )
+            #We load libv4l for 64 Bit PPC architectures
+            LD_PRELOAD=/usr/lib64/libv4l/v4l2convert.so daemon $motion 2> /dev/null ;;
+        * )
+            #Default case, we load libv4l for all 32 Bit architectures
+            LD_PRELOAD=/usr/lib/libv4l/v4l2convert.so daemon $motion 2> /dev/null ;;
+    esac
+    retval=$?
+    echo
+    [ $retval -eq 0 ] && touch $lockfile
+    return $retval
+}
+
+stop() {
+    echo -n $"Stopping $prog: "
+    killproc $motion
+    retval=$?
+    echo
+    [ $retval = 0 ] && rm -f $lockfile
+}
+
+restart() {
+    stop
+    start
+}
+
+reload() {
+    echo -n $"Reloading $prog configuration: "
+    killproc $motion -HUP
+    retval=$?
+    echo
+    return $retval
+}
+
+rh_status() { 
+    # run checks to determine if the service is running or use generic status
+    status $prog
+}
+          
+rh_status_q() {
+    rh_status >/dev/null 2>&1
+}
+
+
+# See how we were called.
+case "$1" in
+    start)
+        rh_status_q && exit 0
+        $1
+        ;;
+    stop)
+        rh_status_q || exit 0
+        $1
+        ;;        
+    restart)
+        $1
+        ;;
+    reload)
+        rh_status_q || exit 7
+        $1
+        ;;
+    force-reload)
+        #force_reload
+        reload
+        ;;
+    status)
+        rh_status
+        ;;
+    condrestart|try-restart)
+        rh_status_q || exit 0
+        restart
+        ;;
+    *)
+                echo $"Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload}"
+		exit 1
+esac
+exit $?
--- /dev/null
+++ motion-3.2.12/motion.init-FreeBSD.sh
@@ -0,0 +1,26 @@
+#!/bin/sh
+#
+# motion.sh for rc.d usage 2006 Angel Carpintero 
+#
+# Add the following line in /etc/rc.conf to enable motion at startup
+#
+# motion_enable="YES"
+#
+
+# PROVIDE: motion 
+# REQUIRE: DAEMON
+# KEYWORD: shutdown
+
+. /etc/rc.subr
+
+motion_enable="${motion_enable-NO}"
+
+name="motion"
+rcvar=`set_rcvar`
+
+command="/home/dave/motion_build/bin/${name}"
+pidfile="/var/run/${name}.pid"
+required_files="/usr/local/etc/${name}.conf"
+
+load_rc_config $name
+run_rc_command "$1"
--- /dev/null
+++ motion-3.2.12/motion.spec
@@ -0,0 +1,134 @@
+Name:           motion
+Version:        3.2.12-4ppa01
+Release:        1%{?dist}
+Summary:        A motion detection system
+
+Group:          Applications/Multimedia
+License:        GPLv2+
+URL:            http://www.lavrsen.dk/twiki/bin/view/Motion/WebHome
+Source0:        http://prdownloads.sourceforge.net/%{name}/%{name}-%{version}.tar.gz
+BuildRoot:      %{_tmppath}/%{name}-%{version}-%{release}-root-%(%{__id_u} -n)
+
+BuildRequires:  libjpeg-devel ffmpeg-devel zlib-devel
+#This requires comes from the startup script, it will be there until motion supports libv4l calls in the code
+Requires: libv4l
+Requires(post): chkconfig
+Requires(preun): chkconfig initscripts
+Requires(postun): initscripts
+
+%description
+Motion is a software motion detector. It grabs images from video4linux devices
+and/or from webcams (such as the axis network cameras). Motion is the perfect
+tool for keeping an eye on your property keeping only those images that are
+interesting. Motion is strictly command line driven and can run as a daemon
+with a rather small footprint. This version is built with ffmpeg support but
+without MySQL and PostgreSQL support.
+
+%prep
+%setup -q
+
+%build
+%configure --sysconfdir=%{_sysconfdir}/%{name} --without-optimizecpu --with-ffmpeg --without-mysql --without-pgsql
+make %{?_smp_mflags}
+
+%install
+rm -rf %{buildroot}
+make install DESTDIR=%{buildroot}
+#We rename the configuration file
+mv %{buildroot}%{_sysconfdir}/%{name}/motion-dist.conf %{buildroot}%{_sysconfdir}/%{name}/motion.conf
+#We change the PID file path to match the one in the startup script
+sed -i 's|/var/run/motion/motion.pid|/var/run/motion.pid|g' %{buildroot}%{_sysconfdir}/%{name}/motion.conf
+#We remove SQL directives in the configuration file, as we don't use them
+sed -i 's|sql_log_image|; sql_log_image|g' %{buildroot}%{_sysconfdir}/%{name}/motion.conf
+sed -i 's|sql_log_snapshot|; sql_log_snapshot|g' %{buildroot}%{_sysconfdir}/%{name}/motion.conf
+sed -i 's|sql_log_mpeg|; sql_log_mpeg|g' %{buildroot}%{_sysconfdir}/%{name}/motion.conf
+sed -i 's|sql_log_timelapse|; sql_log_timelapse|g' %{buildroot}%{_sysconfdir}/%{name}/motion.conf
+sed -i 's|sql_query|; sql_query|g' %{buildroot}%{_sysconfdir}/%{name}/motion.conf
+#We set the log file and target directory - logging is for 3.3 branch
+sed -i 's|;logfile|logfile /var/log/motion.log|g' %{buildroot}%{_sysconfdir}/%{name}/motion.conf
+sed -i 's|target_dir /usr/local/apache2/htdocs/cam1|target_dir /var/motion|g' %{buildroot}%{_sysconfdir}/%{name}/motion.conf
+#We install our startup script
+install -D -m 0755 motion.init-Fedora %{buildroot}%{_initrddir}/%{name}
+
+%post
+#We add the motion init script to the services when installing
+/sbin/chkconfig --add %{name}
+
+%preun
+#We stop the service and remove it from init scripts when erasing
+if [ $1 = 0 ] ; then
+    /sbin/service %{name} stop >/dev/null 2>&1
+    /sbin/chkconfig --del %{name}
+fi
+
+%postun
+#We restart the service during an upgrade
+if [ "$1" -ge "1" ] ; then
+    /sbin/service %{name} condrestart >/dev/null 2>&1
+fi
+
+%clean
+rm -rf %{buildroot}
+
+%files
+#Permissions are bogus upstream, we need to be sure to set them here
+%defattr (-,root,root,-)
+%dir %{_sysconfdir}/%{name}
+%dir %{_datadir}/%{name}-%{version}
+%dir %{_datadir}/%{name}-%{version}/examples
+%doc CHANGELOG COPYING CREDITS INSTALL README motion_guide.html
+%attr(0644,root,root) %{_datadir}/%{name}-%{version}/examples/motion-dist.conf
+%attr(0755,root,root) %{_datadir}/%{name}-%{version}/examples/motion.init-Debian
+%attr(0755,root,root) %{_datadir}/%{name}-%{version}/examples/motion.init-FreeBSD.sh
+%attr(0755,root,root) %{_datadir}/%{name}-%{version}/examples/motion.init-Fedora
+%attr(0644,root,root) %{_datadir}/%{name}-%{version}/examples/thread1.conf
+%attr(0644,root,root) %{_datadir}/%{name}-%{version}/examples/thread2.conf
+%attr(0644,root,root) %{_datadir}/%{name}-%{version}/examples/thread3.conf
+%attr(0644,root,root) %{_datadir}/%{name}-%{version}/examples/thread4.conf
+%attr(0644,root,root) %config(noreplace) %{_sysconfdir}/%{name}/motion.conf
+%attr(0755,root,root) %{_bindir}/motion
+%attr(0644,root,root) %{_mandir}/man1/motion.1*
+%attr(0755,root,root) %{_initrddir}/%{name}
+
+%changelog
+* Thu Mar 06 2010 Steven Moix <steven.moix@axianet.ch> - 3.2.12-1
+- New upstream release, important bugfixes only
+
+* Wed Oct 21 2009 Thorsten Leemhuis <fedora [AT] leemhuis [DOT] info> - 3.2.11.1-3
+- rebuild for new ffmpeg
+
+* Tue Aug 11 2009 Steven Moix <steven.moix@axianet.ch> - 3.2.11.1-1
+- Drop patch for ffmpeg 0.5 compatibility
+- Drop ffmpeg detection patch
+- Moved default output directory to /var/motion
+- New startup script with added v4l2convert to support more cameras - https://bugzilla.rpmfusion.org/show_bug.cgi?id=681
+- Fix Segfault on reload or quit for vloopback (maybe other v4l1 devices too)
+- Fix fd leaks in external pipe
+- Avoid possible stack smashing in v4l_open_vidpipe()
+- Fix segfault for new libjpeg v7
+
+* Mon Jul 06 2009 Steven Moix <steven.moix@axianet.ch> - 3.3.0-1
+- SPEC Preparation for the 3.3 branch
+
+* Sun Jun 05 2009 Steven Moix <steven.moix@axianet.ch> - 3.2.11-5
+- Patch and rebuild for ffmpeg 0.5
+
+* Sun Mar 29 2009 Thorsten Leemhuis <fedora [AT] leemhuis [DOT] info> - 3.2.11-4
+- rebuild for new F11 features
+
+* Wed Mar 18 2009 Steven Moix <steven.moix@axianet.ch> - 3.2.11-3
+- Even more corrected init script thanks to Stewart Adam
+
+* Sun Mar 15 2009 Steven Moix <steven.moix@axianet.ch> - 3.2.11-2
+- Removed the ffmpeg requires
+- Corrected the spec file
+- New init script with a corrected start() function and LSB header support
+
+* Tue Mar 03 2009 Steven Moix <steven.moix@axianet.ch> - 3.2.11-1
+- Updated to Fedora 10 standard
+
+* Sun Sep 18 2005 Kenneth Lavrsen <kenneth@lavrsen.dk> - 3.2.4-1
+- Generic version of livna spec file replacing the old less optimal specfile.
+
+* Thu Sep 15 2005 Dams <anvil[AT]livna.org> - 3.2.3-0.lvn.1
+- Initial released based upon upstream spec file
--- motion-3.2.12.orig/motion.spec.in
+++ motion-3.2.12/motion.spec.in
@@ -5,7 +5,7 @@ Summary:        A motion detection syste
 
 Group:          Applications/Multimedia
 License:        GPLv2+
-URL:            http://www.lavrsen.dk/foswiki/bin/view/Motion/WebHome
+URL:            http://www.lavrsen.dk/twiki/bin/view/Motion/WebHome
 Source0:        http://prdownloads.sourceforge.net/%{name}/%{name}-%{version}.tar.gz
 BuildRoot:      %{_tmppath}/%{name}-%{version}-%{release}-root-%(%{__id_u} -n)
 
@@ -45,7 +45,7 @@ sed -i 's|sql_log_mpeg|; sql_log_mpeg|g'
 sed -i 's|sql_log_timelapse|; sql_log_timelapse|g' %{buildroot}%{_sysconfdir}/%{name}/motion.conf
 sed -i 's|sql_query|; sql_query|g' %{buildroot}%{_sysconfdir}/%{name}/motion.conf
 #We set the log file and target directory - logging is for 3.3 branch
-#sed -i 's|;logfile|logfile /var/log/motion.log|g' %{buildroot}%{_sysconfdir}/%{name}/motion.conf
+sed -i 's|;logfile|logfile /var/log/motion.log|g' %{buildroot}%{_sysconfdir}/%{name}/motion.conf
 sed -i 's|target_dir /usr/local/apache2/htdocs/cam1|target_dir /var/motion|g' %{buildroot}%{_sysconfdir}/%{name}/motion.conf
 #We install our startup script
 install -D -m 0755 motion.init-Fedora %{buildroot}%{_initrddir}/%{name}
--- motion-3.2.12.orig/motion_guide.html
+++ motion-3.2.12/motion_guide.html
@@ -1,13 +1,13 @@
-<h1><a name="Motion_Guide_One_Large_Document"></a>  Motion Guide - One Large Document. </h1>
+<h1><a name="Motion_Guide_One_Large_Document"></a><a name="_Motion_Guide_One_Large_Document"></a>  Motion Guide - One Large Document. </h1>
 This version of the Guide is made for inclusion in the Motion download package for off line reading.
 <p />
-If you read this document from the distribution package of Motion or from some not up to date mirror you should know that the URL for the always up to date version is <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuide" target="_top">http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuide</a>. If you are already on the Foswiki based Motion site clicking the link just mentioned will lead you to the index page for the Motion Guide documents.
+If you read this document from the distribution package of Motion or from some not up to date mirror you should know that the URL for the always up to date version is <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuide" target="_top">http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuide</a>. If you are already on the new TWiki based Motion site clicking the link just mentioned will lead you to the index page for the Motion Guide documents.
 <hr />
 This topic consists of the following subtopics:
-<a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionOverview">MotionOverview</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/KnownProblems">KnownProblems</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/InstallOverview">InstallOverview</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/PrepareInstall">PrepareInstall</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigureScript">ConfigureScript</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MakeInstall">MakeInstall</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/UpgradingFromOlderVersion">UpgradingFromOlderVersion</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/RunningMotionConfigFiles">RunningMotionConfigFiles</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/CommandLineOptions">CommandLineOptions</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigFileOptions">ConfigFileOptions</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/SignalsKill">SignalsKill</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ErrorLogging">ErrorLogging</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/CaptureDeviceOptions">CaptureDeviceOptions</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionDetectionSettings">MotionDetectionSettings</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ImageFileOutput">ImageFileOutput</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/TuningMotion">TuningMotion</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MpegFilmsFFmpeg">MpegFilmsFFmpeg</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/SnapshotsWebCam">SnapshotsWebCam</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/TextFeatures">TextFeatures</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/AdvancedFilenames">AdvancedFilenames</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">ConversionSpecifiers</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/WebcamServer">WebcamServer</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/RemoteControlHttp">RemoteControlHttp</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ExternalCommands">ExternalCommands</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/TrackingControl">TrackingControl</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/UsingDatabases">UsingDatabases</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/LoopbackDevice">LoopbackDevice</a>.
+<a href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionOverview" class="twikiLink">MotionOverview</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/KnownProblems" class="twikiLink">KnownProblems</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/InstallOverview" class="twikiLink">InstallOverview</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/PrepareInstall" class="twikiLink">PrepareInstall</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigureScript" class="twikiLink">ConfigureScript</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/MakeInstall" class="twikiLink">MakeInstall</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/UpgradingFromOlderVersion" class="twikiLink">UpgradingFromOlderVersion</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/RunningMotionConfigFiles" class="twikiLink">RunningMotionConfigFiles</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/CommandLineOptions" class="twikiLink">CommandLineOptions</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigFileOptions" class="twikiLink">ConfigFileOptions</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/SignalsKill" class="twikiLink">SignalsKill</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ErrorLogging" class="twikiLink">ErrorLogging</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/CaptureDeviceOptions" class="twikiLink">CaptureDeviceOptions</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionDetectionSettings" class="twikiLink">MotionDetectionSettings</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ImageFileOutput" class="twikiLink">ImageFileOutput</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/TuningMotion" class="twikiLink">TuningMotion</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/MpegFilmsFFmpeg" class="twikiLink">MpegFilmsFFmpeg</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/SnapshotsWebCam" class="twikiLink">SnapshotsWebCam</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/TextFeatures" class="twikiLink">TextFeatures</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/AdvancedFilenames" class="twikiLink">AdvancedFilenames</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">ConversionSpecifiers</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/WebcamServer" class="twikiLink">WebcamServer</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/RemoteControlHttp" class="twikiLink">RemoteControlHttp</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ExternalCommands" class="twikiLink">ExternalCommands</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/TrackingControl" class="twikiLink">TrackingControl</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/UsingDatabases" class="twikiLink">UsingDatabases</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/LoopbackDevice" class="twikiLink">LoopbackDevice</a>.
 <hr />
 <p />
-<a name="foswikiTOC"></a><div class="foswikiToc"> <ul>
+<div class="twikiToc"> <ul>
 <li> <a href="#Motion_Guide_Installation"> Motion Guide - Installation</a> <ul>
 <li> <a href="#Motion_Overview"> Motion Overview</a> <ul>
 <li> <a href="#What_is_Motion"> What is Motion?</a>
@@ -37,7 +37,6 @@ This topic consists of the following sub
 </li> <li> <a href="#Command_Line_Options"> Command Line Options</a>
 </li> <li> <a href="#Config_File_Options"> Config File Options</a> <ul>
 <li> <a href="#Options_in_Alphabetical_Order"> Options in Alphabetical Order.</a>
-</li> <li> <a href="#Obsolete_Options"> Obsolete Options</a>
 </li></ul> 
 </li> <li> <a href="#Signals_sent_with_e_g_kill_comma"> Signals (sent with e.g. kill command)</a>
 </li> <li> <a href="#Error_Logging"> Error Logging</a>
@@ -58,14 +57,11 @@ This topic consists of the following sub
 </li> <li> <a href="#rotate"> rotate</a>
 </li> <li> <a href="#saturation"> saturation</a>
 </li> <li> <a href="#tunerdevice"> tunerdevice</a>
-</li> <li> <a href="#v4l2_palette"> v4l2_palette</a>
 </li> <li> <a href="#videodevice"> videodevice</a>
 </li> <li> <a href="#width"> width</a>
 </li></ul> 
 </li> <li> <a href="#Network_Cameras"> Network Cameras</a> <ul>
-<li> <a href="#netcam_http"> netcam_http</a>
-</li> <li> <a href="#netcam_proxy"> netcam_proxy</a>
-</li> <li> <a href="#netcam_tolerant_check"> netcam_tolerant_check</a>
+<li> <a href="#netcam_proxy"> netcam_proxy</a>
 </li> <li> <a href="#netcam_url"> netcam_url</a>
 </li> <li> <a href="#netcam_userpass"> netcam_userpass</a>
 </li></ul> 
@@ -75,13 +71,15 @@ This topic consists of the following sub
 </li> <li> <a href="#switchfilter"> switchfilter</a>
 </li></ul> 
 </li> <li> <a href="#Motion_Detection_Settings"> Motion Detection Settings</a> <ul>
-<li> <a href="#area_detect"> area_detect</a>
-</li> <li> <a href="#despeckle"> despeckle</a>
+<li> <a href="#despeckle"> despeckle</a>
 </li> <li> <a href="#gap"> gap</a>
 </li> <li> <a href="#lightswitch"> lightswitch </a>
+</li> <li> <a href="#low_cpu"> low_cpu</a>
 </li> <li> <a href="#mask_file"> mask_file</a>
 </li> <li> <a href="#max_mpeg_time"> max_mpeg_time</a>
+</li> <li> <a href="#minimum_gap"> minimum_gap</a>
 </li> <li> <a href="#minimum_motion_frames"> minimum_motion_frames</a>
+</li> <li> <a href="#night_compensate"> night_compensate</a>
 </li> <li> <a href="#noise_level"> noise_level</a>
 </li> <li> <a href="#noise_tune"> noise_tune</a>
 </li> <li> <a href="#output_all"> output_all</a>
@@ -143,9 +141,7 @@ This topic consists of the following sub
 </li> <li> <a href="#control_port"> control_port</a>
 </li></ul> 
 </li> <li> <a href="#External_Commands"> External Commands</a> <ul>
-<li> <a href="#on_area_detected"> on_area_detected</a>
-</li> <li> <a href="#on_camera_lost"> on_camera_lost</a>
-</li> <li> <a href="#on_event_end"> on_event_end</a>
+<li> <a href="#on_event_end"> on_event_end</a>
 </li> <li> <a href="#on_event_start"> on_event_start</a>
 </li> <li> <a href="#on_motion_detected"> on_motion_detected</a>
 </li> <li> <a href="#on_movie_end"> on_movie_end</a>
@@ -205,10 +201,10 @@ This topic consists of the following sub
 <p />
 <h1><a name="Motion_Guide_Installation"></a> Motion Guide - Installation </h1>
 <p />
-<h2><a name="Motion_Overview"></a> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionOverview">Motion Overview</a> </h2>
+<h2><a name="Motion_Overview"></a> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionOverview" class="twikiLink">Motion Overview</a> </h2>
 <p />
-<h3><a name="What_is_Motion"></a> What is Motion? </h3>
- Motion is a program that monitors the video signal from one or more cameras and is able to detect if a significant part of the picture has changed. Or in other words, it can detect motion.
+<h3><a name="What_is_Motion"></a><a name="What_is_Motion_"></a> What is Motion? </h3>
+Motion is a program that monitors the video signal from one or more cameras and is able to detect if a significant part of the picture has changed. Or in other words, it can detect motion.
 <p />
 The program is written in C and is made for the Linux operating system.
 <p />
@@ -218,18 +214,18 @@ The output from motion can be:
 <p /> <ul>
 <li> jpg files 
 </li> <li> ppm format files 
-</li> <li> mpeg video sequences 
+</li> <li> mpeg video sequences
 </li></ul> 
 <p />
 <h3><a name="How_do_I_get_Motion_and_what_doe"></a> How do I get Motion and what does it cost? </h3>
- Motion is an open source type of project. It does not cost anything. Motion is published under the <a href="http://www.gnu.org/licenses/gpl.html" rel="nofollow" target="_top">GNU GENERAL PUBLIC LICENSE</a> (GPL) version 2 or later. It may be a bit difficult to understand all the details of the license text (especially if your first language is not English). It means that you can get the program, install it and use it freely. You do not have to pay anything and you do not have to register anywhere or ask the author or publisher for permission. The GPL gives you both rights and some very reasonable duties when it comes to copying, distribution and modification of the program. So in very general terms you do not have to worry about licensing as a normal hobby user. If you want to use Motion in a commercial product, if you want to distribute either modified or original versions of Motion - for free or for a fee, you should read the license carefully. For more information about free software and the GPL, I encourage you to study the very interesting documents about the subject available the of the Free Software Foundation pages about the <a href="http://www.gnu.org/philosophy/philosophy.html" rel="nofollow" target="_top">Philosophy of the GNU Project</a>.
+Motion is an open source type of project. It does not cost anything. Motion is published under the <a href="http://www.gnu.org/licenses/gpl.html" rel="nofollow" target="_top">GNU GENERAL PUBLIC LICENSE</a> (GPL) version 2 or later. It may be a bit difficult to understand all the details of the license text (especially if your first language is not English). It means that you can get the program, install it and use it freely. You do not have to pay anything and you do not have to register anywhere or ask the author or publisher for permission. The GPL gives you both rights and some very reasonable duties when it comes to copying, distribution and modification of the program. So in very general terms you do not have to worry about licensing as a normal hobby user. If you want to use Motion in a commercial product, if you want to distribute either modified or original versions of Motion - for free or for a fee, you should read the license carefully. For more information about free software and the GPL, I encourage you to study the very interesting documents about the subject available the of the Free Software Foundation pages about the <a href="http://www.gnu.org/philosophy/philosophy.html" rel="nofollow" target="_top">Philosophy of the GNU Project</a>.
 <p />
 <h3><a name="Maintenance_and_Support"></a> Maintenance and Support </h3>
- Both Motion and the Motion Guide are written by people that do all this as a hobby and without asking for any payments or donations. We have a life other than developing Motion and its documentation. This means that bugfixes and updates to this guide are done as our time and families allow it. You are however encouraged to participate and contribute in a very active <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MailingList">mailing list</a>. It is a list with a very "positive attitude" and with many contributors that propose features, post patches, discuss problems and patiently answer newbie questions with a very positive spirit. Expect 1-10 emails per day.
+Both Motion and the Motion Guide are written by people that do all this as a hobby and without asking for any payments or donations. We have a life other than developing Motion and its documentation. This means that bugfixes and updates to this guide are done as our time and families allow it. You are however encouraged to participate and contribute in a very active <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/MailingList" class="twikiLink">mailing list</a>. It is a list with a very "positive attitude" and with many contributors that propose features, post patches, discuss problems and patiently answer newbie questions with a very positive spirit. Expect 1-10 emails per day.
 <p />
-To get motion direct your browser to the <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/WebHome" class="foswikiCurrentWebHomeLink">Motion Homepage</a>.
+To get motion direct your browser to the <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/WebHome" class="twikiCurrentWebHomeLink twikiLink">Motion Homepage</a>.
 <p />
-On the <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/DownloadFiles">Download Files</a> page you will find a links to the latest stable version both as sources and binaries for some of the most popular Linux distributions. You will also find links to development versions. Snapshot releases are special test releases that are normally very stable. Every day a <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionDailySourceSnap">Motion Daily Source Snap</a> is created from the <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionSubversion">Motion Subversion</a>
+On the <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/DownloadFiles" class="twikiLink">Download Files</a> page you will find a links to the latest stable version both as sources and binaries for some of the most popular Linux distributions. You will also find links to development versions. Snapshot releases are special test releases that are normally very stable. Every day a <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionDailySourceSnap" class="twikiLink">Motion Daily Source Snap</a> is created from the <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionSubversion" class="twikiLink">Motion Subversion</a> 
 <p />
 Motion was originally written by Jeroen Vreeken who still actively participates in the development of Motion and later Folkert van Heusden continued as a lead programmer with Kenneth Lavrsen responsible for Motion Guide, website and releases on Sourceforge.
 <p />
@@ -238,14 +234,14 @@ From version 3.1.12 Motion is now projec
 For support we encourage you to join the mailing list instead of writing to Jeroen, Folkert or Kenneth directly. We are all very active on the mailing list and by using the mailing list much more users will have benefit of the answers. Newbies and stupid questions are welcome on the list. Contributions in the form of patches are also very welcome on the mailing list.
 <p />
 <h3><a name="Which_version_to_download_and_us"></a> Which version to download and use? </h3>
- Versions 3.2.X are the current version. There is at the moment no development branch. The versions 3.1.X ended at 3.1.20 and there will be no more 3.1.X releases. If you use use a version older than 3.2.X you are encouraged to update.
+Versions 3.2.X are the current version. There is at the moment no development branch. The versions 3.1.X ended at 3.1.20 and there will be no more 3.1.X releases. If you use use a version older than 3.2.X you are encouraged to update.
 <p />
-Since 3.1.13 quite many options have been renamed to make setting up Motion easier. From 3.1.17-18 some unfinished features have been removed. The Berkeley mpeg feature is now removed because the ffmpeg feature is now mature and much better working. At version 3.1.18 a new network camera feature was introduced replacing the old cURL based netcam code and introducing support of mjpeg streaming cameras. However this new code was quite difficult to get stable. During the development of 3.2.2 the network camera code was totally rewritten again learning from our experience and now finally it seems to be stable.
+Since 3.1.13 quite many options have been renamed to make setting up Motion easier. From 3.1.17-18 some unfinished features have been removed. The Berkeley mpeg feature is now removed because the ffmpeg feature is now mature and much better working. At version 3.1.18 a new network camera feature was introduced replacing the old cURL based netcam code and introducing support of mjpeg streaming cameras. However this new code was quite difficult to get stable. During the development of 3.2.2 the network camera code was totally rewritten again learning from our experience and now finally it seems to be stable. 
 <p />
-Motion is included in Debian, while Ubuntu and RPM users can find binary packages on the Motion Sourceforge file download page.
+Since 3.2.3 Debian users can find binary packages on the Motion Sourceforge file download page. You can find Debian versions of Motion in different Debian repositories but they are all out of date and hardly ever get updated.
 <p />
-<h3><a name="What_features_does_Motion_have"></a> What features does Motion have? </h3>
- See more description at the <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/WebHome" class="foswikiCurrentWebHomeLink">Motion Homepage</a>.  <ul>
+<h3><a name="What_features_does_Motion_have"></a><a name="What_features_does_Motion_have_"></a> What features does Motion have? </h3>
+See more description at the <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/WebHome" class="twikiCurrentWebHomeLink twikiLink">Motion Homepage</a>. <ul>
 <li> Taking snapshots of movement 
 </li> <li> Watch multiple video devices at the same time 
 </li> <li> Watch multiple inputs on one capture card at the same time 
@@ -253,63 +249,65 @@ Motion is included in Debian, while Ubun
 </li> <li> Real time creation of mpeg movies using libraries from ffmpeg 
 </li> <li> Take automated snapshots on regular intervals 
 </li> <li> Take automated snapshots at irregular intervals using cron 
-</li> <li> Executing external program when detecting movement 
-</li> <li> Execute external program at the beginning of an event of several motion detections. 
+</li> <li> Executing external program when detecting movement
+</li> <li> Execute external program at the beginning of an event of several motion detections.
 </li> <li> Execute external program at the end of an event of several motion detections. 
-</li> <li> Execute external program when a picture is saved. 
-</li> <li> Execute external program when a movie mpeg is created (opened) 
+</li> <li> Execute external program when a picture is saved.
+</li> <li> Execute external program when a movie mpeg is created (opened)
 </li> <li> Execite external program when a movie mpeg ends (closed) 
 </li> <li> Motion tracking 
 </li> <li> Feed events to an MySQL or PostgreSQL database. 
 </li> <li> Feed video back to a video4linux loopback for real time viewing 
-</li> <li> Web interface using <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/RelatedProjects">Motion Related Projects</a> such as <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionCGI">motion.cgi</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/KennethsWebcamPackage">Kenneths Webcam Package</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/KevinsWebpage">Kevins Webpage</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/XMotionTool">X-Motion</a> and many more. 
-</li> <li> User configurable and user defined on screen display. 
-</li> <li> Control via simple web interface. 
-</li> <li> Automatic noise and threshold control 
-</li> <li> Ability to control the pan/tilt of a Logitech Sphere (or Orbit) camera 
-</li> <li> Highly configurable display of text on images. 
-</li> <li> High configurable definition of path and file names of the stored images and films. 
+</li> <li> Web interface using <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/RelatedProjects" class="twikiLink">Motion Related Projects</a> such as <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionCGI" class="twikiLink">motion.cgi</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/KennethsWebcamPackage" class="twikiLink">Kenneths Webcam Package</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/KevinsWebpage" class="twikiLink">Kevins Webpage</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/XMotionTool" class="twikiLink">X-Motion</a> and many more.
+</li> <li> User configurable and user defined on screen display.
+</li> <li> Control via simple web interface.
+</li> <li> Automatic noise and threshold control
+</li> <li> Ability to control the pan/tilt of a Logitech Sphere (or Orbit) camera
+</li> <li> Highly configurable display of text on images.
+</li> <li> High configurable definition of path and file names of the stored images and films.
 </li></ul> 
 <p />
-You can find more information and links at the <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/WebHome" target="_top">Motion Homepage</a>.
+You can find more information and links at the <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/WebHome" target="_top">Motion Homepage</a>.
 <p />
-<h3><a name="FreeBSD"></a> FreeBSD </h3>
+<h3><a name="FreeBSD"></a><a name="_FreeBSD"></a> FreeBSD </h3>
 <p />
-Motion is originally developed for Linux and it is still mainly developed and supported for this platform. From version 3.1.15 an experimental port has been made by Angel Carpintero. Not all features of Motion are supported at this time and it still needs a lot of test time on different hardware. Angel is very interested in feedback. Join the Motion Mailing List and give your feedback there. Patches for bugfixes and for enabling the missing features are very welcome. The rest of this guide is still mainly targeted for Linux users. Follow this topic to <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/FreeBSD" target="_top">Install FreeBSD</a>.
+Motion is originally developed for Linux and it is still mainly developed and supported for this platform. From version 3.1.15 an experimental port has been made by Angel Carpintero. Not all features of Motion are supported at this time and it still needs a lot of test time on different hardware. Angel is very interested in feedback. Join the Motion Mailing List and give your feedback there. Patches for bugfixes and for enabling the missing features are very welcome. The rest of this guide is still mainly targeted for Linux users. Follow this topic to <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/FreeBSD" target="_top">Install FreeBSD</a>.
 <p />
-<h3><a name="MacOSX"></a> MacOSX </h3>
+<h3><a name="MacOSX"></a><a name="_MacOSX"></a> MacOSX </h3>
 <p />
-From Motion version 3.2.4 it is now also possible to build and install Motion under <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MacOSX">MacOSX</a>. Feature set it the same as for FreeBSD. See the <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MacOSX">MacOSX</a> topic for specific help how to install Motion and its dependencies on <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MacOSX">MacOSX</a>. Again this port has been contributed by Angel Carpintero.
+From Motion version 3.2.4 it is now also possible to build and install Motion under <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/MacOSX" class="twikiLink">MacOSX</a>. Feature set it the same as for FreeBSD. See the <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/MacOSX" class="twikiLink">MacOSX</a> topic for specific help how to install Motion and its dependencies on <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/MacOSX" class="twikiLink">MacOSX</a>. Again this port has been contributed by Angel Carpintero.
 <p />
 <h3><a name="Documentation"></a> Documentation </h3>
- You have the following sources of information:
+You have the following sources of information:
 <p /> <ul>
-<li> This <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuide">Motion Guide</a>. 
-</li> <li> The <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/FrequentlyAskedQuestions">Frequently Asked Questions</a> 
-</li> <li> The author of the program has written a description of the <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionTechnology">technology behind motion</a>. 
-</li> <li> The man page. After installation simply write man motion 
-</li> <li> The default motion.conf file (motion-dist.conf) that comes with the package. 
+<li> This <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuide" class="twikiLink">Motion Guide</a>.
+</li> <li> The <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/FrequentlyAskedQuestions" class="twikiLink">Frequently Asked Questions</a>
+</li> <li> The author of the program has written a description of the <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionTechnology" class="twikiLink">technology behind motion</a>.
+</li> <li> The man page. After installation simply write man motion
+</li> <li> The default motion.conf file (motion-dist.conf) that comes with the package.
 </li></ul> 
 <p />
 <h3><a name="Supported_Hardware"></a> Supported Hardware </h3>
- Input devices: Here we are thinking about the cameras.
+Input devices: Here we are thinking about the cameras.
 <p />
 Motion supports video input from two kinds of sources.
 <p />
 Standard video4linux devices (e.g. /dev/video0). Motion has no drivers for cameras. Installing the camera itself is outside the scope of this document. But here are some nice links. <ul>
-<li> <a href="http://www.saillard.org/pwc/" rel="nofollow" target="_top">Driver for USB Philips cameras (and more)</a> This driver is a fork of the old pcw(x) driver which got kicked out of the kernel. (see: <a href="http://www.smcc.demon.nl/webcam/" rel="nofollow" target="_top">http://www.smcc.demon.nl/webcam/</a>). See also the new <a href="http://www.lavrsen.dk/foswiki/bin/view/PWC/WebHome">PWC Documentation Site</a> which is hosted in this wiki. 
-</li> <li> <a href="http://bytesex.org/bttv/index.html" rel="nofollow" target="_top">BTTV Driver</a> (capture cards). Part of many distributions now. 
-</li> <li> <a href="http://alpha.dyndns.org/ov511/" rel="nofollow" target="_top">OV511</a> based USB cameras are supported as standard by newer Kernels. 
-</li> <li> <a href="http://spca50x.sourceforge.net/spca50x.php" rel="nofollow" target="_top">kernel driver for USB cameras based on Sunplus spca50</a> 
-</li> <li> <a href="http://rivatv.sourceforge.net/" rel="nofollow" target="_top">rivatv.sourceforge.net</a> Driver for tv/composite/svideo input with most Nvidia based video cards. Network cameras (which are actually cameras with a built in web server that can be connected directory to your network). 
-</li> <li> <a href="http://www.axis.com/" rel="nofollow" target="_top">Axis Communications</a> 
+<li> <a href="http://www.saillard.org/pwc/" rel="nofollow" target="_top">Driver for USB Philips cameras (and more)</a> This driver is a fork of the old pcw(x) driver which got kicked out of the kernel. (see: <a href="http://www.smcc.demon.nl/webcam/" rel="nofollow" target="_top">http://www.smcc.demon.nl/webcam/</a>). See also the new <a href="http://www.lavrsen.dk/twiki/bin/view/PWC/WebHome" class="twikiLink">PWC Documentation Site</a> which is hosted in this wiki.
+</li> <li> <a href="http://bytesex.org/bttv/index.html" rel="nofollow" target="_top">BTTV Driver</a> (capture cards). Part of many distributions now.
+</li> <li> <a href="http://alpha.dyndns.org/ov511/" rel="nofollow" target="_top">OV511</a> based USB cameras are supported as standard by newer Kernels.
+</li> <li> <a href="http://spca50x.sourceforge.net/spca50x.php" rel="nofollow" target="_top">kernel driver for USB cameras based on Sunplus spca50</a>
+</li> <li> <a href="http://rivatv.sourceforge.net/" rel="nofollow" target="_top">rivatv.sourceforge.net</a> Driver for tv/composite/svideo input with most Nvidia based video cards.
+</li></ul> 
+Network cameras (which are actually cameras with a built in web server that can be connected directory to your network). <ul>
+<li> <a href="http://www.axis.com/" rel="nofollow" target="_top">Axis Communications</a>
 </li></ul> 
 <p />
 <p />
-<h2><a name="Known_Problems"></a> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/KnownProblems">Known Problems</a> </h2>
-See also the <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/FrequentlyAskedQuestions">Frequently Asked Questions</a> and <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReports">Bug Reports</a> for known open bugs.
+<h2><a name="Known_Problems"></a> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/KnownProblems" class="twikiLink">Known Problems</a> </h2>
+See also the <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/FrequentlyAskedQuestions" class="twikiLink">Frequently Asked Questions</a> and <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/BugReports" class="twikiLink">Bug Reports</a> for known open bugs.
 <p />
-<strong>Kernel 2.6 and pwc.</strong> Note that for kernel 2.6 there is a new release of the Philips WebCam (pwc) drivers 10.0.X. It is recommended to install this. At the time of this being written the 2.6.12+ kernels have a version of pwc built-in but it is a cripled version which can only support very small picture size. You can however download the latest source code of the pwc driver (at this time 10.0.11) and build it without having to rebuild your kernel. But you will need to have either the kernel sources or a special kernel-header package installed to compile it. See <a href="http://www.lavrsen.dk/foswiki/bin/view/PWC/InstallationOfPWC">Installation of PWC</a> page which is also hosted in this wiki.
+<strong>Kernel 2.6 and pwc.</strong> Note that for kernel 2.6 there is a new release of the Philips WebCam (pwc) drivers 10.0.X. It is recommended to install this. At the time of this being written the 2.6.12+ kernels have a version of pwc built-in but it is a cripled version which can only support very small picture size. You can however download the latest source code of the pwc driver (at this time 10.0.11) and build it without having to rebuild your kernel. But you will need to have either the kernel sources or a special kernel-header package installed to compile it. See <a href="http://www.lavrsen.dk/twiki/bin/view/PWC/InstallationOfPWC" class="twikiLink">Installation of PWC</a> page which is also hosted in this wiki.
 <p />
 If you use use a <strong>Logitech Quickcam Orbit or Sphere</strong> using the driver pwc/pwcx and kernel 2.6.X you should replace the file in the Motion sources called pwc-ioctl.h with the one that comes with the your pwc version. Motion is shipped with 3 versions of pwc-ioctl.h-VERSION. Rename the one that fits your major pwc version number best to pwc-ioctl.h (after renaming the current to something else). There has been some small adjustments in the API that requires that you have the right header file.
 <p />
@@ -323,8 +321,7 @@ The 3.2.5 release contains a motion_guid
 A bug in 3.2.5 and 3.2.5.1 where a bugfix related to snapshot feature has created a new bug when you compile Motion without ffmpeg libs installed. This is fixed in 3.2.6.
 <p />
 <p />
-<p />
-<h2><a name="How_do_I_install_Motion"></a> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/InstallOverview">How do I install Motion</a>? </h2>
+<h2><a name="How_do_I_install_Motion"></a><a name="How_do_I_install_Motion_"></a> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/InstallOverview" class="twikiLink">How do I install Motion</a>? </h2>
 Motion is mainly distributed as source files that you must compile yourself. There is also an RPM made on Fedora Core 3. And Debian packages are available for selected versions.
 <p />
 The short overview of the steps to install Motion from sources. <ul>
@@ -389,60 +386,28 @@ motion
 </UL>
 <p />
 <p />
-<h2><a name="Preparation_For_Install"></a> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/PrepareInstall">Preparation For Install</a> </h2>
+<h2><a name="Preparation_For_Install"></a> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/PrepareInstall" class="twikiLink">Preparation For Install</a> </h2>
 <p />
-Note: If you're using SuSE 9.2, you might want to <strong>ADDITIONALLY</strong> have a look at <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/SuSE92Prep">Compiling on SuSE 9.2</a>. As mentioned on that page as well, <em>you will still need to read the instructions here as well</em>.
+Note: If you're using SuSE 9.2, you might want to <strong>ADDITIONALLY</strong> have a look at <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/SuSE92Prep" class="twikiLink">Compiling on SuSE 9.2</a>. As mentioned on that page as well, <em>you will still need to read the instructions here as well</em>.
 <p />
 Before you start you may need to install a number of shared libraries that Motion uses. If they are missing the feature will simply normally not be included. Most of these libraries can be found on the CDs of your distribution. A few will have to be downloaded from the Internet. Note that when you install software using pre-compiled binaries (Redhat type RPMs, Debian debs etc) you normally only get what is needed to run the programs themselves. In order to compile other programs from source that uses these pre-compiled libraries you also need to installed the development packages. These are normally called the same name as the package suffixed by -devel or -dev. These development packages contains the header files (xxx.h) that Motion needs to build with the shared libraries. If you build a library from sources you already have these header files. It is recommended to simply install the pre-compiled binary packages and their development brothers.
 <p />
 This is a list of shared libraries used by Motion and the RPM packages that provides them.
 <p />
 Motion will always need these libraries to be built and work 
-<table cellspacing="0" id="table1" cellpadding="0" class="foswikiTable" rules="rows" border="1">
-	<thead>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<th bgcolor="#687684" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a rel="nofollow" href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument;sortcol=0;table=1;up=0#sorted_table" title="Sort by this column"><font color="#ffffff">Library</font></a> </th>
-			<th bgcolor="#687684" valign="top" class="foswikiTableCol1"> <a rel="nofollow" href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument;sortcol=1;table=1;up=0#sorted_table" title="Sort by this column"><font color="#ffffff">RPM Packages</font></a> </th>
-			<th bgcolor="#687684" valign="top" class="foswikiTableCol2 foswikiLastCol"> <a rel="nofollow" href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument;sortcol=2;table=1;up=0#sorted_table" title="Sort by this column"><font color="#ffffff">Debian Packages</font></a> </th>
-		</tr>
-	</thead>
-	<tbody>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> libm, libresolv, libdl, libpthread, libc, ld-linux, libcrypt, and libnsl </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> glibc and glibc-devel </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> libc6 , libc6-dev ,libglib1.2 </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> libjpeg </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> libjpeg and libjpeg-devel </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> libjpeg62 and libjpeg62-dev ( optional libjpeg-mmx-dev ) </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol foswikiLast"> libz </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol1 foswikiLast"> zlib and zlib-devel </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol foswikiLast"> zlib1g and zlib1g-dev </td>
-		</tr>
-	</tbody></table>
+<table style="border-width:1px;" cellspacing="0" cellpadding="0" class="twikiTable" border="1"><tr class="twikiTableEven"><th bgcolor="#6b7f93" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol" maxcols="0"> <a rel="nofollow" href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideOneLargeDocument&amp;amp;sortcol=0;table=1;up=0#sorted_table" style="color:#ffffff" title="Sort by this column">Library</a> </th><th bgcolor="#6b7f93" align="center" valign="top" style="text-align:center;vertical-align:top;" maxcols="0"> <a rel="nofollow" href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideOneLargeDocument&amp;amp;sortcol=1;table=1;up=0#sorted_table" style="color:#ffffff" title="Sort by this column">RPM Packages</a> </th><th bgcolor="#6b7f93" align="center" valign="top" style="text-align:center;vertical-align:top;" maxcols="0"> <a rel="nofollow" href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideOneLargeDocument&amp;amp;sortcol=2;table=1;up=0#sorted_table" style="color:#ffffff" title="Sort by this column">Debian Packages</a> </th></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> libm, libresolv, libdl, libpthread, libc, ld-linux, libcrypt, and libnsl </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> glibc and glibc-devel </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> libc6 , libc6-dev ,libglib1.2 </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> libjpeg </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> libjpeg and libjpeg-devel </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> libjpeg62 and libjpeg62-dev ( optional libjpeg-mmx-dev ) </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol twikiLast"> libz </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiLast"> zlib and zlib-devel </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiLast"> zlib1g and zlib1g-dev </td></tr>
+</table>
 <p />
 For generating mpeg films with <strong>ffmpeg</strong> you need this library:<br>
-(See also the section <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MpegFilmsFFmpeg">Generating MPEG films with ffmpeg</a> for how to install ffmpeg and libavformat/libavcodec)<br>
+(See also the section <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/MpegFilmsFFmpeg" class="twikiLink">Generating MPEG films with ffmpeg</a> for how to install ffmpeg and libavformat/libavcodec)<br>
 <em>Motion must be installed with revision 0.4.8 or 0.4.9pre1 of ffmpeg. Motion will also work with later CVS snapshots of ffmpeg but the API of the ffmpeg libraries changes all the time and without warning. If you have problems compiling Motion or with running an RPM of Motion you may try with an older CVS snapshot of ffmpeg. The Motion developers will like to know when ffmpeg changes and breaks Motion so we can fix it. Please file a bug report then with the exact date of the ffmpeg CVS version you have trouble with.</em>
 <p />
-<table cellspacing="0" id="table2" cellpadding="0" class="foswikiTable" rules="rows" border="1">
-	<thead>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<th bgcolor="#687684" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a rel="nofollow" href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument;sortcol=0;table=2;up=0#sorted_table" title="Sort by this column"><font color="#ffffff">Library</font></a> </th>
-			<th bgcolor="#687684" valign="top" class="foswikiTableCol1"> <a rel="nofollow" href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument;sortcol=1;table=2;up=0#sorted_table" title="Sort by this column"><font color="#ffffff">RPM Packages</font></a> </th>
-			<th bgcolor="#687684" valign="top" class="foswikiTableCol2 foswikiLastCol"> <a rel="nofollow" href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument;sortcol=2;table=2;up=0#sorted_table" title="Sort by this column"><font color="#ffffff">Debian Packages</font></a> </th>
-		</tr>
-	</thead>
-	<tbody>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol foswikiLast"> libavcodec, libavformat </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol1 foswikiLast"> ffmpeg and ffmpeg-devel or install from source </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol foswikiLast"> libavcodec-dev  libavcodec0d libavformat-dev libavformat0d (*) </td>
-		</tr>
-	</tbody></table>
+<table style="border-width:1px;" cellspacing="0" cellpadding="0" class="twikiTable" border="1"><tr class="twikiTableEven"><th bgcolor="#6b7f93" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol" maxcols="0"> <a rel="nofollow" href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideOneLargeDocument&amp;amp;sortcol=0;table=2;up=0#sorted_table" style="color:#ffffff" title="Sort by this column">Library</a> </th><th bgcolor="#6b7f93" align="center" valign="top" style="text-align:center;vertical-align:top;" maxcols="0"> <a rel="nofollow" href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideOneLargeDocument&amp;amp;sortcol=1;table=2;up=0#sorted_table" style="color:#ffffff" title="Sort by this column">RPM Packages</a> </th><th bgcolor="#6b7f93" align="center" valign="top" style="text-align:center;vertical-align:top;" maxcols="0"> <a rel="nofollow" href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideOneLargeDocument&amp;amp;sortcol=2;table=2;up=0#sorted_table" style="color:#ffffff" title="Sort by this column">Debian Packages</a> </th></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol twikiLast"> libavcodec, libavformat </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiLast"> ffmpeg and ffmpeg-devel or install from source </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiLast"> libavcodec-dev  libavcodec0d libavformat-dev libavformat0d (*) </td></tr>
+</table>
 <p />
 <strong>Debian</strong> has not provided deb packages for ffmpeg due patent issues. However this is about to change so checkout for availability of newer versions of debian ffmpeg debs. You can build yourself from source or from <a href="http://debian-multimedia.org/" rel="nofollow" target="_top">Christian Marillat website</a> or apt repository. 
 <pre>
@@ -457,41 +422,17 @@ apt-get update ; apt-get -y install liba
 </pre>
 <p />
 For logging in <strong>MySQL</strong> you need this library:
-<table cellspacing="0" id="table3" cellpadding="0" class="foswikiTable" rules="rows" border="1">
-	<thead>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<th bgcolor="#687684" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a rel="nofollow" href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument;sortcol=0;table=3;up=0#sorted_table" title="Sort by this column"><font color="#ffffff">Library</font></a> </th>
-			<th bgcolor="#687684" valign="top" class="foswikiTableCol1"> <a rel="nofollow" href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument;sortcol=1;table=3;up=0#sorted_table" title="Sort by this column"><font color="#ffffff">RPM Packages</font></a> </th>
-			<th bgcolor="#687684" valign="top" class="foswikiTableCol2 foswikiLastCol"> <a rel="nofollow" href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument;sortcol=2;table=3;up=0#sorted_table" title="Sort by this column"><font color="#ffffff">Debian Packages</font></a> </th>
-		</tr>
-	</thead>
-	<tbody>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol foswikiLast"> libmysqlclient </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol1 foswikiLast"> mysql and mysql-devel </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol foswikiLast"> libmysqlclient15-off and libmysqlclient15-dev </td>
-		</tr>
-	</tbody></table>
+<table style="border-width:1px;" cellspacing="0" cellpadding="0" class="twikiTable" border="1"><tr class="twikiTableEven"><th bgcolor="#6b7f93" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol" maxcols="0"> <a rel="nofollow" href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideOneLargeDocument&amp;amp;sortcol=0;table=3;up=0#sorted_table" style="color:#ffffff" title="Sort by this column">Library</a> </th><th bgcolor="#6b7f93" align="center" valign="top" style="text-align:center;vertical-align:top;" maxcols="0"> <a rel="nofollow" href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideOneLargeDocument&amp;amp;sortcol=1;table=3;up=0#sorted_table" style="color:#ffffff" title="Sort by this column">RPM Packages</a> </th><th bgcolor="#6b7f93" align="center" valign="top" style="text-align:center;vertical-align:top;" maxcols="0"> <a rel="nofollow" href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideOneLargeDocument&amp;amp;sortcol=2;table=3;up=0#sorted_table" style="color:#ffffff" title="Sort by this column">Debian Packages</a> </th></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol twikiLast"> libmysqlclient </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiLast"> mysql and mysql-devel </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiLast"> libmysqlclient15-off and libmysqlclient15-dev </td></tr>
+</table>
 <p />
 For logging in <strong>PostgreSQL</strong> you need this library:
-<table cellspacing="0" id="table4" cellpadding="0" class="foswikiTable" rules="rows" border="1">
-	<thead>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<th bgcolor="#687684" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a rel="nofollow" href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument;sortcol=0;table=4;up=0#sorted_table" title="Sort by this column"><font color="#ffffff">Library</font></a> </th>
-			<th bgcolor="#687684" valign="top" class="foswikiTableCol1"> <a rel="nofollow" href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument;sortcol=1;table=4;up=0#sorted_table" title="Sort by this column"><font color="#ffffff">RPM Packages</font></a> </th>
-			<th bgcolor="#687684" valign="top" class="foswikiTableCol2 foswikiLastCol"> <a rel="nofollow" href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument;sortcol=2;table=4;up=0#sorted_table" title="Sort by this column"><font color="#ffffff">Debian Packages</font></a> </th>
-		</tr>
-	</thead>
-	<tbody>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol foswikiLast"> libpq </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol1 foswikiLast"> postgresql-libs and postgresql-devel </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol foswikiLast"> libpq-dev and libpq4 </td>
-		</tr>
-	</tbody></table>
+<table style="border-width:1px;" cellspacing="0" cellpadding="0" class="twikiTable" border="1"><tr class="twikiTableEven"><th bgcolor="#6b7f93" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol" maxcols="0"> <a rel="nofollow" href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideOneLargeDocument&amp;amp;sortcol=0;table=4;up=0#sorted_table" style="color:#ffffff" title="Sort by this column">Library</a> </th><th bgcolor="#6b7f93" align="center" valign="top" style="text-align:center;vertical-align:top;" maxcols="0"> <a rel="nofollow" href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideOneLargeDocument&amp;amp;sortcol=1;table=4;up=0#sorted_table" style="color:#ffffff" title="Sort by this column">RPM Packages</a> </th><th bgcolor="#6b7f93" align="center" valign="top" style="text-align:center;vertical-align:top;" maxcols="0"> <a rel="nofollow" href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideOneLargeDocument&amp;amp;sortcol=2;table=4;up=0#sorted_table" style="color:#ffffff" title="Sort by this column">Debian Packages</a> </th></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol twikiLast"> libpq </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiLast"> postgresql-libs and postgresql-devel </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiLast"> libpq-dev and libpq4 </td></tr>
+</table>
 <p />
 <p />
-<h2><a name="Configure_Script"></a> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigureScript">Configure Script</a> </h2>
+<h2><a name="Configure_Script"></a> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigureScript" class="twikiLink">Configure Script</a> </h2>
 Configure is script that you run to setup the build environment for the C-compiler. It generates the "Makefile" which the program "make" uses to compile and install the software.
 <p />
 To run configure your current directory must be the motion directory. You type
@@ -503,238 +444,61 @@ You can add the parameter <code>./config
 This is walk through of the options.
 <p />
  
-<div class="editTable">
-<form name="edittable1_Motion_MotionGuideOneLargeDocument" action="http://www.lavrsen.dk/foswiki/bin/viewauth/Motion/ConfigureScript#edittable1" method="post" onsubmit="foswikiStrikeOne(this)"><input type='hidden' name='validation_key' value='?fd8fc4e77a93cc2c570a08a93d66e7dd' />
+<a name="edittable1"></a>
+<div class="editTable"><form name="edittable1" action="http://www.lavrsen.dk/twiki/bin/viewauth/Motion/ConfigureScript#edittable1" method="post">
 <input type="hidden" name="ettablenr" value="1" />
 <input type="hidden" name="etedit" value="on" />
-<table cellspacing="0" id="table5" cellpadding="0" class="foswikiTable" rules="rows" border="1">
-	<thead>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<th width="160" bgcolor="#687684" align="left" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <font color="#ffffff">Option</font> </th>
-			<th bgcolor="#687684" align="left" valign="top" class="foswikiTableCol1"> <font color="#ffffff">Description <br /> Defaults for the options <br /> are specified in brackets [ ]</font> </th>
-			<th bgcolor="#687684" align="left" valign="top" class="foswikiTableCol2 foswikiLastCol"> <font color="#ffffff">Editors comment</font> </th>
-		</tr>
-	</thead>
-	<tbody>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="160" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> -h, --help </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> display this help and exit </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="160" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> --help=short </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> display options specific to this package </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> This command shows the options special to motion. Recommended </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="160" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> --help=recursive </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> display the short help of all the included packages </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="160" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> -V, --version </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> display version information and exit </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Gives no useful information </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="160" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> -q, --quiet, --silent </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> do not print `checking...' messages </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Not very useful. Output to screen is only a few lines anyway. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="160" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> --cache-file=FILE </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> cache test results in FILE. [disabled] </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> No function </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="160" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> -C, --config-cach </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> alias for `--cache-file=config.cache' </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> No function </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="160" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> -n, --no-create </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> do not create output files </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Used for testing if other switches produce error - without writing anything to the disk </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="160" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> --srcdir=DIR </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> find the sources in DIR. [configure dir or `..'] </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> DIR is a directory path. Editor recommends having the current directory being the motion installation directory and not using this switch. Then it defaults to the same directory as where the configure script is which is the current directory. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<th width="160" bgcolor="#687684" align="left" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <font color="#ffffff">Installation directories:</font> </th>
-			<th bgcolor="#687684" align="left" valign="top" class="foswikiTableCol1"> <font color="#ffffff">&nbsp;</font> </th>
-			<th bgcolor="#687684" align="left" valign="top" class="foswikiTableCol2 foswikiLastCol"> <font color="#ffffff">&nbsp;</font> </th>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="160" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> --prefix=PREFIX </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> install architecture-independent files in PREFIX <br /> [/usr/local] </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> The default /usr/local means that the executable binary "motion" is installed in /usr/local/bin, the manual page in /usr/local/man/man1, the document files in /usr/local/docs/motion-version, configuration file in /usr/local/etc, and some examples config files in /usr/local/examples/motion-versionEditor recommends keeping this default setting. <br /> If you are experimenting with many parallel versions it may be interesting to set the PREFIX to e.g. /usr/local/motion and then add /usr/local/motion/bin to your search path (or simply cd /usr/local/motion/bin before execution). <br /> This way you can change version just by changing the symbolic link in /usr/local/motion as suggested earlier in this guide. <br /> If you are installing the software on a machine where you have no access to the /usr/local but have write access to a home directory, then you should change this to point to a directory within your home tree. <br /> Example: --prefix=$HOME </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="160" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> --exec-prefix=EPREFIX </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> install architecture-dependent files in EPREFIX <br /> [PREFIX] </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> If you set this it only defines an alternative installation directory for the executable binary. <br /> Note: The executable binary will be placed in a directory "bin" below the directory specified by this option <br /> Editor recommends leaving this as default (i.e. not setting it). </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="160" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> --bindir=DIR </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> user executables [EPREFIX/bin] </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> With this option you can control exactly in which directory the executable binary is installed. The previous option automatically adds the bin directory. Here you are in fill control. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="160" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> --sbindir=DIR </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> System admin executables [EPREFIX/sbin] </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Not used by motion. Ignore it. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="160" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> --libexecdir=DIR </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> program executables [EPREFIX/libexec] </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Not used by motion. Ignore it. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="160" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> --datadir=DIR </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> read-only architecture-independent data [PREFIX/share] </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Not used by motion. Ignore it. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="160" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> --sysconfdir=DIR </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> read-only single-machine data [PREFIX/etc] </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> This is where motion both installs the default configuration file and also where it later searches for it. <br /> Motion searches for the configuration file "motion.conf" in the following order: <br /> <UL> <br /> 1. Current directory from where motion was invoked <br /> 2. $HOME/.motion <br /> 3. The sysconfig directory set by this switch. If not defined the default is /usr/local/etc/ <br /> </UL> <br /> Editor recommends leaving this at default. Be careful if you run "make install" again. This will overwrite the motion.conf file that you have edited and experimented with for hours. Make sure to keep a copy in a safe place. Alternatively, copy the working file to the motion base install directory. Then make install will simply copy the same file back again. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="160" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> --sharedstatedir=DIR </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> modifiable architecture-independent data [PREFIX/com] </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Not used by motion. Ignore it. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="160" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> --localstatedir=DIR </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> modifiable single-machine data [PREFIX/var] </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Not used by motion. Ignore it. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="160" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> --libdir=DIR </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> object code libraries [EPREFIX/lib] </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Not used by motion. Ignore it. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="160" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> --includedir=DIR </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> C header files [PREFIX/include] </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Not used by motion. Ignore it. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="160" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> --oldincludedir=DIR </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> C header files for non-gcc [/usr/include] </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Not used by motion. Ignore it. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="160" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> --infodir=DIR </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> info documentation [PREFIX/info] </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Not used by motion. Ignore it. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="160" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> --mandir=DIR </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> man documentation [PREFIX/man] </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Editor recommends the default. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<th width="160" bgcolor="#687684" align="left" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <font color="#ffffff">Optional Packages:</font> </th>
-			<th bgcolor="#687684" align="left" valign="top" class="foswikiTableCol1"> <font color="#ffffff">&nbsp;</font> </th>
-			<th bgcolor="#687684" align="left" valign="top" class="foswikiTableCol2 foswikiLastCol"> <font color="#ffffff">&nbsp;</font> </th>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="160" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> --with-linuxthreads </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Use linuxthreads in BSD instead of native phtreads </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Only relevant for BSD. In Linux we always use this per default. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="160" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> --with-pwcbsd </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Use pwcbsd based webcams ( only BSD ) </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> This option allow to build motion to support <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/V4L">V4L</a>/V4L2 in BSD. <br /> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/HowtoMotionPwcFreeBSD">HowtoMotionPwcFreeBSD</a> </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="160" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> --without-bktr </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Exclude to use bktr subsystem , that usually useful for devices as network cameras </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> ONLY used in *BSD </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="160" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> --without-v4l </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Exclude using v4l (video4linux) subsystem. Makes Motion so it only supports network cameras. </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Can be used if you do not need <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/V4L">V4L</a> support and maybe lack some of the libraries for it. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="160" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> --with-jpeg-mmx=DIR </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Specify the prefix for the install path for jpeg-mmx for optimized jpeg handling (optional). If this is not specified motion will try to find the library /usr/lib/libjpeg-mmx.a /usr/local/lib/libjpeg-mmx.a. </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Considered experimental </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="160" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> --with-ffmpeg=DIR </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Specify the path for the directory prefix in which the library and headers are installed. <br /> If not specified configure will search in /usr/ and /usr/local/ </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> DIR is the directory PREFIX in which the ffmpeg shared libraries and their headers are installed. <br /> If you install ffmpeg from sources and use the default directories or if ffmpeg is installed as a binary package (RPM or deb) you do not need to specify the directory prefix. Configure will find the libraries automatically. If you installed ffmpeg from sources and specified a different --prefix when building ffmpeg you must use the same value for the DIR ( --with-ffmpeg=DIR). <br /> For more information on FFmpeg see the <a href="http://ffmpeg.sourceforge.net/" rel="nofollow" target="_top">FFmpeg project home page</a>. <br /> FFmpeg is a package that enables streamed video mpeg signal from your web camera to a browser. <br /> Editor recommends installing ffmpeg from source and in the directory /usr/local/ffmpeg and build ffmpeg with ./configure --enable-shared. <br /> This places libraries in /usr/local/lib and headers in /usr/local/include. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="160" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> --without-ffmpeg </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Do not compile with ffmpeg </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Use this if you do not want to compile with ffmpeg. If ffmpeg is not installed you do not need to specify that Motion must build without ffmpeg. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="160" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> --with-mysql-lib=DIR </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Lib directory of MySQL </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Normally, configure will scan all possible default installation paths for MySQL libs. When its fail, use this command to tell configure where MySQL libs installation root directory is. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="160" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> --with-mysql-include=DIR </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Include directory with headers for MySQL </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Normally, configure will scan all possible default                          installation paths for MySQL include. When its fail, use this command to tell configure where MySQL include installation directory is. This is the directory with the MySQL header files. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="160" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> --without-mysql </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Do not compile with MySQL support </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Use this if you do not want to include MySQL support in the package. <br /> This can also be useful if you get compilation errors related to MySQL and you actually do not need the feature anyway. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="160" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> --without-pgsql </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Do not compile with PostgreSQL support </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Use this if you do not want to include PostgreSQL support in the package. <br /> This can also be useful if you get compilation errors related to PostgreSQL and you actually do not need the feature anyway. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="160" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> --with-pgsql-include=DIR </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Normally, configure will scan all possible default installation paths for pgsql include. When it fails, use this command to tell configure where pgsql include installation root directory is. </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="160" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> --with-pgsql-lib=DIR </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Normally, configure will scan all possible default installation paths for pgsql libs. When it fails, use <br /> this command to tell configure where pgsql libs installation root directory is. </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="160" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> --without-optimizecpu </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Exclude autodetecting platform and cpu type. This will disable the compilation of gcc optimizing code by platform and cpu. </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Use this if the optimization causes problems. Typically if you build on some non X386 compatible CPU. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<th width="160" bgcolor="#687684" align="left" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <font color="#ffffff">Developers options</font> </th>
-			<th bgcolor="#687684" align="left" valign="top" class="foswikiTableCol1"> <font color="#ffffff">&nbsp;</font> </th>
-			<th bgcolor="#687684" align="left" valign="top" class="foswikiTableCol2 foswikiLastCol"> <font color="#ffffff">&nbsp;</font> </th>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="160" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol foswikiLast"> --with-developer-flags </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol1 foswikiLast"> Add additional warning flags for the compiler. </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol foswikiLast"> This option is for developers only. It produces a flood of warnings that helps the developer to write more robust code. These warnings are normally harmless but can sometimes be a latent defect. <br /> For more information about these flags, see <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/CompileWithDeveloperFlags">CompileWithDeveloperFlags</a> </td>
-		</tr>
-	</tbody></table>
-<input type="hidden" name="ettablechanges" value="" />
-<input type="hidden" name="etheaderrows" value="0" />
-<input type="hidden" name="etfooterrows" value="0" />
-<input class="editTableEditImageButton" type="image" src="http://www.lavrsen.dk/foswiki/pub/System/EditTablePlugin/edittable.gif" alt="Edit this table" /> </form>
+<table style="border-width:1px;" cellspacing="0" cellpadding="0" class="twikiTable" border="1"><tr class="twikiTableEven"><th width="160" bgcolor="#6b7f93" align="left" valign="top" style="width:160;text-align:left;vertical-align:top;" class="twikiFirstCol" maxcols="0"> <span style="color:#ffffff"> <strong> Option </strong> </span> </th><th bgcolor="#6b7f93" align="left" valign="top" style="text-align:left;vertical-align:top;" maxcols="0"> <span style="color:#ffffff"> <strong> Description<br />Defaults for the options<br /> are specified in brackets [ ] </strong> </span> </th><th bgcolor="#6b7f93" align="left" valign="top" style="text-align:left;vertical-align:top;" maxcols="0"> <span style="color:#ffffff"> <strong> Editors comment </strong> </span> </th></tr>
+<tr class="twikiTableOdd"><td width="160" bgcolor="#ffffff" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> -h, --help </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> display this help and exit </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> &nbsp; </td></tr>
+<tr class="twikiTableEven"><td width="160" bgcolor="#edf4f9" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> --help=short </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> display options specific to this package </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> This command shows the options special to motion. Recommended </td></tr>
+<tr class="twikiTableOdd"><td width="160" bgcolor="#ffffff" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> --help=recursive </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> display the short help of all the included packages </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> &nbsp; </td></tr>
+<tr class="twikiTableEven"><td width="160" bgcolor="#edf4f9" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> -V, --version </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> display version information and exit </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Gives no useful information </td></tr>
+<tr class="twikiTableOdd"><td width="160" bgcolor="#ffffff" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> -q, --quiet, --silent </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> do not print `checking...' messages </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Not very useful. Output to screen is only a few lines anyway. </td></tr>
+<tr class="twikiTableEven"><td width="160" bgcolor="#edf4f9" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> --cache-file=FILE </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> cache test results in FILE. [disabled] </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> No function </td></tr>
+<tr class="twikiTableOdd"><td width="160" bgcolor="#ffffff" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> -C, --config-cach </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> alias for `--cache-file=config.cache' </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> No function </td></tr>
+<tr class="twikiTableEven"><td width="160" bgcolor="#edf4f9" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> -n, --no-create </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> do not create output files </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Used for testing if other switches produce error - without writing anything to the disk </td></tr>
+<tr class="twikiTableOdd"><td width="160" bgcolor="#ffffff" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> --srcdir=DIR </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> find the sources in DIR. [configure dir or `..'] </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> DIR is a directory path. Editor recommends having the current directory being the motion installation directory and not using this switch. Then it defaults to the same directory as where the configure script is which is the current directory. </td></tr>
+<tr class="twikiTableEven"><th width="160" bgcolor="#6b7f93" align="left" valign="top" style="width:160;text-align:left;vertical-align:top;" class="twikiFirstCol" maxcols="0"> <span style="color:#ffffff"> <strong> Installation directories: </strong> </span> </th><th bgcolor="#6b7f93" align="left" valign="top" style="text-align:left;vertical-align:top;" maxcols="0"> <span style="color:#ffffff"> <strong> &nbsp; </strong> </span> </th><th bgcolor="#6b7f93" align="left" valign="top" style="text-align:left;vertical-align:top;" maxcols="0"> <span style="color:#ffffff"> <strong> &nbsp; </strong> </span> </th></tr>
+<tr class="twikiTableOdd"><td width="160" bgcolor="#ffffff" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> --prefix=PREFIX </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> install architecture-independent files in PREFIX<br />[/usr/local] </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> The default /usr/local means that the executable binary "motion" is installed in /usr/local/bin, the manual page in /usr/local/man/man1, the document files in /usr/local/docs/motion-version, configuration file in /usr/local/etc, and some examples config files in /usr/local/examples/motion-versionEditor recommends keeping this default setting.<br />If you are experimenting with many parallel versions it may be interesting to set the PREFIX to e.g. /usr/local/motion and then add /usr/local/motion/bin to your search path (or simply cd /usr/local/motion/bin before execution).<br />This way you can change version just by changing the symbolic link in /usr/local/motion as suggested earlier in this guide.<br />If you are installing the software on a machine where you have no access to the /usr/local but have write access to a home directory, then you should change this to point to a directory within your home tree.<br />Example: --prefix=$HOME </td></tr>
+<tr class="twikiTableEven"><td width="160" bgcolor="#edf4f9" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> --exec-prefix=EPREFIX </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> install architecture-dependent files in EPREFIX<br />[PREFIX] </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> If you set this it only defines an alternative installation directory for the executable binary.<br />Note: The executable binary will be placed in a directory "bin" below the directory specified by this option<br />Editor recommends leaving this as default (i.e. not setting it). </td></tr>
+<tr class="twikiTableOdd"><td width="160" bgcolor="#ffffff" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> --bindir=DIR </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> user executables [EPREFIX/bin] </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> With this option you can control exactly in which directory the executable binary is installed. The previous option automatically adds the bin directory. Here you are in fill control. </td></tr>
+<tr class="twikiTableEven"><td width="160" bgcolor="#edf4f9" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> --sbindir=DIR </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> System admin executables [EPREFIX/sbin] </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Not used by motion. Ignore it. </td></tr>
+<tr class="twikiTableOdd"><td width="160" bgcolor="#ffffff" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> --libexecdir=DIR </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> program executables [EPREFIX/libexec] </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Not used by motion. Ignore it. </td></tr>
+<tr class="twikiTableEven"><td width="160" bgcolor="#edf4f9" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> --datadir=DIR </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> read-only architecture-independent data [PREFIX/share] </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Not used by motion. Ignore it. </td></tr>
+<tr class="twikiTableOdd"><td width="160" bgcolor="#ffffff" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> --sysconfdir=DIR </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> read-only single-machine data [PREFIX/etc] </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> This is where motion both installs the default configuration file and also where it later searches for it.<br />Motion searches for the configuration file "motion.conf" in the following order:<br /><UL><br />1. Current directory from where motion was invoked<br />2. $HOME/.motion<br />3. The sysconfig directory set by this switch. If not defined the default is /usr/local/etc/<br /></UL><br />Editor recommends leaving this at default. Be careful if you run "make install" again. This will overwrite the motion.conf file that you have edited and experimented with for hours. Make sure to keep a copy in a safe place. Alternatively, copy the working file to the motion base install directory. Then make install will simply copy the same file back again. </td></tr>
+<tr class="twikiTableEven"><td width="160" bgcolor="#edf4f9" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> --sharedstatedir=DIR </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> modifiable architecture-independent data [PREFIX/com] </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Not used by motion. Ignore it. </td></tr>
+<tr class="twikiTableOdd"><td width="160" bgcolor="#ffffff" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> --localstatedir=DIR </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> modifiable single-machine data [PREFIX/var] </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Not used by motion. Ignore it. </td></tr>
+<tr class="twikiTableEven"><td width="160" bgcolor="#edf4f9" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> --libdir=DIR </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> object code libraries [EPREFIX/lib] </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Not used by motion. Ignore it. </td></tr>
+<tr class="twikiTableOdd"><td width="160" bgcolor="#ffffff" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> --includedir=DIR </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> C header files [PREFIX/include] </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Not used by motion. Ignore it. </td></tr>
+<tr class="twikiTableEven"><td width="160" bgcolor="#edf4f9" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> --oldincludedir=DIR </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> C header files for non-gcc [/usr/include] </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Not used by motion. Ignore it. </td></tr>
+<tr class="twikiTableOdd"><td width="160" bgcolor="#ffffff" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> --infodir=DIR </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> info documentation [PREFIX/info] </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Not used by motion. Ignore it. </td></tr>
+<tr class="twikiTableEven"><td width="160" bgcolor="#edf4f9" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> --mandir=DIR </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> man documentation [PREFIX/man] </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Editor recommends the default. </td></tr>
+<tr class="twikiTableOdd"><th width="160" bgcolor="#6b7f93" align="left" valign="top" style="width:160;text-align:left;vertical-align:top;" class="twikiFirstCol" maxcols="0"> <span style="color:#ffffff"> <strong> Optional Packages: </strong> </span> </th><th bgcolor="#6b7f93" align="left" valign="top" style="text-align:left;vertical-align:top;" maxcols="0"> <span style="color:#ffffff"> <strong> &nbsp; </strong> </span> </th><th bgcolor="#6b7f93" align="left" valign="top" style="text-align:left;vertical-align:top;" maxcols="0"> <span style="color:#ffffff"> <strong> &nbsp; </strong> </span> </th></tr>
+<tr class="twikiTableEven"><td width="160" bgcolor="#ffffff" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> --with-ffmpeg=DIR </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Specify the path for the directory prefix in which the library and headers are installed.<br />If not specified configure will search in /usr/ and /usr/local/ </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> DIR is the directory PREFIX in which the ffmpeg shared libraries and their headers are installed.<br />If you install ffmpeg from sources and use the default directories or if ffmpeg is installed as a binary package (RPM or deb) you do not need to specify the directory prefix. Configure will find the libraries automatically. If you installed ffmpeg from sources and specified a different --prefix when building ffmpeg you must use the same value for the DIR ( --with-ffmpeg=DIR).<br />For more information on FFmpeg see the <a href="http://ffmpeg.sourceforge.net/" rel="nofollow" target="_top">FFmpeg project home page</a>.<br />FFmpeg is a package that enables streamed video mpeg signal from your web camera to a browser.<br />Editor recommends installing ffmpeg from source and in the directory /usr/local/ffmpeg and build ffmpeg with ./configure --enable-shared.<br />This places libraries in /usr/local/lib and headers in /usr/local/include. </td></tr>
+<tr class="twikiTableOdd"><td width="160" bgcolor="#edf4f9" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> --without-ffmpeg </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Do not compile with ffmpeg </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Use this if you do not want to compile with ffmpeg. If ffmpeg is not installed you do not need to specify that Motion must build without ffmpeg. </td></tr>
+<tr class="twikiTableEven"><td width="160" bgcolor="#ffffff" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> --with-mysql-lib=DIR </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Lib directory of MySQL </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Normally, configure will scan all possible default installation paths for MySQL libs. When its fail, use this command to tell configure where MySQL libs installation root directory is. </td></tr>
+<tr class="twikiTableOdd"><td width="160" bgcolor="#edf4f9" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> --with-mysql-include=DIR </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Include directory with headers for MySQL </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Normally, configure will scan all possible default                          installation paths for MySQL include. When its fail, use this command to tell configure where MySQL include installation directory is. This is the directory with the MySQL header files. </td></tr>
+<tr class="twikiTableEven"><td width="160" bgcolor="#ffffff" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> --without-mysql </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Do not compile with MySQL support </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Use this if you do not want to include MySQL support in the package.<br />This can also be useful if you get compilation errors related to MySQL and you actually do not need the feature anyway. </td></tr>
+<tr class="twikiTableOdd"><td width="160" bgcolor="#edf4f9" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> --with-pgsql=DIR </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Include PostgreSQL support.  DIR is the PostgreSQL base install directory, defaults to /usr/local/pgsql.<br />Set DIR to "shared" to build as a dynamic library, or "shared,DIR"  to build as a dynamic library and still specify DIR. </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Default is that make searches in the normal installation directories of most distributions.<br />See section later about PostgreSQL about potential problem during compilation. There is an easy workaround for it. </td></tr>
+<tr class="twikiTableEven"><td width="160" bgcolor="#ffffff" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> --without-pgsql </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Do not compile with PostgreSQL support </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Use this if you do not want to include PostgreSQL support in the package.<br />This can also be useful if you get compilation errors related to PostgreSQL and you actually do not need the feature anyway. </td></tr>
+<tr class="twikiTableOdd"><td width="160" bgcolor="#edf4f9" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> --without-v4l </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Exclude using v4l (video4linux) subsystem. Makes Motion so it only supports network cameras. </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Can be used if you do not need <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/V4L" class="twikiLink">V4L</a> support and maybe lack some of the libraries for it. </td></tr>
+<tr class="twikiTableEven"><td width="160" bgcolor="#ffffff" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> --with-linuxthreads </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Use linuxthreads in BSD instead of native phtreads </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Only relevant for BSD. In Linux we always use this per default. </td></tr>
+<tr class="twikiTableOdd"><td width="160" bgcolor="#edf4f9" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> --without-bktr </td><td bgcolor="#edf4f9" align="right" valign="top" style="vertical-align:top;"> Exclude to use bktr subsystem , that usually useful for devices as network cameras </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> ONLY used in *BSD </td></tr>
+<tr class="twikiTableEven"><td width="160" bgcolor="#ffffff" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> --with-jpeg-mmx=DIR </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Specify the prefix for the install path for jpeg-mmx for optimized jpeg handling (optional). If this is not specified motion will try to find the library /usr/lib/libjpeg-mmx.a /usr/local/lib/libjpeg-mmx.a. </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Considered experimental </td></tr>
+<tr class="twikiTableOdd"><td width="160" bgcolor="#edf4f9" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol"> --without-optimizecpu </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Exclude autodetecting platform and cpu type. This will disable the compilation of gcc optimizing code by platform and cpu. </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Use this if the optimization causes problems. Typically if you build on some non X386 compatible CPU. </td></tr>
+<tr class="twikiTableEven"><th width="160" bgcolor="#6b7f93" align="left" valign="top" style="width:160;text-align:left;vertical-align:top;" class="twikiFirstCol" maxcols="0"> <span style="color:#ffffff"> <strong> Developers options </strong> </span> </th><th bgcolor="#6b7f93" align="left" valign="top" style="text-align:left;vertical-align:top;" maxcols="0"> <span style="color:#ffffff"> <strong> &nbsp; </strong> </span> </th><th bgcolor="#6b7f93" align="left" valign="top" style="text-align:left;vertical-align:top;" maxcols="0"> <span style="color:#ffffff"> <strong> &nbsp; </strong> </span> </th></tr>
+<tr class="twikiTableOdd"><td width="160" bgcolor="#ffffff" valign="top" style="width:160;vertical-align:top;" class="twikiFirstCol twikiLast"> --with-developer-flags </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiLast"> Add additional warning flags for the compiler. </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiLast"> This option is for developers only. It produces a flood of warnings that helps the developer to write more robust code. These warnings are normally harmless but can sometimes be a latent defect.<br />For more information about these flags, see <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/CompileWithDeveloperFlags" class="twikiLink">CompileWithDeveloperFlags</a> </td></tr>
+</table>
+<input type="hidden" name="etrows"   value="40" />
+<input class="editTableEditImageButton" type="image" src="http://www.lavrsen.dk/twiki/pub/TWiki/EditTablePlugin/edittable.gif" alt="Edit this table" /></form>
 </div><!-- /editTable -->
 <p />
-<p />
-<h2><a name="Make"></a> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MakeInstall">Make</a> </h2>
+<h2><a name="Make"></a> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/MakeInstall" class="twikiLink">Make</a> </h2>
 When you run make, all the C-source files are automatically compiled and linked. Just look out for error messages.
 <p />
 Make uses a file called "Makefile" which is generated by the "configure" script you just ran. If you have special needs you can manually edit this file. Next time you run configure a new Makefile will be generated and your changes are lost.
 <p />
-<img src="http://www.lavrsen.dk/foswiki/pub/System/DocumentGraphics/warning.gif" alt="ALERT!" title="ALERT!" width="16" height="16" border="0" /> Attention!
+<img src="http://www.lavrsen.dk/twiki/pub/TWiki/TWikiDocGraphics/warning.gif" alt="ALERT!" title="ALERT!" width="16" height="16" border="0" /> Attention!
 <p />
 If you have run <code>make</code> before, you should run a <code>make clean</code> before running <code>make</code> again. This cleans out all the object files that were generated the previous time you ran <code>make</code>. If you do not run <code>make clean</code> first before you rebuild Motion you may not get the additional feature included. For example: If you built Motion without ffmpeg support and then add it later - and rebuild Motion without running <code>make clean</code> first - the ffmpeg feature does not get compiled into the Motion binary.
 <p />
@@ -775,8 +539,9 @@ The make command can be run with several
 </dd></dl> 
 <p />
 <p />
-<h2><a name="Upgrading_From_Older_Version"></a> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/UpgradingFromOlderVersion">Upgrading From Older Version</a> </h2>
- If you are upgrading from motion 3.0.X or from an older version of 3.1.X you should note that many options have been removed from version 3.1.13 and forward and many new have arrived. You still have most of the old features. The options have been changed for two reasons. New more flexible features and to simplify getting started with Motion. With 3.2.1 the changes are significant. You should also note these major differences.  <ul>
+<h2><a name="Upgrading_From_Older_Version"></a> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/UpgradingFromOlderVersion" class="twikiLink">Upgrading From Older Version</a> </h2>
+If you are upgrading from motion 3.0.X or from an older version of 3.1.X you should note that many options have been removed from version 3.1.13 and forward and many new have arrived. You still have most of the old features. The options have been changed for two reasons. New more flexible features and to simplify getting started with Motion. With 3.2.1 the changes are significant.
+You should also note these major differences. <ul>
 <li> The use of thread files has completely changed. Read the section "The Config Files" carefully.
 </li> <li> The mask file format has changed. Read the section about "Mask File"
 </li> <li> Pre_capture feature introduced in 3.1.12
@@ -807,213 +572,67 @@ The make command can be run with several
 </li> <li> New feature: ffmpeg_deinterlace which can de-interlace using the ffmpeg libs (3.2.5)
 </li> <li> New feature: minimum_frame_time which enables Motion to run at frame rates below 2. minimum_gap feature was removed since this was useless and the new minimum_frame_time feature replaces it with much better function. (3.2.7)
 </li> <li> New feature: process_id_file which writes a PID file when started and removes it when stopped (3.2.7)
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/V4L2">V4L2</a> support with many new supported palettes : <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/V4L2">V4L2</a>_PIX_FMT_SBGGR8, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/V4L2">V4L2</a>_PIX_FMT_SN9C10X, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/V4L2">V4L2</a>_PIX_FMT_JPEG, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/V4L2">V4L2</a>_PIX_FMT_UYVY (3.2.8)
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/V4L2" class="twikiLink">V4L2</a> support with many new supported palettes : <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/V4L2" class="twikiLink">V4L2</a>_PIX_FMT_SBGGR8, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/V4L2" class="twikiLink">V4L2</a>_PIX_FMT_SN9C10X, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/V4L2" class="twikiLink">V4L2</a>_PIX_FMT_JPEG, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/V4L2" class="twikiLink">V4L2</a>_PIX_FMT_UYVY (3.2.8)
 </li> <li> ffmpeg_video_codec allow swf (3.2.8)
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/V4L2">V4L2</a> fix support for : <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/V4L2">V4L2</a>_PIX_FMT_MJPEG (3.2.9)
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/V4L2" class="twikiLink">V4L2</a> fix support for :  <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/V4L2" class="twikiLink">V4L2</a>_PIX_FMT_MJPEG (3.2.9)
 </li> <li> ffmpeg_video_codec allow flv and ffv1(3.2.9)
-</li> <li> v4l2_palette: allow to choose preferable palette to be use by motion to capture from those supported by your videodevice.
-</li> <li> netcam_http: setup keep_alive , 1.1 or 1.0 http method to be used by netcam.
-</li> <li> on_camera_lost: Command to be executed when a camera can't be opened or if it is lost.
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/AreaDetect">AreaDetect</a>, on_area_detected: Command to be executed by area_detect trigger.
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionNetcamTolerantCheck">ConfigOptionNetcamTolerantCheck</a> , netcam_tolerant_check less strict jpeg checks for network cameras with a poor/buggy firmware ( 3.2.11 ).
 </li></ul> 
 <p />
-The table below shows the new options in the left column, and obsolete options in the right column. If the there are options on both sides in a row it means that the options in the left column replaced the options in the right column.
 <p />
+The table below shows the new options in the left column, and obsolete options in the right column. If the there are options on both sides in a row it means that the options in the left column replaced the options in the right column.
 <p />
-<div class="editTable">
-<form name="edittable1_Motion_MotionGuideOneLargeDocument" action="http://www.lavrsen.dk/foswiki/bin/viewauth/Motion/UpgradingFromOlderVersion#edittable1" method="post" onsubmit="foswikiStrikeOne(this)"><input type='hidden' name='validation_key' value='?fd8fc4e77a93cc2c570a08a93d66e7dd' />
+<a name="edittable1"></a>
+<div class="editTable"><form name="edittable1" action="http://www.lavrsen.dk/twiki/bin/viewauth/Motion/UpgradingFromOlderVersion#edittable1" method="post">
 <input type="hidden" name="ettablenr" value="1" />
 <input type="hidden" name="etedit" value="on" />
-<table cellspacing="0" id="table6" cellpadding="0" class="foswikiTable" rules="rows" border="1">
-	<thead>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<th width="50%" bgcolor="#687684" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a rel="nofollow" href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument;sortcol=0;table=6;up=0#sorted_table" title="Sort by this column"><font color="#ffffff">New Options</font></a> </th>
-			<th width="50%" bgcolor="#687684" valign="top" class="foswikiTableCol1 foswikiLastCol"> <a rel="nofollow" href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument;sortcol=1;table=6;up=0#sorted_table" title="Sort by this column"><font color="#ffffff">Obsolete Options</font></a> </th>
-		</tr>
-	</thead>
-	<tbody>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> text_left (3.1.13) <br /> text_right (3.1.13) <br /> text_changes (3.1.13) </td>
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol1 foswikiLastCol"> drawtext_user (3.1.13) <br /> drawtext_shots (3.1.13) <br /> drawtext_changes (3.1.13) </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> jpeg_filename (3.1.13) <br /> ffmpeg_filename (3.1.13) <br /> snapshot_filename (3.1.13) <br /> timelapse_filename (3.1.13) <br /> predict_filename (3.1.13) <br /> (predict_filename removed in 3.1.18) </td>
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1 foswikiLastCol"> oldlayout (3.1.13) <br /> snapshots_overwrite (3.1.13) </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> snapshot_interval (3.1.13) </td>
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol1 foswikiLastCol"> snapshots (3.1.13) </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> &nbsp; </td>
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1 foswikiLastCol"> realmotion (3.1.13) </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> despeckle (3.1.13) </td>
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol1 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> pre_capture (3.1.12) </td>
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> ffmpeg_timelapse (v. 3.1.14) </td>
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol1 foswikiLastCol"> ffmpeg_timelaps (renamed v 3.1.14) </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> ffmpeg_timelapse_mode (3.1.14) </td>
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> sql_log_image (3.1.14) <br /> sql_log_snapshot (3.1.14) <br /> sql_log_mpeg (3.1.14) <br /> sql_log_timelapse (3.1.14) <br /> sql_log_prediction (3.1.14) </td>
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol1 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> minimum_motion_frames (3.1.14) </td>
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> rotate (3.1.15) </td>
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol1 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> ffmpeg_variable_bitrate (3.1.15) <br /> ffmpeg_video_codec (3.1.15) </td>
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> &nbsp; </td>
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol1 foswikiLastCol"> berkeley_single_directory (3.1.18) <br /> mpeg_encode (3.1.18) <br /> mpeg_encode_bin (3.1.18) <br /> adjust_rate off (3.1.18) <br /> jpg_cleanup (3.1.18) </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> &nbsp; </td>
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1 foswikiLastCol"> predict_filename (3.1.18) <br /> predict_enable (3.1.18) <br /> predict_threshold (3.1.18) <br /> predict_description (3.1.18) <br /> sql_log_prediction (3.1.18) </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> brightness (3.1.18) <br /> contrast (3.1.18) <br /> saturation (3.1.18) <br /> hue (3.1.18) </td>
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol1 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> smart_mask_speed (3.1.18) </td>
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> output_normal <br /> valid values are now "on", "off", "first" (3.1.18) and "best" (3.2.1) </td>
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol1 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> setup_mode (3.2.1) </td>
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1 foswikiLastCol"> always_changes (3.2.1) </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> locate <br /> valid values are now "on", "off", "preview" (3.2.1) </td>
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol1 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> jpeg_filename <br /> Besides normal path names the value "preview" has speciel meaning together with output_normal = "best" (3.2.1) </td>
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> control_html_output (3.2.1) </td>
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol1 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> on_event_start (3.2.1) </td>
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1 foswikiLastCol"> execute (3.2.1) <br /> sms (3.2.1) <br /> mail (3.2.1) </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> on_event_end (3.2.1) </td>
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol1 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> on_motion_detected (3.2.1) </td>
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> on_picture_save (3.2.1) </td>
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol1 foswikiLastCol"> onsave (3.2.1) </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> on_movie_start (3.2.1) <br /> on_movie_end (3.2.1) </td>
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1 foswikiLastCol"> onmpeg (3.2.1) <br /> onffmpegclose (introduced 3.1.13)(renamed to on_movie_end 3.2.1) </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> netcam_proxy (3.2.2) </td>
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol1 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> text_double (3.2.2) </td>
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> webcam_motion <br /> Feature has been heavily improved so it is actually usefull now (3.2.2). </td>
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol1 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> netcam_url <br /> Now also supports fetching single frame jpeg pictures via ftp using ftp:// syntax (3.2.4) </td>
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> track_step_angle_x (3.2.4) <br /> track_step_angle_y (3.2.4) <br /> Add better configuration of auto tracking with a Logitech Sphere/Orbit camera. </td>
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol1 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> track_move_wait (3.2.4) <br /> track_auto (3.2.4) <br /> Adds better configuration of auto tracking feature </td>
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> sql_query (3.2.4) <br /> Adds full flexibility of defining fields when using the SQL database features. </td>
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol1 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> track_maxy (3.2.5) <br /> track_motory (3.2.5) </td>
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> movie_filename (3.2.5) </td>
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol1 foswikiLastCol"> ffmpeg_filename (3.2.5) </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> ffmpeg_deinterlace (3.2.5) </td>
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> minimum_frame_time (3.2.7) </td>
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol1 foswikiLastCol"> minimum_gap (3.2.7) </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> process_id_file (3.2.7) </td>
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> ffmpeg_video_codec allow swf (3.2.8) </td>
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol1 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> ffmpeg_video_codec allow flv and ffv1 (3.2.9) </td>
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> v4l2_palette (3.2.10) <br /> netcam_http (3.2.10) <br /> on_camera_lost (3.2.10) <br /> area_detect, on_area_detected(3.2.10) <br /> ffmpeg_video_codec mov(3.2.10) <br /> output_normal center(3.2.10) </td>
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol1 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> &nbsp; </td>
-			<td width="50%" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1 foswikiLastCol"> night_compensate (3.2.10) <br /> low_cpu (3.2.10) </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol foswikiLast"> netcam_tolerant_check (3.2.11) </td>
-			<td width="50%" bgcolor="#ffffff" valign="top" class="foswikiTableCol1 foswikiLastCol foswikiLast"> &nbsp; </td>
-		</tr>
-	</tbody></table>
-<input type="hidden" name="ettablechanges" value="" />
-<input type="hidden" name="etheaderrows" value="0" />
-<input type="hidden" name="etfooterrows" value="0" />
-<input class="editTableEditImageButton" type="image" src="http://www.lavrsen.dk/foswiki/pub/System/EditTablePlugin/edittable.gif" alt="Edit this table" /> </form>
+<table style="border-width:1px;" cellspacing="0" cellpadding="0" class="twikiTable" border="1"><tr class="twikiTableEven"><th width="50%" bgcolor="#6b7f93" align="center" valign="top" style="width:50%;text-align:center;vertical-align:top;" class="twikiFirstCol" maxcols="0"> <a rel="nofollow" href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideOneLargeDocument&amp;amp;sortcol=0;table=6;up=0#sorted_table" style="color:#ffffff" title="Sort by this column">New Options</a> </th><th width="50%" bgcolor="#6b7f93" align="center" valign="top" style="width:50%;text-align:center;vertical-align:top;" maxcols="0"> <a rel="nofollow" href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideOneLargeDocument&amp;amp;sortcol=1;table=6;up=0#sorted_table" style="color:#ffffff" title="Sort by this column">Obsolete Options</a> </th></tr>
+<tr class="twikiTableOdd"><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> text_left (3.1.13)<br />text_right (3.1.13)<br />text_changes (3.1.13) </td><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;"> drawtext_user (3.1.13)<br />drawtext_shots (3.1.13)<br />drawtext_changes (3.1.13) </td></tr>
+<tr class="twikiTableEven"><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> jpeg_filename (3.1.13)<br />ffmpeg_filename (3.1.13)<br />snapshot_filename (3.1.13)<br />timelapse_filename (3.1.13)<br />predict_filename (3.1.13)<br />(predict_filename removed in 3.1.18)<br /> </td><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;"> oldlayout (3.1.13)<br />snapshots_overwrite (3.1.13) </td></tr>
+<tr class="twikiTableOdd"><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> snapshot_interval (3.1.13) </td><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;"> snapshots (3.1.13) </td></tr>
+<tr class="twikiTableEven"><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> &nbsp; </td><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;"> realmotion (3.1.13) </td></tr>
+<tr class="twikiTableOdd"><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> despeckle (3.1.13) </td><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;"> &nbsp; </td></tr>
+<tr class="twikiTableEven"><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> pre_capture (3.1.12) </td><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;"> &nbsp; </td></tr>
+<tr class="twikiTableOdd"><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> ffmpeg_timelapse (v. 3.1.14) </td><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;"> ffmpeg_timelaps (renamed v 3.1.14) </td></tr>
+<tr class="twikiTableEven"><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> ffmpeg_timelapse_mode (3.1.14) </td><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;"> &nbsp; </td></tr>
+<tr class="twikiTableOdd"><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> sql_log_image (3.1.14)<br />sql_log_snapshot (3.1.14)<br />sql_log_mpeg (3.1.14)<br />sql_log_timelapse (3.1.14)<br />sql_log_prediction (3.1.14) </td><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;"> &nbsp; </td></tr>
+<tr class="twikiTableEven"><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> minimum_motion_frames (3.1.14) </td><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;"> &nbsp; </td></tr>
+<tr class="twikiTableOdd"><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> rotate (3.1.15) </td><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;"> &nbsp; </td></tr>
+<tr class="twikiTableEven"><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> ffmpeg_variable_bitrate (3.1.15)<br />ffmpeg_video_codec (3.1.15) </td><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;"> &nbsp; </td></tr>
+<tr class="twikiTableOdd"><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> &nbsp; </td><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;"> berkeley_single_directory (3.1.18)<br />mpeg_encode (3.1.18)<br />mpeg_encode_bin (3.1.18)<br />adjust_rate off (3.1.18)<br />jpg_cleanup (3.1.18) </td></tr>
+<tr class="twikiTableEven"><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> &nbsp; </td><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;"> predict_filename (3.1.18)<br />predict_enable (3.1.18)<br />predict_threshold (3.1.18)<br />predict_description (3.1.18)<br />sql_log_prediction (3.1.18) </td></tr>
+<tr class="twikiTableOdd"><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> brightness (3.1.18)<br />contrast (3.1.18)<br />saturation (3.1.18)<br />hue (3.1.18) </td><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;"> &nbsp; </td></tr>
+<tr class="twikiTableEven"><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> smart_mask_speed (3.1.18) </td><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;"> &nbsp; </td></tr>
+<tr class="twikiTableOdd"><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> output_normal<br />valid values are now "on", "off", "first" (3.1.18) and "best" (3.2.1)<br /> </td><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;"> &nbsp; </td></tr>
+<tr class="twikiTableEven"><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> setup_mode (3.2.1) </td><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;"> always_changes (3.2.1) </td></tr>
+<tr class="twikiTableOdd"><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> locate<br />valid values are now "on", "off", "preview" (3.2.1) </td><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;"> &nbsp; </td></tr>
+<tr class="twikiTableEven"><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> jpeg_filename<br />Besides normal path names the value "preview" has speciel meaning together with output_normal = "best" (3.2.1) </td><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;"> &nbsp; </td></tr>
+<tr class="twikiTableOdd"><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> control_html_output (3.2.1) </td><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;"> &nbsp; </td></tr>
+<tr class="twikiTableEven"><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> on_event_start (3.2.1)<br /> </td><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;"> execute (3.2.1)<br />sms (3.2.1)<br />mail (3.2.1) </td></tr>
+<tr class="twikiTableOdd"><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> on_event_end (3.2.1)<br /> </td><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;"> &nbsp; </td></tr>
+<tr class="twikiTableEven"><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> on_motion_detected (3.2.1)<br /> </td><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;"> &nbsp; </td></tr>
+<tr class="twikiTableOdd"><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> on_picture_save (3.2.1)<br /> </td><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;"> onsave (3.2.1) </td></tr>
+<tr class="twikiTableEven"><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> on_movie_start (3.2.1)<br />on_movie_end (3.2.1)<br /> </td><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;"> onmpeg (3.2.1)<br />onffmpegclose (introduced 3.1.13)(renamed to on_movie_end 3.2.1)<br /> </td></tr>
+<tr class="twikiTableOdd"><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> netcam_proxy (3.2.2) </td><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;"> &nbsp; </td></tr>
+<tr class="twikiTableEven"><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> text_double (3.2.2) </td><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;"> &nbsp; </td></tr>
+<tr class="twikiTableOdd"><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> webcam_motion<br />Feature has been heavily improved so it is actually usefull now (3.2.2). </td><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;"> &nbsp; </td></tr>
+<tr class="twikiTableEven"><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> netcam_url<br />Now also supports fetching single frame jpeg pictures via ftp using ftp:// syntax (3.2.4) </td><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;"> &nbsp; </td></tr>
+<tr class="twikiTableOdd"><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> track_step_angle_x (3.2.4)<br />track_step_angle_y (3.2.4)<br />Add better configuration of auto tracking with a Logitech Sphere/Orbit camera.<br /> </td><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;"> &nbsp; </td></tr>
+<tr class="twikiTableEven"><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> track_move_wait (3.2.4)<br />track_auto (3.2.4)<br />Adds better configuration of auto tracking feature </td><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;"> &nbsp; </td></tr>
+<tr class="twikiTableOdd"><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> sql_query (3.2.4)<br />Adds full flexibility of defining fields when using the SQL database features. </td><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;"> &nbsp; </td></tr>
+<tr class="twikiTableEven"><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> track_maxy (3.2.5)<br />track_motory (3.2.5) </td><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;"> &nbsp; </td></tr>
+<tr class="twikiTableOdd"><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> movie_filename (3.2.5) </td><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;"> ffmpeg_filename (3.2.5) </td></tr>
+<tr class="twikiTableEven"><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> ffmpeg_deinterlace (3.2.5) </td><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;"> &nbsp; </td></tr>
+<tr class="twikiTableOdd"><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> minimum_frame_time (3.2.7) </td><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;"> minimum_gap (3.2.7) </td></tr>
+<tr class="twikiTableEven"><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> process_id_file (3.2.7) </td><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;"> &nbsp; </td></tr>
+<tr class="twikiTableOdd"><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> ffmpeg_video_codec allow swf (3.2.8) </td><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;"> &nbsp; </td></tr>
+<tr class="twikiTableEven"><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol"> ffmpeg_video_codec allow flv and ffv1 (3.2.9) </td><td width="50%" bgcolor="#edf4f9" valign="top" style="width:50%;vertical-align:top;"> &nbsp; </td></tr>
+<tr class="twikiTableOdd"><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;" class="twikiFirstCol twikiLast"> &nbsp; </td><td width="50%" bgcolor="#ffffff" valign="top" style="width:50%;vertical-align:top;" class="twikiLast"> night_compensate (3.2.10)<br />low_cpu (3.2.10) </td></tr>
+</table>
+<input type="hidden" name="etrows"   value="42" />
+<input class="editTableEditImageButton" type="image" src="http://www.lavrsen.dk/twiki/pub/TWiki/EditTablePlugin/edittable.gif" alt="Edit this table" /></form>
 </div><!-- /editTable -->
 <p />
-<p />
-<h2><a name="Running_Motion"></a> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/RunningMotionConfigFiles">Running Motion</a> </h2>
+<h2><a name="Running_Motion"></a> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/RunningMotionConfigFiles" class="twikiLink">Running Motion</a> </h2>
 <p />
 <h3><a name="Important_Definitions"></a> Important Definitions </h3>
 Motion is invoked from the command line. It has no GUI. Everything is controlled from config files. From version 3.2 the command line is only used to define location of config file and a few special runtime modes (setup and non-daemon).
@@ -1063,75 +682,40 @@ Motion reads its configuration parameter
 </li></ol> 
 So always call the thread config files in the end of the motion.conf file. If you define options in motion.conf  AFTER the thread file calls, the same options in the thread files will never be used. So always put the thread file call at the end of motion.conf.
 <p />
-Nearly all config options can be unique for a specific camera and placed in a thread config file. There are a few options that must be in motion.conf and cannot be in a thread config file: <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionControlAuthentication">control_authentication</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionControlHtmlOutput">control_html_output</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionControlLocalhost">control_localhost</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionControlPort">control_port</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionDaemon">daemon</a>, and <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionThread">thread</a>.
+Nearly all config options can be unique for a specific camera and placed in a thread config file. There are a few options that must be in motion.conf and cannot be in a thread config file: <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionControlAuthentication" class="twikiLink">control_authentication</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionControlHtmlOutput" class="twikiLink">control_html_output</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionControlLocalhost" class="twikiLink">control_localhost</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionControlPort" class="twikiLink">control_port</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionDaemon" class="twikiLink">daemon</a>, and <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionThread" class="twikiLink">thread</a>.
 <p />
 If motion is built without specific features such as ffmpeg, mysql etc it will ignore the options that belongs to these features. You do not have to remove them or comment them out.
 <p />
 If you run the http control command <a href="http://host:port/0/config/writeyes" rel="nofollow" target="_top">http://host:port/0/config/writeyes</a>, motion will overwrite motion.conf and all the thread.conf files by autogenerated config files neatly formatted and only with the features included that Motion was built with. If you later re-build Motion with more features or upgrade to a new version, you can use your old config files, run the motion.conf.write command, and you will have new config files with the new options included all set to their default values. This makes upgrading very easy to do.
 <p />
 <p />
-<h2><a name="Command_Line_Options"></a> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/CommandLineOptions">Command Line Options</a> </h2>
+<h2><a name="Command_Line_Options"></a> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/CommandLineOptions" class="twikiLink">Command Line Options</a> </h2>
 <p />
-<img src="http://www.lavrsen.dk/foswiki/pub/System/DocumentGraphics/warning.gif" alt="ALERT!" title="ALERT!" width="16" height="16" border="0" /> In Motion 3.2.1 and forward most command line options have been removed and replaced them by an option to specify location to motion.conf and a few options related to setting up motion. There are now only few command line options left and they are basically all new.
+<img src="http://www.lavrsen.dk/twiki/pub/TWiki/TWikiDocGraphics/warning.gif" alt="ALERT!" title="ALERT!" width="16" height="16" border="0" /> In Motion 3.2.1 and forward most command line options have been removed and replaced them by an option to specify location to motion.conf and a few options related to setting up motion. There are now only few command line options left and they are basically all new.
 <p />
 SYNOPSIS
 <pre>
-motion &#91; -hns ] &#91; -c config file path ] &#91; -d level ]  &#91; -p process&#95;id&#95;file ]
+motion &#91; -hns ] &#91; -c config file path]
 </pre>
 <p />
-<div class="editTable">
-<form name="edittable1_Motion_MotionGuideOneLargeDocument" action="http://www.lavrsen.dk/foswiki/bin/viewauth/Motion/CommandLineOptions#edittable1" method="post" onsubmit="foswikiStrikeOne(this)"><input type='hidden' name='validation_key' value='?fd8fc4e77a93cc2c570a08a93d66e7dd' />
+<a name="edittable1"></a>
+<div class="editTable"><form name="edittable1" action="http://www.lavrsen.dk/twiki/bin/viewauth/Motion/CommandLineOptions#edittable1" method="post">
 <input type="hidden" name="ettablenr" value="1" />
 <input type="hidden" name="etedit" value="on" />
-<table cellspacing="0" id="table7" cellpadding="0" class="foswikiTable" rules="rows" border="1">
-	<thead>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<th width="150" bgcolor="#687684" align="left" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a rel="nofollow" href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument;sortcol=0;table=7;up=0#sorted_table" title="Sort by this column"><font color="#ffffff">Option</font></a> </th>
-			<th width="250" bgcolor="#687684" align="left" valign="top" class="foswikiTableCol1"> <a rel="nofollow" href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument;sortcol=1;table=7;up=0#sorted_table" title="Sort by this column"><font color="#ffffff">Description</font></a> </th>
-			<th bgcolor="#687684" align="left" valign="top" class="foswikiTableCol2 foswikiLastCol"> <a rel="nofollow" href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument;sortcol=2;table=7;up=0#sorted_table" title="Sort by this column"><font color="#ffffff">Editors comment</font></a> </th>
-		</tr>
-	</thead>
-	<tbody>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="150" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> -n </td>
-			<td width="250" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Run in non-daemon mode. </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Instead of running Motion in the background Motion runs in the terminal window writing messages when things happen. If you have problems getting Motion to start or work, run Motion in this mode to get more messages that can help you solve the problem. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="150" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> -s </td>
-			<td width="250" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Run in setup mode. </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Also forces non-daemon mode </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="150" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> -c config file path </td>
-			<td width="250" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Full path and filename of config file. </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> E.g. /home/kurt/motion.conf. Default is /usr/local/etc unless specified differently when building Motion. Many RPMs and debian packages will most likely use /etc or /etc/motion as default </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="150" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> -h </td>
-			<td width="250" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Show help screen. </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="150" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> -d level </td>
-			<td width="250" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Debugging mode </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> This mode is used for developers to enable debug messages. Normal users will not need to use this mode unless a developer request to get additional information in the attempt to resolve a bug. Mainly the netcam code has debugging features. The level defines how much debugging info you get. A high number displays all debugging. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="150" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol foswikiLast"> -p process_id_file </td>
-			<td width="250" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1 foswikiLast"> Full path of process ID file </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol foswikiLast"> Full path and filename of process id file (PID file). This is optional. If none is given as command line option or in motion.conf (process_id_file) Motion will not create a PID file. </td>
-		</tr>
-	</tbody></table>
-<input type="hidden" name="ettablechanges" value="" />
-<input type="hidden" name="etheaderrows" value="0" />
-<input type="hidden" name="etfooterrows" value="0" />
-<input class="editTableEditImageButton" type="image" src="http://www.lavrsen.dk/foswiki/pub/System/EditTablePlugin/edittable.gif" alt="Edit this table" /> </form>
+<table style="border-width:1px;" cellspacing="0" cellpadding="0" class="twikiTable" border="1"><tr class="twikiTableEven"><th width="150" bgcolor="#6b7f93" align="left" valign="top" style="width:150;text-align:left;vertical-align:top;" class="twikiFirstCol" maxcols="0"> <a rel="nofollow" href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideOneLargeDocument&amp;amp;sortcol=0;table=7;up=0#sorted_table" style="color:#ffffff" title="Sort by this column">Option</a> </th><th width="250" bgcolor="#6b7f93" align="left" valign="top" style="width:250;text-align:left;vertical-align:top;" maxcols="0"> <a rel="nofollow" href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideOneLargeDocument&amp;amp;sortcol=1;table=7;up=0#sorted_table" style="color:#ffffff" title="Sort by this column">Description</a> </th><th bgcolor="#6b7f93" align="left" valign="top" style="text-align:left;vertical-align:top;" maxcols="0"> <a rel="nofollow" href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideOneLargeDocument&amp;amp;sortcol=2;table=7;up=0#sorted_table" style="color:#ffffff" title="Sort by this column">Editors comment</a> </th></tr>
+<tr class="twikiTableOdd"><td width="150" bgcolor="#ffffff" valign="top" style="width:150;vertical-align:top;" class="twikiFirstCol"> -n </td><td width="250" bgcolor="#ffffff" valign="top" style="width:250;vertical-align:top;"> Run in non-daemon mode. </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Instead of running Motion in the background Motion runs in the terminal window writing messages when things happen. If you have problems getting Motion to start or work, run Motion in this mode to get more messages that can help you solve the problem. </td></tr>
+<tr class="twikiTableEven"><td width="150" bgcolor="#edf4f9" valign="top" style="width:150;vertical-align:top;" class="twikiFirstCol"> -s </td><td width="250" bgcolor="#edf4f9" valign="top" style="width:250;vertical-align:top;"> Run in setup mode. </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Also forces non-daemon mode </td></tr>
+<tr class="twikiTableOdd"><td width="150" bgcolor="#ffffff" valign="top" style="width:150;vertical-align:top;" class="twikiFirstCol"> -c config file path </td><td width="250" bgcolor="#ffffff" valign="top" style="width:250;vertical-align:top;"> Full path and filename of config file. </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> E.g. /home/kurt/motion.conf. Default is /usr/local/etc unless specified differently when building Motion. Many RPMs and debian packages will most likely use /etc or /etc/motion as default </td></tr>
+<tr class="twikiTableEven"><td width="150" bgcolor="#edf4f9" valign="top" style="width:150;vertical-align:top;" class="twikiFirstCol"> -h </td><td width="250" bgcolor="#edf4f9" valign="top" style="width:250;vertical-align:top;"> Show help screen. </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> &nbsp; </td></tr>
+<tr class="twikiTableOdd"><td width="150" bgcolor="#ffffff" valign="top" style="width:150;vertical-align:top;" class="twikiFirstCol"> -d level </td><td width="250" bgcolor="#ffffff" valign="top" style="width:250;vertical-align:top;"> Debugging mode </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> This mode is used for developers to enable debug messages. Normal users will not need to use this mode unless a developer request to get additional information in the attempt to resolve a bug. Mainly the netcam code has debugging features. The level defines how much debugging info you get. A high number displays all debugging. </td></tr>
+<tr class="twikiTableEven"><td width="150" bgcolor="#edf4f9" valign="top" style="width:150;vertical-align:top;" class="twikiFirstCol twikiLast"> -p process_id_file </td><td width="250" bgcolor="#edf4f9" valign="top" style="width:250;vertical-align:top;" class="twikiLast"> Full path of process ID file </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiLast"> Full path and filename of process id file (PID file). This is optional. If none is given as command line option or in motion.conf (process_id_file) Motion will not create a PID file. </td></tr>
+</table>
+<input type="hidden" name="etrows"   value="7" />
+<input class="editTableEditImageButton" type="image" src="http://www.lavrsen.dk/twiki/pub/TWiki/EditTablePlugin/edittable.gif" alt="Edit this table" /></form>
 </div><!-- /editTable -->
 <p />
 <p />
-<p />
-<h2><a name="Config_File_Options"></a> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigFileOptions">Config File Options</a> </h2>
+<h2><a name="Config_File_Options"></a> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigFileOptions" class="twikiLink">Config File Options</a> </h2>
 These are the options that can be used in the config file.
 <p />
 All number values are integer numbers (no decimals allowed). Boolean options can be on or off.
@@ -1150,663 +734,138 @@ FFMPEG (libavcodec) <ul>
 <li> ffmpeg_cap_new, ffmpeg_cap_motion, ffmpeg_filename, ffmpeg_timelapse, ffmpeg_timelapse_mode, ffmpeg_bps, ffmpeg_variable_bitrate, ffmpeg_video_codec
 </li></ul> 
 <p />
-<h3><a name="Options_in_Alphabetical_Order"></a> Options in Alphabetical Order. </h3>
+<h3><a name="Options_in_Alphabetical_Order"></a><a name="Options_in_Alphabetical_Order_"></a> Options in Alphabetical Order. </h3>
 <p />
 The table below lists all the Motion options in alphabetical order. Click on the option name to see a longer description of each.
-<table cellspacing="0" id="table8" cellpadding="0" class="foswikiTable" rules="rows" border="1">
-	<thead>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<th width="170" bgcolor="#687684" align="left" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a rel="nofollow" href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument;sortcol=0;table=8;up=0#sorted_table" title="Sort by this column"><font color="#ffffff">Option</font></a> </th>
-			<th width="240" bgcolor="#687684" align="left" valign="top" class="foswikiTableCol1"> <a rel="nofollow" href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument;sortcol=1;table=8;up=0#sorted_table" title="Sort by this column"><font color="#ffffff">Range/Values<br />Default</font></a> </th>
-			<th bgcolor="#687684" align="left" valign="top" class="foswikiTableCol2 foswikiLastCol"> <a rel="nofollow" href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument;sortcol=2;table=8;up=0#sorted_table" title="Sort by this column"><font color="#ffffff">Description</font></a> </th>
-		</tr>
-	</thead>
-	<tbody>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionAreaDetect">area_detect</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: 1 - 999999999<br />Default: Not defined </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Detect motion center in predefined areas. A script (on_area_detected) is started immediately when motion center is detected in one of the given areas, but only once during an event even if there is motion in a different configured area. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionAutoBrightness">auto_brightness</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: on, off<br />Default: off </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Let motion regulate the brightness of a video device. Only recommended for cameras without auto brightness </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionBrightness">brightness</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: 0 - 255<br />Default: 0 (disabled) </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> The brightness level for the video device. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionContrast">contrast</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: 0 - 255<br />Default: 0 (disabled) </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> The contrast level for the video device. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionControlAuthentication">control_authentication</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: Max 4096 characters<br />Default: Not defined </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> To protect HTTP Control by username and password, use this option for HTTP 1.1 Basic authentication. The string is specified as username:password. Do not specify this option for no authentication. This option must be placed in motion.conf and not in a thread config file. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionControlHtmlOutput">control_html_output</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: on, off<br />Default: on </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Enable HTML in the answer sent back to a browser connecting to the control_port. This option must be placed in motion.conf and not in a thread config file. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionControlLocalhost">control_localhost</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: on, off<br />Default: on </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Limits the http (html) control to the localhost. This option must be placed in motion.conf and not in a thread config file. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionControlPort">control_port</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: 0 - 65535<br />Default: 0 (disabled) </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Sets the port number for the http (html using browser) based remote control. This option must be placed in motion.conf and not in a thread config file. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionDaemon">daemon</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: on, off<br />Default: off </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Start in daemon (background) mode and release terminal. This option must be placed in motion.conf and not in a thread config file. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionDespeckle">despeckle</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: EedDl<br />Default: Not defined </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Despeckle motion image using combinations of (E/e)rode or (D/d)ilate. And ending with optional (l)abeling. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionFfmpegBps">ffmpeg_bps</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: 0 - 9999999<br />Default: 400000 </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Bitrate of mpegs produced by ffmpeg. Bitrate is bits per second. Default: 400000 (400kbps). Higher value mans better quality and larger files. Option requires that ffmpeg libraries are installed. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionFfmpegCapMotion">ffmpeg_cap_motion</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: on, off<br />Default: off </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Use ffmpeg libraries to encode motion type mpeg movies where you only see the pixels that changes. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionFfmpegCapNew">ffmpeg_cap_new</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: on, off<br />Default: off </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Use ffmpeg libraries to encode mpeg movies in realtime. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionFfmpegDeinterlace">ffmpeg_deinterlace</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: on, off<br />Default: off </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Use ffmpeg to deinterlace video. Necessary if you use an analog camera and see horizontal combing on moving objects in video or pictures. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionFfmpegFilename">ffmpeg_filename (now called movie_filename)</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: %v-%Y%m%d%H%M%S </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> File path for motion triggered ffmpeg movies (mpeg) relative to target_dir. This option was renamed to movie_filename in 3.2.5 to enable better integration of alternative movie libraries to the current ffmpeg solution. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionFfmpegTimelapse">ffmpeg_timelapse</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: 0 - 2147483647<br />Default: 0 (disabled) </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Create a timelapse movie saving a picture frame at the interval in seconds set by this parameter. Set it to 0 if not used. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionFfmpegTimelapseMode">ffmpeg_timelapse_mode</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: hourly, daily, weekly-sunday, weekly-monday, monthly, manual<br />Default: daily </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> The file rollover mode of the timelapse video. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionFfmpegVariableBitrate">ffmpeg_variable_bitrate</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: 0, 2 - 31<br />Default: 0 (disabled) </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Enables and defines variable bitrate for the ffmpeg encoder. ffmpeg_bps is ignored if variable bitrate is enabled. Valid values: 0 (default) = fixed bitrate defined by ffmpeg_bps, or the range 2 - 31 where 2 means best quality and 31 is worst. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionFfmpegVideoCodec">ffmpeg_video_codec</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: mpeg1 (ffmpeg-0.4.8 only), mpeg4, msmpeg4, swf, flv, ffv1, mov<br />Default: mpeg4 </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Codec to be used by ffmpeg for the video compression. Timelapse mpegs are always made in mpeg1 format independent from this option. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionFramerate">framerate</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: 2 - 100<br />Default: 100 (no limit) </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Maximum number of frames to be captured from the camera per second. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionFrequency">frequency</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: 0 - 999999<br />Default: 0 (Not set) </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> The frequency to set the tuner to (kHz). Valid range: per tuner spec, default: 0 (Don't set it) </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionGap">gap</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: 0 - 2147483647<br />Default: 60 </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Gap is the seconds of no motion detection that triggers the end of an event. An event is defined as a series of motion images taken within a short timeframe. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionHeight">height </a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: Device Dependent<br />Default: 288 </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> The height of each frame in pixels. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionHue">hue</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: 0 - 255<br />Default: 0 (disabled) </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> The hue level for the video device. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionInput">input </a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: 0 - 7, 8 = disabled<br />Default: 8 (disabled) </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Input channel to use expressed as an integer number starting from 0. Should normally be set to 1 for video/TV cards, and 8 for USB cameras. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionJpegFilename">jpeg_filename</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: %v-%Y%m%d%H%M%S-%q </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> File path for motion triggered images (jpeg or ppm) relative to target_dir. Value 'preview' makes a jpeg filename with the same name body as the associated saved mpeg movie file. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionLightswitch">lightswitch </a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: 0 - 100<br />Default: 0 (disabled) </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Ignore sudden massive light intensity changes given as a percentage of the picture area that changed intensity. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionLocate">locate</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: on, off, preview<br />Default: off </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Locate and draw a box around the moving object. Value 'preview' makes Motion only draw a box on a saved preview jpeg image and not on the saved mpeg movie. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionMaskFile">mask_file</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: Not defined </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> PGM file to use as a sensitivity mask. This picture MUST have the same width and height as the frames being captured and be in binary format. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionMaxMpegTime">max_mpeg_time</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: 0 (infinite) - 2147483647<br />Default: 3600 </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> The maximum length of an mpeg movie in seconds. Set this to zero for unlimited length. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionMinimumFrameTime">minimum_frame_time</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: 0 - 2147483647<br />Default: 0 </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Minimum time in seconds between the capturing picture frames from the camera. Default: 0 = disabled - the capture rate is given by the camera framerate. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionMinimumMotionFrames">minimum_motion_frames</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: 1 - 1000s<br />Default: 1 </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Picture frames must contain motion at least the specified number of frames in a row before they are detected as true motion. At the default of 1, all motion is detected. Valid range is 1 to thousands, but it is recommended to keep it within 1-5. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionMotionVideoPipe">motion_video_pipe</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: Not defined </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> The video4linux video loopback input device for motion images. If a particular pipe is to be used then use the device filename of this pipe, if a dash '-' is given motion will use /proc/video/vloopback/vloopbacks to locate a free pipe. Default: not set </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionMovieFilename">movie_filename</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: %v-%Y%m%d%H%M%S </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> File path for motion triggered ffmpeg movies (mpeg) relative to target_dir. This was previously called ffmpeg_filename. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionMysqlDb">mysql_db</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: Not defined </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Name of the MySQL database. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionMysqlHost">mysql_host</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: localhost </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> IP address or domain name for the MySQL server. Use "localhost" if motion and MySQL runs on the same server. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionMysqlPassword">mysql_password</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: Not defined </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> The MySQL password. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionMysqlUser">mysql_user</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: Not defined </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> The MySQL user name. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionNetcamHttp">netcam_http</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: 1.0, keep_alive, 1.1<br />Default: 1.0 </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> The setting for keep-alive of network socket, should improve performance on compatible net cameras. ( new in 3.2.10 ) <br /> </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionNetcamProxy">netcam_proxy</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: Not defined </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> URL to use for a netcam proxy server, if required. The syntax is <a href="http://myproxy:portnumber" rel="nofollow" target="_top">http://myproxy:portnumber</a> </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionNetcamTolerantCheck">netcam_tolerant_check</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: on, off <br />Default: off </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Set less strict jpeg checks for network cameras with a poor/buggy firmware. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionNetcamUrl">netcam_url</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: Not defined </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Specify an url to a downloadable jpeg file or raw mjpeg stream to use as input device. Such as an AXIS 2100 network camera. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionNetcamUserpass">netcam_userpass</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: Not defined </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> For network cameras protected by username and password, use this option for HTTP 1.1 Basic authentication. The string is specified as username:password. Do not specify this option for no authentication. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionNoiseLevel">noise_level</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: 1 - 255<br />Default: 32 </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> The noise level is used as a threshold for distinguishing between noise and motion. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionNoiseTune">noise_tune</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: on, off<br />Default: on </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Activates the automatic tuning of noise level. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionNorm">norm</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: 0 (PAL), 1 (NTSC), 2 (SECAM), 3 (PAL NC no colour)<br />Default: 0 (PAL) </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Select the norm of the video device. Values: 0 (PAL), 1 (NTSC), 2 (SECAM), 3 (PAL NC no colour). Default: 0 (PAL) </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionOnAreaDetected">on_area_detected</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: Not defined </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Command to be executed when motion in a predefined area is detected. Check option area_detect. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionOnCameraLost">on_camera_lost</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: Not defined </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Command to be executed when a camera can't be opened or if it is lost. You can use <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">Conversion Specifiers</a> and spaces as part of the command. Use %f for passing filename (with full path) to the command. (new in 3.2.10) </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionOnEventEnd">on_event_end</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: Not defined </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Command to be executed when an event ends after a period of no motion. The period of no motion is defined by option gap. You can use <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">Conversion Specifiers</a> and spaces as part of the command. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionOnEventStart">on_event_start</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: Not defined </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Command to be executed when an event starts. An event starts at first motion detected after a period of no motion defined by gap. You can use <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">ConversionSpecifiers</a> and spaces as part of the command. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionOnMotionDetected">on_motion_detected</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: Not defined </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Command to be executed when a motion frame is detected. You can use <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">Conversion Specifiers</a> and spaces as part of the command. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionOnMovieEnd">on_movie_end</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: Not defined </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Command to be executed when an ffmpeg movie is closed at the end of an event. You can use <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">Conversion Specifiers</a> and spaces as part of the command. Use %f for passing filename (with full path) to the command. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionOnMovieStart">on_movie_start</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: Not defined </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Command to be executed when an mpeg movie is created. You can use <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">Conversion Specifiers</a> and spaces as part of the command. Use %f for passing filename (with full path) to the command. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionOnPictureSave">on_picture_save</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: Not defined </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Command to be executed when an image is saved. You can use <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">Conversion Specifiers</a> and spaces as part of the command. Use %f for passing filename (with full path) to the command. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionOutputAll">output_all</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: on, off<br />Default: off </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Picture are saved continuously as if motion was detected all the time. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionOutputMotion">output_motion</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: on, off<br />Default: off </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Output pictures with only the moving object. This feature generates the special motion type movies where you only see the pixels that changes as a graytone image. If labelling is enabled you see the largest area in blue. Smartmask is shown in red. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionOutputNormal">output_normal</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: on, off, first, best, center (since 3.2.10)<br />Default: on </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Normal image is an image that is stored when motion is detected. It is the same image that was taken by the camera. I.e. not a motion image like defined by output_motion. Default is that normal images are stored. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionPgsqlDb">pgsql_db</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: Not defined </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Name of the PostgreSQL database. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionPgsqlHost">pgsql_host</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: localhost </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> IP address or domain name for the PostgreSQL server. Use "localhost" if motion and PostgreSQL runs on the same server. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionPgsqlPassword">pgsql_password</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: Not defined </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> The PostgreSQL password. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionPgsqlPort">pgsql_port</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: 0 - 65535<br />Default: 5432 </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> The PostgreSQL server port number. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionPgsqlUser">pgsql_user</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: Not defined </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> The PostgreSQL user name. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionPostCapture">post_capture</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: 0 - 2147483647 <br />Default: 0 (disabled) </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Specifies the number of frames to be captured after motion has been detected. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionPpm">ppm</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: on, off<br />Default: off </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Output ppm images instead of jpeg. This uses less CPU time, but causes a LOT of hard disk I/O, and it is generally slower than jpeg. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionPreCapture">pre_capture</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: 0 - 100s<br />Default: 0 (disabled) </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Specifies the number of previous frames to be outputted at motion detection. Recommended range: 0 to 5, default=0. Do not use large values! Large values will cause Motion to skip video frames and cause unsmooth mpegs. To smooth mpegs use larger values of post_capture instead. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionProcessIdFile">process_id_file</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: Not defined </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> File to store the process ID, also called pid file. Recommended value when used: /var/run/motion.pid </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionQuality">quality</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: 1 - 100<br />Default: 75 </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> The quality for the jpeg images in percent. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionQuiet">quiet</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: on, off<br />Default: off </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Be quiet, don't output beeps when detecting motion. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionRotate">rotate</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: 0, 90, 180, 270<br />Default: 0 (not rotated) </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Rotate image the given number of degrees. The rotation affects all saved images as well as mpeg movies. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionRoundrobinFrames">roundrobin_frames</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: 1 - 2147483647<br />Default: 1 </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Specifies the number of frames to capture before switching inputs, this way also slow switching (e.g. every second) is possible. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionRoundrobinSkip">roundrobin_skip</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: 1 - 2147483647<br />Default: 1 </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Specifies the number of frames to skip after a switch. (1 if you are feeling lucky, 2 if you want to be safe). </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionSaturation">saturation</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: 0 - 255<br />Default: 0 (disabled) </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> The colour saturation level for the video device. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionSetupMode">setup_mode</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: on, off<br />Default: off </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Run Motion in setup mode. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionSmartMaskSpeed">smart_mask_speed</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: 0 - 10<br />Default: 0 (disabled) </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Slugginess of the smart mask. Default is 0 = DISABLED. 1 is slow, 10 is fast. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionSnapshotFilename">snapshot_filename</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: %v-%Y%m%d%H%M%S-snapshot </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> File path for snapshots (jpeg or ppm) relative to target_dir. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionSnapshotInterval">snapshot_interval</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: 0 - 2147483647<br />Default: 0 (disabled) </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Make automated snapshots every 'snapshot_interval' seconds. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionSqlLogImage">sql_log_image</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: on, off<br />Default: on </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Log to the database when creating motion triggered image file. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionSqlLogMpeg">sql_log_mpeg</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: on, off<br />Default: off </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Log to the database when creating motion triggered mpeg file. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionSqlLogSnapshot">sql_log_snapshot</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: on, off<br />Default: on </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Log to the database when creating a snapshot image file. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionSqlLogTimelapse">sql_log_timelapse</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: on, off<br />Default: off </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Log to the database when creating timelapse mpeg file </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionSqlQuery">sql_query</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: insert into security(camera, filename, frame, file_type, time_stamp, text_event) values('%t', '%f', '%q', '%n', '%Y-%m-%d %T', '%C') </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> SQL query string that is sent to the database. The values for each field are given by using <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">convertion specifiers</a> </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionSwitchfilter">switchfilter</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: on, off<br />Default: off </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Turns the switch filter on or off. The filter can distinguish between most switching noise and real motion. With this you can even set roundrobin_skip to 1 without generating much false detection. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTargetDir">target_dir</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: Not defined = current working directory </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Target directory for picture and movie files. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTextChanges">text_changes</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: on, off<br />Default: off </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Turns the text showing changed pixels on/off. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTextDouble">text_double</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: on, off<br />Default: off </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Draw characters at twice normal size on images. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTextEvent">text_event</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: %Y%m%d%H%M%S </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> This option defines the value of the speciel event conversion specifier %C. You can use any conversion specifier in this option except %C. Date and time values are from the timestamp of the first image in the current event. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTextLeft">text_left</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: Not defined </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> User defined text overlayed on each in the lower left corner. Use A-Z, a-z, 0-9, " / ( ) @ ~ # &lt; &gt; , . : - + _ \n and vertical bar and <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">conversion specifiers</a> (codes starting by a %). </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTextRight">text_right</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: %Y-%m-%d\n%T </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> User defined text overlayed on each in the lower right corner. Use A-Z, a-z, 0-9, " / ( ) @ ~ # &lt; &gt; , . : - + _ \n and vertical bar and <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">conversion specifiers</a> (codes starting by a %). Default: %Y-%m-%d\n%T = date in ISO format and time in 24 hour clock </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionThread">thread</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: Not defined </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Specifies full path and filename for a thread config file. Each camera needs a thread config file containing the options that are unique to the camera. If you only have one camera you do not need thread config files. If you have two or more cameras you need one thread config file for each camera in addition to motion.conf. This option must be placed in motion.conf and not in a thread config file. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionThreshold">threshold</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: 1 - 2147483647<br />Default: 1500 </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Threshold for declaring motion. The threshold is the number of changed pixels counted after noise filtering, masking, despeckle, and labelling. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionThresholdTune">threshold_tune</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: on, off<br />Default: off </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Activates the automatic tuning of threshold level. ( It's broken ) </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTimelapseFilename">timelapse_filename</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: %v-%Y%m%d-timelapse </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> File path for timelapse mpegs relative to target_dir (ffmpeg only). </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTrackAuto">track_auto</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: on, off<br />Default: off </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Enable auto tracking </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTrackIomojoId">track_iomojo_id</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: 0 - 65535<br />Default: 0 </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Use this option if you have an iomojo smilecam connected to the serial port instead of a general stepper motor controller. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTrackMaxx">track_maxx</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: 0 - 65535<br />Default: 0 </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> The maximum position for servo x. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTrackMaxy">track_maxy</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: 0 - 65535<br />Default: 0 </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> The maximum position for servo y. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTrackMotorx">track_motorx</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: 0 - 65535<br />Default: 0 </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> The motor number that is used for controlling the x-axis. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTrackMotory">track_motory</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: 0 - 65535<br />Default: 0 </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> The motor number that is used for controlling the y-axis. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTrackMoveWait">track_move_wait</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: 0 - 65535<br />Default: 10 </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Delay during which tracking is disabled after auto tracking has moved the camera. Delay is defined as number of picture frames. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTrackPort">track_port</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: Not defined </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> This is the device name of the serial port to which the stepper motor interface is connected. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTrackSpeed">track_speed</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: 0 - 255<br />Default: 255 </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Speed to set the motor to. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTrackStepAngleX">track_step_angle_x</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: 0-90<br />Default: 10 </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Angle in degrees the camera moves per step on the X-axis with auto tracking. Currently only used with pwc type cameras. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTrackStepAngleY">track_step_angle_y</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: 0-40<br />Default: 10 </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Angle in degrees the camera moves per step on the Y-axis with auto tracking. Currently only used with pwc type cameras. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTrackStepsize">track_stepsize</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: 0 - 255<br />Default: 40 </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Number of steps to make. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTrackType">track_type</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: 0 (none), 1 (stepper), 2 (iomojo), 3 (pwc), 4 (generic), 5 (uvcvideo)<br />Default: 0 (None) </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Type of tracker. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTunerdevice">tunerdevice</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: /dev/tuner0 </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> The tuner device used for controlling the tuner in a tuner card. This option is only used when Motion is compiled for <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/FreeBSD">FreeBSD</a>. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionV4L2Palette">v4l2_palette</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: 0 - 8<br />Default: 8 </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Allow to choose preferable palette to be use by motion<br /> to capture from those supported by your videodevice. ( new in 3.2.10 ) </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionVideoPipe">video_pipe</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: Not defined </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> The video4linux video loopback input device for normal images. If a particular pipe is to be used then use the device filename of this pipe. If a dash '-' is given motion will use /proc/video/vloopback/vloopbacks to locate a free pipe. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionVideodevice">videodevice</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: Max 4095 characters<br />Default: /dev/video0 (<a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/FreeBSD">FreeBSD</a>: /dev/bktr0) </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> The video device to be used for capturing. Default for Linux is /dev/video0. for <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/FreeBSD">FreeBSD</a> the default is /dev/bktr0. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionWebcamLimit">webcam_limit</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: 0 - 2147483647<br />Default: 0 (unlimited) </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Limit the number of frames to number frames. After 'webcam_limit' number of frames the connection will be closed by motion. The value 0 means unlimited. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionWebcamLocalhost">webcam_localhost</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: on, off<br />Default: on </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Limits the access to the webcam to the localhost. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionWebcamMaxrate">webcam_maxrate</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: 1 - 100<br />Default: 1 </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> Limit the framerate of the webcam in frames per second. Default is 1. Set the value to 100 for practically unlimited. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionWebcamMotion">webcam_motion</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: on, off<br />Default: off </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> If set to 'on' Motion sends slows down the webcam stream to 1 picture per second when no motion is detected. When motion is detected the stream runs as defined by webcam_maxrate. When 'off' the webcam stream always runs as defined by webcam_maxrate. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionWebcamPort">webcam_port</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: 0 - 65535<br />Default: 0 (disabled) </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> TCP port on which motion will listen for incoming connects with its webcam server. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionWebcamQuality">webcam_quality</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: 1 - 100<br />Default: 50 </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> Quality setting in percent for the mjpeg picture frames transferred over the webcam connection. Keep it low to restrict needed bandwidth. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol foswikiLast"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionWidth">width</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1 foswikiLast"> Values: Device Dependent<br />Default: 352 </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol foswikiLast"> The width in pixels of each frame. Valid range is camera dependent. </td>
-		</tr>
-	</tbody></table>
-<p />
-<h3><a name="Obsolete_Options"></a> Obsolete Options </h3>
-<p />
-<table cellspacing="0" id="table9" cellpadding="0" class="foswikiTable" rules="rows" border="1">
-	<thead>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<th width="170" bgcolor="#687684" align="left" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a rel="nofollow" href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument;sortcol=0;table=9;up=0#sorted_table" title="Sort by this column"><font color="#ffffff">Option</font></a> </th>
-			<th width="240" bgcolor="#687684" align="left" valign="top" class="foswikiTableCol1"> <a rel="nofollow" href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument;sortcol=1;table=9;up=0#sorted_table" title="Sort by this column"><font color="#ffffff">Range/Values<br />Default</font></a> </th>
-			<th bgcolor="#687684" align="left" valign="top" class="foswikiTableCol2 foswikiLastCol"> <a rel="nofollow" href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument;sortcol=2;table=9;up=0#sorted_table" title="Sort by this column"><font color="#ffffff">Description</font></a> </th>
-		</tr>
-	</thead>
-	<tbody>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionLowCpu">low_cpu</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> Values: 0 - 100<br />Default: 0 (disabled) </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> When this option is not zero motion will be in a low cpu mode while not detecting motion. In low cpu mode Motion reduces the framerate to the value given for this option. Value zero means disabled. ( DEPRECATED ) </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="170" bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionMinimumGap">minimum_gap</a> </td>
-			<td width="240" bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> Values: 0 - 2147483647<br />Default: 0 (no minimum) </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> The minimum time between two shots in seconds. ( DEPRECATED ) </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="170" bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol foswikiLast"> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionNightCompensate">night_compensate</a> </td>
-			<td width="240" bgcolor="#ffffff" valign="top" class="foswikiTableCol1 foswikiLast"> Values: on, off<br />Default: off </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol foswikiLast"> When this option is set the noise threshold will be lowered if the picture is dark. This will improve the sensitivity in dark places. However it might also increase the number of false alarms since most cameras also increase light sensitivity with their AGC (Automatic Gain Control) and this will increase noise. ( DEPRECATED ) </td>
-		</tr>
-	</tbody></table>
-<p />
-<p />
+<table style="border-width:1px;" cellspacing="0" cellpadding="0" class="twikiTable" border="1"><tr class="twikiTableEven"><th bgcolor="#6b7f93" align="left" valign="top" style="text-align:left;vertical-align:top;" class="twikiFirstCol" maxcols="0"> <a rel="nofollow" href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideOneLargeDocument&amp;amp;sortcol=0;table=8;up=0#sorted_table" style="color:#ffffff" title="Sort by this column">Option</a> </th><th bgcolor="#6b7f93" align="left" valign="top" style="text-align:left;vertical-align:top;" maxcols="0"> <a rel="nofollow" href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideOneLargeDocument&amp;amp;sortcol=1;table=8;up=0#sorted_table" style="color:#ffffff" title="Sort by this column">Range/Values<br />Default</a> </th><th bgcolor="#6b7f93" align="left" valign="top" style="text-align:left;vertical-align:top;" maxcols="0"> <a rel="nofollow" href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideOneLargeDocument&amp;amp;sortcol=2;table=8;up=0#sorted_table" style="color:#ffffff" title="Sort by this column">Description</a> </th></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionAutoBrightness" class="twikiLink">auto_brightness</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: on, off<br />Default: off </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Let motion regulate the brightness of a video device. Only recommended for cameras without auto brightness </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionBrightness" class="twikiLink">brightness</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: 0 - 255<br />Default: 0 (disabled) </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> The brightness level for the video device. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionContrast" class="twikiLink">contrast</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: 0 - 255<br />Default: 0 (disabled) </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> The contrast level for the video device. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionControlAuthentication" class="twikiLink">control_authentication</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: Max 4096 characters<br />Default: Not defined </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> To protect HTTP Control by username and password, use this option for HTTP 1.1 Basic authentication. The string is specified as username:password. Do not specify this option for no authentication. This option must be placed in motion.conf and not in a thread config file. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionControlHtmlOutput" class="twikiLink">control_html_output</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: on, off<br />Default: on </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Enable HTML in the answer sent back to a browser connecting to the control_port. This option must be placed in motion.conf and not in a thread config file. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionControlLocalhost" class="twikiLink">control_localhost</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: on, off<br />Default: on </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Limits the http (html) control to the localhost. This option must be placed in motion.conf and not in a thread config file. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionControlPort" class="twikiLink">control_port</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: 0 - 65535<br />Default: 0 (disabled) </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Sets the port number for the http (html using browser) based remote control. This option must be placed in motion.conf and not in a thread config file. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionDaemon" class="twikiLink">daemon</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: on, off<br />Default: off </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Start in daemon (background) mode and release terminal. This option must be placed in motion.conf and not in a thread config file. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionDespeckle" class="twikiLink">despeckle</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: EedDl<br />Default: Not defined </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Despeckle motion image using combinations of (E/e)rode or (D/d)ilate. And ending with optional (l)abeling. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionFfmpegBps" class="twikiLink">ffmpeg_bps</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: 0 - 9999999<br />Default: 400000 </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Bitrate of mpegs produced by ffmpeg. Bitrate is bits per second. Default: 400000 (400kbps). Higher value mans better quality and larger files. Option requires that ffmpeg libraries are installed. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionFfmpegCapMotion" class="twikiLink">ffmpeg_cap_motion</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: on, off<br />Default: off </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Use ffmpeg libraries to encode motion type mpeg movies where you only see the pixels that changes. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionFfmpegCapNew" class="twikiLink">ffmpeg_cap_new</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: on, off<br />Default: off </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Use ffmpeg libraries to encode mpeg movies in realtime. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionFfmpegDeinterlace" class="twikiLink">ffmpeg_deinterlace</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: on, off<br />Default: off </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Use ffmpeg to deinterlace video. Necessary if you use an analog camera and see horizontal combing on moving objects in video or pictures. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionFfmpegFilename" class="twikiLink">ffmpeg_filename (now called movie_filename)</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: %v-%Y%m%d%H%M%S </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> File path for motion triggered ffmpeg movies (mpeg) relative to target_dir. This option was renamed to movie_filename in 3.2.5 to enable better integration of alternative movie libraries to the current ffmpeg solution. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionFfmpegTimelapse" class="twikiLink">ffmpeg_timelapse</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: 0 - 2147483647<br />Default: 0 (disabled) </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Create a timelapse movie saving a picture frame at the interval in seconds set by this parameter. Set it to 0 if not used. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionFfmpegTimelapseMode" class="twikiLink">ffmpeg_timelapse_mode</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: hourly, daily, weekly-sunday, weekly-monday, monthly, manual<br />Default: daily </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> The file rollover mode of the timelapse video. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionFfmpegVariableBitrate" class="twikiLink">ffmpeg_variable_bitrate</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: 0, 2 - 31<br />Default: 0 (disabled) </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Enables and defines variable bitrate for the ffmpeg encoder. ffmpeg_bps is ignored if variable bitrate is enabled. Valid values: 0 (default) = fixed bitrate defined by ffmpeg_bps, or the range 2 - 31 where 2 means best quality and 31 is worst. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionFfmpegVideoCodec" class="twikiLink">ffmpeg_video_codec</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: mpeg1 (ffmpeg-0.4.8 only), mpeg4, msmpeg4, swf, flv, ffv1<br />Default: mpeg4 </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Codec to be used by ffmpeg for the video compression. Timelapse mpegs are always made in mpeg1 format independent from this option. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionFramerate" class="twikiLink">framerate</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: 2 - 100<br />Default: 100 (no limit) </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Maximum number of frames to be captured from the camera per second. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionFrequency" class="twikiLink">frequency</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: 0 - 999999<br />Default: 0 (Not set) </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> The frequency to set the tuner to (kHz). Valid range: per tuner spec, default: 0 (Don't set it) </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionGap" class="twikiLink">gap</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: 0 - 2147483647<br />Default: 60 </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Gap is the seconds of no motion detection that triggers the end of an event. An event is defined as a series of motion images taken within a short timeframe. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionHeight" class="twikiLink">height </a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: Device Dependent<br />Default: 288 </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> The height of each frame in pixels. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionHue" class="twikiLink">hue</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: 0 - 255<br />Default: 0 (disabled) </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> The hue level for the video device. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionInput" class="twikiLink">input </a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: 0 - 7, 8 = disabled<br />Default: 8 (disabled) </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Input channel to use expressed as an integer number starting from 0. Should normally be set to 1 for video/TV cards, and 8 for USB cameras. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionJpegFilename" class="twikiLink">jpeg_filename</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: %v-%Y%m%d%H%M%S-%q </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> File path for motion triggered images (jpeg or ppm) relative to target_dir. Value 'preview' makes a jpeg filename with the same name body as the associated saved mpeg movie file. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionLightswitch" class="twikiLink">lightswitch </a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: 0 - 100<br />Default: 0 (disabled) </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Ignore sudden massive light intensity changes given as a percentage of the picture area that changed intensity. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionLocate" class="twikiLink">locate</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: on, off, preview<br />Default: off </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Locate and draw a box around the moving object. Value 'preview' makes Motion only draw a box on a saved preview jpeg image and not on the saved mpeg movie. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionLowCpu" class="twikiLink">low_cpu</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: 0 - 100<br />Default: 0 (disabled) </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> When this option is not zero motion will be in a low cpu mode while not detecting motion. In low cpu mode Motion reduces the framerate to the value given for this option. Value zero means disabled. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionMaskFile" class="twikiLink">mask_file</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: Not defined </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> PGM file to use as a sensitivity mask. This picture MUST have the same width and height as the frames being captured and be in binary format. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionMaxMpegTime" class="twikiLink">max_mpeg_time</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: 0 (infinite) - 2147483647<br />Default: 3600 </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> The maximum length of an mpeg movie in seconds. Set this to zero for unlimited length. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionMinimumFrameTime" class="twikiLink">minimum_frame_time</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: 0 - 2147483647<br />Default: 0 </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Minimum time in seconds between the capturing picture frames from the camera. Default: 0 = disabled - the capture rate is given by the camera framerate. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionMinimumGap" class="twikiLink">minimum_gap</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: 0 - 2147483647<br />Default: 0 (no minimum) </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> The minimum time between two shots in seconds. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionMinimumMotionFrames" class="twikiLink">minimum_motion_frames</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: 1 - 1000s<br />Default: 1 </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Picture frames must contain motion at least the specified number of frames in a row before they are detected as true motion. At the default of 1, all motion is detected. Valid range is 1 to thousands, but it is recommended to keep it within 1-5. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionMotionVideoPipe" class="twikiLink">motion_video_pipe</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: Not defined </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> The video4linux video loopback input device for motion images. If a particular pipe is to be used then use the device filename of this pipe, if a dash '-' is given motion will use /proc/video/vloopback/vloopbacks to locate a free pipe. Default: not set </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionMovieFilename" class="twikiLink">movie_filename</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: %v-%Y%m%d%H%M%S </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> File path for motion triggered ffmpeg movies (mpeg) relative to target_dir. This was previously called ffmpeg_filename. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionMysqlDb" class="twikiLink">mysql_db</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: Not defined </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Name of the MySQL database. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionMysqlHost" class="twikiLink">mysql_host</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: localhost </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> IP address or domain name for the MySQL server. Use "localhost" if motion and MySQL runs on the same server. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionMysqlPassword" class="twikiLink">mysql_password</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: Not defined </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> The MySQL password. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionMysqlUser" class="twikiLink">mysql_user</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: Not defined </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> The MySQL user name. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionNetcamProxy" class="twikiLink">netcam_proxy</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: Not defined </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> URL to use for a netcam proxy server, if required. The syntax is <a href="http://myproxy:portnumber" rel="nofollow" target="_top">http://myproxy:portnumber</a> </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionNetcamUrl" class="twikiLink">netcam_url</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: Not defined </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Specify an url to a downloadable jpeg file or raw mjpeg stream to use as input device. Such as an AXIS 2100 network camera. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionNetcamUserpass" class="twikiLink">netcam_userpass</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: Not defined </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> For network cameras protected by username and password, use this option for HTTP 1.1 Basic authentication. The string is specified as username:password. Do not specify this option for no authentication. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionNightCompensate" class="twikiLink">night_compensate</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: on, off<br />Default: off </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> When this option is set the noise threshold will be lowered if the picture is dark. This will improve the sensitivity in dark places. However it might also increase the number of false alarms since most cameras also increase light sensitivity with their AGC (Automatic Gain Control) and this will increase noise. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionNoiseLevel" class="twikiLink">noise_level</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: 1 - 255<br />Default: 32 </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> The noise level is used as a threshold for distinguishing between noise and motion. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionNoiseTune" class="twikiLink">noise_tune</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: on, off<br />Default: on </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Activates the automatic tuning of noise level. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionNorm" class="twikiLink">norm</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: 0 (PAL), 1 (NTSC), 2 (SECAM), 3 (PAL NC no colour)<br />Default: 0 (PAL) </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Select the norm of the video device. Values: 0 (PAL), 1 (NTSC), 2 (SECAM), 3 (PAL NC no colour). Default: 0 (PAL) </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionOnEventEnd" class="twikiLink">on_event_end</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: Not defined </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Command to be executed when an event ends after a period of no motion. The period of no motion is defined by option gap. You can use <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">Conversion Specifiers</a> and spaces as part of the command. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionOnEventStart" class="twikiLink">on_event_start</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: Not defined </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Command to be executed when an event starts. An event starts at first motion detected after a period of no motion defined by gap. You can use <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">ConversionSpecifiers</a> and spaces as part of the command. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionOnMotionDetected" class="twikiLink">on_motion_detected</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: Not defined </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Command to be executed when a motion frame is detected. You can use <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">Conversion Specifiers</a> and spaces as part of the command. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionOnMovieEnd" class="twikiLink">on_movie_end</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: Not defined </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Command to be executed when an ffmpeg movie is closed at the end of an event. You can use <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">Conversion Specifiers</a> and spaces as part of the command. Use %f for passing filename (with full path) to the command. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionOnMovieStart" class="twikiLink">on_movie_start</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: Not defined </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Command to be executed when an mpeg movie is created. You can use <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">Conversion Specifiers</a> and spaces as part of the command. Use %f for passing filename (with full path) to the command. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionOnPictureSave" class="twikiLink">on_picture_save</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: Not defined </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Command to be executed when an image is saved. You can use <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">Conversion Specifiers</a> and spaces as part of the command. Use %f for passing filename (with full path) to the command. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionOutputAll" class="twikiLink">output_all</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: on, off<br />Default: off </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Picture are saved continuously as if motion was detected all the time. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionOutputMotion" class="twikiLink">output_motion</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: on, off<br />Default: off </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Output pictures with only the moving object. This feature generates the special motion type movies where you only see the pixels that changes as a graytone image. If labelling is enabled you see the largest area in blue. Smartmask is shown in red. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionOutputNormal" class="twikiLink">output_normal</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: on, off, first, best<br />Default: on </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Normal image is an image that is stored when motion is detected. It is the same image that was taken by the camera. I.e. not a motion image like defined by output_motion. Default is that normal images are stored. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionPgsqlDb" class="twikiLink">pgsql_db</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: Not defined </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Name of the PostgreSQL database. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionPgsqlHost" class="twikiLink">pgsql_host</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: localhost </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> IP address or domain name for the PostgreSQL server. Use "localhost" if motion and PostgreSQL runs on the same server. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionPgsqlPassword" class="twikiLink">pgsql_password</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: Not defined </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> The PostgreSQL password. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionPgsqlPort" class="twikiLink">pgsql_port</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: 0 - 65535<br />Default: 5432 </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> The PostgreSQL server port number. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionPgsqlUser" class="twikiLink">pgsql_user</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: Not defined </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> The PostgreSQL user name. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionPostCapture" class="twikiLink">post_capture</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: 0 - 2147483647 <br />Default: 0 (disabled) </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Specifies the number of frames to be captured after motion has been detected. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionPpm" class="twikiLink">ppm</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: on, off<br />Default: off </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Output ppm images instead of jpeg. This uses less CPU time, but causes a LOT of hard disk I/O, and it is generally slower than jpeg. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionPreCapture" class="twikiLink">pre_capture</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: 0 - 100s<br />Default: 0 (disabled) </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Specifies the number of previous frames to be outputted at motion detection. Recommended range: 0 to 5, default=0. Do not use large values! Large values will cause Motion to skip video frames and cause unsmooth mpegs. To smooth mpegs use larger values of post_capture instead. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionProcessIdFile" class="twikiLink">process_id_file</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: Not defined </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> File to store the process ID, also called pid file. Recommended value when used: /var/run/motion.pid </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionQuality" class="twikiLink">quality</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: 1 - 100<br />Default: 75 </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> The quality for the jpeg images in percent. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionQuiet" class="twikiLink">quiet</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: on, off<br />Default: off </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Be quiet, don't output beeps when detecting motion. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionRotate" class="twikiLink">rotate</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: 0, 90, 180, 270<br />Default: 0 (not rotated) </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Rotate image the given number of degrees. The rotation affects all saved images as well as mpeg movies. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionRoundrobinFrames" class="twikiLink">roundrobin_frames</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: 1 - 2147483647<br />Default: 1 </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Specifies the number of frames to capture before switching inputs, this way also slow switching (e.g. every second) is possible. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionRoundrobinSkip" class="twikiLink">roundrobin_skip</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: 1 - 2147483647<br />Default: 1 </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Specifies the number of frames to skip after a switch. (1 if you are feeling lucky, 2 if you want to be safe). </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionSaturation" class="twikiLink">saturation</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: 0 - 255<br />Default: 0 (disabled) </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> The colour saturation level for the video device. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionSetupMode" class="twikiLink">setup_mode</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: on, off<br />Default: off </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Run Motion in setup mode. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionSmartMaskSpeed" class="twikiLink">smart_mask_speed</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: 0 - 10<br />Default: 0 (disabled) </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Slugginess of the smart mask. Default is 0 = DISABLED. 1 is slow, 10 is fast. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionSnapshotFilename" class="twikiLink">snapshot_filename</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: %v-%Y%m%d%H%M%S-snapshot </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> File path for snapshots (jpeg or ppm) relative to target_dir. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionSnapshotInterval" class="twikiLink">snapshot_interval</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: 0 - 2147483647<br />Default: 0 (disabled) </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Make automated snapshots every 'snapshot_interval' seconds. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionSqlLogImage" class="twikiLink">sql_log_image</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: on, off<br />Default: on </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Log to the database when creating motion triggered image file. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionSqlLogMpeg" class="twikiLink">sql_log_mpeg</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: on, off<br />Default: off </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Log to the database when creating motion triggered mpeg file. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionSqlLogSnapshot" class="twikiLink">sql_log_snapshot</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: on, off<br />Default: on </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Log to the database when creating a snapshot image file. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionSqlLogTimelapse" class="twikiLink">sql_log_timelapse</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: on, off<br />Default: off </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Log to the database when creating timelapse mpeg file </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionSqlQuery" class="twikiLink">sql_query</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: insert into security(camera, filename, frame, file_type, time_stamp, text_event) values('%t', '%f', '%q', '%n', '%Y-%m-%d %T', '%C') </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> SQL query string that is sent to the database. The values for each field are given by using <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">convertion specifiers</a> </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionSwitchfilter" class="twikiLink">switchfilter</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: on, off<br />Default: off </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Turns the switch filter on or off. The filter can distinguish between most switching noise and real motion. With this you can even set roundrobin_skip to 1 without generating much false detection. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTargetDir" class="twikiLink">target_dir</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: Not defined = current working directory </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Target directory for picture and movie files. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTextChanges" class="twikiLink">text_changes</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: on, off<br />Default: off </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Turns the text showing changed pixels on/off. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTextDouble" class="twikiLink">text_double</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: on, off<br />Default: off </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Draw characters at twice normal size on images. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTextEvent" class="twikiLink">text_event</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: %Y%m%d%H%M%S </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> This option defines the value of the speciel event conversion specifier %C. You can use any conversion specifier in this option except %C. Date and time values are from the timestamp of the first image in the current event. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTextLeft" class="twikiLink">text_left</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: Not defined </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> User defined text overlayed on each in the lower left corner. Use A-Z, a-z, 0-9, " / ( ) @ ~ # &lt; &gt; \ , . : - + _ \n and <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">conversion specifiers</a> (codes starting by a %). </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTextRight" class="twikiLink">text_right</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: %Y-%m-%d\n%T </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> User defined text overlayed on each in the lower right corner. Use A-Z, a-z, 0-9, " / ( ) @ ~ # &lt; &gt; , . : - + _ \n and <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">conversion specifiers</a> (codes starting by a %). Default: %Y-%m-%d\n%T = date in ISO format and time in 24 hour clock </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionThread" class="twikiLink">thread</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: Not defined </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Specifies full path and filename for a thread config file. Each camera needs a thread config file containing the options that are unique to the camera. If you only have one camera you do not need thread config files. If you have two or more cameras you need one thread config file for each camera in addition to motion.conf. This option must be placed in motion.conf and not in a thread config file. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionThreshold" class="twikiLink">threshold</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: 1 - 2147483647<br />Default: 1500 </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Threshold for declaring motion. The threshold is the number of changed pixels counted after noise filtering, masking, despeckle, and labelling. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionThresholdTune" class="twikiLink">threshold_tune</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: on, off<br />Default: off </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Activates the automatic tuning of threshold level. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTimelapseFilename" class="twikiLink">timelapse_filename</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: %v-%Y%m%d-timelapse </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> File path for timelapse mpegs relative to target_dir (ffmpeg only). </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTrackAuto" class="twikiLink">track_auto</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: on, off<br />Default: off </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Enable auto tracking </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTrackIomojoId" class="twikiLink">track_iomojo_id</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: 0 - 2147483647<br />Default: 0 </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Use this option if you have an iomojo smilecam connected to the serial port instead of a general stepper motor controller. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTrackMaxx" class="twikiLink">track_maxx</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: 0 - 2147483647<br />Default: 0 </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> The maximum position for servo x. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTrackMaxy" class="twikiLink">track_maxy</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: 0 - 2147483647<br />Default: 0 </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> The maximum position for servo y. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTrackMotorx" class="twikiLink">track_motorx</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: -1 - 2147483647<br />Default: -1 </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> The motor number that is used for controlling the x-axis. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTrackMotory" class="twikiLink">track_motory</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: -1 - 2147483647<br />Default: -1 </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> The motor number that is used for controlling the y-axis. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTrackMoveWait" class="twikiLink">track_move_wait</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: 0 - 2147483647<br />Default: 10 </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Delay during which tracking is disabled after auto tracking has moved the camera. Delay is defined as number of picture frames. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTrackPort" class="twikiLink">track_port</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: Not defined </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> This is the device name of the serial port to which the stepper motor interface is connected. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTrackSpeed" class="twikiLink">track_speed</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: 0 - 255<br />Default: 255 </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Speed to set the motor to. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTrackStepAngleX" class="twikiLink">track_step_angle_x</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: 0-90<br />Default: 10 </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Angle in degrees the camera moves per step on the X-axis with auto tracking. Currently only used with pwc type cameras. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTrackStepAngleY" class="twikiLink">track_step_angle_y</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: 0-40<br />Default: 10 </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Angle in degrees the camera moves per step on the Y-axis with auto tracking. Currently only used with pwc type cameras. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTrackStepsize" class="twikiLink">track_stepsize</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: 0 - 255<br />Default: 40 </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Number of steps to make. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTrackType" class="twikiLink">track_type</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: 0 (none), 1 (stepper), 2 (iomojo), 3 (pwc), 4 (generic), 5 (uvcvideo)<br />Default: 0 (None) </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Type of tracker. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTunerdevice" class="twikiLink">tunerdevice</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: /dev/tuner0 </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> The tuner device used for controlling the tuner in a tuner card. This option is only used when Motion is compiled for <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/FreeBSD" class="twikiLink">FreeBSD</a>. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionVideoPipe" class="twikiLink">video_pipe</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: Not defined </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> The video4linux video loopback input device for normal images. If a particular pipe is to be used then use the device filename of this pipe. If a dash '-' is given motion will use /proc/video/vloopback/vloopbacks to locate a free pipe. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionVideodevice" class="twikiLink">videodevice</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: Max 4095 characters<br />Default: /dev/video0 (<a href="http://www.lavrsen.dk/twiki/bin/view/Motion/FreeBSD" class="twikiLink">FreeBSD</a>: /dev/bktr0) </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> The video device to be used for capturing. Default for Linux is /dev/video0. for <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/FreeBSD" class="twikiLink">FreeBSD</a> the default is /dev/bktr0. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionWebcamLimit" class="twikiLink">webcam_limit</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: 0 - 2147483647<br />Default: 0 (unlimited) </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Limit the number of frames to number frames. After 'webcam_limit' number of frames the connection will be closed by motion. The value 0 means unlimited. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionWebcamLocalhost" class="twikiLink">webcam_localhost</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: on, off<br />Default: on </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Limits the access to the webcam to the localhost. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionWebcamMaxrate" class="twikiLink">webcam_maxrate</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: 1 - 100<br />Default: 1 </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Limit the framerate of the webcam in frames per second. Default is 1. Set the value to 100 for practically unlimited. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionWebcamMotion" class="twikiLink">webcam_motion</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: on, off<br />Default: off </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> If set to 'on' Motion sends slows down the webcam stream to 1 picture per second when no motion is detected. When motion is detected the stream runs as defined by webcam_maxrate. When 'off' the webcam stream always runs as defined by webcam_maxrate. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionWebcamPort" class="twikiLink">webcam_port</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Values: 0 - 65535<br />Default: 0 (disabled) </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> TCP port on which motion will listen for incoming connects with its webcam server. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionWebcamQuality" class="twikiLink">webcam_quality</a> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Values: 1 - 100<br />Default: 50 </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Quality setting in percent for the mjpeg picture frames transferred over the webcam connection. Keep it low to restrict needed bandwidth. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol twikiLast"> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionWidth" class="twikiLink">width</a> </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiLast"> Values: Device Dependent<br />Default: 352 </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiLast"> The width in pixels of each frame. Valid range is camera dependent. </td></tr>
+</table>
 <p />
 <p />
-<h2><a name="Signals_sent_with_e_g_kill_comma"></a> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/SignalsKill">Signals (sent with e.g. kill command)</a> </h2>
+<h2><a name="Signals_sent_with_e_g_kill_comma"></a> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/SignalsKill" class="twikiLink">Signals (sent with e.g. kill command)</a> </h2>
 A signal can be sent from the command line by typing e.g. <code>kill -s SIGHUP pid</code>, where the last parameter is the process ID which you get by typing <code>ps -ef &brvbar; grep motion</code>. The PID is the first on the list which is the parent process for the threads.
 Motion responds to the following signals:
 <p />
-<table cellspacing="0" id="table10" cellpadding="0" class="foswikiTable" rules="rows" border="1">
-	<thead>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<th bgcolor="#687684" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a rel="nofollow" href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument;sortcol=0;table=10;up=0#sorted_table" title="Sort by this column"><font color="#ffffff">Signal</font></a> </th>
-			<th bgcolor="#687684" valign="top" class="foswikiTableCol1"> <a rel="nofollow" href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument;sortcol=1;table=10;up=0#sorted_table" title="Sort by this column"><font color="#ffffff">Description</font></a> </th>
-			<th bgcolor="#687684" valign="top" class="foswikiTableCol2 foswikiLastCol"> <a rel="nofollow" href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument;sortcol=2;table=10;up=0#sorted_table" title="Sort by this column"><font color="#ffffff">Editors comment</font></a> </th>
-		</tr>
-	</thead>
-	<tbody>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> SIGHUP </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> The config file will be reread. </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol"> This is a very useful signal when you experiment with settings in the config file. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> SIGTERM </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> If needed motion will create an mpeg file of the last event and exit </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLastCol"> &nbsp; </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol foswikiLast"> SIGUSR1 </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol1 foswikiLast"> Motion will create an mpeg file of the current event. </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2 foswikiLastCol foswikiLast"> &nbsp; </td>
-		</tr>
-	</tbody></table>
+<table style="border-width:1px;" cellspacing="0" cellpadding="0" class="twikiTable" border="1"><tr class="twikiTableEven"><th bgcolor="#6b7f93" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol" maxcols="0"> <a rel="nofollow" href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideOneLargeDocument&amp;amp;sortcol=0;table=9;up=0#sorted_table" style="color:#ffffff" title="Sort by this column">Signal</a> </th><th bgcolor="#6b7f93" align="center" valign="top" style="text-align:center;vertical-align:top;" maxcols="0"> <a rel="nofollow" href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideOneLargeDocument&amp;amp;sortcol=1;table=9;up=0#sorted_table" style="color:#ffffff" title="Sort by this column">Description</a> </th><th bgcolor="#6b7f93" align="center" valign="top" style="text-align:center;vertical-align:top;" maxcols="0"> <a rel="nofollow" href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideOneLargeDocument&amp;amp;sortcol=2;table=9;up=0#sorted_table" style="color:#ffffff" title="Sort by this column">Editors comment</a> </th></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> SIGHUP </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> The config file will be reread. </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> This is a very useful signal when you experiment with settings in the config file. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> SIGTERM </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> If needed motion will create an mpeg file of the last event and exit </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> &nbsp; </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol twikiLast"> SIGUSR1 </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiLast"> Motion will create an mpeg file of the current event. </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiLast"> &nbsp; </td></tr>
+</table>
 <p />
 <p />
-<h2><a name="Error_Logging"></a> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ErrorLogging">Error Logging</a> </h2>
+<h2><a name="Error_Logging"></a> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ErrorLogging" class="twikiLink">Error Logging</a> </h2>
 Motion reports errors to the console when it runs in non-daemon mode. And it outputs even more information when run in setup mode.
 <p />
 Error logging has been implemented so that errors during daemon (background) mode are logged in the syslog.
@@ -1816,76 +875,70 @@ The syslog is in most Linux systems the
 <p />
 <h1><a name="Motion_Guide_Basic_Features"></a> Motion Guide - Basic Features </h1>
 <p />
-<h2><a name="Capture_Device_Options_The_Basic"></a> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/CaptureDeviceOptions">Capture Device Options - The Basic Setup</a> </h2>
+<h2><a name="Capture_Device_Options_The_Basic"></a> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/CaptureDeviceOptions" class="twikiLink">Capture Device Options - The Basic Setup</a> </h2>
 Before you can start using motion you need to know some basics about your camera.
 Either you have a camera connected directly to your computer. In this case it is a video4linux type of camera. Or you connect to a network camera using a normal web URL.
 <p />
-<h2><a name="video4linux_V4L_devices"></a> video4linux (<a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/V4L">V4L</a>) devices </h2>
+<h2><a name="video4linux_V4L_devices"></a> video4linux (<a href="http://www.lavrsen.dk/twiki/bin/view/Motion/V4L" class="twikiLink">V4L</a>) devices </h2>
 You need to install your camera with the right driver. It is out of scope of this document to tell you how to do this and it depends on which type of camera. 
 <p />
 Once installed the camera(s) will have the device names /dev/video0, /dev/video1, /dev/video2...
 <p />
 FreeBSD has a different naming of devices. When you build Motion for FreeBSD the default device name is /dev/bktr0. Under FreeBSD a TV card has a special device for controlling the tuner (e.g. /dev/tuner0). The option tunerdevice is only valid when Motion is built and running under FreeBSD. For Linux do not include this option in the config file (remove or comment out). 
 <p />
-<strong>USB cameras</strong> take a lot of bandwidth. A USB camera connected to a USB 1.1 port or hub consumes all the bandwidth. Even with a small framesize and low framerate you should not expect to have more than one camera per USB 1.1 controller. If you need more than 1 USB camera add extra USB PCI cards to your computer. There exists cards that have 4 inputs each with their own controller and with full bandwidth. Many 4-input cards only have 1 controller. USB cameras do not have the feature of selecting input channels. <em>To disable the input selection the option <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionInput">input</a> must be set to the value 8 for USB cameras.</em>
+<strong>USB cameras</strong> take a lot of bandwidth. A USB camera connected to a USB 1.1 port or hub consumes all the bandwidth. Even with a small framesize and low framerate you should not expect to have more than one camera per USB 1.1 controller. If you need more than 1 USB camera add extra USB PCI cards to your computer. There exists cards that have 4 inputs each with their own controller and with full bandwidth. Many 4-input cards only have 1 controller. USB cameras do not have the feature of selecting input channels. <em>To disable the input selection the option <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionInput" class="twikiLink">input</a> must be set to the value 8 for USB cameras.</em>
 <p />
 <strong>Composite video cards</strong> are normally made with a chip called BT878 (older cards have a BT848). They all use the Linux driver called 'bttv'.
 <p />
-There are cards with more then one video input but still only one BT878 chip. They have a video multiplexer which input is selected with the config option <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionInput">input</a>. Input channel numbers start at 0 (which is why the value 8 and not 0 disables input selection). There are video capture cards available with 4 or 8 inputs but only one chip. They present themselves as one single video device and you select input using the 'input' option. If you define e.g. 4 thread config files with the same videodevice name but different input numbers Motion automatically goes into round robin mode. See the <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument#RoundRobin" class="foswikiCurrentTopicLink">round robin</a> section for more information. Many TV tuner cards have the input channels: TV Tuner = 0, Standard composite video = 1, S-VHS = 3. Other have TV=0, composite video 1= 1, composite video = 2,  S-VHS = 3. For video capture cards input 1 is normally the composite video input.
+There are cards with more then one video input but still only one BT878 chip. They have a video multiplexer which input is selected with the config option <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionInput" class="twikiLink">input</a>. Input channel numbers start at 0 (which is why the value 8 and not 0 disables input selection). There are video capture cards available with 4 or 8 inputs but only one chip. They present themselves as one single video device and you select input using the 'input' option. If you define e.g. 4 thread config files with the same videodevice name but different input numbers Motion automatically goes into round robin mode. See the <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideOneLargeDocument#RoundRobin" class="twikiCurrentTopicLink twikiAnchorLink">round robin</a> section for more information. Many TV tuner cards have the input channels: TV Tuner = 0, Standard composite video = 1, S-VHS = 3. Other have TV=0, composite video 1= 1, composite video = 2,  S-VHS = 3. For video capture cards input 1 is normally the composite video input.
 <p />
 Some capture cards are specially made for surveillance with for example 4 inputs. Others have a TV tuner, a composite input (phono socket) and perhaps also a S-VHS input. For all these cards the inputs are numbered. The numbering varies from card to card so the easiest is to experiment for 5 minutes with a program that can show the videostream. Use a program such as Camstream or xawtv to experiment with the values.
 <p />
-If you use the TV tuner input you also need to set the frequency of the TV channel using the option <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionFrequency">frequency</a>. Otherwise set 'frequency' to 0.
+If you use the TV tuner input you also need to set the frequency of the TV channel using the option <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionFrequency" class="twikiLink">frequency</a>. Otherwise set 'frequency' to 0.
 <p />
 Finally you need to set the TV norm. Values: 0 (PAL), 1 (NTSC), 2 (SECAM), 3 (PAL NC no colour). Default is 0 (PAL). If your camera is a PAL black and white you may get a better result with norm=3 (PAL no colour).
 <p />
-If the <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionNetcamUrl">netcam_url</a> option is defined all the video4linux options are ignored so make sure the netcam_url option is commented out if you do not need it.
+If the <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionNetcamUrl" class="twikiLink">netcam_url</a> option is defined all the video4linux options are ignored so make sure the netcam_url option is commented out if you do not need it.
 <p />
 <strong>These are the parameters used for video4linux devices</strong>
 <p />
 <p />
-<p />
 <h3><a name="auto_brightness"></a> auto_brightness </h3>
 <p /> <ul>
 <li> Type: Boolean
 </li> <li> Range / Valid values: on, off
 </li> <li> Default: off
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionAutoBrightness">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionAutoBrightness" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Let motion regulate the brightness of a video device. Only recommended for cameras without auto brightness
 <p />
 Motion will try to adjust the brightness of the video device if the images captured are too dark or too light. This option will be most useful for video devices like web cams, which sometimes don't have such an option in hardware.
 <p />
-The auto_brightness feature will adjust the brightness of the device up or down until the value defined by the option <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionBrightness">brightness</a> is reached (1 = dark, 255 = bright). If <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionBrightness">brightness</a> is zero auto_brightness will try to adjust to the average brightness level 128.
+The auto_brightness feature will adjust the brightness of the device up or down until the value defined by the option <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionBrightness" class="twikiLink">brightness</a> is reached (1 = dark, 255 = bright). If <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionBrightness" class="twikiLink">brightness</a> is zero auto_brightness will try to adjust to the average brightness level 128.
 <p />
 You need to know if the camera supports auto brightness. Most cameras have auto everything. If your video device already does this for you this option might cause oscillations. If you do not know assume that it has and do not use the Motion auto brightness feature. At least not to start with.
 <p />
 <p />
-<p />
-<p />
-<p />
 <h3><a name="brightness"></a> brightness </h3> <ul>
 <li> Type: Integer
 </li> <li> Range / Valid values: 0 - 255
 </li> <li> Default: 0 (disabled)
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionBrightness">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionBrightness" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 The brightness level for the video device.
 <p />
 Value 0 means that Motion does not set the brightness value but leaves it unchanged.
 <p />
-If this setting is used in conjunction with the <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionAutoBrightness">auto_brightness</a> feature then this setting is the average brightness level in the range 1 (dark) to 255 (bright) that the auto_brightness feature will try to achieve by adjusting the device brightness up and down.
-<p />
-<p />
+If this setting is used in conjunction with the <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionAutoBrightness" class="twikiLink">auto_brightness</a> feature then this setting is the average brightness level in the range 1 (dark) to 255 (bright) that the auto_brightness feature will try to achieve by adjusting the device brightness up and down.
 <p />
 <p />
 <h3><a name="contrast"></a> contrast </h3> <ul>
 <li> Type: Boolean
 </li> <li> Range / Valid values: 0 - 255
 </li> <li> Default: 0 (disabled)
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionContrast">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionContrast" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 The contrast level for the video device.
@@ -1893,14 +946,12 @@ The contrast level for the video device.
 Disabled (Value 0) means that Motion does not set the contrast value.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="framerate"></a> framerate </h3>
 <p /> <ul>
 <li> Type: Integer
 </li> <li> Range / Valid values: 2 - 100
 </li> <li> Default: 100 (no limit)
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionFramerate">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionFramerate" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Maximum number of frames to be captured from the camera per second.
@@ -1914,14 +965,12 @@ Set this parameter to the maximum number
 To set intervals longer than one second use the 'minimum_gap' option instead.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="frequency"></a> frequency </h3>
 <p /> <ul>
 <li> Type: Boolean
 </li> <li> Range / Valid values: 0 - 999999
 </li> <li> Default: 0 (Not set)
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionFrequency">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionFrequency" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 The frequency to set the tuner to (kHz). Valid range: per tuner spec, default: 0 (Don't set it)
@@ -1929,14 +978,12 @@ The frequency to set the tuner to (kHz).
 This option is only relevant if you have a TV tuner card where you can select the tuner frequency. Your tuner card must support this feature.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="height"></a> height </h3>
 <p /> <ul>
 <li> Type: Integer
 </li> <li> Range / Valid values: Device Dependent
 </li> <li> Default: 288
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionHeight">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionHeight" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 The height of each frame in pixels.
@@ -1952,14 +999,12 @@ For some device drivers like pwc (driver
 Motion requires that dimensions of camera image must have both height and width that are a multiple of 16. Ths is normally not a problem. All standard sizes like 640, 480, 352, 320, 288, 240, ...etc are multiples of 16.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="hue"></a> hue </h3>
 <p /> <ul>
 <li> Type: Integer
 </li> <li> Range / Valid values: 0 - 255
 </li> <li> Default: 0 (disabled)
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionHue">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionHue" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 The hue level for the video device.
@@ -1967,14 +1012,12 @@ The hue level for the video device.
 Normally only relevant for NTSC cameras.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="input"></a> input </h3>
 <p /> <ul>
 <li> Type: Integer
 </li> <li> Range / Valid values: 0 - 7, 8 = disabled
 </li> <li> Default: 8 (disabled)
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionInput">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionInput" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Input channel to use expressed as an integer number starting from 0. Should normally be set to 1 for video/TV cards, and 8 for USB cameras.
@@ -1985,9 +1028,7 @@ However if you set the input number to e
 <p />
 If you have a video capture card you can define the channel to tune to using this option. If you are using a USB device, network camera or a capture card without tuner you should set the value to the default 8.
 <p />
-Many TV tuner cards have the input channels: TV Tuner = 0, Standard composite video = 1, S-VHS = 3. Other have TV=0, composite video 1= 1, composite video = 2, S-VHS = 3. It is recommended to set the parameter to 8 for USB cameras as your first try. For video capture cards input 1 is normally the composite video input.
-<p />
-<p />
+Many TV tuner cards have the input channels: TV Tuner = 0, Standard composite video = 1, S-VHS = 3. Other have TV=0, composite video 1= 1, composite video = 2,  S-VHS = 3. It is recommended to set the parameter to 8 for USB cameras as your first try. For video capture cards input 1 is normally the composite video input.
 <p />
 <p />
 <h3><a name="minimum_frame_time"></a> minimum_frame_time </h3>
@@ -1995,7 +1036,7 @@ Many TV tuner cards have the input chann
 <li> Type: Integer
 </li> <li> Range / Valid values: 0 - 2147483647
 </li> <li> Default: 0
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionMinimumFrameTime">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionMinimumFrameTime" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Minimum time in seconds between the capturing picture frames from the camera. Default: 0 = disabled - the capture rate is given by the camera framerate.
@@ -2004,21 +1045,19 @@ This option is used when you want to cap
 <p />
 When this is enabled the framerate option is used only to set the pace the Motion service the webcam port etc. Running Motion at framerate 2 is normally fine.
 <p />
-<img src="http://www.lavrsen.dk/foswiki/pub/System/DocumentGraphics/warning.gif" alt="ALERT!" title="ALERT!" width="16" height="16" border="0" /> This feature is introduced in Motion 3.2.7
+<img src="http://www.lavrsen.dk/twiki/pub/TWiki/TWikiDocGraphics/warning.gif" alt="ALERT!" title="ALERT!" width="16" height="16" border="0" /> This feature is introduced in Motion 3.2.7
 <p />
 <!--
 Add Additional Description Below 
 -->
 <p />
 <p />
-<p />
-<p />
 <h3><a name="norm"></a> norm </h3>
 <p /> <ul>
 <li> Type: Discrete Strings
 </li> <li> Range / Valid values: 0 (PAL), 1 (NTSC), 2 (SECAM), 3 (PAL NC no colour)
 </li> <li> Default: 0 (PAL)
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionNorm">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionNorm" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Select the norm of the video device. Values: 0 (PAL), 1 (NTSC), 2 (SECAM), 3 (PAL NC no colour). Default: 0 (PAL)
@@ -2026,14 +1065,12 @@ Select the norm of the video device. Val
 This value is only used for capture cards using the <a href="http://bytesex.org/bttv/index.html" rel="nofollow" target="_top">BTTV driver</a>.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="rotate"></a> rotate </h3>
 <p /> <ul>
 <li> Type: Discrete Strings
 </li> <li> Range / Valid values: 0, 90, 180, 270
 </li> <li> Default: 0 (not rotated)
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionRotate">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionRotate" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Rotate image the given number of degrees. The rotation affects all saved images as well as mpeg movies.
@@ -2043,91 +1080,49 @@ The rotation feature is used when the ca
 Note that the CPU load increases when using this feature with a value other than 0. Also note that Motion automatically swaps width and height if you rotate 90 or 270 degrees, so you don't have to touch these options.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="saturation"></a> saturation </h3>
 <p /> <ul>
 <li> Type: Integer
 </li> <li> Range / Valid values: 0 - 255
 </li> <li> Default: 0 (disabled)
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionSaturation">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionSaturation" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 The colour saturation level for the video device.
 <p />
 <p />
-<p />
-<p />
-<p />
-<p />
 <h3><a name="tunerdevice"></a> tunerdevice </h3>
 <p /> <ul>
 <li> Type: String
 </li> <li> Range / Valid values: Max 4095 characters
 </li> <li> Default: /dev/tuner0
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTunerdevice">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTunerdevice" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
-The tuner device used for controlling the tuner in a tuner card. This option is only used when Motion is compiled for <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/FreeBSD">FreeBSD</a>.
+The tuner device used for controlling the tuner in a tuner card. This option is only used when Motion is compiled for <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/FreeBSD" class="twikiLink">FreeBSD</a>.
 <p />
 Make sure to remove or comment out this option when running Motion under Linux.
 <p />
 <p />
-<p />
-<p />
-<h3><a name="v4l2_palette"></a> v4l2_palette </h3>
-<p /> <ul>
-<li> Type: Integer
-</li> <li> Range / Valid values: 0 - 8
-</li> <li> Default: 8
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionV4L2Palette">Option Topic</a>
-</li></ul> 
-<p />
-Allow to choose preferable palette to be use by motion
- to capture from those supported by your videodevice. ( new in 3.2.10 )
-<p />
-<!--
-Add Additional Description Below 
--->
-<p />
-i.ex if your videodevice supports <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/V4L2">V4L2</a> _PIX_FMT_SBGGR8 and <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/V4L2">V4L2</a> _PIX_FMT_MJPEG by default motion will use <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/V4L2">V4L2</a> _PIX_FMT_MJPEG so set v4l2_palette 1 to force motion use <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/V4L2">V4L2</a> _PIX_FMT_SBGGR8 instead.
-<p />
-Values :
-<pre>V4L2&#95;PIX&#95;FMT&#95;SN9C10X : 0 &#39;S910&#39;
-V4L2&#95;PIX&#95;FMT&#95;SBGGR8 : 1 &#39;BA81&#39;
-V4L2&#95;PIX&#95;FMT&#95;MJPEG : 2 &#39;MJPEG&#39;
-V4L2&#95;PIX&#95;FMT&#95;JPEG : 3 &#39;JPEG&#39;
-V4L2&#95;PIX&#95;FMT&#95;RGB24 : 4 &#39;RGB3&#39;
-V4L2&#95;PIX&#95;FMT&#95;UYVY : 5 &#39;UYVY&#39;
-V4L2&#95;PIX&#95;FMT&#95;YUYV : 6 &#39;YUYV&#39;
-V4L2&#95;PIX&#95;FMT&#95;YUV422P : 7 &#39;422P&#39;
-V4L2&#95;PIX&#95;FMT&#95;YUV420 : 8 &#39;YU12&#39;
-</pre>
-<p />
-<p />
-<p />
-<p />
 <h3><a name="videodevice"></a> videodevice </h3>
 <p /> <ul>
 <li> Type: String
 </li> <li> Range / Valid values: Max 4095 characters
-</li> <li> Default: /dev/video0 (<a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/FreeBSD">FreeBSD</a>: /dev/bktr0)
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionVideodevice">Option Topic</a>
+</li> <li> Default: /dev/video0 (<a href="http://www.lavrsen.dk/twiki/bin/view/Motion/FreeBSD" class="twikiLink">FreeBSD</a>: /dev/bktr0)
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionVideodevice" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
-The video device to be used for capturing. Default for Linux is /dev/video0. for <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/FreeBSD">FreeBSD</a> the default is /dev/bktr0.
+The video device to be used for capturing. Default for Linux is /dev/video0. for <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/FreeBSD" class="twikiLink">FreeBSD</a> the default is /dev/bktr0.
 <p />
 This is the video4linux device name. Ignore this for net cameras.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="width"></a> width </h3>
 <p /> <ul>
 <li> Type: Integer
 </li> <li> Range / Valid values: Device Dependent
 </li> <li> Default: 352
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionWidth">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionWidth" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 The width in pixels of each frame. Valid range is camera dependent.
@@ -2145,7 +1140,6 @@ For some device drivers like pwc (driver
 Motion requires that dimensions of camera image must have both height and width that are a multiple of 16. Ths is normally not a problem. All standard sizes like 640, 480, 352, 320, 288, 240, ...etc are multiples of 16.
 <p />
 <p />
-<p />
 <h2><a name="Network_Cameras"></a> Network Cameras </h2>
 Motion can connect to a network camera through a normal TCP socket. All you need to give it is the URL. The URL given must return either one single jpeg picture or an mjpeg stream. For the time being Motion cannot connect to a video stream such a mpeg, mpeg4, divx. The URL must return one single jpeg image or an mjpeg stream! You can connect through a proxy server.
 <p />
@@ -2157,31 +1151,7 @@ If the connection to a network camera is
 <p />
 Note that Motion requires that dimensions of camera image must have both height and width that are a multiple of 16. Ths is normally not a problem. All standard sizes like 640, 480, 352, 320, 288, 240, ...etc are multiples of 16. But if you intend to monitor a network camera which is saving jpeg images you may have to pay attention to the dimensions of the picture.
 <p />
-<em>The network camera feature has been completely re-written in Motion 3.2.2. We believe the netcam feature is much more stable now that it was in previous versions. Motion tries to reconnect to the camera if the connection is lost. There is no official standard for mjpeg and we know that there are probably still some cameras that are not yet supported. If you run into a problem please file a <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/BugReports">Bug Report</a> with as much information about the format as possible. A binary raw dump of the first 2-3 frames with headers and boundary strings is very useful. You can see how to make it on the special topic <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/NetcamMjpegStreamDumps">NetcamMjpegStreamDumps</a>. When you have the file you can upload it to the same topic.</em>
-<p />
-<p />
-<p />
-<h3><a name="netcam_http"></a> netcam_http </h3>
-<p /> <ul>
-<li> Type: Discrete Strings
-</li> <li> Range / Valid values: 1.0, keep_alive, 1.1
-</li> <li> Default: 1.0
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionNetcamHttp">Option Topic</a>
-</li></ul> 
-<p />
-The setting for keep-alive of network socket, should improve performance on compatible net cameras. ( new in 3.2.10 ) 
-<p />
-<p /> <ul>
-<li> 1.0: the historical implementation using HTTP/1.0, closing the socket after each http request.
-</li> <li> keep_alive: Use HTTP/1.0 requests with keep alive header to reuse the same connection.
-</li> <li> 1.1: Use HTTP/1.1 requests that support keep alive as default.
-</li></ul> 
-<p />
-<!--
-Add Additional Description Below 
--->
-<p />
-<p />
+<em>The network camera feature has been completely re-written in Motion 3.2.2. We believe the netcam feature is much more stable now that it was in previous versions. Motion tries to reconnect to the camera if the connection is lost. There is no official standard for mjpeg and we know that there are probably still some cameras that are not yet supported. If you run into a problem please file a <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/BugReports" class="twikiLink">Bug Report</a> with as much information about the format as possible. A binary raw dump of the first 2-3 frames with headers and boundary strings is very useful. You can see how to make it on the special topic <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/NetcamMjpegStreamDumps" class="twikiLink">NetcamMjpegStreamDumps</a>. When you have the file you can upload it to the same topic.</em>
 <p />
 <p />
 <h3><a name="netcam_proxy"></a> netcam_proxy </h3>
@@ -2189,7 +1159,7 @@ Add Additional Description Below
 <li> Type: String
 </li> <li> Range / Valid values: Max 4095 characters
 </li> <li> Default: Not defined
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionNetcamProxy">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionNetcamProxy" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 URL to use for a netcam proxy server, if required. The syntax is <a href="http://myproxy:portnumber" rel="nofollow" target="_top">http://myproxy:portnumber</a>
@@ -2203,32 +1173,14 @@ If the proxy port number is 80 you can o
 Leave this option undefined if you do not use a proxy server.
 <p />
 <p />
-<p />
-<p />
-<h3><a name="netcam_tolerant_check"></a> netcam_tolerant_check </h3>
-<p /> <ul>
-<li> Type: Boolean
-</li> <li> Range / Valid values: on, off 
-</li> <li> Default: off
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionNetcamTolerantCheck">Option Topic</a>
-</li></ul> 
-<p />
-Set less strict jpeg checks for network cameras with a poor/buggy firmware.
-<p />
-<!--
-Add Additional Description Below 
--->
-<p />
-<p />
-<p />
-<p />
 <h3><a name="netcam_url"></a> netcam_url </h3>
 <p /> <ul>
 <li> Type: String
 </li> <li> Range / Valid values: Max 4095 characters
 </li> <li> Default: Not defined
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionNetcamUrl">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionNetcamUrl" class="twikiLink">Option Topic</a>
 </li></ul> 
+<p />
 Specify an url to a downloadable jpeg file or raw mjpeg stream to use as input device. Such as an AXIS 2100 network camera.
 <p />
 Example of URL: http://www.gate.com/pe1rxq/jeroen.jpg.
@@ -2242,14 +1194,12 @@ When the netcam_url is defined all the v
 Motion can also fetch jpeg pictures via ftp. You then use the ftp:// syntax instead.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="netcam_userpass"></a> netcam_userpass </h3>
 <p /> <ul>
 <li> Type: String
 </li> <li> Range / Valid values: Max 4095 characters
 </li> <li> Default: Not defined
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionNetcamUserpass">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionNetcamUserpass" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 For network cameras protected by username and password, use this option for HTTP 1.1 Basic authentication. The string is specified as username:password. Do not specify this option for no authentication.
@@ -2258,30 +1208,28 @@ To use no authentication simply remove t
 <p />
 <p />
 <p />
-<p />
 <a name="RoundRobin"></a>
 <h2><a name="Round_Robin_feature"></a> Round Robin feature </h2>
-This feature is automatically activated where multiple threads are sharing the same video device (for example /dev/video0). Each thread can then set different input channels to change camera with the <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionInput">input</a> option or by tuning the tuner with <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionFrequency">frequency</a> option.
+This feature is automatically activated where multiple threads are sharing the same video device (for example /dev/video0). Each thread can then set different input channels to change camera with the <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionInput" class="twikiLink">input</a> option or by tuning the tuner with <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionFrequency" class="twikiLink">frequency</a> option.
 <p />
-<img src="http://www.lavrsen.dk/foswiki/pub/System/DocumentGraphics/warning.gif" alt="ALERT!" title="ALERT!" width="16" height="16" border="0" /> Round Robin is not relevant for Network cameras or standard USB web cameras. The Round Robin feature is used with video capture cards which have multiple inputs per video chip.
+<img src="http://www.lavrsen.dk/twiki/pub/TWiki/TWikiDocGraphics/warning.gif" alt="ALERT!" title="ALERT!" width="16" height="16" border="0" /> Round Robin is not relevant for Network cameras or standard USB web cameras. The Round Robin feature is used with video capture cards which have multiple inputs per video chip.
 <p />
-<img src="http://www.lavrsen.dk/foswiki/pub/System/DocumentGraphics/warning.gif" alt="ALERT!" title="ALERT!" width="16" height="16" border="0" /> Note that round robin is not the ideal way to run multiple cameras. When the capture card changes input it takes a little while before the decoder chip has syncronized to the new camera. You can improve this if you have expensive cameras with a syncronize input. Only one camera can be decoded at a time so if you have 4 cameras connected 3 of the camera threads will need to wait for their turn. The fact that cameras have to take turns and the fact that you have to skip a few frames after each turn dramatically lowers the possible framerate. You can get a high framerate by viewing each camera for a long time. But then you may miss the action on one of the inactive cameras. If you can affort it avoid Round Robin and buy the more expensive type of capture cards that has one decoder chip per input. If you only need 2 or 3 cameras you can also simply put 2 or 3 cheap TV cards in the computer. Linux has no problem working with multiple TV cards.
+<img src="http://www.lavrsen.dk/twiki/pub/TWiki/TWikiDocGraphics/warning.gif" alt="ALERT!" title="ALERT!" width="16" height="16" border="0" /> Note that round robin is not the ideal way to run multiple cameras. When the capture card changes input it takes a little while before the decoder chip has syncronized to the new camera. You can improve this if you have expensive cameras with a syncronize input. Only one camera can be decoded at a time so if you have 4 cameras connected 3 of the camera threads will need to wait for their turn. The fact that cameras have to take turns and the fact that you have to skip a few frames after each turn dramatically lowers the possible framerate. You can get a high framerate by viewing each camera for a long time. But then you may miss the action on one of the inactive cameras. If you can affort it avoid Round Robin and buy the more expensive type of capture cards that has one decoder chip per input. If you only need 2 or 3 cameras you can also simply put 2 or 3 cheap TV cards in the computer. Linux has no problem working with multiple TV cards.
 <p /> <ul>
-<li> If multiple threads use the same video device, they each can capture <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionRoundrobinFrames">roundrobin_frames</a> number of frames before having to share the device with the other threads.
-</li> <li> When another thread wants to watch another input or frequency or size the first <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionRoundrobinSkip">roundrobin_skip</a> number of frames are skipped to allow the device to settle.
-</li> <li> The last option <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionSwitchfilter">switch_filter</a> is supposed to prevent the change of camera from being detected as Motion. Its function is not perfect and sometimes prevents detection of real motion. You should start with having the option disabled and then try with the option enabled to see if you can skip less frames without loosing the detection of the type of motion you normally want to detect.
+<li> If multiple threads use the same video device, they each can capture <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionRoundrobinFrames" class="twikiLink">roundrobin_frames</a> number of frames before having to share the device with the other threads.
+</li> <li> When another thread wants to watch another input or frequency or size the first <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionRoundrobinSkip" class="twikiLink">roundrobin_skip</a> number of frames are skipped to allow the device to settle.
+</li> <li> The last option <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionSwitchfilter" class="twikiLink">switch_filter</a> is supposed to prevent the change of camera from being detected as Motion. Its function is not perfect and sometimes prevents detection of real motion. You should start with having the option disabled and then try with the option enabled to see if you can skip less frames without loosing the detection of the type of motion you normally want to detect.
 </li></ul> 
 <p />
 <strong>These are the special Round Robin options</strong>
 <p />
 <p />
-<p />
 <h3><a name="roundrobin_frames"></a> roundrobin_frames </h3>
 <p /> <ul>
 <li> Type: Integer
 </li> <li> Range / Valid values: 1 - 2147483647
 </li> <li> Default: 1
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionRoundrobinFrames">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionRoundrobinFrames" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Specifies the number of frames to capture before switching inputs, this way also slow switching (e.g. every second) is possible.
@@ -2291,14 +1239,12 @@ The Round Robin feature is automatically
 If multiple threads use the same video device, they each can capture roundrobin_frames number of frames before having to share the device with the other threads.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="roundrobin_skip"></a> roundrobin_skip </h3>
 <p /> <ul>
 <li> Type: Integer
 </li> <li> Range / Valid values: 1 - 2147483647
 </li> <li> Default: 1
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionRoundrobinSkip">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionRoundrobinSkip" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Specifies the number of frames to skip after a switch. (1 if you are feeling lucky, 2 if you want to be safe).
@@ -2308,65 +1254,31 @@ The Round Robin feature is automatically
 When another thread wants to watch another input or frequency or size the first roundrobin_skip number of frames are skipped to allow the device to settle.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="switchfilter"></a> switchfilter </h3>
 <p /> <ul>
 <li> Type: Boolean
 </li> <li> Range / Valid values: on, off
 </li> <li> Default: off
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionSwitchfilter">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionSwitchfilter" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Turns the switch filter on or off. The filter can distinguish between most switching noise and real motion. With this you can even set roundrobin_skip to 1 without generating much false detection.
 <p />
 This is a round robin related feature used when you have a capture card with multiple inputs (controlled by the 'input' option) on the same videodevice.
 <p />
-<img src="http://www.lavrsen.dk/foswiki/pub/System/DocumentGraphics/warning.gif" alt="ALERT!" title="ALERT!" width="16" height="16" border="0" /> This feature was seriously broken until Motion 3.2.4
+<img src="http://www.lavrsen.dk/twiki/pub/TWiki/TWikiDocGraphics/warning.gif" alt="ALERT!" title="ALERT!" width="16" height="16" border="0" /> This feature was seriously broken until Motion 3.2.4
 <p />
 <p />
-<p />
-<p />
-<p />
-<h2><a name="Motion_Detection_Settings"></a> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionDetectionSettings">Motion Detection Settings</a> </h2>
+<h2><a name="Motion_Detection_Settings"></a> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionDetectionSettings" class="twikiLink">Motion Detection Settings</a> </h2>
 These are the options that controls the detection of motion. Further details follows after.
 <p />
 <p />
-<p />
-<h3><a name="area_detect"></a> area_detect </h3>
-<p /> <ul>
-<li> Type: String
-</li> <li> Range / Valid values: 1 - 999999999
-</li> <li> Default: Not defined
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionAreaDetect">Option Topic</a>
-</li></ul> 
-<p />
-Detect motion center in predefined areas. A script (on_area_detected) is started immediately when motion center is detected in one of the given areas, but only once during an event even if there is motion in a different configured area.
-<p />
-<!--
-Add Additional Description Below 
--->
-<p />
-Areas are numbered like that:
-<p />
-<pre>      1    2    3
-      4    5    6
-      7    8    9
-</pre>
-<p />
- One or more areas can be specified with this option.
-<p />
-Example: You want to monitor if the center of motion occurrs in the lower third of the image - that is area 7, 8 and 9. Simply set 'area_detect' to '789' and 'on_area_detect' will be executed as soon as the center of motion was detected in area 7, 8 or 9. If you want to monitor area 2, 3, 5 and 6, set '2356'.
-<p />
-<p />
-<p />
-<p />
 <h3><a name="despeckle"></a> despeckle </h3>
 <p /> <ul>
 <li> Type: String
 </li> <li> Range / Valid values: EedDl
 </li> <li> Default: Not defined
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionDespeckle">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionDespeckle" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Despeckle motion image using combinations of (E/e)rode or (D/d)ilate. And ending with optional (l)abeling.
@@ -2385,14 +1297,12 @@ If you have very few problems with false
 A very detailed technical explanation of the despeckle part can be found at the webpage of the author of this feature <a href="http://emit.demon.co.uk/motion/" rel="nofollow" target="_top">Ian McConnell's Webcam: Motion Web Page</a>
 <p />
 <p />
-<p />
-<p />
 <h3><a name="gap"></a> gap </h3>
 <p /> <ul>
 <li> Type: Integer
 </li> <li> Range / Valid values: 0 - 2147483647
 </li> <li> Default: 60
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionGap">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionGap" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Gap is the seconds of no motion detection that triggers the end of an event. An event is defined as a series of motion images taken within a short timeframe.
@@ -2426,15 +1336,14 @@ The gap value impacts many functions in
 Note that 'gap' and 'minimum_gap' have nothing to do with each other.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="lightswitch"></a> lightswitch </h3>
 <p /> <ul>
 <li> Type: Integer
 </li> <li> Range / Valid values: 0 - 100
 </li> <li> Default: 0 (disabled)
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionLightswitch">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionLightswitch" class="twikiLink">Option Topic</a>
 </li></ul> 
+<p />
 Ignore sudden massive light intensity changes given as a percentage of the picture area that changed intensity.
 <p />
 Experiment to see what works best for your application.
@@ -2444,6 +1353,17 @@ Note: From version 3.1.17 (snap release
 The value defines the picture areas in percent that will trigger the lightswitch condition. When lightswitch is detected motion detection is disabled for 5 picture frames. This is to avoid false detection when light conditions change and when a camera changes sensitivity at low light.
 <p />
 <p />
+<h3><a name="low_cpu"></a> low_cpu </h3>
+<p /> <ul>
+<li> Type: Integer
+</li> <li> Range / Valid values: 0 - 100
+</li> <li> Default: 0 (disabled)
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionLowCpu" class="twikiLink">Option Topic</a>
+</li></ul> 
+<p />
+When this option is not zero motion will be in a low cpu mode while not detecting motion. In low cpu mode Motion reduces the framerate to the value given for this option. Value zero means disabled.
+<p />
+This is smart for running a server that also does other tasks such as running Apache, MySQL etc. Motion grabs this lower number of frames per second until it detects motion. Then it speeds up to normal speed and take pictures as set by the option "framerate".
 <p />
 <p />
 <h3><a name="mask_file"></a> mask_file </h3>
@@ -2451,7 +1371,7 @@ The value defines the picture areas in p
 <li> Type: String
 </li> <li> Range / Valid values: Max 4095 characters
 </li> <li> Default: Not defined
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionMaskFile">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionMaskFile" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 PGM file to use as a sensitivity mask. This picture MUST have the same width and height as the frames being captured and be in binary format. 
@@ -2486,18 +1406,12 @@ Below are an example of a webcam picture
 <p />
 Normal picture. Notice the street is visible through the hedge.
 <p />
-<img alt="normal.jpg" src="http://www.lavrsen.dk/foswiki/pub/Motion/ConfigOptionMaskFile/normal.jpg" />
+<img alt="normal.jpg" src="http://www.lavrsen.dk/twiki/pub/Motion/ConfigOptionMaskFile/normal.jpg" />
 <p />
 Mask file (converted to png format so it can be shown by your web browser)
 <p />
-<table cellspacing="0" id="table11" cellpadding="0" class="foswikiTable" rules="rows" border="1">
-	<tbody>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol foswikiLastCol foswikiLast"> <img alt="mask1.png" src="http://www.lavrsen.dk/foswiki/pub/Motion/ConfigOptionMaskFile/mask1.png" /> </td>
-		</tr>
-	</tbody></table>
-<p />
-<p />
+<table style="border-width:1px;" cellspacing="0" cellpadding="0" class="twikiTable" border="1"><tr class="twikiTableEven"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol twikiLast"> <img alt="mask1.png" src="http://www.lavrsen.dk/twiki/pub/Motion/ConfigOptionMaskFile/mask1.png" /> </td></tr>
+</table>
 <p />
 <p />
 <h3><a name="max_mpeg_time"></a> max_mpeg_time </h3>
@@ -2505,7 +1419,7 @@ Mask file (converted to png format so it
 <li> Type: Integer
 </li> <li> Range / Valid values: 0 (infinite) - 2147483647
 </li> <li> Default: 3600
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionMaxMpegTime">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionMaxMpegTime" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 The maximum length of an mpeg movie in seconds. Set this to zero for unlimited length.
@@ -2517,6 +1431,23 @@ Add Additional Description Below
 -->
 <p />
 <p />
+<h3><a name="minimum_gap"></a> minimum_gap </h3>
+<p /> <ul>
+<li> Type: Integer
+</li> <li> Range / Valid values: 0 - 2147483647
+</li> <li> Default: 0 (no minimum)
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionMinimumGap" class="twikiLink">Option Topic</a>
+</li></ul> 
+<p />
+The minimum time between two shots in seconds. 
+<p />
+This is the minimum gap between the storing pictures while detecting motion. 
+<p />
+The value zero means that pictures can be stored almost at the framerate of the camera. Normally you will set this to 0
+<p />
+This option has nothing to do with the 'gap' option.
+<p />
+<img src="http://www.lavrsen.dk/twiki/pub/TWiki/TWikiDocGraphics/warning.gif" alt="ALERT!" title="ALERT!" width="16" height="16" border="0" /> From motion 3.2.7 this feature has been removed because it was in practical a useless feature. It prevented saving more than one picture per minimum_gap seconds but the capturing and motion detect was still run at full framerate loading the CPU heavily. From 3.2.7 a new feature called <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionMinimumFrameTime" class="twikiLink">minimum_frame_time</a> has been introduced which lower the capture rate. So it gives the same effect as minimum_gap did but additionally lower the CPU load significantly.
 <p />
 <p />
 <h3><a name="minimum_motion_frames"></a> minimum_motion_frames </h3>
@@ -2524,7 +1455,7 @@ Add Additional Description Below
 <li> Type: Boolean
 </li> <li> Range / Valid values: 1 - 1000s
 </li> <li> Default: 1
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionMinimumMotionFrames">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionMinimumMotionFrames" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Picture frames must contain motion at least the specified number of frames in a row before they are detected as true motion. At the default of 1, all motion is detected. Valid range is 1 to thousands, but it is recommended to keep it within 1-5.
@@ -2536,6 +1467,17 @@ The feature is used when you get many fa
 Experiment for best setting. Even though Motion accepts large values you should set this to a relatively low number (below 10). For each step larger than 1 Motion reserves space in RAM for the picture frame buffer. If you have a large value Motion will miss many frames from the camera while it is processing the all the pictures in the buffer.
 <p />
 <p />
+<h3><a name="night_compensate"></a> night_compensate </h3>
+<p /> <ul>
+<li> Type: Boolean
+</li> <li> Range / Valid values: on, off
+</li> <li> Default: off
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionNightCompensate" class="twikiLink">Option Topic</a>
+</li></ul> 
+<p />
+When this option is set the noise threshold will be lowered if the picture is dark. This will improve the sensitivity in dark places. However it might also increase the number of false alarms since most cameras also increase light sensitivity with their AGC (Automatic Gain Control) and this will increase noise.
+<p />
+It has normally been the advice not to use this with 'noise_tune' turned on. However the latest experience is that with the new improved noise_tune algorithm it actually works fine in combination with 'night_compensate'.
 <p />
 <p />
 <h3><a name="noise_level"></a> noise_level </h3>
@@ -2543,7 +1485,7 @@ Experiment for best setting. Even though
 <li> Type: Integer
 </li> <li> Range / Valid values: 1 - 255
 </li> <li> Default: 32
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionNoiseLevel">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionNoiseLevel" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 The noise level is used as a threshold for distinguishing between noise and motion.
@@ -2551,14 +1493,12 @@ The noise level is used as a threshold f
 This is different from the threshold parameter. This is changes at pixel level. The purpose is to eliminate the changes generated by electric noise in the camera. Especially in complete darkness you can see the noise as small grey dots that come randomly in the picture. This noise can create false motion detection. What this parameter means is that the intensity of a pixel must change more than +/- the noise threshold parameter to be counted.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="noise_tune"></a> noise_tune </h3>
 <p /> <ul>
 <li> Type: Boolean
 </li> <li> Range / Valid values: on, off
 </li> <li> Default: on
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionNoiseTune">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionNoiseTune" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Activates the automatic tuning of noise level.
@@ -2566,14 +1506,12 @@ Activates the automatic tuning of noise
 This feature makes Motion continuously adjust the noise threshold for distinguishing between noise and motion. The 'noise_level' setting is ignored when activating this feature. This is a new feature and new algorithm. It may give different results depending on camera and light conditions. Report your experience with it on the Motion mailing list. If it does not work well, deactivate the 'noise_tune' option and use the manual setting of 'noise_level' instead.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="output_all"></a> output_all </h3>
 <p /> <ul>
 <li> Type: Boolean
 </li> <li> Range / Valid values: on, off
 </li> <li> Default: off
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionOutputAll">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionOutputAll" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Picture are saved continuously as if motion was detected all the time.
@@ -2587,14 +1525,12 @@ It does all the normal actions that are
 The idea of this feature is that you can turn the feature on and off for a short period of time to test or to generate continuous mpeg films when needed.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="post_capture"></a> post_capture </h3>
 <p /> <ul>
 <li> Type: Integer
 </li> <li> Range / Valid values: 0 - 2147483647 
 </li> <li> Default: 0 (disabled)
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionPostCapture">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionPostCapture" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Specifies the number of frames to be captured after motion has been detected.
@@ -2606,14 +1542,12 @@ This option is the preferred way to crea
 If you only store mpegs movies and do not have output_normal on, then the recommended post_capture value is what is equivalent to 1-5 seconds of movie.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="pre_capture"></a> pre_capture </h3>
 <p /> <ul>
 <li> Type: Integer
 </li> <li> Range / Valid values: 0 - 100s
 </li> <li> Default: 0 (disabled)
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionPreCapture">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionPreCapture" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Specifies the number of previous frames to be outputted at motion detection. Recommended range: 0 to 5, default=0. Do not use large values! Large values will cause Motion to skip video frames and cause unsmooth mpegs. To smooth mpegs use larger values of post_capture instead.
@@ -2630,9 +1564,7 @@ Motion will not grab another image until
 <p />
 If you wish to create smooth mpegs during events using large pre_capture values will do the opposite! It will create a long pause where a lot of action is missed.
 <p />
-To get a smooth mpeg use a large value for <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionPostCapture">post_capture</a> which does not cost any performance hit or RAM space. 
-<p />
-<p />
+To get a smooth mpeg use a large value for <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionPostCapture" class="twikiLink">post_capture</a> which does not cost any performance hit or RAM space. 
 <p />
 <p />
 <h3><a name="smart_mask_speed"></a> smart_mask_speed </h3>
@@ -2640,7 +1572,7 @@ To get a smooth mpeg use a large value f
 <li> Type: Integer
 </li> <li> Range / Valid values: 0 - 10
 </li> <li> Default: 0 (disabled)
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionSmartMaskSpeed">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionSmartMaskSpeed" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Slugginess of the smart mask. Default is 0 = DISABLED. 1 is slow, 10 is fast.
@@ -2649,11 +1581,11 @@ Smartmask is a dynamic, self-learning ma
 <p />
 smart_mask_speed - tunes the slugginess of the mask. It accepts values from 0 (turned off) to 10 (fast). Fast means here that the mask is built quick, but it is also not staying very long with no more motion. Slow means that it takes a while until the mask is built but it also stays longer. A good start value for smart_mask_speed is 5. This setting is independent from the framerate. The attack and decay time is constant over all available framerates.
 <p />
-When smartmask is enabled and motion is also configured to either write motion-images or motion-mpegs, the current smartmask is copied as an overlay into the black/white motion-pictures/mpegs in red colour. Same thing happens to the webcam stream when Motion runs in <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionSetupMode">setup_mode</a>. That way you can easily adjust smart_mask_speed.
+When smartmask is enabled and motion is also configured to either write motion-images or motion-mpegs, the current smartmask is copied as an overlay into the black/white motion-pictures/mpegs in red colour. Same thing happens to the webcam stream when Motion runs in <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionSetupMode" class="twikiLink">setup_mode</a>. That way you can easily adjust smart_mask_speed.
 <p />
 <strong>Detailed Description</strong>
 <p />
-The <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionMaskFile">mask_file</a> option provides a static mask to turn off sensitivity in certain areas. This is very usefull to mask a street with cars passing by all day long etc...
+The <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionMaskFile" class="twikiLink">mask_file</a> option provides a static mask to turn off sensitivity in certain areas. This is very usefull to mask a street with cars passing by all day long etc...
 <p />
 But imagine a scenario with large bushes and big trees where all the leaves are moving in the wind also triggering motion from time to time even with despeckle turned on. Of course you can also define a static mask here, but what if the bushes are growing during spring and summer? Well, you have to adapt the mask from time to time. What if the camera position moves slightly? What if someone grows new plants in your garden? You always have to setup a new static mask.
 <p />
@@ -2662,15 +1594,12 @@ The answer to this problem is the smart
 Smart mask will disable sensitivity in areas with frequent motion (like trees in the wind). Sensitivity is turned on again after some time of no more motion in this area. The built mask is a bit larger at the borders than the actual motion. This way smartmask works more reliably when sudden moves occur under windy conditions.
 <p />
 <p />
-<p />
-<p />
-<p />
 <h3><a name="threshold"></a> threshold </h3>
 <p /> <ul>
 <li> Type: Integer
 </li> <li> Range / Valid values: 1 - 2147483647
 </li> <li> Default: 1500
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionThreshold">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionThreshold" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Threshold for declaring motion. The threshold is the number of changed pixels counted after noise filtering, masking, despeckle, and labelling.
@@ -2680,37 +1609,31 @@ The 'threshold' option is the most impor
 Use the -s (setup mode) command line option and/or the text_changes config file option to experiment to find the right threshold value. If you do not get small movements detected (see the mouse on the kitchen floor) lower the value. If motion detects too many birds or moving trees, increase the number. Practical values would be from a few hundred to 2000 indoors and 1000-10000 outdoors.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="threshold_tune"></a> threshold_tune </h3>
 <p /> <ul>
 <li> Type: Boolean
 </li> <li> Range / Valid values: on, off
 </li> <li> Default: off
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionThresholdTune">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionThresholdTune" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
-Activates the automatic tuning of threshold level. ( It's broken )
+Activates the automatic tuning of threshold level.
 <p />
 This feature makes Motion continuously adjust the threshold for declaring motion.
 <p />
-The <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionThreshold">threshold</a> setting is ignored when activating this feature. It may give different results depending on your camera, light conditions, indoor/outdoor, the motion to be detected etc. If it does not work well, deactivate the 'threshold_tune' option and use the manual setting of <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionThreshold">threshold</a> instead.
-<p />
-<p />
+The <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionThreshold" class="twikiLink">threshold</a> setting is ignored when activating this feature. It may give different results depending on your camera, light conditions, indoor/outdoor, the motion to be detected etc. If it does not work well, deactivate the 'threshold_tune' option and use the manual setting of <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionThreshold" class="twikiLink">threshold</a> instead.
 <p />
 <p />
-<p />
-<h2><a name="Image_File_Output"></a> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ImageFileOutput">Image File Output</a> </h2>
+<h2><a name="Image_File_Output"></a> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ImageFileOutput" class="twikiLink">Image File Output</a> </h2>
 The following options controls how Motion generates images when detection motion.
 <p />
 <p />
-<p />
 <h3><a name="output_motion"></a> output_motion </h3>
 <p /> <ul>
 <li> Type: Boolean
 </li> <li> Range / Valid values: on, off
 </li> <li> Default: off
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionOutputMotion">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionOutputMotion" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Output pictures with only the moving object. This feature generates the special motion type movies where you only see the pixels that changes as a graytone image. If labelling is enabled you see the largest area in blue. Smartmask is shown in red.
@@ -2720,14 +1643,12 @@ Motion images shows the motion content o
 Default is not to store motion images. Motion pictures are stored the same place and with the same filename as normal motion triggered pictures except they have an "m" appended at the end of the filename before the .jpg or .ppm. E.g. the name can be 01-20020424232936-00m.jpg.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="output_normal"></a> output_normal </h3>
 <p /> <ul>
 <li> Type: Discrete Strings
-</li> <li> Range / Valid values: on, off, first, best, center (since 3.2.10)
+</li> <li> Range / Valid values: on, off, first, best
 </li> <li> Default: on
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionOutputNormal">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionOutputNormal" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Normal image is an image that is stored when motion is detected. It is the same image that was taken by the camera. I.e. not a motion image like defined by output_motion. Default is that normal images are stored.
@@ -2736,11 +1657,7 @@ If you set the value to 'first' Motion s
 <p />
 If you set it to "best" Motion saves the picture with most changed pixels during the event. This is useful if you store mpegs on a webserver and want to present a jpeg to show the content of the mpeg on a webpage. "best" requires a little more CPU power and resources compared to "first".
 <p />
-Picture with motion nearest center of picture is saved when set to 'center' (since 3.2.10).
-<p />
-Set to 'off' to not write pictures (jpeg or ppm).
-<p />
-<p />
+Set to 'off' to don't write pictures ( jpeg or ppm ).
 <p />
 <p />
 <h3><a name="ppm"></a> ppm </h3>
@@ -2748,7 +1665,7 @@ Set to 'off' to not write pictures (jpeg
 <li> Type: Boolean
 </li> <li> Range / Valid values: on, off
 </li> <li> Default: off
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionPpm">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionPpm" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Output ppm images instead of jpeg. This uses less CPU time, but causes a LOT of hard disk I/O, and it is generally slower than jpeg.
@@ -2756,14 +1673,12 @@ Output ppm images instead of jpeg. This
 The recommendation is to always use jpg except if you have a specific need to store high quality pictures without any quality loss. For web cameras you should always choose jpg. Note that the built in webcam server requires that this parameter is set to off.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="quality"></a> quality </h3>
 <p /> <ul>
 <li> Type: Integer
 </li> <li> Range / Valid values: 1 - 100
 </li> <li> Default: 75
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionQuality">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionQuality" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 The quality for the jpeg images in percent.
@@ -2771,11 +1686,7 @@ The quality for the jpeg images in perce
 100 means hardly compressed. A small number means a much smaller file size but also a less nice quality image to look at. 50 is a good compromise for most.
 <p />
 <p />
-<p />
-<p />
-<p />
-<p />
-<h2><a name="Tuning_Motion"></a> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/TuningMotion">Tuning Motion</a> </h2>
+<h2><a name="Tuning_Motion"></a> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/TuningMotion" class="twikiLink">Tuning Motion</a> </h2>
 <p />
 Motion 3.2 introduces a new feature Setup Mode. This is a great new feature with really make tuning all the settings of Motion much more easy and transparent. In setup mode two things happen:
 <p /> <ol>
@@ -2801,26 +1712,26 @@ In normal mode you can use the same sett
 From the web interface you can ask Motion to write all your changes back to the config files (motion.conf and thread config files). It will even tidy them up for you so they look nice.
 <p />
 There are two sets of options to adjust. <ul>
-<li> The options that controls the camera device: See <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/CaptureDeviceOptions">CaptureDeviceOptions</a>
-</li> <li> The options that controls the actual motion detection: <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionDetectionSettings">MotionDetectionSettings</a>
+<li> The options that controls the camera device: See <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/CaptureDeviceOptions" class="twikiLink">CaptureDeviceOptions</a>
+</li> <li> The options that controls the actual motion detection: <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionDetectionSettings" class="twikiLink">MotionDetectionSettings</a>
 </li></ul> 
 <p />
 <hr />
 <p />
 Normal picture frame
 <p />
-<img alt="outputnormal1.jpg" src="http://www.lavrsen.dk/foswiki/pub/Motion/TuningMotion/outputnormal1.jpg" />
+<img alt="outputnormal1.jpg" src="http://www.lavrsen.dk/twiki/pub/Motion/TuningMotion/outputnormal1.jpg" />
 <p />
 <hr />
 Motion type picture frame with despeckle. Note that the largest area is blue and only this is counted as Motion.
 <p />
 The Motion image shows how Motion maintains a "reference frame" which is not just the last picture frame but a matematical calculation of the past images. This enlarges real Motion and ensures that it is not easy to sneak in slowly.
 <p />
-<img alt="outputmotion1.jpg" src="http://www.lavrsen.dk/foswiki/pub/Motion/TuningMotion/outputmotion1.jpg" />
+<img alt="outputmotion1.jpg" src="http://www.lavrsen.dk/twiki/pub/Motion/TuningMotion/outputmotion1.jpg" />
 <hr />
 <p />
 <p />
-<h2><a name="Generating_MPEG_films_with_ffmpe"></a> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MpegFilmsFFmpeg">Generating MPEG films with ffmpeg</a> </h2>
+<h2><a name="Generating_MPEG_films_with_ffmpe"></a> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/MpegFilmsFFmpeg" class="twikiLink">Generating MPEG films with ffmpeg</a> </h2>
 The ffmpeg option can generate mpeg films very fast and "on the fly". This means that the mpeg film is growing each time motion is detected.
 <p />
 Some people on the Motion mailing list have had trouble building the ffmpeg package because they did not have the NASM assembler package installed. So pay attention to this if you run into problems.
@@ -2835,14 +1746,14 @@ Motion works with the following versions
 <li> ffmpeg-0.4.8. With this release Motion supports mpeg1, mpeg4 and msmpeg4. Lately newer distributions have problems building this 2003 release of ffmpeg so many of you no longer have this option.
 </li> <li> ffmpeg-0.4.9pre1. Is supported starting from Motion version 3.1.18. With this release Motion supports mpeg4 and msmpeg4 but not mpeg1. The reason is that the ffmpeg team has decided no longer to support non-standard framerates in their mpeg1 encoder library. Also ffmpeg-0.4.9pre1 gives people problems on newer distributions.
 </li> <li> ffmpeg from CVS. This may work. We cannot continuously monitor and try every time a new source file is checked into ffmpeg. You will have to try.
-</li> <li> ffmpeg RPMs. Currently each Motion release is tested with the current Livna ffmpeg rpm package for Fedora. See the <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/DownloadFiles">Download Files</a> page for direct links to the version which has been certified with the latest Motion release.
+</li> <li> ffmpeg RPMs. Currently each Motion release is tested with the current Livna ffmpeg rpm package for Fedora. See the <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/DownloadFiles" class="twikiLink">Download Files</a> page for direct links to the version which has been certified with the latest Motion release.
 </li> <li> ffmpeg debian binaries. Latest versions from the debian repository for Debian Sarge works fine with Motion.
 </li> <li> Certified ffmpeg CVS snapshot for latest Motion release is available from the <a href="http://sourceforge.net/project/showfiles.php?group_id=13468&amp;package_id=116390" rel="nofollow" target="_top">Motion Sourceforge Related Projects file area</a>
 </li></ul> 
 <p />
 The timelapse feature always runs mpeg1 with both ffmpeg 0.4.8 and 0.4.9 and newer. Motion simply creates the timelapse film with a standard mpeg1 framerate. <font color="#ff0000"> Note : maximum size for timelapse files is 2GB. </font>
 <p />
-In principle Motion can be made to support many other formats. It requires additional coding in Motion. You are welcome to submit <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionPatches">patches</a>. All ffmpeg related code is in the source file ffmpeg.c. It is not trivial to do because the ffmpeg libraries not documented at all. All you have is a couple of code examples.
+In principle Motion can be made to support many other formats. It requires additional coding in Motion. You are welcome to submit <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionPatches" class="twikiLink">patches</a>. All ffmpeg related code is in the source file ffmpeg.c. It is not trivial to do because the ffmpeg libraries not documented at all. All you have is a couple of code examples.
 <p />
 To build ffpmeg from source follow these steps:
 <p />
@@ -2881,13 +1792,12 @@ Note that if you install ffmpeg from sou
 <strong>These are the config file options related to ffmpeg.</strong>
 <p />
 <p />
-<p />
 <h3><a name="ffmpeg_bps"></a> ffmpeg_bps </h3>
 <p /> <ul>
 <li> Type: Integer
 </li> <li> Range / Valid values: 0 - 9999999
 </li> <li> Default: 400000
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionFfmpegBps">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionFfmpegBps" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Bitrate of mpegs produced by ffmpeg. Bitrate is bits per second. Default: 400000 (400kbps). Higher value mans better quality and larger files. Option requires that ffmpeg libraries are installed.
@@ -2897,14 +1807,12 @@ To use this feature you need to install
 Experiment to get the desired quality. The better quality the bigger files. This option is ignored if ffmpeg_variable_bitrate is not 0 (disabled).
 <p />
 <p />
-<p />
-<p />
 <h3><a name="ffmpeg_cap_motion"></a> ffmpeg_cap_motion </h3>
 <p /> <ul>
 <li> Type: Boolean
 </li> <li> Range / Valid values: on, off
 </li> <li> Default: off
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionFfmpegCapMotion">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionFfmpegCapMotion" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Use ffmpeg libraries to encode motion type mpeg movies where you only see the pixels that changes.
@@ -2916,14 +1824,12 @@ This feature generates the special motio
 To use this feature you need to install the FFmpeg Streaming Multimedia System
 <p />
 <p />
-<p />
-<p />
 <h3><a name="ffmpeg_cap_new"></a> ffmpeg_cap_new </h3>
 <p /> <ul>
 <li> Type: Boolean
 </li> <li> Range / Valid values: on, off
 </li> <li> Default: off
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionFfmpegCapNew">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionFfmpegCapNew" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Use ffmpeg libraries to encode mpeg movies in realtime.
@@ -2935,14 +1841,12 @@ To use this feature you need to install
 Must not be included in config file without having ffmpeg installed.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="ffmpeg_deinterlace"></a> ffmpeg_deinterlace </h3>
 <p /> <ul>
 <li> Type: Boolean
 </li> <li> Range / Valid values: on, off
 </li> <li> Default: off
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionFfmpegDeinterlace">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionFfmpegDeinterlace" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Use ffmpeg to deinterlace video. Necessary if you use an analog camera and see horizontal combing on moving objects in video or pictures. 
@@ -2957,14 +1861,12 @@ Add Additional Description Below
 -->
 <p />
 <p />
-<p />
-<p />
 <h3><a name="ffmpeg_timelapse"></a> ffmpeg_timelapse </h3>
 <p /> <ul>
 <li> Type: Boolean
 </li> <li> Range / Valid values: 0 - 2147483647
 </li> <li> Default: 0 (disabled)
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionFfmpegTimelapse">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionFfmpegTimelapse" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Create a timelapse movie saving a picture frame at the interval in seconds set by this parameter. Set it to 0 if not used.
@@ -2980,14 +1882,12 @@ To use this feature you need to install
 (renamed from ffmpeg_timelaps to ffmpeg_timelapse in 3.1.14)
 <p />
 <p />
-<p />
-<p />
 <h3><a name="ffmpeg_timelapse_mode"></a> ffmpeg_timelapse_mode </h3>
 <p /> <ul>
 <li> Type: Discrete Strings
 </li> <li> Range / Valid values: hourly, daily, weekly-sunday, weekly-monday, monthly, manual
 </li> <li> Default: daily
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionFfmpegTimelapseMode">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionFfmpegTimelapseMode" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 The file rollover mode of the timelapse video.
@@ -2997,14 +1897,12 @@ Note that it is important that you use t
 The value 'Manual' means that Motion does not automatically rollover to a new filename. You can do it manually using the http control interface by setting the option 'ffmpeg_timelapse' to 0 and then back to your chosen value. Value 'hourly' rolls over on the full hour. Value 'daily' which is the default rolls over at midnight. There are two weekly options because depending on where you come from a week may either start on Sunday or Monday. And 'monthly' naturally rolls over on the 1st of the month.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="ffmpeg_variable_bitrate"></a> ffmpeg_variable_bitrate </h3>
 <p /> <ul>
 <li> Type: Integer
 </li> <li> Range / Valid values: 0, 2 - 31
 </li> <li> Default: 0 (disabled)
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionFfmpegVariableBitrate">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionFfmpegVariableBitrate" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Enables and defines variable bitrate for the ffmpeg encoder. ffmpeg_bps is ignored if variable bitrate is enabled. Valid values: 0 (default) = fixed bitrate defined by ffmpeg_bps, or the range 2 - 31 where 2 means best quality and 31 is worst.
@@ -3012,63 +1910,61 @@ Enables and defines variable bitrate for
 Experiment for the value that gives you the desired compromise between size and quality.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="ffmpeg_video_codec"></a> ffmpeg_video_codec </h3>
 <p /> <ul>
 <li> Type: Discrete Strings
-</li> <li> Range / Valid values: mpeg1 (ffmpeg-0.4.8 only), mpeg4, msmpeg4, swf, flv, ffv1, mov
+</li> <li> Range / Valid values: mpeg1 (ffmpeg-0.4.8 only), mpeg4, msmpeg4, swf, flv, ffv1
 </li> <li> Default: mpeg4
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionFfmpegVideoCodec">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionFfmpegVideoCodec" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Codec to be used by ffmpeg for the video compression. Timelapse mpegs are always made in mpeg1 format independent from this option.
-<p /> <ul>
-<li> mpeg1 - gives you mpeg1 files with extension .mpg. It is only supported by the old ffmpeg version 0.4.8. The ffmpeg team decided no longer to support non-standard framerates for mpeg1 from ffmpeg version 0.4.9pre1.
-</li> <li> mpeg4 - gives you mpeg4 files with extension .avi
-</li> <li> msmpeg4 - also gives you mpeg4 files. It is s recommended for use with Windows Media Player because it requires with no installation of codec on the Windows client.
-</li> <li> swf - gives you a flash film with extension .swf
-</li> <li> flv - gives you a flash video with extension .flv
-</li> <li> ffv1 - FF video codec 1 for Lossless Encoding (experimental)
-</li> <li> mov - QuickTime (since 3.2.10).
-</li></ul> 
 <p />
-This option does not affect the timelapse feature. Timelapse is always recorded in mpeg1 format because we need to be able to append to an existing file. mpeg4 does not easily allow this.
+mpeg1 gives you files with extension .mpg. It is only supported by the old ffmpeg version 0.4.8. The ffmpeg team decided no longer to support non-standard framerates for mpeg1 from ffmpeg version 0.4.9pre1.
+<p />
+mpeg4 or msmpeg4 give you files with extension .avi
+<p />
+msmpeg4 is recommended for use with Windows Media Player because it requires with no installation of codec on the Windows client.
+<p />
+swf gives you a flash film with extension .swf
 <p />
+flv gives you a flash video with extension .flv
+<p />
+ffv1 , FF video codec 1 for Lossless Encoding ( experimental )
+<p />
+This option does not affect the timelapse feature. Timelapse is always recorded in mpeg1 format because we need to be able to append to an existing file. mpeg4 does not easily allow this.
 <p />
 <p />
 <hr />
 <p />
-See also the section <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/AdvancedFilenames">Advanced Filenames</a> where the two additional options <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionFfmpegFilename">ffmpeg_filename</a> and <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTimelapseFilename">timelapse_filename</a> are defined.
+See also the section <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/AdvancedFilenames" class="twikiLink">Advanced Filenames</a> where the two additional options <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionFfmpegFilename" class="twikiLink">ffmpeg_filename</a> and <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTimelapseFilename" class="twikiLink">timelapse_filename</a> are defined.
 <p />
 If you want to use this feature you can read about the <a href="http://ffmpeg.sourceforge.net/" rel="nofollow" target="_top">FFmpeg Streaming Multimedia System</a>
 <p />
 <p />
-<h2><a name="Snapshots_The_Traditional_Period"></a> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/SnapshotsWebCam">Snapshots - The Traditional Periodic Web Camera</a> </h2>
+<h2><a name="Snapshots_The_Traditional_Period"></a> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/SnapshotsWebCam" class="twikiLink">Snapshots - The Traditional Periodic Web Camera</a> </h2>
 Motion can also act like a traditional web camera.
 <p />
 <p />
-<p />
 <h3><a name="snapshot_interval"></a> snapshot_interval </h3>
 <p /> <ul>
 <li> Type: Integer
 </li> <li> Range / Valid values: 0 - 2147483647
 </li> <li> Default: 0 (disabled)
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionSnapshotInterval">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionSnapshotInterval" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Make automated snapshots every 'snapshot_interval' seconds.
 <p />
-The snapshots are stored in the target directory + the directory/filename specified by the <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionSnapshotFilename">snapshot_filename</a> option.
+The snapshots are stored in the target directory + the directory/filename specified by the <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionSnapshotFilename" class="twikiLink">snapshot_filename</a> option.
 <p />
 This is the traditional web camera feature where a picture is taken at a regular interval independently of motion in the picture.
 <p />
 <p />
-<p />
-See the also <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionSnapshotFilename">snapshot_filename</a> option in the section <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/AdvancedFilenames">Advanced Filenames</a>.
+See the also <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionSnapshotFilename" class="twikiLink">snapshot_filename</a> option in the section <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/AdvancedFilenames" class="twikiLink">Advanced Filenames</a>.
 <p />
 <p />
-<h2><a name="Text_Features"></a> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/TextFeatures">Text Features</a> </h2>
+<h2><a name="Text_Features"></a> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/TextFeatures" class="twikiLink">Text Features</a> </h2>
 Text features are highly flexible. You can taylor the text displayed on the images and films to your taste and you can add your own user defined text.
 <p />
 This is how the overlayed text is located.
@@ -3105,13 +2001,12 @@ Below are the options that controls the
 The <code>text_event</code> feature is special in that it defines the conversion specifier %C which can be used both for text display and for filenames.
 <p />
 <p />
-<p />
 <h3><a name="locate"></a> locate </h3>
 <p /> <ul>
 <li> Type: Boolean
 </li> <li> Range / Valid values: on, off, preview
 </li> <li> Default: off
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionLocate">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionLocate" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Locate and draw a box around the moving object. Value 'preview' makes Motion only draw a box on a saved preview jpeg image and not on the saved mpeg movie. 
@@ -3119,14 +2014,12 @@ Locate and draw a box around the moving
 The value 'preview' only works when 'output_normal' is set to either 'first' or 'best'.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="text_changes"></a> text_changes </h3>
 <p /> <ul>
 <li> Type: Boolean
 </li> <li> Range / Valid values: on, off
 </li> <li> Default: off
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTextChanges">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTextChanges" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Turns the text showing changed pixels on/off.
@@ -3134,8 +2027,6 @@ Turns the text showing changed pixels on
 By setting this option to 'on' the number of pixels that changed compared to the reference frame is displayed in the upper right corner of the pictures. This is good for calibration and test. Maybe not so interesting for a greater public. Set it to your personal taste.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="text_double"></a> text_double </h3>
 <p /> <ul>
 <li> Type: Boolean
@@ -3152,14 +2043,12 @@ Add Additional Description Below
 -->
 <p />
 <p />
-<p />
-<p />
 <h3><a name="text_event"></a> text_event </h3>
 <p /> <ul>
 <li> Type: String
 </li> <li> Range / Valid values: Max 4095 characters
 </li> <li> Default: %Y%m%d%H%M%S
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTextEvent">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTextEvent" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 This option defines the value of the speciel event conversion specifier %C. You can use any conversion specifier in this option except %C. Date and time values are from the timestamp of the first image in the current event.
@@ -3169,17 +2058,15 @@ The idea is that %C can be used filename
 Option text_event defines the value %C which then can be used in filenames and text_right/text_left. The text_event/%C uses the time stamp for the first image detected in a new event. %C is an empty string when no event is in progress (gap period expired). Pre_captured and minimum_motion_frames images are time stamped before the event happens so %C in text_left/right does not have any effect on those images.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="text_left"></a> text_left </h3>
 <p /> <ul>
 <li> Type: String
 </li> <li> Range / Valid values: Max 4095 characters
 </li> <li> Default: Not defined
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTextLeft">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTextLeft" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
-User defined text overlayed on each in the lower left corner. Use A-Z, a-z, 0-9, " / ( ) @ ~ # &lt; &gt; , . : - + _ \n and vertical bar and <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">conversion specifiers</a> (codes starting by a %).
+User defined text overlayed on each in the lower left corner. Use A-Z, a-z, 0-9, " / ( ) @ ~ # &lt; &gt; \ , . : - + _ \n and <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">conversion specifiers</a> (codes starting by a %).
 <p />
 text_left is displayed in the lower left corner of the pictures. If the option is not defined no text is displayed at this position.
 <p />
@@ -3187,7 +2074,7 @@ You can place the text in quotation mark
 <p />
 <strong>Detailed Description</strong>
 <p />
-A conversion specifier is a code that starts by % (except newline which is \n). The <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">conversion specifiers</a> used has the same function as for the C function strftime (3). The most commonly used are: <ul>
+A conversion specifier is a code that starts by % (except newline which is \n). The <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">conversion specifiers</a> used has the same function as for the C function strftime (3). The most commonly used are: <ul>
 <li> %Y = year
 </li> <li> %m = month as two digits
 </li> <li> %d = date
@@ -3212,10 +2099,7 @@ These are unique to motion  <ul>
 <p />
 With a combination of text, spaces, new lines \n and conversion specifiers you have some very flexible text features. 
 <p />
-For a full list of conversion specifiers see the section <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">Conversion Specifiers</a> for Advanced Filename and Text Feature.
-<p />
-<p />
-<p />
+For a full list of conversion specifiers see the section <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">Conversion Specifiers</a> for Advanced Filename and Text Feature.
 <p />
 <p />
 <h3><a name="text_right"></a> text_right </h3>
@@ -3223,10 +2107,10 @@ For a full list of conversion specifiers
 <li> Type: String
 </li> <li> Range / Valid values: Max 4095 characters
 </li> <li> Default: %Y-%m-%d\n%T
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTextRight">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTextRight" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
-User defined text overlayed on each in the lower right corner. Use A-Z, a-z, 0-9, " / ( ) @ ~ # &lt; &gt; , . : - + _ \n and vertical bar and <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">conversion specifiers</a> (codes starting by a %). Default: %Y-%m-%d\n%T = date in ISO format and time in 24 hour clock
+User defined text overlayed on each in the lower right corner. Use A-Z, a-z, 0-9, " / ( ) @ ~ # &lt; &gt; , . : - + _ \n and <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">conversion specifiers</a> (codes starting by a %). Default: %Y-%m-%d\n%T = date in ISO format and time in 24 hour clock
 <p />
 text_right is displayed in the lower right corner of the pictures. If the option is not defined no text is displayed at this position.
 <p />
@@ -3236,7 +2120,7 @@ A major difference from text_left is tha
 <p />
 <strong>Detailed Description</strong>
 <p />
-A conversion specifier is a code that starts by % (except newline which is \n). The <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">conversion specifiers</a> used has the same function as for the C function strftime (3). The most commonly used are: <ul>
+A conversion specifier is a code that starts by % (except newline which is \n). The <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">conversion specifiers</a> used has the same function as for the C function strftime (3). The most commonly used are: <ul>
 <li> %Y = year
 </li> <li> %m = month as two digits
 </li> <li> %d = date
@@ -3261,22 +2145,19 @@ These are unique to motion  <ul>
 <p />
 With a combination of text, spaces, new lines \n and conversion specifiers you have some very flexible text features. 
 <p />
-For a full list of conversion specifiers see the section <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">Conversion Specifiers</a> for Advanced Filename and Text Feature.
-<p />
+For a full list of conversion specifiers see the section <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">Conversion Specifiers</a> for Advanced Filename and Text Feature.
 <p />
 <p />
-<p />
-<p />
-<h2><a name="Advanced_Filenames"></a> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/AdvancedFilenames">Advanced Filenames</a> </h2>
+<h2><a name="Advanced_Filenames"></a> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/AdvancedFilenames" class="twikiLink">Advanced Filenames</a> </h2>
 Motion has a very advanced and flexible automated filenaming feature.
 <p />
-By using <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">conversion specifiers</a> (codes that consist of a '%' followed by a letter) you can build up the filenames including sub directories for pictures and movies using any combination of letters, numbers and conversion specifiers which are codes that represents time, date, event number and frame numbers.
+By using <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">conversion specifiers</a> (codes that consist of a '%' followed by a letter) you can build up the filenames including sub directories for pictures and movies using any combination of letters, numbers and conversion specifiers which are codes that represents time, date, event number and frame numbers.
 <p />
 The option <code>target_dir</code> is the target directory for all snapshots, motion images and normal images. The default is the current working directory (current working directory of the terminal from which motion was started). You will normally always want to specify this parameter.
 <p />
 Note that the options <code>snapshot_filename</code>, <code>jpeg_filename</code>, <code>ffmpeg_filename</code>, and <code>timelapse_filename</code> all allow specifying directories by using '/' in the filename. These will all be relative to <code>target_dir</code>. This means in principle that you can specify <code>target_dir</code> as '/' and be 100% flexible. It also means that Motion can write files all over your harddisk if you make a mistake. It is recommended to specify the <code>target_dir</code> as deep or detailed as possible for this reason. And note that <code>targer_dir</code> does not allow conversion specifiers.
 <p />
-The conversion specifier %C which is defined by the option <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTextEvent">text_event</a> is interesting in connection with filenames because it can be used to create files and directories for each event in a very flexible way.
+The conversion specifier %C which is defined by the option <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTextEvent" class="twikiLink">text_event</a> is interesting in connection with filenames because it can be used to create files and directories for each event in a very flexible way.
 <p />
 The convertion specifier %t (thread/camera number) is also very useful. Here is an example of filename definitions in motion.conf:
 <p />
@@ -3292,7 +2173,7 @@ The smart thing is that this defines the
 <p />
 NOTE: Unless you use the <code>minimum_gap</code> option to limit the number of shots to less then one per second - you must use the frame modifier %q as part of the <code>jpeg_filename</code>. Otherwise the pictures saved within the same second will overwrite each other. The %q in <code>jpeg_filename</code> ensures that each jpeg (or ppm) picture saved gets a unique filename.
 <p />
-<img src="http://www.lavrsen.dk/foswiki/pub/System/DocumentGraphics/warning.gif" alt="ALERT!" title="ALERT!" width="16" height="16" border="0" /> Security Warning! Note that the flexibility of this feature also means you have to pay attention to the following. <ul>
+<img src="http://www.lavrsen.dk/twiki/pub/TWiki/TWikiDocGraphics/warning.gif" alt="ALERT!" title="ALERT!" width="16" height="16" border="0" /> Security Warning! Note that the flexibility of this feature also means you have to pay attention to the following. <ul>
 <li> Anyone with access to the remote control port (http) can alter the values of these options and save files anywhere on your server with the same privileges as the user running Motion. Anyone can access your control port if you have not either limited access to localhost or limited access using firewalls in the server. You should always have a router between a machine running Motion with remote control enabled and the Internet and make sure the Motion control port is not accessible from the outside.
 </li> <li> Anyone with local access to the computer and edit rights to the motion.conf file can alter the values of these options and save files anywhere on your server with the same privileges as the user running Motion. Make sure the motion.conf file is maximum readonly to anyone else but the user running Motion.
 </li> <li> It is a good idea to run Motion as a harmless user. Not as root.
@@ -3301,15 +2182,14 @@ NOTE: Unless you use the <code>minimum_g
 <strong>These are the advanced filename options in motion.conf</strong>
 <p />
 <p />
-<p />
 <h3><a name="ffmpeg_filename_now_called_movie"></a> ffmpeg_filename (now called movie_filename) </h3>
 <p />
-<img src="http://www.lavrsen.dk/foswiki/pub/System/DocumentGraphics/warning.gif" alt="ALERT!" title="ALERT!" width="16" height="16" border="0" /> <font color="#ff0000">This option was renamed to <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionMovieFilename">movie_filename</a> in 3.2.5 to enable better integration of alternative movie libraries to the current ffmpeg solution.</font>
+<img src="http://www.lavrsen.dk/twiki/pub/TWiki/TWikiDocGraphics/warning.gif" alt="ALERT!" title="ALERT!" width="16" height="16" border="0" /> <font color="#ff0000">This option was renamed to <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionMovieFilename" class="twikiLink">movie_filename</a> in 3.2.5 to enable better integration of alternative movie libraries to the current ffmpeg solution.</font>
 <p /> <ul>
 <li> Type: String
 </li> <li> Range / Valid values: Max 4095 characters
 </li> <li> Default: %v-%Y%m%d%H%M%S
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionFfmpegFilename">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionFfmpegFilename" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 File path for motion triggered ffmpeg movies (mpeg) relative to target_dir. This option was renamed to movie_filename in 3.2.5 to enable better integration of alternative movie libraries to the current ffmpeg solution.
@@ -3319,7 +2199,7 @@ For Motion 3.0 compatible mode (director
 <p />
 File extension .mpg or .avi is automatically added so do not include this.
 <p />
-This option uses <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">conversion specifiers</a> which are codes that start by % and then a letter. The conversion specifiers used has the same function as for the C function strftime (3). The most commonly used are: <ul>
+This option uses <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">conversion specifiers</a> which are codes that start by % and then a letter. The conversion specifiers used has the same function as for the C function strftime (3). The most commonly used are: <ul>
 <li> %Y = year
 </li> <li> %m = month as two digits
 </li> <li> %d = date
@@ -3345,21 +2225,19 @@ These are unique to motion  <ul>
 If you are happy with the directory structures the way they were in earlier versions of motion use %v-%Y%m%d%H%M%S for 'oldlayout on' and %Y/%m/%d/%H%M%S for 'oldlayout off'.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="jpeg_filename"></a> jpeg_filename </h3>
 <p /> <ul>
 <li> Type: String
 </li> <li> Range / Valid values: Max 4095 characters
 </li> <li> Default: %v-%Y%m%d%H%M%S-%q
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionJpegFilename">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionJpegFilename" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 File path for motion triggered images (jpeg or ppm) relative to target_dir. Value 'preview' makes a jpeg filename with the same name body as the associated saved mpeg movie file.
 <p />
 Default value is equivalent to legacy 'oldlayout' option. For Motion 3.0 compatible mode (directories based on date and time) choose: %Y/%m/%d/%H/%M/%S-%q
 <p />
-This option uses <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">conversion specifiers</a> which are codes that start by % and then a letter. The conversion specifiers used has the same function as for the C function strftime (3). The most commonly used are: <ul>
+This option uses <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">conversion specifiers</a> which are codes that start by % and then a letter. The conversion specifiers used has the same function as for the C function strftime (3). The most commonly used are: <ul>
 <li> %Y = year
 </li> <li> %m = month as two digits
 </li> <li> %d = date
@@ -3387,26 +2265,24 @@ If you are happy with the directory stru
 The value 'preview' only works when 'output_normal' is set to 'best'. It makes Motion name the best preview jpeg file (image with most changed pixels during the event) with the same body name as the mpeg movie created during the same event. The purpose is to create a good single image that represents the saved mpeg moview so you can decide if you want to see it and spend time downloading it from a web page.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="movie_filename"></a> movie_filename </h3>
 <p /> <ul>
 <li> Type: String
 </li> <li> Range / Valid values: Max 4095 characters
 </li> <li> Default: %v-%Y%m%d%H%M%S
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionMovieFilename">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionMovieFilename" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 File path for motion triggered ffmpeg movies (mpeg) relative to target_dir. This was previously called ffmpeg_filename.
 <p />
-<img src="http://www.lavrsen.dk/foswiki/pub/System/DocumentGraphics/warning.gif" alt="ALERT!" title="ALERT!" width="16" height="16" border="0" /> This option was renamed from ffmpeg_filename to movie_filename in Motion 3.2.5.
+<img src="http://www.lavrsen.dk/twiki/pub/TWiki/TWikiDocGraphics/warning.gif" alt="ALERT!" title="ALERT!" width="16" height="16" border="0" /> This option was renamed from ffmpeg_filename to movie_filename in Motion 3.2.5.
 <p />
 Default value is equivalent to legacy 'oldlayout' option
 For Motion 3.0 compatible mode (directories based on date and time) choose: %Y/%m/%d/%H%M%S
 <p />
 File extension .mpg or .avi is automatically added so do not include this.
 <p />
-This option uses <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">conversion specifiers</a> which are codes that start by % and then a letter. The conversion specifiers used has the same function as for the C function strftime (3). The most commonly used are: <ul>
+This option uses <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">conversion specifiers</a> which are codes that start by % and then a letter. The conversion specifiers used has the same function as for the C function strftime (3). The most commonly used are: <ul>
 <li> %Y = year
 </li> <li> %m = month as two digits
 </li> <li> %d = date
@@ -3432,14 +2308,12 @@ These are unique to motion  <ul>
 If you are happy with the directory structures the way they were in earlier versions of motion use %v-%Y%m%d%H%M%S for 'oldlayout on' and %Y/%m/%d/%H%M%S for 'oldlayout off'.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="snapshot_filename"></a> snapshot_filename </h3>
 <p /> <ul>
 <li> Type: String
 </li> <li> Range / Valid values: Max 4095 characters
 </li> <li> Default: %v-%Y%m%d%H%M%S-snapshot
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionSnapshotFilename">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionSnapshotFilename" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 File path for snapshots (jpeg or ppm) relative to target_dir.
@@ -3449,7 +2323,7 @@ Default value is equivalent to legacy 'o
 File extension .jpg or .ppm is automatically added so do not include this
 A symbolic link called lastsnap.jpg (or lastsnap.ppm) created in the target_dir will always point to the latest snapshot, unless snapshot_filename is exactly 'lastsnap'
 <p />
-This option uses <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">conversion specifiers</a> which are codes that start by % and then a letter. The conversion specifiers used has the same function as for the C function strftime (3). The most commonly used are: <ul>
+This option uses <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">conversion specifiers</a> which are codes that start by % and then a letter. The conversion specifiers used has the same function as for the C function strftime (3). The most commonly used are: <ul>
 <li> %Y = year
 </li> <li> %m = month as two digits
 </li> <li> %d = date
@@ -3477,14 +2351,12 @@ If you are happy with the directory stru
 For the equivalent of the now obsolete option 'snap_overwrite' use the value 'lastsnap'.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="target_dir"></a> target_dir </h3>
 <p /> <ul>
 <li> Type: String
 </li> <li> Range / Valid values: Max 4095 characters
 </li> <li> Default: Not defined = current working directory
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTargetDir">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTargetDir" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Target directory for picture and movie files.
@@ -3494,14 +2366,12 @@ This is the target directory for all sna
 Note that the options snapshot_filename, jpeg_filename, ffmpeg_filename, and timelapse_filename all allows specifying directories. These will all be relative to 'target_dir'. This means in principle that you can specify target_dir as '/' and be 100% flexible. It also means that Motion can write files all over your harddisk if you make a mistake. It is recommended to specify the target_dir as deep or detailed as possible for this reason.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="timelapse_filename"></a> timelapse_filename </h3>
 <p /> <ul>
 <li> Type: String
 </li> <li> Range / Valid values: Max 4095 characters
 </li> <li> Default: %v-%Y%m%d-timelapse
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTimelapseFilename">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTimelapseFilename" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 File path for timelapse mpegs relative to target_dir (ffmpeg only).
@@ -3512,7 +2382,7 @@ For Motion 3.0 compatible mode (director
 <p />
 File extension .mpg is automatically added so do not include this.
 <p />
-This option uses <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">conversion specifiers</a> which are codes that start by % and then a letter. The conversion specifiers used has the same function as for the C function strftime (3). The most commonly used are: <ul>
+This option uses <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">conversion specifiers</a> which are codes that start by % and then a letter. The conversion specifiers used has the same function as for the C function strftime (3). The most commonly used are: <ul>
 <li> %Y = year
 </li> <li> %m = month as two digits
 </li> <li> %d = date
@@ -3538,219 +2408,68 @@ These are unique to motion  <ul>
 If you are happy with the directory structures the way they were in earlier versions of motion use %v-%Y%m%d-timelapse for 'oldlayout on' and %Y/%m/%d-timelapse for 'oldlayout off'.
 <p />
 <p />
-<p />
-<p />
-<p />
-<h2><a name="Conversion_Specifiers_for_Advanc"></a> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">Conversion Specifiers for Advanced Filename and Text Features</a> </h2>
+<h2><a name="Conversion_Specifiers_for_Advanc"></a> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">Conversion Specifiers for Advanced Filename and Text Features</a> </h2>
 The table below shows all the supported Conversion Specifiers you can use in the options <code>text_event</code>, <code>text_left</code>, <code>text_right</code>, <code>sql_query</code>, <code>snapshot_filename</code>, <code>jpeg_filename</code>, <code>ffmpeg_filename</code>, <code>timelapse_filename</code>, <code>on_event_start</code>, <code>on_event_end</code>, <code>on_picture_save</code>, <code>on_movie_start</code>, <code>on_movie_end</code>, and <code>on_motion_detected</code>.
 <p />
 In <code>text_left</code> and <code>text_right</code> you can additionally use '\n' for new line.
 <p />
-<table cellspacing="0" id="table12" cellpadding="0" class="foswikiTable" rules="rows" border="1">
-	<thead>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<th bgcolor="#687684" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a rel="nofollow" href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument;sortcol=0;table=12;up=0#sorted_table" title="Sort by this column"><font color="#ffffff">Conversion Specifier</font></a> </th>
-			<th bgcolor="#687684" valign="top" class="foswikiTableCol1 foswikiLastCol"> <a rel="nofollow" href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument;sortcol=1;table=12;up=0#sorted_table" title="Sort by this column"><font color="#ffffff">Description</font></a> </th>
-		</tr>
-	</thead>
-	<tbody>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %a </td>
-			<td bgcolor="#ffffff" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> The abbreviated weekday name according to the current locale. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td bgcolor="#edf4f9" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %A </td>
-			<td bgcolor="#edf4f9" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> The full weekday name according to the current locale. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %b </td>
-			<td bgcolor="#ffffff" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> The abbreviated month name according to the current locale. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td bgcolor="#edf4f9" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %B </td>
-			<td bgcolor="#edf4f9" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> The full month name according to the current locale. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %c </td>
-			<td bgcolor="#ffffff" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> The preferred date and time representation for the current locale. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td bgcolor="#edf4f9" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %C </td>
-			<td bgcolor="#edf4f9" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> Text defined by the <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTextEvent">text_event</a> feature </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %d </td>
-			<td bgcolor="#ffffff" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> The day of the month as a decimal number (range 01 to 31). </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td bgcolor="#edf4f9" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %D </td>
-			<td bgcolor="#edf4f9" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> Number of pixels detected as Motion. If labelling is enabled the number is the number of pixels in the largest labelled motion area. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %E </td>
-			<td bgcolor="#ffffff" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> Modifier: use alternative format, see below. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td bgcolor="#edf4f9" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %f </td>
-			<td bgcolor="#edf4f9" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> File name - used in the <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionOnPictureSave">on_picture_save</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionOnMovieStart">on_movie_start</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionOnMovieEnd">on_movie_end</a>, and <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionSqlQuery">sql_query</a> features. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %F </td>
-			<td bgcolor="#ffffff" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> Equivalent to %Y-%m-%d (the ISO 8601 date format). </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td bgcolor="#edf4f9" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %H </td>
-			<td bgcolor="#edf4f9" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> The hour as a decimal number using a 24-hour clock (range 00 to 23). </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %i </td>
-			<td bgcolor="#ffffff" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> Width of the rectangle containing the motion pixels (the rectangle that is shown on the image when <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionLocate">locate</a> is on). </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td bgcolor="#edf4f9" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %I </td>
-			<td bgcolor="#edf4f9" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> The hour as a decimal number using a 12-hour clock (range 01 to 12). </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %j </td>
-			<td bgcolor="#ffffff" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> The day of the year as a decimal number (range 001 to 366). </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td bgcolor="#edf4f9" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %J </td>
-			<td bgcolor="#edf4f9" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> Height of the rectangle containing the motion pixels (the rectangle that is shown on the image when <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionLocate">locate</a> is on). </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %k </td>
-			<td bgcolor="#ffffff" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> The hour (24-hour clock) as a decimal number (range 0 to 23); single digits are preceded by a blank. (See also %H.) </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td bgcolor="#edf4f9" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %K </td>
-			<td bgcolor="#edf4f9" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> X coordinate in pixels of the center point of motion. Origin is upper left corner. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %l </td>
-			<td bgcolor="#ffffff" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> The hour (12-hour clock) as a decimal number (range 1 to 12); single digits are preceded by a blank. (See also %I.) </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td bgcolor="#edf4f9" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %L </td>
-			<td bgcolor="#edf4f9" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> Y coordinate in pixels of the center point of motion. Origin is upper left corner and number is positive moving downwards (I may change this soon). </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %m </td>
-			<td bgcolor="#ffffff" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> The month as a decimal number (range 01 to 12). </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td bgcolor="#edf4f9" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %M </td>
-			<td bgcolor="#edf4f9" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> The minute as a decimal number (range 00 to 59). </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %n </td>
-			<td bgcolor="#ffffff" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> Filetype as used in the <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionOnPictureSave">on_picture_save</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionOnMovieStart">on_movie_start</a>, <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionOnMovieEnd">on_movie_end</a>, and <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionSqlQuery">sql_query</a> features. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td bgcolor="#edf4f9" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %N </td>
-			<td bgcolor="#edf4f9" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> Noise level. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %o </td>
-			<td bgcolor="#ffffff" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> Threshold. The number of detected pixels required to trigger motion. When <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionThresholdTune">threshold_tune</a> is 'on' this can be used to show the current tuned value of threshold. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td bgcolor="#edf4f9" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %p </td>
-			<td bgcolor="#edf4f9" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> Either 'AM' or 'PM' according to the given time value, or the corresponding strings for the current locale. Noon is treated as `pm' and midnight as `am'. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %P </td>
-			<td bgcolor="#ffffff" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> Like %p but in lowercase: `am' or `pm' or a corresponding string for the current locale. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td bgcolor="#edf4f9" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %q </td>
-			<td bgcolor="#edf4f9" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> Picture frame number within current second. For jpeg filenames this should always be included in the filename if you save more then 1 picture per second to ensure unique filenames. It is not needed in filenames for mpegs. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %Q </td>
-			<td bgcolor="#ffffff" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> Number of detected labels found by the despeckle feature </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td bgcolor="#edf4f9" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %r </td>
-			<td bgcolor="#edf4f9" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> The time in a.m. or p.m. notation. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %R </td>
-			<td bgcolor="#ffffff" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> The time in 24-hour notation (%H:%M). </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td bgcolor="#edf4f9" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %s </td>
-			<td bgcolor="#edf4f9" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> The number of seconds since the Epoch, i.e., since 1970-01-01 00:00:00 UTC. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %S </td>
-			<td bgcolor="#ffffff" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> The second as a decimal number (range 00 to 61). </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td bgcolor="#edf4f9" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %t </td>
-			<td bgcolor="#edf4f9" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> Thread number (camera number) </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %T </td>
-			<td bgcolor="#ffffff" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> The time in 24-hour notation (%H:%M:%S). </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td bgcolor="#edf4f9" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %u </td>
-			<td bgcolor="#edf4f9" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> The day of the week as a decimal, range 1 to 7, Monday being 1. See also %w. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %U </td>
-			<td bgcolor="#ffffff" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> The week number of the current year as a decimal number, range 00 to 53, starting with the first Sunday as the first day of week 01. See also %V and %W. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td bgcolor="#edf4f9" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %v </td>
-			<td bgcolor="#edf4f9" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> Event number. An event is a series of motion detections happening with less than 'gap' seconds between them. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %V </td>
-			<td bgcolor="#ffffff" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> The ISO 8601:1988 week number of the current year as a decimal number, range 01 to 53, where week 1 is the first week that has at least 4 days in the current year, and with Monday as the first day of the week. See also %U and %W. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td bgcolor="#edf4f9" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %w </td>
-			<td bgcolor="#edf4f9" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> The day of the week as a decimal, range 0 to 6, Sunday being 0. See also %u. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %W </td>
-			<td bgcolor="#ffffff" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> The week number of the current year as a decimal number, range 00 to 53, starting with the first Monday as the first day of week 01. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td bgcolor="#edf4f9" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %x </td>
-			<td bgcolor="#edf4f9" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> The preferred date representation for the current locale without the time. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %X </td>
-			<td bgcolor="#ffffff" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> The preferred time representation for the current locale without the date. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td bgcolor="#edf4f9" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %y </td>
-			<td bgcolor="#edf4f9" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> The year as a decimal number without a century (range 00 to 99). </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %Y </td>
-			<td bgcolor="#ffffff" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> The year as a decimal number including the century. </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td bgcolor="#edf4f9" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol"> %z </td>
-			<td bgcolor="#edf4f9" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol"> The time-zone as hour offset from GMT. </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" align="center" valign="top" class="foswikiTableCol0 foswikiFirstCol foswikiLast"> %Z </td>
-			<td bgcolor="#ffffff" align="left" valign="top" class="foswikiTableCol1 foswikiLastCol foswikiLast"> The time zone or name or abbreviation. </td>
-		</tr>
-	</tbody></table>
+<table style="border-width:1px;" cellspacing="0" cellpadding="0" class="twikiTable" border="1"><tr class="twikiTableEven"><th bgcolor="#6b7f93" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol" maxcols="0"> <a rel="nofollow" href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideOneLargeDocument&amp;amp;sortcol=0;table=11;up=0#sorted_table" style="color:#ffffff" title="Sort by this column">Conversion Specifier</a> </th><th bgcolor="#6b7f93" align="center" valign="top" style="text-align:center;vertical-align:top;" maxcols="0"> <a rel="nofollow" href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideOneLargeDocument&amp;amp;sortcol=1;table=11;up=0#sorted_table" style="color:#ffffff" title="Sort by this column">Description</a> </th></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %a </td><td bgcolor="#ffffff" align="left" valign="top" style="text-align:left;vertical-align:top;"> The abbreviated weekday name according to the current locale. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %A </td><td bgcolor="#edf4f9" align="left" valign="top" style="text-align:left;vertical-align:top;"> The full weekday name according to the current locale. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %b </td><td bgcolor="#ffffff" align="left" valign="top" style="text-align:left;vertical-align:top;"> The abbreviated month name according to the current locale. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %B </td><td bgcolor="#edf4f9" align="left" valign="top" style="text-align:left;vertical-align:top;"> The full month name according to the current locale. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %c </td><td bgcolor="#ffffff" align="left" valign="top" style="text-align:left;vertical-align:top;"> The preferred date and time representation for the current locale. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %C </td><td bgcolor="#edf4f9" align="left" valign="top" style="text-align:left;vertical-align:top;"> Text defined by the <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTextEvent" class="twikiLink">text_event</a> feature </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %d </td><td bgcolor="#ffffff" align="left" valign="top" style="text-align:left;vertical-align:top;"> The day of the month as a decimal number (range 01 to 31). </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %D </td><td bgcolor="#edf4f9" align="left" valign="top" style="text-align:left;vertical-align:top;"> Number of pixels detected as Motion. If labelling is enabled the number is the number of pixels in the largest labelled motion area. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %E </td><td bgcolor="#ffffff" align="left" valign="top" style="text-align:left;vertical-align:top;"> Modifier: use alternative format, see below. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %f </td><td bgcolor="#edf4f9" align="left" valign="top" style="text-align:left;vertical-align:top;"> File name - used in the <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionOnPictureSave" class="twikiLink">on_picture_save</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionOnMovieStart" class="twikiLink">on_movie_start</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionOnMovieEnd" class="twikiLink">on_movie_end</a>, and <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionSqlQuery" class="twikiLink">sql_query</a> features. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %F </td><td bgcolor="#ffffff" align="left" valign="top" style="text-align:left;vertical-align:top;"> Equivalent to %Y-%m-%d (the ISO 8601 date format). </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %H </td><td bgcolor="#edf4f9" align="left" valign="top" style="text-align:left;vertical-align:top;"> The hour as a decimal number using a 24-hour clock (range 00 to 23). </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %i </td><td bgcolor="#ffffff" align="left" valign="top" style="text-align:left;vertical-align:top;"> Width of the rectangle containing the motion pixels (the rectangle that is shown on the image when <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionLocate" class="twikiLink">locate</a> is on). </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %I </td><td bgcolor="#edf4f9" align="left" valign="top" style="text-align:left;vertical-align:top;"> The hour as a decimal number using a 12-hour clock (range 01 to 12). </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %j </td><td bgcolor="#ffffff" align="left" valign="top" style="text-align:left;vertical-align:top;"> The day of the year as a decimal number (range 001 to 366). </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %J </td><td bgcolor="#edf4f9" align="left" valign="top" style="text-align:left;vertical-align:top;"> Height of the rectangle containing the motion pixels (the rectangle that is shown on the image when <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionLocate" class="twikiLink">locate</a> is on). </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %k </td><td bgcolor="#ffffff" align="left" valign="top" style="text-align:left;vertical-align:top;"> The hour (24-hour clock) as a decimal number (range 0 to 23); single digits are preceded by a blank. (See also %H.) </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %K </td><td bgcolor="#edf4f9" align="left" valign="top" style="text-align:left;vertical-align:top;"> X coordinate in pixels of the center point of motion. Origin is upper left corner. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %l </td><td bgcolor="#ffffff" align="left" valign="top" style="text-align:left;vertical-align:top;"> The hour (12-hour clock) as a decimal number (range 1 to 12); single digits are preceded by a blank. (See also %I.) </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %L </td><td bgcolor="#edf4f9" align="left" valign="top" style="text-align:left;vertical-align:top;"> Y coordinate in pixels of the center point of motion. Origin is upper left corner and number is positive moving downwards (I may change this soon). </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %m </td><td bgcolor="#ffffff" align="left" valign="top" style="text-align:left;vertical-align:top;"> The month as a decimal number (range 01 to 12). </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %M </td><td bgcolor="#edf4f9" align="left" valign="top" style="text-align:left;vertical-align:top;"> The minute as a decimal number (range 00 to 59). </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %n </td><td bgcolor="#ffffff" align="left" valign="top" style="text-align:left;vertical-align:top;"> Filetype as used in the <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionOnPictureSave" class="twikiLink">on_picture_save</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionOnMovieStart" class="twikiLink">on_movie_start</a>, <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionOnMovieEnd" class="twikiLink">on_movie_end</a>, and <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionSqlQuery" class="twikiLink">sql_query</a> features. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %N </td><td bgcolor="#edf4f9" align="left" valign="top" style="text-align:left;vertical-align:top;"> Noise level. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %o </td><td bgcolor="#ffffff" align="left" valign="top" style="text-align:left;vertical-align:top;"> Threshold. The number of detected pixels required to trigger motion. When <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionThresholdTune" class="twikiLink">threshold_tune</a> is 'on' this can be used to show the current tuned value of threshold. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %p </td><td bgcolor="#edf4f9" align="left" valign="top" style="text-align:left;vertical-align:top;"> Either 'AM' or 'PM' according to the given time value, or the corresponding strings for the current locale. Noon is treated as `pm' and midnight as `am'. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %P </td><td bgcolor="#ffffff" align="left" valign="top" style="text-align:left;vertical-align:top;"> Like %p but in lowercase: `am' or `pm' or a corresponding string for the current locale. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %q </td><td bgcolor="#edf4f9" align="left" valign="top" style="text-align:left;vertical-align:top;"> Picture frame number within current second. For jpeg filenames this should always be included in the filename if you save more then 1 picture per second to ensure unique filenames. It is not needed in filenames for mpegs. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %Q </td><td bgcolor="#ffffff" align="left" valign="top" style="text-align:left;vertical-align:top;"> Number of detected labels found by the despeckle feature </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %r </td><td bgcolor="#edf4f9" align="left" valign="top" style="text-align:left;vertical-align:top;"> The time in a.m. or p.m. notation. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %R </td><td bgcolor="#ffffff" align="left" valign="top" style="text-align:left;vertical-align:top;"> The time in 24-hour notation (%H:%M). </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %s </td><td bgcolor="#edf4f9" align="left" valign="top" style="text-align:left;vertical-align:top;"> The number of seconds since the Epoch, i.e., since 1970-01-01 00:00:00 UTC. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %S </td><td bgcolor="#ffffff" align="left" valign="top" style="text-align:left;vertical-align:top;"> The second as a decimal number (range 00 to 61). </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %t </td><td bgcolor="#edf4f9" align="left" valign="top" style="text-align:left;vertical-align:top;"> Thread number (camera number) </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %T </td><td bgcolor="#ffffff" align="left" valign="top" style="text-align:left;vertical-align:top;"> The time in 24-hour notation (%H:%M:%S). </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %u </td><td bgcolor="#edf4f9" align="left" valign="top" style="text-align:left;vertical-align:top;"> The day of the week as a decimal, range 1 to 7, Monday being 1. See also %w. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %U </td><td bgcolor="#ffffff" align="left" valign="top" style="text-align:left;vertical-align:top;"> The week number of the current year as a decimal number, range 00 to 53, starting with the first Sunday as the first day of week 01. See also %V and %W. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %v </td><td bgcolor="#edf4f9" align="left" valign="top" style="text-align:left;vertical-align:top;"> Event number. An event is a series of motion detections happening with less than 'gap' seconds between them. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %V </td><td bgcolor="#ffffff" align="left" valign="top" style="text-align:left;vertical-align:top;"> The ISO 8601:1988 week number of the current year as a decimal number, range 01 to 53, where week 1 is the first week that has at least 4 days in the current year, and with Monday as the first day of the week. See also %U and %W. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %w </td><td bgcolor="#edf4f9" align="left" valign="top" style="text-align:left;vertical-align:top;"> The day of the week as a decimal, range 0 to 6, Sunday being 0. See also %u. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %W </td><td bgcolor="#ffffff" align="left" valign="top" style="text-align:left;vertical-align:top;"> The week number of the current year as a decimal number, range 00 to 53, starting with the first Monday as the first day of week 01. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %x </td><td bgcolor="#edf4f9" align="left" valign="top" style="text-align:left;vertical-align:top;"> The preferred date representation for the current locale without the time. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %X </td><td bgcolor="#ffffff" align="left" valign="top" style="text-align:left;vertical-align:top;"> The preferred time representation for the current locale without the date. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %y </td><td bgcolor="#edf4f9" align="left" valign="top" style="text-align:left;vertical-align:top;"> The year as a decimal number without a century (range 00 to 99). </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %Y </td><td bgcolor="#ffffff" align="left" valign="top" style="text-align:left;vertical-align:top;"> The year as a decimal number including the century. </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol"> %z </td><td bgcolor="#edf4f9" align="left" valign="top" style="text-align:left;vertical-align:top;"> The time-zone as hour offset from GMT. </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol twikiLast"> %Z </td><td bgcolor="#ffffff" align="left" valign="top" style="text-align:left;vertical-align:top;" class="twikiLast"> The time zone or name or abbreviation. </td></tr>
+</table>
 <p />
 <p />
-<h2><a name="Webcam_Server"></a> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/WebcamServer">Webcam Server</a> </h2>
+<h2><a name="Webcam_Server"></a> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/WebcamServer" class="twikiLink">Webcam Server</a> </h2>
 Motion has simple webcam server built in. The video stream is in mjpeg format.
 <p />
 Each thread can have its own webcam server. If you enable the webcam server (option webcam_port to a number different from 0) and you have more than one camera, you must make sure to include webcam_port in each thread config file and set webcam_port to different and unique port numbers or zero (disable). Otherwise each webcam server will use the setting from the motion.conf file and try to bind to the same port. If the webcam_port numbers are not different from each other Motion will disable the webcam feature.
 <p />
-Note: The webcam server feature requires that the option <code>ppm</code> is set to <strong>off</strong>.
+Note: The webcam server feature requires that the option <code>ppm</code> is set to <strong>off</strong>. (I.e. saved images are jpeg images).
 <p />
 The <code>webcam_maxrate</code> and <code>webcam_quality</code> options are important to limit the load on your server and link. Don't set them too high unless you only use it on the localhost or on an internal LAN. The option <code>webcam_quality</code> is equivalent to the quality level for jpeg pictures.
 <p />
@@ -3790,20 +2509,17 @@ Note that the <code>stream.mjpg</code> p
 <strong>These are the special webcam parameters.</strong>
 <p />
 <p />
-<p />
 <h3><a name="webcam_limit"></a> webcam_limit </h3>
 <p /> <ul>
 <li> Type: Integer
 </li> <li> Range / Valid values: 0 - 2147483647
 </li> <li> Default: 0 (unlimited)
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionWebcamLimit">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionWebcamLimit" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Limit the number of frames to number frames. After 'webcam_limit' number of frames the connection will be closed by motion. The value 0 means unlimited.
 <p />
-Number can be defined by multiplying actual webcam rate by desired number of seconds. Actual webcam rate is the smallest of the numbers <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionFramerate">framerate</a> and <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionWebcamMaxrate">webcam_maxrate</a>.
-<p />
-<p />
+Number can be defined by multiplying actual webcam rate by desired number of seconds. Actual webcam rate is the smallest of the numbers <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionFramerate" class="twikiLink">framerate</a> and <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionWebcamMaxrate" class="twikiLink">webcam_maxrate</a>.
 <p />
 <p />
 <h3><a name="webcam_localhost"></a> webcam_localhost </h3>
@@ -3811,7 +2527,7 @@ Number can be defined by multiplying act
 <li> Type: Boolean
 </li> <li> Range / Valid values: on, off
 </li> <li> Default: on
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionWebcamLocalhost">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionWebcamLocalhost" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Limits the access to the webcam to the localhost.
@@ -3819,14 +2535,12 @@ Limits the access to the webcam to the l
 By setting this to on, the webcam can only be accessed on the same machine on which Motion is running.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="webcam_maxrate"></a> webcam_maxrate </h3>
 <p /> <ul>
 <li> Type: Integer
 </li> <li> Range / Valid values: 1 - 100
 </li> <li> Default: 1
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionWebcamMaxrate">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionWebcamMaxrate" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Limit the framerate of the webcam in frames per second. Default is 1. Set the value to 100 for practically unlimited.
@@ -3834,14 +2548,12 @@ Limit the framerate of the webcam in fra
 Don't set 'webcam_maxrate' too high unless you only use it on the localhost or on an internal LAN.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="webcam_motion"></a> webcam_motion </h3>
 <p /> <ul>
 <li> Type: Boolean
 </li> <li> Range / Valid values: on, off
 </li> <li> Default: off
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionWebcamMotion">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionWebcamMotion" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 If set to 'on' Motion sends slows down the webcam stream to 1 picture per second when no motion is detected. When motion is detected the stream runs as defined by webcam_maxrate. When 'off' the webcam stream always runs as defined by webcam_maxrate.
@@ -3852,13 +2564,12 @@ Note that this feature was greatly impro
 <p />
 <p />
 <p />
-<p />
 <h3><a name="webcam_port"></a> webcam_port </h3>
 <p /> <ul>
 <li> Type: Integer
 </li> <li> Range / Valid values: 0 - 65535
 </li> <li> Default: 0 (disabled)
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionWebcamPort">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionWebcamPort" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 TCP port on which motion will listen for incoming connects with its webcam server.
@@ -3868,23 +2579,19 @@ Note that each camera thread must have i
 A good value to select is 8081 for camera 1, 8082 for camera 2, 8083 for camera 3 etc etc.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="webcam_quality"></a> webcam_quality </h3>
 <p /> <ul>
 <li> Type: Integer
 </li> <li> Range / Valid values: 1 - 100
 </li> <li> Default: 50
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionWebcamQuality">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionWebcamQuality" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Quality setting in percent for the mjpeg picture frames transferred over the webcam connection. Keep it low to restrict needed bandwidth.
 <p />
 The mjpeg stream consists of a header followed by jpeg frames separated by content-length and boundary string. The quality level defines the size of the individual jpeg pictures in the mjpeg stream. If you set it too high you need quite a high bandwidth to view the stream.
 <p />
-<p />
-<p />
-<h2><a name="Remote_Control_with_http"></a> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/RemoteControlHttp">Remote Control with http</a> </h2>
+<h2><a name="Remote_Control_with_http"></a> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/RemoteControlHttp" class="twikiLink">Remote Control with http</a> </h2>
 <p />
 Motion can be remote controlled via a simple http interface. http is the language a normal web browser talks when it requests a web page. The web server answers back with some simple http headers followed by a webpage coded in HTML.
 <p />
@@ -3892,9 +2599,9 @@ Most Motion config options can be change
 <p />
 So the most obvious tool to use to remote control Motion is any web browser. All commands are sent using the http GET method which simply means that the information is sent via the URL and maybe a query string. You can use any browser (Firefox, Mozilla, Internet Explorer, Konquerer, Opera etc). You can also use the text based browser lynx to control Motion from a console. It navigates fine through the very simple and minimalistic http control interface of Motion.
 <p />
-The details about how to control Motion via the URL is described in detail in the <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionHttpAPI">Motion http API</a> topic.
+The details about how to control Motion via the URL is described in detail in the <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionHttpAPI" class="twikiLink">Motion http API</a> topic.
 <p />
-But it is probably simpler to connect to the control port with a browser, navigate to the function you want, and copy the URL from the browser URL entry line. If your <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionControlPort">control_port</a> is 8080 and you browse from the same machine on which Motion runs simply look up <a href="http://localhost:8080/" rel="nofollow" target="_top">http://localhost:8080/</a> and navigate around. Connecting from a remote machine is done by using a domain name (example <a href="http://mydomain.com:8080/" rel="nofollow" target="_top">http://mydomain.com:8080/</a>) or the IP address of the machine (example <a href="http://192.168.1.4:8080/" rel="nofollow" target="_top">http://192.168.1.4:8080/</a>). The option <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionControlLocalhost">control_localhost</a> must be off to allow connection from a remote machine.
+But it is probably simpler to connect to the control port with a browser, navigate to the function you want, and copy the URL from the browser URL entry line. If your <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionControlPort" class="twikiLink">control_port</a> is 8080 and you browse from the same machine on which Motion runs simply look up <a href="http://localhost:8080/" rel="nofollow" target="_top">http://localhost:8080/</a> and navigate around. Connecting from a remote machine is done by using a domain name (example <a href="http://mydomain.com:8080/" rel="nofollow" target="_top">http://mydomain.com:8080/</a>) or the IP address of the machine (example <a href="http://192.168.1.4:8080/" rel="nofollow" target="_top">http://192.168.1.4:8080/</a>). The option <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionControlLocalhost" class="twikiLink">control_localhost</a> must be off to allow connection from a remote machine.
 <p />
 If you want to use a script or cron to automatically change Motion settings while Motion runs you use a program that can fetch a webpage. We simply just throw away the html page that Motion returns. Programs commonly available on Linux machines are wget and lwp-request. Here is an example of how to start and stop motion detection via cron. These two lines are added to /etc/crontab.
 <p />
@@ -3913,7 +2620,7 @@ What happened to XMLRPC?
 <p />
 XMLRPC is replaced by a simpler http remote control interface. It is still being worked on but it is absolutely useable now and much nicer to work with than xmlrpc. Another advantage is that you do not need to install xmlrpc libraries. It is all written in standard C.
 <p />
-<img src="http://www.lavrsen.dk/foswiki/pub/System/DocumentGraphics/warning.gif" alt="ALERT!" title="ALERT!" width="16" height="16" border="0" /> Security Warning! Note that this feature also means you have to pay attention to the following. <ul>
+<img src="http://www.lavrsen.dk/twiki/pub/TWiki/TWikiDocGraphics/warning.gif" alt="ALERT!" title="ALERT!" width="16" height="16" border="0" /> Security Warning! Note that this feature also means you have to pay attention to the following. <ul>
 <li> Anyone with access to the remote control port (http) can alter the values of any options and save files anywhere on your server with the same privileges as the user running Motion. They can execute any command on your computer with the same privileges as the user running Motion. Anyone can access your control port if you have not either limited access to localhost or limited access using firewalls in the server. You should always have a router between a machine running Motion with remote control enabled and the Internet and make sure the Motion control port is not accessible from the outside.
 </li> <li> If you limit control port to localhost you still need to take care of any user logging into the server with any kind of terminal session.
 </li> <li> It is a good idea to run Motion as a harmless user. Not as root!!
@@ -3924,13 +2631,12 @@ XMLRPC is replaced by a simpler http rem
 These must be placed in motion.conf and not in a thread config file.
 <p />
 <p />
-<p />
 <h3><a name="control_authentication"></a> control_authentication </h3>
 <p /> <ul>
 <li> Type: String
 </li> <li> Range / Valid values: Max 4096 characters
 </li> <li> Default: Not defined
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionControlAuthentication">Option Topic</a>   
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionControlAuthentication" class="twikiLink">Option Topic</a>   
 </li></ul> 
 <p />
 To protect HTTP Control by username and password, use this option for HTTP 1.1 Basic authentication. The string is specified as username:password. Do not specify this option for no authentication. This option must be placed in motion.conf and not in a thread config file.
@@ -3944,14 +2650,12 @@ Add Additional Description Below
 -->
 <p />
 <p />
-<p />
-<p />
 <h3><a name="control_html_output"></a> control_html_output </h3>
 <p /> <ul>
 <li> Type: Boolean
 </li> <li> Range / Valid values: on, off
 </li> <li> Default: on
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionControlHtmlOutput">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionControlHtmlOutput" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Enable HTML in the answer sent back to a browser connecting to the control_port. This option must be placed in motion.conf and not in a thread config file.
@@ -3959,14 +2663,12 @@ Enable HTML in the answer sent back to a
 The recommended value for most is "on" which means that you can navigate and control Motion with a normal browser. By setting this option to "off" the replies are in plain text which may be easier to parse for 3rd party programs that control Motion.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="control_localhost"></a> control_localhost </h3>
 <p /> <ul>
 <li> Type: Boolean
 </li> <li> Range / Valid values: on, off
 </li> <li> Default: on
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionControlLocalhost">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionControlLocalhost" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Limits the http (html) control to the localhost. This option must be placed in motion.conf and not in a thread config file.
@@ -3974,14 +2676,12 @@ Limits the http (html) control to the lo
 By setting this to on, the control using http (browser) can only be accessed on the same machine on which Motion is running.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="control_port"></a> control_port </h3>
 <p /> <ul>
 <li> Type: Integer
 </li> <li> Range / Valid values: 0 - 65535
 </li> <li> Default: 0 (disabled)
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionControlPort">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionControlPort" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Sets the port number for the http (html using browser) based remote control. This option must be placed in motion.conf and not in a thread config file.
@@ -3990,68 +2690,29 @@ This sets the TCP/IP port number to be u
 <p />
 <p />
 <p />
+-- <a href="http://www.lavrsen.dk/twiki/bin/view/Main/KennethLavrsen" class="twikiLink">KennethLavrsen</a> - 12 Apr 2005
 <p />
--- <a href="http://www.lavrsen.dk/foswiki/bin/view/Main/KennethLavrsen">KennethLavrsen</a> - 12 Apr 2005
 <p />
-<h2><a name="External_Commands"></a> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ExternalCommands">External Commands</a> </h2>
+<h2><a name="External_Commands"></a> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ExternalCommands" class="twikiLink">External Commands</a> </h2>
 Motion can execute external commands based on the motion detection and related events. They are all described in this section. The option <code>quiet</code> is also included in this section.
 <p />
 A redesign of the external commands was due. They were not very easy to understand, not all were flexible enough and some were missing. So a new external command feature set was made for 3.2.1 and on.
 <p />
 This is how the new script commands look like:
 <p />
-<table cellspacing="0" id="table13" cellpadding="0" class="foswikiTable" rules="rows" border="1">
-	<thead>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<th bgcolor="#687684" valign="top" class="foswikiTableCol0 foswikiFirstCol"> <a rel="nofollow" href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument;sortcol=0;table=13;up=0#sorted_table" title="Sort by this column"><font color="#ffffff">Function</font></a> </th>
-			<th bgcolor="#687684" valign="top" class="foswikiTableCol1"> <a rel="nofollow" href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument;sortcol=1;table=13;up=0#sorted_table" title="Sort by this column"><font color="#ffffff">Old Option</font></a> </th>
-			<th bgcolor="#687684" valign="top" class="foswikiTableCol2"> <a rel="nofollow" href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument;sortcol=2;table=13;up=0#sorted_table" title="Sort by this column"><font color="#ffffff">New Option</font></a> </th>
-			<th bgcolor="#687684" valign="top" class="foswikiTableCol3 foswikiLastCol"> <a rel="nofollow" href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument;sortcol=3;table=13;up=0#sorted_table" title="Sort by this column"><font color="#ffffff">Argument Appended</font></a> </th>
-		</tr>
-	</thead>
-	<tbody>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> Start of event (first motion) </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> execute </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2"> on_event_start </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol3 foswikiLastCol"> None </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> End of event (no motion for gap seconds) </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> <em>New!</em> </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2"> on_event_end </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol3 foswikiLastCol"> None </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> Picture saved (jpg or ppm) </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> onsave </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2"> on_picture_save </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol3 foswikiLastCol"> Filename of picture </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol"> Movie starts (mpeg file opened) </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol1"> onmpeg </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2"> on_movie_start </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol3 foswikiLastCol"> Filename of movie </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol0 foswikiFirstCol"> Movie ends (mpeg file closed) </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol1"> onffmpegclose </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol2"> on_movie_end </td>
-			<td bgcolor="#ffffff" valign="top" class="foswikiTableCol3 foswikiLastCol"> Filename of movie </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol0 foswikiFirstCol foswikiLast"> Motion detected (each single frame with Motion detected) </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol1 foswikiLast"> <em>New!</em> </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol2 foswikiLast"> on_motion_detected </td>
-			<td bgcolor="#edf4f9" valign="top" class="foswikiTableCol3 foswikiLastCol foswikiLast"> None </td>
-		</tr>
-	</tbody></table>
+<table style="border-width:1px;" cellspacing="0" cellpadding="0" class="twikiTable" border="1"><tr class="twikiTableEven"><th bgcolor="#6b7f93" align="center" valign="top" style="text-align:center;vertical-align:top;" class="twikiFirstCol" maxcols="0"> <a rel="nofollow" href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideOneLargeDocument&amp;amp;sortcol=0;table=12;up=0#sorted_table" style="color:#ffffff" title="Sort by this column">Function</a> </th><th bgcolor="#6b7f93" align="center" valign="top" style="text-align:center;vertical-align:top;" maxcols="0"> <a rel="nofollow" href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideOneLargeDocument&amp;amp;sortcol=1;table=12;up=0#sorted_table" style="color:#ffffff" title="Sort by this column">Old Option</a> </th><th bgcolor="#6b7f93" align="center" valign="top" style="text-align:center;vertical-align:top;" maxcols="0"> <a rel="nofollow" href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideOneLargeDocument&amp;amp;sortcol=2;table=12;up=0#sorted_table" style="color:#ffffff" title="Sort by this column">New Option</a> </th><th bgcolor="#6b7f93" align="center" valign="top" style="text-align:center;vertical-align:top;" maxcols="0"> <a rel="nofollow" href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideOneLargeDocument&amp;amp;sortcol=3;table=12;up=0#sorted_table" style="color:#ffffff" title="Sort by this column">Argument Appended</a> </th></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> Start of event (first motion) </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> execute </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> on_event_start </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> None </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> End of event (no motion for gap seconds) </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> <em>New!</em> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> on_event_end </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> None </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> Picture saved (jpg or ppm) </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> onsave </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> on_picture_save </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Filename of picture </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol"> Movie starts (mpeg file opened) </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> onmpeg </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> on_movie_start </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;"> Filename of movie </td></tr>
+<tr class="twikiTableOdd"><td bgcolor="#ffffff" valign="top" style="vertical-align:top;" class="twikiFirstCol"> Movie ends (mpeg file closed) </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> onffmpegclose </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> on_movie_end </td><td bgcolor="#ffffff" valign="top" style="vertical-align:top;"> Filename of movie </td></tr>
+<tr class="twikiTableEven"><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiFirstCol twikiLast"> Motion detected (each single frame with Motion detected) </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiLast"> <em>New!</em> </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiLast"> on_motion_detected </td><td bgcolor="#edf4f9" valign="top" style="vertical-align:top;" class="twikiLast"> None </td></tr>
+</table>
 <p />
-Mail and sms has been removed because they were not configurable. If you want to send event-based mails or sms, just use one of those commands above and send the mail from that script. See <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideOneLargeDocument#MailSMS" class="foswikiCurrentTopicLink">What happened to mail and sms?</a>
+Mail and sms has been removed because they were not configurable. If you want to send event-based mails or sms, just use one of those commands above and send the mail from that script. See <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideOneLargeDocument#MailSMS" class="twikiCurrentTopicLink twikiAnchorLink">What happened to mail and sms?</a>
 <p />
 <p />
-<img src="http://www.lavrsen.dk/foswiki/pub/System/DocumentGraphics/warning.gif" alt="ALERT!" title="ALERT!" width="16" height="16" border="0" /> Security Warning! Note that this feature also means you have to pay attention to the following. <ul>
+<img src="http://www.lavrsen.dk/twiki/pub/TWiki/TWikiDocGraphics/warning.gif" alt="ALERT!" title="ALERT!" width="16" height="16" border="0" /> Security Warning! Note that this feature also means you have to pay attention to the following. <ul>
 <li> Anyone with access to the remote control port (http) can execute any command on your computer with the same privileges as the user running Motion. Anyone can access your control port if you have not either limited access to localhost or limited access using firewalls in the server. You should always have a router between a machine running Motion with remote control enabled and the Internet and make sure the Motion control port is not accessible from the outside.
 </li> <li> If you limit control port to localhost you still need to take care of any user logging into the server with any kind of GUI or terminal session. All it takes is a browser or single command line execution to change settings in Motion.
 </li> <li> It is a good idea to run Motion as a harmless user. Not as root!!
@@ -4060,52 +2721,15 @@ Mail and sms has been removed because th
 <strong>These are the options</strong>
 <p />
 <p />
-<p />
-<h3><a name="on_area_detected"></a> on_area_detected </h3>
-<p /> <ul>
-<li> Type: String
-</li> <li> Range / Valid values: Max 4095 characters
-</li> <li> Default: Not defined
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionOnAreaDetected">Option Topic</a>
-</li></ul> 
-<p />
-Command to be executed when motion in a predefined area is detected. Check option area_detect.
-<p />
-<!--
-Add Additional Description Below 
--->
-<p />
-<p />
-<p />
-<p />
-<h3><a name="on_camera_lost"></a> on_camera_lost </h3>
-<p /> <ul>
-<li> Type: String
-</li> <li> Range / Valid values: Max 4095 characters
-</li> <li> Default: Not defined
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionOnCameraLost">Option Topic</a>
-</li></ul> 
-<p />
-Command to be executed when a camera can't be opened or if it is lost. You can use <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">Conversion Specifiers</a> and spaces as part of the command. Use %f for passing filename (with full path) to the command. (new in 3.2.10)
-<p />
-<!--
-Add Additional Description Below 
--->
-<p />
-NOTE: There is situations when motion don't detect a lost camera!<br /> It depends on the driver, some drivers dosn't detect a lost camera at all<br /> Some hangs the motion thread. Some even hangs the PC!
-<p />
-<p />
-<p />
-<p />
 <h3><a name="on_event_end"></a> on_event_end </h3>
 <p /> <ul>
 <li> Type: String
 </li> <li> Range / Valid values: Max 4095 characters
 </li> <li> Default: Not defined
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionOnEventEnd">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionOnEventEnd" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
-Command to be executed when an event ends after a period of no motion. The period of no motion is defined by option gap. You can use <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">Conversion Specifiers</a> and spaces as part of the command.
+Command to be executed when an event ends after a period of no motion. The period of no motion is defined by option gap. You can use <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">Conversion Specifiers</a> and spaces as part of the command.
 <p />
 Full path name of the program/script.
 <p />
@@ -4114,17 +2738,15 @@ This can be any type of program or scrip
 The command is run when an event is over. I.e. the number of seconds defined by the time 'gap' has passed since the last detection of motion and motion closes the mpeg file.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="on_event_start"></a> on_event_start </h3>
 <p /> <ul>
 <li> Type: String
 </li> <li> Range / Valid values: Max 4095 characters
 </li> <li> Default: Not defined
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionOnEventStart">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionOnEventStart" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
-Command to be executed when an event starts. An event starts at first motion detected after a period of no motion defined by gap. You can use <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">ConversionSpecifiers</a> and spaces as part of the command.
+Command to be executed when an event starts. An event starts at first motion detected after a period of no motion defined by gap. You can use <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">ConversionSpecifiers</a> and spaces as part of the command.
 <p />
 Full path name of the program/script.
 <p />
@@ -4135,31 +2757,28 @@ The command is run when an event starts.
 This option replaces the former options 'mail', 'sms' and 'execute'.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="on_motion_detected"></a> on_motion_detected </h3>
 <p /> <ul>
 <li> Type: String
 </li> <li> Range / Valid values: Max 4095 characters
 </li> <li> Default: Not defined
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionOnMotionDetected">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionOnMotionDetected" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
-Command to be executed when a motion frame is detected. You can use <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">Conversion Specifiers</a> and spaces as part of the command.
+Command to be executed when a motion frame is detected. You can use <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">Conversion Specifiers</a> and spaces as part of the command.
 <p />
 Do not write "none" if you do not want to execute commands. Simply do not include the option in the file or comment it out by placing a "#" or ";" as the first character on the line before the execute command.
 <p />
 <p />
-<p />
 <h3><a name="on_movie_end"></a> on_movie_end </h3>
 <p /> <ul>
 <li> Type: String
 </li> <li> Range / Valid values: Max 4095 characters
 </li> <li> Default: Not defined
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionOnMovieEnd">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionOnMovieEnd" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
-Command to be executed when an ffmpeg movie is closed at the end of an event. You can use <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">Conversion Specifiers</a> and spaces as part of the command. Use %f for passing filename (with full path) to the command.
+Command to be executed when an ffmpeg movie is closed at the end of an event. You can use <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">Conversion Specifiers</a> and spaces as part of the command. Use %f for passing filename (with full path) to the command.
 <p />
 Full path name of the program/script.
 <p />
@@ -4171,7 +2790,7 @@ This option was previously called onffmp
 <p />
 Note that from Motion 3.2.4 the path name of the picture file is no longer appended to the command. Instead you can use the conversion specifier %f to insert the picture filename (full path) anywhere in the command.
 <p />
-Most common <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">conversion specifiers</a> 
+Most common <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">conversion specifiers</a> 
 <p /> <ul>
 <li> %Y = year, %m = month, %d = date
 </li> <li> %H = hour, %M = minute, %S = second
@@ -4188,28 +2807,25 @@ Most common <a href="http://www.lavrsen.
 </li></ul> 
 <p />
 <p />
-<p />
-<p />
-<p />
 <h3><a name="on_movie_start"></a> on_movie_start </h3>
 <p /> <ul>
 <li> Type: String
 </li> <li> Range / Valid values: Max 4095 characters
 </li> <li> Default: Not defined
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionOnMovieStart">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionOnMovieStart" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
-Command to be executed when an mpeg movie is created. You can use <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">Conversion Specifiers</a> and spaces as part of the command. Use %f for passing filename (with full path) to the command.
+Command to be executed when an mpeg movie is created. You can use <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">Conversion Specifiers</a> and spaces as part of the command. Use %f for passing filename (with full path) to the command.
 <p />
 Full path name of the program/script.
 <p />
-This can be any type of program or script. Remember to set the execution bit in the ACL and if it is a script type program such as perl or bash also remember the shebang line (e.g. #!/user/bin/perl) as the first line of the script. When you use ffmpeg the film is generated on the fly and on_movie_start then runs when the new mpeg file is created. Often you will want to use the <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionOnMovieEnd">on_movie_end</a> option which runs when the mpeg file is closed and the event is over.
+This can be any type of program or script. Remember to set the execution bit in the ACL and if it is a script type program such as perl or bash also remember the shebang line (e.g. #!/user/bin/perl) as the first line of the script. When you use ffmpeg the film is generated on the fly and on_movie_start then runs when the new mpeg file is created. Often you will want to use the <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionOnMovieEnd" class="twikiLink">on_movie_end</a> option which runs when the mpeg file is closed and the event is over.
 <p />
 This option was previously called onmpeg.
 <p />
 Note that from Motion 3.2.4 the path name of the picture file is no longer appended to the command. Instead you can use the conversion specifier %f to insert the picture filename (full path) anywhere in the command.
 <p />
-Most common <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">conversion specifiers</a> 
+Most common <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">conversion specifiers</a> 
 <p /> <ul>
 <li> %Y = year, %m = month, %d = date
 </li> <li> %H = hour, %M = minute, %S = second
@@ -4226,18 +2842,15 @@ Most common <a href="http://www.lavrsen.
 </li></ul> 
 <p />
 <p />
-<p />
-<p />
-<p />
 <h3><a name="on_picture_save"></a> on_picture_save </h3>
 <p /> <ul>
 <li> Type: String
 </li> <li> Range / Valid values: Max 4095 characters
 </li> <li> Default: Not defined
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionOnPictureSave">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionOnPictureSave" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
-Command to be executed when an image is saved. You can use <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">Conversion Specifiers</a> and spaces as part of the command. Use %f for passing filename (with full path) to the command.
+Command to be executed when an image is saved. You can use <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">Conversion Specifiers</a> and spaces as part of the command. Use %f for passing filename (with full path) to the command.
 <p />
 Full path name of the program/script.
 <p />
@@ -4245,7 +2858,7 @@ This can be any type of program or scrip
 <p />
 Note that from Motion 3.2.4 the path name of the picture file is no longer appended to the command. Instead you can use the conversion specifier %f to insert the picture filename (full path) anywhere in the command.
 <p />
-Most common <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">conversion specifiers</a> 
+Most common <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">conversion specifiers</a> 
 <p /> <ul>
 <li> %Y = year, %m = month, %d = date
 </li> <li> %H = hour, %M = minute, %S = second
@@ -4262,15 +2875,12 @@ Most common <a href="http://www.lavrsen.
 </li></ul> 
 <p />
 <p />
-<p />
-<p />
-<p />
 <h3><a name="quiet"></a> quiet </h3>
 <p /> <ul>
 <li> Type: Boolean
 </li> <li> Range / Valid values: on, off
 </li> <li> Default: off
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionQuiet">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionQuiet" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Be quiet, don't output beeps when detecting motion.
@@ -4279,15 +2889,14 @@ Only works in non-daemon mode.
 <p />
 <p />
 <p />
-<p />
 <a name="MailSMS"></a>
-<h3><a name="What_happened_to_mail_and_sms"></a> What happened to mail and sms? </h3>
+<h3><a name="What_happened_to_mail_and_sms"></a><a name="What_happened_to_mail_and_sms_"></a> What happened to mail and sms? </h3>
 The 6 new on_xxxxx options replace the former execute, mail and sms options.
 <p />
 They are quite generic and flexible. These small bash scripts gives to the same functionality as mail and sms BUT you have all the flexibility you want to extend the messages, change the 'from' email address etc.
 <p />
 <h4><a name="Sending_email_at_start_of_event"></a> Sending email at start of event </h4>
-<em>Script written by <a href="http://www.lavrsen.dk/foswiki/bin/view/Main/JoergWeber">JoergWeber</a></em>
+<em>Script written by <a href="http://www.lavrsen.dk/twiki/bin/view/Main/JoergWeber" class="twikiLink">JoergWeber</a></em>
 <pre>
 #!/bin/sh
 
@@ -4309,7 +2918,7 @@ echo -e &#34;This is an automated messag
 </pre>
 <p />
 <h4><a name="Sending_SMS_at_start_of_event"></a> Sending SMS at start of event </h4>
-<em>Script written by <a href="http://www.lavrsen.dk/foswiki/bin/view/Main/JoergWeber">JoergWeber</a></em>
+<em>Script written by <a href="http://www.lavrsen.dk/twiki/bin/view/Main/JoergWeber" class="twikiLink">JoergWeber</a></em>
 <p />
 If you uncomment the line <code>#/usr/local/bin/send_mail $1</code> you can combine both sending email and sms.
 <pre>
@@ -4337,28 +2946,26 @@ $SMS&#95;CLIENT $TO &#34;Motion detected
 </pre>
 <p />
 <p />
-<p />
 <h1><a name="Motion_Guide_Special_Features"></a> Motion Guide - Special Features </h1>
 <p />
-<h2><a name="Tracking_Control"></a> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/TrackingControl">Tracking Control</a> </h2>
-This is still at the experimental stage. Read more about it <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionTracking">motion tracking</a> page.
+<h2><a name="Tracking_Control"></a> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/TrackingControl" class="twikiLink">Tracking Control</a> </h2>
+This is still at the experimental stage. Read more about it <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionTracking" class="twikiLink">motion tracking</a> page.
 <p />
 <h3><a name="Tracking_Feature_with_Logitech_Q"></a> Tracking Feature with Logitech Quickcam Sphere/Orbit </h3>
 Motion supports controlling the pan and tilt feature of a Logitech Quickcam Sphere/Orbit.
 <p />
-Motion can move the camera to a fixed position given in degrees pan (left-right) and tilt (down-up). Movement can be set with absolute coordinates or relative to current position. There is also an auto tracking feature for the Logitech Quickcam Sphere/Orbit but it is not very mature. It is fun to play with but not very useful yet. See this topic of how <a href="http://www.lavrsen.dk/foswiki/bin/view/Main/KennethLavrsen">KennethLavrsen</a> controls his Sphere: <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/LogitechSphereControl">LogitechSphereControl</a>.
+Motion can move the camera to a fixed position given in degrees pan (left-right) and tilt (down-up). Movement can be set with absolute coordinates or relative to current position. There is also an auto tracking feature for the Logitech Quickcam Sphere/Orbit but it is not very mature. It is fun to play with but not very useful yet. See this topic of how <a href="http://www.lavrsen.dk/twiki/bin/view/Main/KennethLavrsen" class="twikiLink">KennethLavrsen</a> controls his Sphere: <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/LogitechSphereControl" class="twikiLink">LogitechSphereControl</a>.
 <p />
-For a detailed description of http remote control see the section <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/RemoteControlHttp">Remote Control with http</a>.
+For a detailed description of http remote control see the section <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/RemoteControlHttp" class="twikiLink">Remote Control with http</a>.
 <p />
 <strong>List of tracking options</strong>
 <p />
-<p />
 <h3><a name="track_auto"></a> track_auto </h3>
 <p /> <ul>
 <li> Type: Boolean
 </li> <li> Range / Valid values: on, off
 </li> <li> Default: off
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTrackAuto">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTrackAuto" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Enable auto tracking
@@ -4366,14 +2973,12 @@ Enable auto tracking
 Requires a tracking camera type supported by Motion.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="track_iomojo_id"></a> track_iomojo_id </h3>
 <p /> <ul>
 <li> Type: Integer
-</li> <li> Range / Valid values: 0 - 65535
+</li> <li> Range / Valid values: 0 - 2147483647
 </li> <li> Default: 0 
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTrackIomojoId">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTrackIomojoId" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Use this option if you have an iomojo smilecam connected to the serial port instead of a general stepper motor controller.
@@ -4381,14 +2986,12 @@ Use this option if you have an iomojo sm
 Only used for iomojo camera.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="track_maxx"></a> track_maxx </h3>
 <p /> <ul>
 <li> Type: Integer
-</li> <li> Range / Valid values: 0 - 65535
-</li> <li> Default: 0
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTrackMaxx">Option Topic</a>
+</li> <li> Range / Valid values: 0 - 2147483647
+</li> <li> Default: 0 
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTrackMaxx" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 The maximum position for servo x.
@@ -4396,14 +2999,12 @@ The maximum position for servo x.
 Only used for stepper motor tracking.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="track_maxy"></a> track_maxy </h3>
 <p /> <ul>
 <li> Type: Integer
-</li> <li> Range / Valid values: 0 - 65535
+</li> <li> Range / Valid values: 0 - 2147483647
 </li> <li> Default: 0 
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTrackMaxy">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTrackMaxy" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 The maximum position for servo y.
@@ -4415,14 +3016,12 @@ Add Additional Description Below
 -->
 <p />
 <p />
-<p />
-<p />
 <h3><a name="track_motorx"></a> track_motorx </h3>
 <p /> <ul>
 <li> Type: Integer
-</li> <li> Range / Valid values: 0 - 65535
-</li> <li> Default: 0
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTrackMotorx">Option Topic</a>
+</li> <li> Range / Valid values: -1 - 2147483647
+</li> <li> Default: -1
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTrackMotorx" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 The motor number that is used for controlling the x-axis.
@@ -4430,14 +3029,12 @@ The motor number that is used for contro
 Only used for stepper motor tracking. 
 <p />
 <p />
-<p />
-<p />
 <h3><a name="track_motory"></a> track_motory </h3>
 <p /> <ul>
 <li> Type: Integer
-</li> <li> Range / Valid values: 0 - 65535
-</li> <li> Default: 0
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTrackMotory">Option Topic</a>
+</li> <li> Range / Valid values: -1 - 2147483647
+</li> <li> Default: -1
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTrackMotory" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 The motor number that is used for controlling the y-axis.
@@ -4449,14 +3046,12 @@ Add Additional Description Below
 -->
 <p />
 <p />
-<p />
-<p />
 <h3><a name="track_move_wait"></a> track_move_wait </h3>
 <p /> <ul>
 <li> Type: Integer
-</li> <li> Range / Valid values: 0 - 65535
+</li> <li> Range / Valid values: 0 - 2147483647
 </li> <li> Default: 10
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTrackMoveWait">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTrackMoveWait" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Delay during which tracking is disabled after auto tracking has moved the camera. Delay is defined as number of picture frames.
@@ -4464,14 +3059,12 @@ Delay during which tracking is disabled
 The actual delay is depending on the chosen framerate. If you want the camera to move maximum once every 2 seconds and the framerate is 10 then you need to set the track_move_wait value to 2 * 10 = 20.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="track_port"></a> track_port </h3>
 <p /> <ul>
 <li> Type: String
 </li> <li> Range / Valid values: Max 4095 characters
 </li> <li> Default: Not defined
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTrackPort">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTrackPort" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 This is the device name of the serial port to which the stepper motor interface is connected.
@@ -4479,14 +3072,12 @@ This is the device name of the serial po
 Only used for stepper motor tracking.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="track_speed"></a> track_speed </h3>
 <p /> <ul>
 <li> Type: Integer
 </li> <li> Range / Valid values: 0 - 255
 </li> <li> Default: 255
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTrackSpeed">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTrackSpeed" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Speed to set the motor to.
@@ -4494,14 +3085,12 @@ Speed to set the motor to.
 Only used for stepper motor tracking.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="track_step_angle_x"></a> track_step_angle_x </h3>
 <p /> <ul>
 <li> Type: Integer
 </li> <li> Range / Valid values: 0-90
 </li> <li> Default: 10
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTrackStepAngleX">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTrackStepAngleX" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Angle in degrees the camera moves per step on the X-axis with auto tracking. Currently only used with pwc type cameras.
@@ -4509,14 +3098,12 @@ Angle in degrees the camera moves per st
 Requires a tracking camera type pwc.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="track_step_angle_y"></a> track_step_angle_y </h3>
 <p /> <ul>
 <li> Type: Integer
 </li> <li> Range / Valid values: 0-40
 </li> <li> Default: 10
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTrackStepAngleY">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTrackStepAngleY" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Angle in degrees the camera moves per step on the Y-axis with auto tracking. Currently only used with pwc type cameras.
@@ -4528,14 +3115,12 @@ Add Additional Description Below
 -->
 <p />
 <p />
-<p />
-<p />
 <h3><a name="track_stepsize"></a> track_stepsize </h3>
 <p /> <ul>
 <li> Type: Integer
 </li> <li> Range / Valid values: 0 - 255
 </li> <li> Default: 40
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTrackStepsize">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTrackStepsize" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Number of steps to make.
@@ -4543,52 +3128,45 @@ Number of steps to make.
 Only used for stepper motor tracking.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="track_type"></a> track_type </h3>
 <p /> <ul>
 <li> Type: Discrete Strings
 </li> <li> Range / Valid values: 0 (none), 1 (stepper), 2 (iomojo), 3 (pwc), 4 (generic), 5 (uvcvideo)
 </li> <li> Default: 0 (None)
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionTrackType">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionTrackType" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Type of tracker.
 <p />
-Motion has special tracking options which use either a serial stepper motor controller, an iomojo smile cam or a Philips <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/WebCam">WebCam</a> driver compatible pan/tilt camera such as the Logitech Quickcam Sphere or Orbit.
+Motion has special tracking options which use either a serial stepper motor controller, an iomojo smile cam or a Philips <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/WebCam" class="twikiLink">WebCam</a> driver compatible pan/tilt camera such as the Logitech Quickcam Sphere or Orbit.
 <p />
 To disable tracking, set this to 0 and the other track options are ignored.
 <p />
-Value 1 is for the special <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionTracking">Motion Tracking</a> project using a stepper motor and a home made controller.
+Value 1 is for the special <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/MotionTracking" class="twikiLink">Motion Tracking</a> project using a stepper motor and a home made controller.
 <p />
 Value 2 is for the iomojo smilecam
 <p />
-Value 3 is for pwc type USB tracking cameras such as the Logitech Quickcam Sphere/Orbit which is driven by the pwc (Philips <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/WebCam">WebCam</a>) driver. To use this camera your version of pwc must be at least 8.12.
+Value 3 is for pwc type USB tracking cameras such as the Logitech Quickcam Sphere/Orbit which is driven by the pwc (Philips <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/WebCam" class="twikiLink">WebCam</a>) driver. To use this camera your version of pwc must be at least 8.12.
 <p />
 Value 4 is the generic track type. Currently it has no other function than enabling some of the internal Motion features related to tracking. Eventually more functionality will be implemented for this type.
 <p />
 Value 5 is for uvcvideo type USB tracking cameras such as the Logitech Quickcam Sphere/Orbit MP (new Model) which is driven by the <a href="http://linux-uvc.berlios.de/" rel="nofollow" target="_top">uvcvideo</a> driver. This option was added in Motion 3.2.8.
 <p />
 <p />
-<p />
-<p />
-<p />
-<p />
-<h2><a name="Using_Databases"></a> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/UsingDatabases">Using Databases</a> </h2>
-Motion can be compiled with both MySQL and PostgreSQL database support. When enabled Motion adds a record to a table in the database as specified by the <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionSqlQuery">sql_query</a>. The query contains the fields that are used and the value are given by using <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">conversion specifiers</a> for dynamic data like filename, time, number of detected pixels etc. Motion does not place any binary images in the database and it cannot remove old records.
+<h2><a name="Using_Databases"></a> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/UsingDatabases" class="twikiLink">Using Databases</a> </h2>
+Motion can be compiled with both MySQL and PostgreSQL database support. When enabled Motion adds a record to a table in the database as specified by the <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionSqlQuery" class="twikiLink">sql_query</a>. The query contains the fields that are used and the value are given by using <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">conversion specifiers</a> for dynamic data like filename, time, number of detected pixels etc. Motion does not place any binary images in the database and it cannot remove old records.
 <p />
 Motion only adds records to the database when files are created. The database contains records of saved files which means to get a record in the database the feature that enables for example motion detection, timelapse, snapshots etc must be enabled. The sql_log options defines which types of files are logged in the database.
 <p />
 The following sql_log options are common to both MySQL and PostgreSQL.
 <p />
 <p />
-<p />
 <h3><a name="sql_log_image"></a> sql_log_image </h3>
 <p /> <ul>
 <li> Type: Boolean
 </li> <li> Range / Valid values: on, off
 </li> <li> Default: on
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionSqlLogImage">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionSqlLogImage" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Log to the database when creating motion triggered image file.
@@ -4596,14 +3174,12 @@ Log to the database when creating motion
 Configuration option common to MySQL and PostgreSQL. Motion must be built with MySQL or PostgreSQL support to use this feature.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="sql_log_mpeg"></a> sql_log_mpeg </h3>
 <p /> <ul>
 <li> Type: Boolean
 </li> <li> Range / Valid values: on, off
 </li> <li> Default: off
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionSqlLogMpeg">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionSqlLogMpeg" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Log to the database when creating motion triggered mpeg file.
@@ -4611,14 +3187,12 @@ Log to the database when creating motion
 Configuration option common to MySQL and PostgreSQL. Motion must be built with MySQL or PostgreSQL support to use this feature.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="sql_log_snapshot"></a> sql_log_snapshot </h3>
 <p /> <ul>
 <li> Type: Boolean
 </li> <li> Range / Valid values: on, off
 </li> <li> Default: on
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionSqlLogSnapshot">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionSqlLogSnapshot" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Log to the database when creating a snapshot image file.
@@ -4626,14 +3200,12 @@ Log to the database when creating a snap
 Configuration option common to MySQL and PostgreSQL. Motion must be built with MySQL or PostgreSQL support to use this feature.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="sql_log_timelapse"></a> sql_log_timelapse </h3>
 <p /> <ul>
 <li> Type: Boolean
 </li> <li> Range / Valid values: on, off
 </li> <li> Default: off
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionSqlLogTimelapse">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionSqlLogTimelapse" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Log to the database when creating timelapse mpeg file
@@ -4641,19 +3213,17 @@ Log to the database when creating timela
 Configuration option common to MySQL and PostgreSQL. Motion must be built with MySQL or PostgreSQL support to use this feature.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="sql_query"></a> sql_query </h3>
 <p /> <ul>
 <li> Type: String
 </li> <li> Range / Valid values: Max 4095 characters
 </li> <li> Default: insert into security(camera, filename, frame, file_type, time_stamp, text_event) values('%t', '%f', '%q', '%n', '%Y-%m-%d %T', '%C') 
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionSqlQuery">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionSqlQuery" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
-SQL query string that is sent to the database. The values for each field are given by using <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">convertion specifiers</a>
+SQL query string that is sent to the database. The values for each field are given by using <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">convertion specifiers</a>
 <p />
-Most common <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConversionSpecifiers">conversion specifiers</a> 
+Most common <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConversionSpecifiers" class="twikiLink">conversion specifiers</a> 
 <p /> <ul>
 <li> %Y = year, %m = month, %d = date
 </li> <li> %H = hour, %M = minute, %S = second
@@ -4670,13 +3240,12 @@ Most common <a href="http://www.lavrsen.
 </li></ul> 
 <p />
 <p />
-<p />
 See the "MySQL" section for detailed information about the database itself.
 <p />
-<h2><a name="MySQL"></a> MySQL </h2>
+<h2><a name="MySQL"></a><a name="_MySQL"></a> MySQL </h2>
 You can use the MySQL database to register each file that is stored by motion.
 <p />
-You need to generate a new database with a name of your own choice. You must enter this name in the config file (mysql_db option). The default value for the option <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionSqlQuery">sql_query</a> requires that you create a new database in MySQL with a new table called "security" with the following fields:
+You need to generate a new database with a name of your own choice. You must enter this name in the config file (mysql_db option). The default value for the option <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionSqlQuery" class="twikiLink">sql_query</a> requires that you create a new database in MySQL with a new table called "security" with the following fields:
 <p />
 insert into security(camera, filename, frame, file_type, time_stamp, text_event) values('%t', '%f', '%q', '%n', '%Y-%m-%d %T', '%C')
 <p /> <ul>
@@ -4688,37 +3257,17 @@ insert into security(camera, filename, f
 </li> <li> text_event (timestamp) - The text from the text_event option which by default is compatible with timestamps in SQL.
 </li></ul> 
 <p />
-Note from version 3.2.4 the introduction of <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionSqlQuery">sql_query</a> completely redefines the way you setup the SQL feature. It is now 100% flexible and can easily be made compatible with your existing Motion database from earlier versions of Motion.
+Note from version 3.2.4 the introduction of <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionSqlQuery" class="twikiLink">sql_query</a> completely redefines the way you setup the SQL feature. It is now 100% flexible and can easily be made compatible with your existing Motion database from earlier versions of Motion.
 <p />
 These are the file type descriptions and the file type numbers stored in the database.
 <p />
-<table cellspacing="0" id="table14" cellpadding="0" class="foswikiTable" rules="rows" border="1">
-	<tbody>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="400" bgcolor="#ffffff" align="left" valign="top" class="foswikiTableCol0 foswikiFirstCol"> Normal image </td>
-			<td width="70" bgcolor="#ffffff" align="center" valign="top" class="foswikiTableCol1 foswikiLastCol"> 1 </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="400" bgcolor="#edf4f9" align="left" valign="top" class="foswikiTableCol0 foswikiFirstCol"> Snapshot image </td>
-			<td width="70" bgcolor="#edf4f9" align="center" valign="top" class="foswikiTableCol1 foswikiLastCol"> 2 </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="400" bgcolor="#ffffff" align="left" valign="top" class="foswikiTableCol0 foswikiFirstCol"> Motion image (showing only pixels defined as motion) </td>
-			<td width="70" bgcolor="#ffffff" align="center" valign="top" class="foswikiTableCol1 foswikiLastCol"> 4 </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="400" bgcolor="#edf4f9" align="left" valign="top" class="foswikiTableCol0 foswikiFirstCol"> Normal mpeg image </td>
-			<td width="70" bgcolor="#edf4f9" align="center" valign="top" class="foswikiTableCol1 foswikiLastCol"> 8 </td>
-		</tr>
-		<tr class="foswikiTableOdd foswikiTableRowdataBgSorted0 foswikiTableRowdataBg0">
-			<td width="400" bgcolor="#ffffff" align="left" valign="top" class="foswikiTableCol0 foswikiFirstCol"> Motion mpeg (showing only pixels defined as motion) </td>
-			<td width="70" bgcolor="#ffffff" align="center" valign="top" class="foswikiTableCol1 foswikiLastCol"> 16 </td>
-		</tr>
-		<tr class="foswikiTableEven foswikiTableRowdataBgSorted1 foswikiTableRowdataBg1">
-			<td width="400" bgcolor="#edf4f9" align="left" valign="top" class="foswikiTableCol0 foswikiFirstCol foswikiLast"> Timelapse mpeg </td>
-			<td width="70" bgcolor="#edf4f9" align="center" valign="top" class="foswikiTableCol1 foswikiLastCol foswikiLast"> 32 </td>
-		</tr>
-	</tbody></table>
+<table style="border-width:1px;" cellspacing="0" cellpadding="0" class="twikiTable" border="1"><tr class="twikiTableEven"><td width="400" bgcolor="#ffffff" align="left" valign="top" style="width:400;text-align:left;vertical-align:top;" class="twikiFirstCol"> Normal image </td><td width="70" bgcolor="#ffffff" align="center" valign="top" style="width:70;text-align:center;vertical-align:top;"> 1 </td></tr>
+<tr class="twikiTableOdd"><td width="400" bgcolor="#edf4f9" align="left" valign="top" style="width:400;text-align:left;vertical-align:top;" class="twikiFirstCol"> Snapshot image </td><td width="70" bgcolor="#edf4f9" align="center" valign="top" style="width:70;text-align:center;vertical-align:top;"> 2 </td></tr>
+<tr class="twikiTableEven"><td width="400" bgcolor="#ffffff" align="left" valign="top" style="width:400;text-align:left;vertical-align:top;" class="twikiFirstCol"> Motion image (showing only pixels defined as motion) </td><td width="70" bgcolor="#ffffff" align="center" valign="top" style="width:70;text-align:center;vertical-align:top;"> 4 </td></tr>
+<tr class="twikiTableOdd"><td width="400" bgcolor="#edf4f9" align="left" valign="top" style="width:400;text-align:left;vertical-align:top;" class="twikiFirstCol"> Normal mpeg image </td><td width="70" bgcolor="#edf4f9" align="center" valign="top" style="width:70;text-align:center;vertical-align:top;"> 8 </td></tr>
+<tr class="twikiTableEven"><td width="400" bgcolor="#ffffff" align="left" valign="top" style="width:400;text-align:left;vertical-align:top;" class="twikiFirstCol"> Motion mpeg (showing only pixels defined as motion) </td><td width="70" bgcolor="#ffffff" align="center" valign="top" style="width:70;text-align:center;vertical-align:top;"> 16 </td></tr>
+<tr class="twikiTableOdd"><td width="400" bgcolor="#edf4f9" align="left" valign="top" style="width:400;text-align:left;vertical-align:top;" class="twikiFirstCol twikiLast"> Timelapse mpeg </td><td width="70" bgcolor="#edf4f9" align="center" valign="top" style="width:70;text-align:center;vertical-align:top;" class="twikiLast"> 32 </td></tr>
+</table>
 <p />
 You can create the table using the following SQL statement.
 <p />
@@ -4742,13 +3291,12 @@ The <a href="http://www.phpmyadmin.net/"
 <strong>The options for MySQL</strong>
 <p />
 <p />
-<p />
 <h3><a name="mysql_db"></a> mysql_db </h3>
 <p /> <ul>
 <li> Type: String
 </li> <li> Range / Valid values: Max 4095 characters
 </li> <li> Default: Not defined
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionMysqlDb">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionMysqlDb" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Name of the MySQL database.
@@ -4758,14 +3306,12 @@ MySQL CONFIG FILE OPTION. Motion must be
 If you compiled motion with MySQL support you will need to set the mysql options if you want motion to log events to the database.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="mysql_host"></a> mysql_host </h3>
 <p /> <ul>
 <li> Type: String
 </li> <li> Range / Valid values: Max 4095 characters
 </li> <li> Default: localhost
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionMysqlHost">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionMysqlHost" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 IP address or domain name for the MySQL server. Use "localhost" if motion and MySQL runs on the same server.
@@ -4773,14 +3319,12 @@ IP address or domain name for the MySQL
 MySQL CONFIG FILE OPTION. Motion must be built with MySQL libraries to use this feature.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="mysql_password"></a> mysql_password </h3>
 <p /> <ul>
 <li> Type: String
 </li> <li> Range / Valid values: Max 4095 characters
 </li> <li> Default: Not defined
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionMysqlPassword">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionMysqlPassword" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 The MySQL password.
@@ -4788,14 +3332,12 @@ The MySQL password.
 MySQL CONFIG FILE OPTION. Motion must be built with MySQL libraries to use this feature.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="mysql_user"></a> mysql_user </h3>
 <p /> <ul>
 <li> Type: String
 </li> <li> Range / Valid values: Max 4095 characters
 </li> <li> Default: Not defined
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionMysqlUser">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionMysqlUser" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 The MySQL user name.
@@ -4804,20 +3346,18 @@ MySQL CONFIG FILE OPTION. Motion must be
 <p />
 <p />
 <p />
-<p />
-<h2><a name="PostgreSQL"></a> PostgreSQL </h2>
+<h2><a name="PostgreSQL"></a><a name="_PostgreSQL"></a> PostgreSQL </h2>
 Same/similar as for MySQL above.
 <p />
 <strong>The options for PostgreSQL</strong>
 <p />
 <p />
-<p />
 <h3><a name="pgsql_db"></a> pgsql_db </h3>
 <p /> <ul>
 <li> Type: String
 </li> <li> Range / Valid values: Max 4095 characters
 </li> <li> Default: Not defined
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionPgsqlDb">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionPgsqlDb" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 Name of the PostgreSQL database.
@@ -4827,14 +3367,12 @@ PostgreSQL CONFIG FILE OPTION. Motion mu
 If you compiled motion with PostgreSQL support you will need to set all the pgsql_ options if you want motion to log events to the database.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="pgsql_host"></a> pgsql_host </h3>
 <p /> <ul>
 <li> Type: String
 </li> <li> Range / Valid values: Max 4095 characters
 </li> <li> Default: localhost
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionPgsqlHost">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionPgsqlHost" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 IP address or domain name for the PostgreSQL server. Use "localhost" if motion and PostgreSQL runs on the same server.
@@ -4842,14 +3380,12 @@ IP address or domain name for the Postgr
 PostgreSQL CONFIG FILE OPTION. Motion must be built with pgsql_db libraries to use this feature.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="pgsql_password"></a> pgsql_password </h3>
 <p /> <ul>
 <li> Type: String
 </li> <li> Range / Valid values: Max 4095 characters
 </li> <li> Default: Not defined
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionPgsqlPassword">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionPgsqlPassword" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 The PostgreSQL password. 
@@ -4857,14 +3393,12 @@ The PostgreSQL password.
 PostgreSQL CONFIG FILE OPTION. Motion must be built with PostgreSQL libraries to use this feature.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="pgsql_port"></a> pgsql_port </h3>
 <p /> <ul>
 <li> Type: Integer
 </li> <li> Range / Valid values: 0 - 65535
 </li> <li> Default: 5432
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionPgsqlPort">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionPgsqlPort" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 The PostgreSQL server port number.
@@ -4872,14 +3406,12 @@ The PostgreSQL server port number.
 PostgreSQL CONFIG FILE OPTION. Motion must be built with PostgreSQL libraries to use this feature.
 <p />
 <p />
-<p />
-<p />
 <h3><a name="pgsql_user"></a> pgsql_user </h3>
 <p /> <ul>
 <li> Type: String
 </li> <li> Range / Valid values: Max 4095 characters
 </li> <li> Default: Not defined
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionPgsqlUser">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionPgsqlUser" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 The PostgreSQL user name. 
@@ -4887,12 +3419,8 @@ The PostgreSQL user name.
 PostgreSQL CONFIG FILE OPTION. Motion must be built with PostgreSQL libraries to use this feature.
 <p />
 <p />
-<p />
-<p />
-<p />
-<p />
-<h2><a name="Video4Linux_Loopback_Device"></a> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/LoopbackDevice">Video4Linux Loopback Device</a> </h2>
-You can use this driver for looking at motion in realtime. The video4linux driver is written by the same author that first created Motion. You can find the source and a brief description at the <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/VideoFourLinuxLoopbackDevice">video4linux loopback device web page</a>. 
+<h2><a name="Video4Linux_Loopback_Device"></a> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/LoopbackDevice" class="twikiLink">Video4Linux Loopback Device</a> </h2>
+You can use this driver for looking at motion in realtime. The video4linux driver is written by the same author that first created Motion. You can find the source and a brief description at the <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/VideoFourLinuxLoopbackDevice" class="twikiLink">video4linux loopback device web page</a>. 
 <p />
 The video4linux device is a Kernel module which installs itself as a video pipe. It has an input and an output. The module simply takes anything that comes on its input and send it out at the output. The purpose of this is to create a standard video4linux type video device that other programs can then use. You may now ask: "What do I need that for?".
 <p />
@@ -4925,7 +3453,7 @@ You may need to set the ownership and pe
 <p />
 Now you need to install the video loopback device.
 <p />
-Download the latest <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/VideoFourLinuxLoopbackDevice" target="_top">video4linux loopback device</a> . Place the file in a place of your own choice. 
+Download the latest <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/VideoFourLinuxLoopbackDevice" target="_top">video4linux loopback device</a> . Place the file in a place of your own choice. 
 <p />
 Untar and uncompress the file to the place you want the program installed. Editor recommends /usr/local/vloopback.
 <p />
@@ -4979,13 +3507,12 @@ De-activating should be done with this c
 <strong>Description of the motion.conf options related to video loopback device.</strong>
 <p />
 <p />
-<p />
 <h3><a name="motion_video_pipe"></a> motion_video_pipe </h3>
 <p /> <ul>
 <li> Type: String
 </li> <li> Range / Valid values: Max 4095 characters
 </li> <li> Default: Not defined
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionMotionVideoPipe">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionMotionVideoPipe" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 The video4linux video loopback input device for motion images. If a particular pipe is to be used then use the device filename of this pipe, if a dash '-' is given motion will use /proc/video/vloopback/vloopbacks to locate a free pipe. Default: not set
@@ -4995,15 +3522,12 @@ Using this you can view the results in r
 Disable this option by not having it in the config file (or comment it out with "#" or ";").
 <p />
 <p />
-<p />
-<p />
-<p />
 <h3><a name="video_pipe"></a> video_pipe </h3>
 <p /> <ul>
 <li> Type: String
 </li> <li> Range / Valid values: Max 4095 characters
 </li> <li> Default: Not defined
-</li> <li> <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/ConfigOptionVideoPipe">Option Topic</a>
+</li> <li> <a href="http://www.lavrsen.dk/twiki/bin/view/Motion/ConfigOptionVideoPipe" class="twikiLink">Option Topic</a>
 </li></ul> 
 <p />
 The video4linux video loopback input device for normal images. If a particular pipe is to be used then use the device filename of this pipe. If a dash '-' is given motion will use /proc/video/vloopback/vloopbacks to locate a free pipe.
@@ -5015,7 +3539,4 @@ Disable this option by not having it in
 <p />
 <p />
 <p />
-<p />
-<p />
-<p />
--- <a href="http://www.lavrsen.dk/foswiki/bin/view/Main/KennethLavrsen">KennethLavrsen</a> - 13 Apr 2005
\ No newline at end of file
+-- <a href="http://www.lavrsen.dk/twiki/bin/view/Main/KennethLavrsen" class="twikiLink">KennethLavrsen</a> - 13 Apr 2005
\ No newline at end of file
--- motion-3.2.12.orig/netcam.c
+++ motion-3.2.12/netcam.c
@@ -41,46 +41,38 @@
 
 #include <netdb.h>
 #include <netinet/in.h>
-#include <regex.h>                  /* For parsing of the URL */
+#include <regex.h>                    /* For parsing of the URL */
 #include <sys/socket.h>
 
 #include "netcam_ftp.h"
+#include "netcam_rtsp.h"
 
-#define CONNECT_TIMEOUT        10   /* timeout on remote connection attempt */
-#define READ_TIMEOUT            5   /* default timeout on recv requests */
-#define POLLING_TIMEOUT  READ_TIMEOUT /* file polling timeout [s] */
-#define POLLING_TIME  500*1000*1000 /* file polling time quantum [ns] (500ms) */
-#define MAX_HEADER_RETRIES      5   /* Max tries to find a header record */
+#define CONNECT_TIMEOUT        10     /* Timeout on remote connection attempt */
+#define READ_TIMEOUT            5     /* Default timeout on recv requests */
+#define POLLING_TIMEOUT  READ_TIMEOUT /* File polling timeout [s] */
+#define POLLING_TIME  500*1000*1000   /* File polling time quantum [ns] (500ms) */
+#define MAX_HEADER_RETRIES      5     /* Max tries to find a header record */
 #define MINVAL(x, y) ((x) < (y) ? (x) : (y))
 
-/*
- * The macro NETCAM_DEBUG is for development testing of this module.
- * The macro SETUP is to assure that "configuration-setup" type messages
- * are also printed when NETCAM_DEBUG is set.  Set the following #if to
- * 1 to enable it, or 0 (normal setting) to disable it.
- */
-#define SETUP    ((cnt->conf.setup_mode) || (debug_level >= CAMERA_INFO))
-
-
 tfile_context *file_new_context(void);
 void file_free_context(tfile_context* ctxt);
 
-/* These strings are used for the HTTP connection */
-static const char    *connect_req;
+/* These strings are used for the HTTP connection. */
+static const char *connect_req;
 
-static const char    *connect_req_http10 = "GET %s HTTP/1.0\r\n"
-                      "Host: %s\r\n"
-                      "User-Agent: Motion-netcam/" VERSION "\r\n";
+static const char *connect_req_http10 = "GET %s HTTP/1.0\r\n"
+                                        "Host: %s\r\n"
+                                        "User-Agent: Motion-netcam/" VERSION "\r\n";
 
-static const char    *connect_req_http11 = "GET %s HTTP/1.1\r\n"
-                      "Host: %s\r\n"
-                      "User-Agent: Motion-netcam/" VERSION "\r\n";
+static const char *connect_req_http11 = "GET %s HTTP/1.1\r\n"
+                                        "Host: %s\r\n"
+                                        "User-Agent: Motion-netcam/" VERSION "\r\n";
 
-static const char    *connect_req_close = "Connection: close\r\n";
+static const char *connect_req_close = "Connection: close\r\n";
 
-static const char    *connect_req_keepalive = "Connection: Keep-Alive\r\n";
+static const char *connect_req_keepalive = "Connection: Keep-Alive\r\n";
 
-static const char    *connect_auth_req = "Authorization: Basic %s\r\n";
+static const char *connect_auth_req = "Authorization: Basic %s\r\n";
 
 /*
  * The following three routines (netcam_url_match, netcam_url_parse and
@@ -129,7 +121,7 @@ static char *netcam_url_match(regmatch_t
     if (m.rm_so != -1) {
         len = m.rm_eo - m.rm_so;
 
-        if ((match = (char *) malloc(len + 1)) != NULL) {
+        if ((match = (char *) mymalloc(len + 1)) != NULL) {
             strncpy(match, input + m.rm_so, len);
             match[len] = '\0';
         }
@@ -155,17 +147,18 @@ static void netcam_url_parse(struct url_
 {
     char *s;
     int i;
-    const char *re = "(http|ftp)://(((.*):(.*))@)?"
+
+    const char *re = "(http|ftp|mjpg|mjpeg|rtsp)://(((.*):(.*))@)?"
                      "([^/:]|[-.a-z0-9]+)(:([0-9]+))?($|(/[^:]*))";
     regex_t pattbuf;
     regmatch_t matches[10];
 
-    if (!strncmp( text_url, "file", 4 ) ) 
+    if (!strncmp(text_url, "file", 4)) 
         re = "(file)://(((.*):(.*))@)?"
              "([^/:]|[-.a-z0-9]*)(:([0-9]*))?($|(/[^:][/-_.a-z0-9]+))";
 
-    if (debug_level > CAMERA_DEBUG)
-        motion_log(-1, 0, "Entry netcam_url_parse data %s", text_url );
+    MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: Entry netcam_url_parse data %s", 
+               text_url);
 
     memset(parse_url, 0, sizeof(struct url_t));
     /*
@@ -173,14 +166,14 @@ static void netcam_url_parse(struct url_
      * suitable for regexec searches
      * regexec matches the URL string against the regular expression
      * and returns an array of pointers to strings matching each match
-     * within (). The results that we need are finally placed in parse_url
+     * within (). The results that we need are finally placed in parse_url.
      */
     if (!regcomp(&pattbuf, re, REG_EXTENDED | REG_ICASE)) {
         if (regexec(&pattbuf, text_url, 10, matches, 0) != REG_NOMATCH) {
             for (i = 0; i < 10; i++) {
                 if ((s = netcam_url_match(matches[i], text_url)) != NULL) {
-                    if (debug_level > CAMERA_DEBUG)
-                        motion_log(-1, 0, "Parse case %d data %s", i, s );
+                    MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: Parse case %d"
+                               " data %s", i, s);
                     switch (i) {
                     case 1:
                         parse_url->service = s;
@@ -198,7 +191,7 @@ static void netcam_url_parse(struct url_
                     case 9:
                         parse_url->path = s;
                         break;
-                        /* other components ignored */
+                        /* Other components ignored */
                     default:
                         free(s);
                         break;
@@ -207,11 +200,13 @@ static void netcam_url_parse(struct url_
             }
         }
     }
-    if ((!parse_url->port) && (parse_url->service)){
+    if ((!parse_url->port) && (parse_url->service)) {
         if (!strcmp(parse_url->service, "http"))
             parse_url->port = 80;
         else if (!strcmp(parse_url->service, "ftp"))
             parse_url->port = 21;
+        else if (!strcmp(parse_url->service, "rtsp") && parse_url->port == 0)
+            parse_url->port = 554;
     }
 
     regfree(&pattbuf);
@@ -224,12 +219,12 @@ static void netcam_url_parse(struct url_
  *
  * Parameters:
  *
- *      parse_url       Structure containing the parsed data
+ *      parse_url       Structure containing the parsed data.
  *
  * Returns:             Nothing
  *
  */
-static void netcam_url_free(struct url_t *parse_url)
+void netcam_url_free(struct url_t *parse_url)
 {
     if (parse_url->service) {
         free(parse_url->service);
@@ -260,9 +255,9 @@ static void netcam_url_free(struct url_t
  *
  * Parameters:
  *
- *      str             Pointer to a string
+ *      str             Pointer to a string.
  *
- * Returns:             Nothing, but updates the target if necessary
+ * Returns:             Nothing, but updates the target if necessary.
  *
  */
 static void check_quote(char *str)
@@ -284,20 +279,20 @@ static void check_quote(char *str)
 /**
  * netcam_check_content_length
  *
- *     Analyse an HTTP-header line to see if it is a Content-length
+ *     Analyse an HTTP-header line to see if it is a Content-length.
  *
  * Parameters:
  *
- *      header          Pointer to a string containing the header line
+ *      header          Pointer to a string containing the header line.
  *
  * Returns:
- *      -1              Not a Content-length line
- *      >=0             Value of Content-length field
+ *      -1              Not a Content-length line.
+ *      >=0             Value of Content-length field.
  *
  */
 static long netcam_check_content_length(char *header)
 {
-    long length = -1;    /* note this is a long, not an int */
+    long length = -1;    /* Note this is a long, not an int. */
 
     if (!header_process(header, "Content-Length", header_extract_number, &length)) {
         /*
@@ -306,10 +301,13 @@ static long netcam_check_content_length(
          * number we might as well try to use it.
          */
         if (length > 0)
-            return length;
-        return -1;
+            MOTION_LOG(WRN, TYPE_NETCAM, NO_ERRNO, "%s: malformed token"
+                       " Content-Length but value %ld", length);
     }
 
+    MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: Content-Length %ld", 
+               length);
+
     return length;
 }
 
@@ -320,11 +318,11 @@ static long netcam_check_content_length(
  *
  * Parameters:
  *
- *      header          Pointer to a string containing the header line
+ *      header          Pointer to a string containing the header line.
  *
  * Returns:
- *      -1              Not a Keep-Alive line
- *      1               Is a Keep-Alive line
+ *      -1              Not a Keep-Alive line.
+ *      1               Is a Keep-Alive line.
  *
  */
 static int netcam_check_keepalive(char *header)
@@ -335,7 +333,6 @@ static int netcam_check_keepalive(char *
         return -1;
 
     /* We do not detect the second field or other case mixes at present. */
-
     if (content_type) 
         free(content_type);
 
@@ -345,15 +342,15 @@ static int netcam_check_keepalive(char *
 /**
  * netcam_check_close
  *
- *     Analyse an HTTP-header line to see if it is a Connection: close
+ *     Analyse an HTTP-header line to see if it is a Connection: close.
  *
  * Parameters:
  *
- *      header          Pointer to a string containing the header line
+ *      header          Pointer to a string containing the header line.
  *
  * Returns:
- *      -1              Not a Connection: close
- *      1               Is a Connection: close
+ *      -1              Not a Connection: close.
+ *      1               Is a Connection: close.
  *
  */
 static int netcam_check_close(char *header)
@@ -364,7 +361,7 @@ static int netcam_check_close(char *head
     if (!header_process(header, "Connection", http_process_type, &type))
         return -1;
     
-    if (!strcmp(type, "close")) /* strcmp returns 0 for match */
+    if (!strcmp(type, "close")) /* strcmp returns 0 for match. */
         ret = 1;
     
     if (type) 
@@ -376,17 +373,18 @@ static int netcam_check_close(char *head
 /**
  * netcam_check_content_type
  *
- *     Analyse an HTTP-header line to see if it is a Content-type
+ *     Analyse an HTTP-header line to see if it is a Content-type.
  *
  * Parameters:
  *
- *      header          Pointer to a string containing the header line
+ *      header          Pointer to a string containing the header line.
  *
  * Returns:
  *      -1              Not a Content-type line
  *      0               Content-type not recognized
  *      1               image/jpeg
  *      2               multipart/x-mixed-replace or multipart/mixed
+ *      3               application/octet-stream (used by WVC200 Linksys IP Camera)
  *
  */
 static int netcam_check_content_type(char *header)
@@ -397,15 +395,20 @@ static int netcam_check_content_type(cha
     if (!header_process(header, "Content-type", http_process_type, &content_type))
         return -1;
 
+    MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: Content-type %s", 
+               content_type);
+
     if (!strcmp(content_type, "image/jpeg")) {
         ret = 1;
     } else if (!strcmp(content_type, "multipart/x-mixed-replace") ||
                !strcmp(content_type, "multipart/mixed")) {
         ret = 2;
+    } else if (!strcmp(content_type, "application/octet-stream")) {
+        ret = 3;
     } else {
         ret = 0;
     }
-            
+
     if (content_type)
         free(content_type);
 
@@ -420,9 +423,9 @@ static int netcam_check_content_type(cha
  *
  * Parameters
  *
- *      netcam          pointer to a netcam_context
+ *      netcam          pointer to a netcam_context.
  *
- * Returns:             0 for success, -1 if any error
+ * Returns:             0 for success, -1 if any error.
  *
  */
 static int netcam_read_next_header(netcam_context_ptr netcam)
@@ -430,9 +433,7 @@ static int netcam_read_next_header(netca
     int retval;
     char *header;
 
-    /*
-     * return if not connected
-     */
+    /* Return if not connected */
     if (netcam->sock == -1) 
         return -1;
     /*
@@ -444,25 +445,26 @@ static int netcam_read_next_header(netca
      *
      */
     netcam->caps.content_length = 0;
+
     /*
      * If this is a "streaming" camera, the stream header must be
-     * preceded by a "boundary" string
+     * preceded by a "boundary" string.
      */
-    if (netcam->caps.streaming) {
+    if (netcam->caps.streaming == NCS_MULTIPART) {
         while (1) {
             retval = header_get(netcam, &header, HG_NONE);
 
             if (retval != HG_OK) {
-                /* Header reported as not-OK, check to see if it's null */
+                /* Header reported as not-OK, check to see if it's null. */
                 if (strlen(header) == 0) {
-                    if (debug_level > CAMERA_INFO)
-                        motion_log(LOG_DEBUG, 0, "Error reading image header, streaming mode (1). Null header.");
+                    MOTION_LOG(WRN, TYPE_NETCAM, NO_ERRNO, "%s: Error reading image header, " 
+                               "streaming mode (1). Null header.");
                 } else {
                     /* Header is not null. Output it in case it's a new camera with unknown headers. */
-                    if (debug_level > CAMERA_INFO)
-                        motion_log(LOG_ERR, 0, "Error reading image header, streaming mode (1). "
-                                               "Unknown header '%s'", header );
-                }
+                    MOTION_LOG(WRN, TYPE_NETCAM, NO_ERRNO, "%s: Error reading image header, "
+                               "streaming mode (1). Unknown header '%s'", 
+                               header);
+                 }
 
                 free(header);
                 return -1;
@@ -480,7 +482,7 @@ static int netcam_read_next_header(netca
         retval = header_get(netcam, &header, HG_NONE);
 
         if (retval != HG_OK) {
-            motion_log(LOG_ERR, 0, "Error reading image header (2)");
+            MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Error reading image header (2)"); 
             free(header);
             return -1;
         }
@@ -490,22 +492,28 @@ static int netcam_read_next_header(netca
 
         if ((retval = netcam_check_content_type(header)) >= 0) {
             if (retval != 1) {
-                motion_log(LOG_ERR, 0, "Header not JPEG");
+                MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Header not JPEG");
                 free(header);
                 return -1;
             }
         }
 
-        if ((retval = (int) netcam_check_content_length(header)) > 0) {
-            netcam->caps.content_length = 1;       /* set flag */
-            netcam->receiving->content_length = (int) retval;
-        }
+        if ((retval = (int) netcam_check_content_length(header)) >= 0) {
+            if (retval > 0) {
+                netcam->caps.content_length = 1;       /* Set flag */
+                netcam->receiving->content_length = retval;
+            } else {
+                netcam->receiving->content_length = 0;
+                MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Content-Length 0"); 
+                free(header);
+                return -1;
+            }    
+        }    
 
         free(header);
     }
 
-    if (debug_level > CAMERA_INFO)
-        motion_log(-1, 0, "Found image header record");
+    MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: Found image header record"); 
 
     free(header);
     return 0;
@@ -528,26 +536,26 @@ static int netcam_read_next_header(netca
  * After this processing, the routine returns to the caller.
  *
  * Parameters:
- *      netcam            Pointer to the netcam_context structure
+ *      netcam            Pointer to the netcam_context structure.
  *
  * Returns:               Content-type code if successful, -1 if not
- *
+ *                                                         -2 if Content-length = 0
  */
 static int netcam_read_first_header(netcam_context_ptr netcam)
 {
-    int retval = -2;                         /* "Unknown err" */
+    int retval = -3;      /* "Unknown err" */
     int ret;
     int firstflag = 1;
-    int aliveflag = 0;    /* If we have seen a Keep-Alive header from cam */
-    int closeflag = 0;    /* If we have seen a Connection: close header from cam */
+    int aliveflag = 0;    /* If we have seen a Keep-Alive header from cam. */
+    int closeflag = 0;    /* If we have seen a Connection: close header from cam. */
     char *header;
     char *boundary;
-    struct context *cnt = netcam->cnt;       /* for conf debug_level */
 
-    /* Send the initial command to the camera */
+    /* Send the initial command to the camera. */
     if (send(netcam->sock, netcam->connect_request,
              strlen(netcam->connect_request), 0) < 0) {
-        motion_log(LOG_ERR, 1, "Error sending 'connect' request");
+        MOTION_LOG(ERR, TYPE_NETCAM, SHOW_ERRNO, "%s: Error sending"
+                   " 'connect' request");
         return -1;
     }
 
@@ -573,47 +581,49 @@ static int netcam_read_first_header(netc
      * there may be a Content-length.
      *
      */
-    while (1) {                                 /* 'Do forever' */
+    while (1) {     /* 'Do forever' */
         ret = header_get(netcam, &header, HG_NONE);
 
-        if (debug_level > CAMERA_INFO)    /* Changed criterion and moved up from below to catch headers that cause returns */
-            motion_log(LOG_DEBUG, 0, "Received first header ('%s')", header);
+        MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: Received first header ('%s')", 
+                   header);
 
         if (ret != HG_OK) {
-            if (debug_level > CAMERA_INFO)
-                motion_log(LOG_ERR, 0, "Error reading first header (%s)", header);
+            MOTION_LOG(WRN, TYPE_NETCAM, NO_ERRNO, "%s: Error reading first header (%s)", 
+                       header);
             free(header);
             return -1;
         }
 
         if (firstflag) {
             if ((ret = http_result_code(header)) != 200) {
-                if (debug_level > CAMERA_INFO)
-                    motion_log(-1, 0, "HTTP Result code %d", ret);
+                MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: HTTP Result code %d",
+                           ret);
 
                 free(header);
-
                 if (netcam->connect_keepalive) {
-                    /* Cannot unset netcam->cnt->conf.netcam_http as it is assigned const */
-                    /* But we do unset the netcam keepalive flag which was set in netcam_start */
-                    /* This message is logged as Information as it would be useful to know */
-                    /* if your netcam often returns bad HTTP result codes */
-                    netcam->connect_keepalive = 0;
-                    motion_log(LOG_INFO, 0, "Removed netcam Keep-Alive flag"
-                                            "due to apparent closed HTTP connection.");
+                    /* 
+                     * Cannot unset netcam->cnt->conf.netcam_keepalive as it is assigned const 
+                     * But we do unset the netcam keepalive flag which was set in netcam_start 
+                     * This message is logged as Information as it would be useful to know
+                     * if your netcam often returns bad HTTP result codes. 
+                     */
+                    netcam->connect_keepalive = FALSE;
+                    free((void *)netcam->cnt->conf.netcam_keepalive);
+                    netcam->cnt->conf.netcam_keepalive = strdup("off"); 
+                    MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: Removed netcam Keep-Alive flag"
+                               "due to apparent closed HTTP connection.");
                 }
                 return ret;
             }
-
             firstflag = 0;
             free(header);
             continue;
         }
 
-        if (*header == 0)                  /* blank line received */
+        if (*header == 0)   /* Blank line received */
             break;
 
-        /* Check if this line is the content type */
+        /* Check if this line is the content type. */
         if ((ret = netcam_check_content_type(header)) >= 0) {
             retval = ret;
             /*
@@ -624,113 +634,144 @@ static int netcam_read_first_header(netc
              * camera which provides a single frame only.
              */
             switch (ret) {
-            case 1:         /* not streaming */
-                if (SETUP) {
-                    if (netcam->connect_keepalive) 
-                        motion_log(LOG_DEBUG, 0, "Non-streaming camera (keep-alive set)");
-                    else
-                        motion_log(LOG_DEBUG, 0, "Non-streaming camera (keep-alive not set)");
-                }
-                netcam->caps.streaming = 0;
+            case 1:         /* Not streaming */
+                if (netcam->connect_keepalive) 
+                    MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: Non-streaming camera " 
+                               "(keep-alive set)");
+                else
+                    MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: Non-streaming camera " 
+                               "(keep-alive not set)");
+
+                netcam->caps.streaming = NCS_UNSUPPORTED;
                 break;
 
-            case 2:         /* streaming */
-                if (SETUP)
-                    motion_log(LOG_DEBUG, 0, "Streaming camera");
+            case 2:         /* Streaming */
+                MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: Streaming camera"); 
 
-                netcam->caps.streaming = 1;
+                netcam->caps.streaming = NCS_MULTIPART;
 
                 if ((boundary = strstr(header, "boundary="))) {
-                    /*
-                     * on error recovery this
-                     * may already be set
-                     * */
+                    /* On error recovery this may already be set. */
                     if (netcam->boundary)
                         free(netcam->boundary);
 
-                    netcam->boundary = strdup(boundary + 9);
+                    netcam->boundary = mystrdup(boundary + 9);
                     /*
                      * HTTP protocol apparently permits the boundary string
                      * to be quoted (the Lumenera does this, which caused
                      * trouble) so we need to get rid of any surrounding
-                     * quotes
+                     * quotes.
                      */
-                    check_quote(netcam->boundary);
-                    netcam->boundary_length = strlen(netcam->boundary);
+                     check_quote(netcam->boundary);
+                     netcam->boundary_length = strlen(netcam->boundary);
 
-                    if (SETUP) 
-                        motion_log(LOG_DEBUG, 0, "Boundary string [%s]",
-                                   netcam->boundary);
-                        
-                }                    
+                     MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: Boundary string [%s]",
+                                netcam->boundary);
+                }
+                break;
+            case 3:  /* MJPG-Block style streaming. */
+                MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: Streaming camera probably using MJPG-blocks,"
+                           " consider using mjpg:// netcam_url.");
                 break;
 
-            default:       /* error */
-                motion_log(LOG_ERR, 0, "Unrecognized content type");
+            default:
+                /* Error */
+                MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Unrecognized content type");
                 free(header);
                 return -1;
                 
             }
         } else if ((ret = (int) netcam_check_content_length(header)) >= 0) {
-            if (SETUP)
-                motion_log(LOG_DEBUG, 0, "Content-length present");
+            MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: Content-length present");
 
-            netcam->caps.content_length = 1;     /* set flag */
-            netcam->receiving->content_length = ret;
+            if (ret > 0) {
+                netcam->caps.content_length = 1;     /* Set flag */
+                netcam->receiving->content_length = ret;
+            } else { 
+                netcam->receiving->content_length = 0;
+                MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Content-length 0");
+                retval = -2;
+            }
         } else if (netcam_check_keepalive(header) == TRUE) {
-            /* Note that we have received a Keep-Alive header, and thus the socket can be left open */
-            aliveflag=TRUE;
+            /* Note that we have received a Keep-Alive header, and thus the socket can be left open. */
+            aliveflag = TRUE;
             netcam->keepalive_thisconn = TRUE;
-            /* This flag will not be set when a Streaming cam is in use, but that */
-            /* does not matter as the test below looks at Streaming state also.   */
+            /* 
+             * This flag will not be set when a Streaming cam is in use, but that 
+             * does not matter as the test below looks at Streaming state also.   
+             */
         } else if (netcam_check_close(header) == TRUE) {
-            /* Note that we have received a Connection: close header */
-            closeflag=TRUE;
-            /* This flag is acted upon below */
-            if (debug_level > CAMERA_INFO) /* Changed criterion and moved up from below to catch headers that cause returns */
-                motion_log(LOG_DEBUG, 0, "Found Conn:close header ('%s')", header);
+            /* Note that we have received a Connection: close header. */
+            closeflag = TRUE;
+            /* 
+             * This flag is acted upon below. 
+             * Changed criterion and moved up from below to catch headers that cause returns. 
+             */
+             MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: Found Conn: close header ('%s')", 
+                        header);
         }
         free(header);
     }
     free(header);
 
-    if (!netcam->caps.streaming && netcam->connect_keepalive) {
+    if (netcam->caps.streaming == NCS_UNSUPPORTED && netcam->connect_keepalive) {
         
-        /*
-         * If we are a non-streaming (ie. Jpeg) netcam and keepalive is configured 
-         */
+        /* If we are a non-streaming (ie. Jpeg) netcam and keepalive is configured. */
 
         if (aliveflag) {
             if (closeflag) {
+                netcam->warning_count++;
+                if (netcam->warning_count > 3) {
+                    netcam->warning_count = 0;
+                    MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: Both 'Connection: Keep-Alive' and "
+                               "'Connection: close' header received. Motion removes keepalive.");
+                    netcam->connect_keepalive = FALSE;
+                    free((void *)netcam->cnt->conf.netcam_keepalive);
+                    netcam->cnt->conf.netcam_keepalive = strdup("off");
+                } else {
                    /*
                     * If not a streaming cam, and keepalive is set, and the flag shows we 
                     * did not see a Keep-Alive field returned from netcam and a Close field.
                     * Not quite sure what the correct course of action is here. In for testing.
                     */ 
-                motion_log(LOG_INFO, 0, "Info: Both 'Connection: Keep-Alive' and 'Connection: close' "
-                                        "header received. Motion continues unchanged.");
+                    MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: Both 'Connection: Keep-Alive' and "
+                               "'Connection: close' header received. Motion continues unchanged.");
+                }
             } else {
-                    /* aliveflag && !closeflag 
-                     *
-                     * If not a streaming cam, and keepalive is set, and the flag shows we 
-                     * just got a Keep-Alive field returned from netcam and no Close field.
-                     * No action, as this is the normal case. In debug we print a notification.
-                     */
+               /* 
+                * aliveflag && !closeflag 
+                *
+                * If not a streaming cam, and keepalive is set, and the flag shows we 
+                * just got a Keep-Alive field returned from netcam and no Close field.
+                * No action, as this is the normal case. In debug we print a notification.
+                */
         
-                if (debug_level > CAMERA_INFO)
-                    motion_log(LOG_INFO, 0, "Info: Received a Keep-Alive field in this set of headers.");
+                MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: Received a Keep-Alive field in this"
+                           "set of headers.");
             }
         } else { /* !aliveflag */
             if (!closeflag) {
+                netcam->warning_count++;
+
+                if (netcam->warning_count > 3) {
+                    netcam->warning_count = 0;
+                    MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: No 'Connection: Keep-Alive' nor 'Connection: close'"
+                               " header received.\n Motion removes keepalive.");
+                    netcam->connect_keepalive = FALSE;
+                    free((void *)netcam->cnt->conf.netcam_keepalive);
+                    netcam->cnt->conf.netcam_keepalive = strdup("off");
+                } else {
                    /*
                     * If not a streaming cam, and keepalive is set, and the flag shows we 
                     * did not see a Keep-Alive field returned from netcam nor a Close field.
                     * Not quite sure what the correct course of action is here. In for testing.
                     */                                                                                                     
-                motion_log(LOG_INFO, 0, "Info: No 'Connection: Keep-Alive' nor 'Connection: close' "
-                                        "header received. Motion continues unchanged.");
+                    MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: No 'Connection: Keep-Alive' nor 'Connection: close'"
+                               " header received.\n Motion continues unchanged.");
+                }
             } else {  
-                /* !aliveflag & closeflag 
+                /* 
+                 * !aliveflag & closeflag 
                  * If not a streaming cam, and keepalive is set, and the flag shows we 
                  * received a 'Connection: close' field returned from netcam. It is not likely
                  * we will get a Keep-Alive and Close header together - this is picked up by
@@ -753,13 +794,15 @@ static int netcam_read_first_header(netc
                  */
                 if (!netcam->keepalive_thisconn) {
                     netcam->connect_keepalive = FALSE;    /* No further attempts at keep-alive */
-                    motion_log(LOG_INFO, 0, "Removed netcam Keep-Alive flag because 'Connection: close' "
-                                            "header received. Netcam does not support Keep-Alive. Motion "
-                                            "continues in non-Keep-Alive.");
+                    free((void *)netcam->cnt->conf.netcam_keepalive);
+                    netcam->cnt->conf.netcam_keepalive = strdup("off");
+                    MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: Removed netcam Keep-Alive flag because"
+                               " 'Connection: close' header received.\n Netcam does not support " 
+                               "Keep-Alive. Motion continues in non-Keep-Alive.");
                 } else {
                     netcam->keepalive_timeup = TRUE;    /* We will close and re-open keep-alive */
-                    motion_log(LOG_INFO, 0, "Keep-Alive has reached end of valid period. Motion will close " 
-                                            "netcam, then resume Keep-Alive with a new socket.");
+                    MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "Keep-Alive has reached end of valid period.\n" 
+                               "Motion will close netcam, then resume Keep-Alive with a new socket.");
                 }
             }
         }
@@ -784,7 +827,7 @@ static void netcam_disconnect(netcam_con
 {
     if (netcam->sock > 0) {
         if (close(netcam->sock) < 0)
-            motion_log(LOG_ERR, 1, "netcam_disconnect");
+            MOTION_LOG(ERR, TYPE_NETCAM, SHOW_ERRNO, "%s: netcam_disconnect");
 
         netcam->sock = -1;
     }
@@ -809,93 +852,88 @@ static void netcam_disconnect(netcam_con
  */
 static int netcam_connect(netcam_context_ptr netcam, int err_flag)
 {
-    struct sockaddr_in server;      /* for connect */
-    struct addrinfo *res;           /* for getaddrinfo */
+    struct sockaddr_in server;      /* For connect */
+    struct addrinfo *res;           /* For getaddrinfo */
     int ret;
     int saveflags;
     int back_err;
     int optval;
-    socklen_t optlen=sizeof(optval);
+    socklen_t optlen = sizeof(optval);
     socklen_t len;
     fd_set fd_w;
     struct timeval selecttime;
 
-    /* Assure any previous connection has been closed - IF we are not in keepalive */
+    /* Assure any previous connection has been closed - IF we are not in keepalive. */
     if (!netcam->connect_keepalive) {
-        if (debug_level > CAMERA_INFO)
-            motion_log(LOG_DEBUG, 0, "netcam_connect, disconnecting netcam since keep-alive not set." );
-        
+        MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: disconnecting netcam " 
+                   "since keep-alive not set.");
+
         netcam_disconnect(netcam);
 
-        /* create a new socket */
+        /* Create a new socket. */
         if ((netcam->sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
-            motion_log(LOG_ERR, 1, "netcam_connect with no keepalive, attempt to create socket failed.");
+            MOTION_LOG(WRN, TYPE_NETCAM, SHOW_ERRNO, "%s:  with no keepalive, attempt "
+                       "to create socket failed.");
             return -1;
         }
 
-        if (debug_level > CAMERA_INFO )
-            motion_log(LOG_DEBUG, 0, "netcam_connect with no keepalive, new socket created fd %d", netcam->sock);
-
-    } else {       /* We are in keepalive mode, check for invalid socket */
-        if (netcam->sock == -1) {
-            /* Must be first time, or closed, create a new socket */
-            if ((netcam->sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
-                motion_log(LOG_ERR, 1, "netcam_connect with keepalive set, invalid socket." 
-                                       "This could be the first time. Creating a new one failed.");
-                return -1;
-            }
+        MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: with no keepalive, "
+                   "new socket created fd %d", netcam->sock);
 
-            if (debug_level > CAMERA_INFO)
-                motion_log(LOG_DEBUG, 0, "netcam_connect with keepalive set, invalid socket."
-                                         "This could be first time, created a new one with fd %d", netcam->sock);
-
-            /* Record that this connection has not yet received a Keep-Alive header */
-            netcam->keepalive_thisconn = FALSE;
-
-            /* Check the socket status for the keepalive option */
-            if (getsockopt(netcam->sock, SOL_SOCKET, SO_KEEPALIVE, &optval, &optlen) < 0) {
-                motion_log(LOG_ERR, 1, "netcam_connect : getsockopt()");
-                return -1;
-            }
+    } else if (netcam->sock == -1) {   /* We are in keepalive mode, check for invalid socket. */
+        /* Must be first time, or closed, create a new socket. */
+        if ((netcam->sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
+            MOTION_LOG(WRN, TYPE_NETCAM, SHOW_ERRNO, "%s: with keepalive set, invalid socket." 
+                       "This could be the first time. Creating a new one failed.");
+            return -1;
+        }
 
-            if (debug_level > CAMERA_INFO) {
-                if (optval == 1)    
-                    motion_log(LOG_DEBUG, 0, "netcam_connect: SO_KEEPALIVE is ON");
-                else
-                    motion_log(LOG_DEBUG, 0, "netcam_connect: SO_KEEPALIVE is OFF");
-            }
-    
-            /* Set the option active */
-            optval = 1;
-            optlen = sizeof(optval);
+        MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: with keepalive set, invalid socket."
+                   "This could be first time, created a new one with fd %d", 
+                    netcam->sock);
+
+        /* Record that this connection has not yet received a Keep-Alive header. */
+        netcam->keepalive_thisconn = FALSE;
+
+        /* Check the socket status for the keepalive option. */
+        if (getsockopt(netcam->sock, SOL_SOCKET, SO_KEEPALIVE, &optval, &optlen) < 0) {
+            MOTION_LOG(ERR, TYPE_NETCAM, SHOW_ERRNO, "%s: getsockopt()");
+            return -1;
+        }
 
-            if (setsockopt(netcam->sock, SOL_SOCKET, SO_KEEPALIVE, &optval, optlen) < 0) {
-                motion_log(LOG_ERR, 1, "netcam_connect : setsockopt()");
-                return -1;
-            }
+        MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: SO_KEEPALIVE is %s", 
+                   optval ? "ON":"OFF");
 
-            if (debug_level > CAMERA_INFO )
-                motion_log(LOG_DEBUG, 0, "netcam_connect: SO_KEEPALIVE set on socket.");
+        /* Set the option active. */
+        optval = 1;
+        optlen = sizeof(optval);
 
-        } else if (debug_level > CAMERA_INFO) {
-            motion_log(LOG_DEBUG, 0, "netcam_connect re-using socket %d since keepalive is set.", netcam->sock);
+        if (setsockopt(netcam->sock, SOL_SOCKET, SO_KEEPALIVE, &optval, optlen) < 0) {
+            MOTION_LOG(ERR, TYPE_NETCAM, SHOW_ERRNO, "%s: setsockopt()");
+            return -1;
         }
-    }
 
-    /* lookup the hostname given in the netcam URL */
+        MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: SO_KEEPALIVE set on socket.");
+    } 
+    
+    MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: re-using socket %d since keepalive is set.", 
+               netcam->sock);
+
+    /* Lookup the hostname given in the netcam URL. */
     if ((ret = getaddrinfo(netcam->connect_host, NULL, NULL, &res)) != 0) {
         if (!err_flag)
-            motion_log(LOG_ERR, 0, "getaddrinfo() failed (%s): %s",
+            MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: getaddrinfo() failed (%s): %s",
                        netcam->connect_host, gai_strerror(ret));
-        if (debug_level > CAMERA_INFO)
-            motion_log(LOG_DEBUG, 0, "netcam_connect disconnecting netcam (1)");
+
+        MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: disconnecting netcam (1)");
+
         netcam_disconnect(netcam);
         return -1;
     }
 
     /*
      * Fill the hostname details into the 'server' structure and
-     * attempt to connect to the remote server
+     * attempt to connect to the remote server.
      */
     memset(&server, 0, sizeof(server));
     memcpy(&server, res->ai_addr, sizeof(server));
@@ -910,49 +948,48 @@ static int netcam_connect(netcam_context
      */
 
     if ((saveflags = fcntl(netcam->sock, F_GETFL, 0)) < 0) {
-        motion_log(LOG_ERR, 1, "fcntl(1) on socket");
+        MOTION_LOG(ERR, TYPE_NETCAM, SHOW_ERRNO, "%s: fcntl(1) on socket");
         netcam_disconnect(netcam);
         return -1;
     }
 
-    /* Set the socket non-blocking */
+    /* Set the socket non-blocking. */
     if (fcntl(netcam->sock, F_SETFL, saveflags | O_NONBLOCK) < 0) {
-        motion_log(LOG_ERR, 1, "fcntl(2) on socket");
+        MOTION_LOG(ERR, TYPE_NETCAM, SHOW_ERRNO, "%s: fcntl(2) on socket");
         netcam_disconnect(netcam);
         return -1;
     }
 
-    /* Now the connect call will return immediately */
+    /* Now the connect call will return immediately. */
     ret = connect(netcam->sock, (struct sockaddr *) &server,
                   sizeof(server));
-    back_err = errno;           /* save the errno from connect */
+    back_err = errno;           /* Save the errno from connect */
 
-    /* If the connect failed with anything except EINPROGRESS, error */
+    /* If the connect failed with anything except EINPROGRESS, error. */
     if ((ret < 0) && (back_err != EINPROGRESS)) {
         if (!err_flag)
-            motion_log(LOG_ERR, 1, "connect() failed (%d)", back_err);
+            MOTION_LOG(ERR, TYPE_NETCAM, SHOW_ERRNO, "%s: connect() failed (%d)", 
+                       back_err);
 
-        if (debug_level > CAMERA_INFO)    
-            motion_log(LOG_DEBUG, 0, "netcam_connect disconnecting netcam (4)");
+        MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: disconnecting netcam (4)");
 
         netcam_disconnect(netcam);
         return -1;
     }
 
-    /* Now we do a 'select' with timeout to wait for the connect */
+    /* Now we do a 'select' with timeout to wait for the connect. */
     FD_ZERO(&fd_w);
     FD_SET(netcam->sock, &fd_w);
     selecttime.tv_sec = CONNECT_TIMEOUT;
     selecttime.tv_usec = 0;
     ret = select(FD_SETSIZE, NULL, &fd_w, NULL, &selecttime);
 
-    if (ret == 0) {            /* 0 means timeout */
+    if (ret == 0) {            /* 0 means timeout. */
         if (!err_flag)
-            motion_log(LOG_ERR, 0, "timeout on connect()");
-
-        if (debug_level > CAMERA_INFO)
-            motion_log(LOG_DEBUG, 0, "netcam_connect disconnecting netcam (2)");
-
+            MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: timeout on connect()");
+        
+        MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: disconnecting netcam (2)");
+        
         netcam_disconnect(netcam);
         return -1;
     }
@@ -965,25 +1002,26 @@ static int netcam_connect(netcam_context
     len = sizeof(ret);
 
     if (getsockopt(netcam->sock, SOL_SOCKET, SO_ERROR, &ret, &len) < 0) {
-        motion_log(LOG_ERR, 0, "getsockopt after connect");
+        MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: getsockopt after connect");
         netcam_disconnect(netcam);
         return -1;
     }
 
-    /* If the return code is anything except 0, error on connect */
+    /* If the return code is anything except 0, error on connect. */
     if (ret) {
         if (!err_flag)
-            motion_log(LOG_ERR, 1, "connect returned error");
-        if (debug_level > CAMERA_INFO)
-            motion_log(LOG_DEBUG, 0, "netcam_connect disconnecting netcam (3)");
+            MOTION_LOG(ERR, TYPE_NETCAM, SHOW_ERRNO, "%s: connect returned error");
+
+        MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: disconnecting netcam (3)");
+
         netcam_disconnect(netcam);
         return -1;
     }
 
-    /* The socket info is stored in the rbuf structure of our context */
+    /* The socket info is stored in the rbuf structure of our context. */
     rbuf_initialize(netcam);
 
-    return 0;            /* success */
+    return 0;   /* Success */
 }
 
 
@@ -995,23 +1033,35 @@ static int netcam_connect(netcam_context
  * the buffer and adjust it's size.
  *
  * Parameters:
- *      buff            Pointer to a netcam_image_buffer structure
- *      numbytes        The number of bytes to be copied
+ *      buff            Pointer to a netcam_image_buffer structure.
+ *      numbytes        The number of bytes to be copied.
  *
  * Returns:             Nothing
  */
 static void netcam_check_buffsize(netcam_buff_ptr buff, size_t numbytes)
 {
+    int min_size_to_alloc;
+    int real_alloc;
+    int new_size;
+
     if ((buff->size - buff->used) >= numbytes)
         return;
 
-    if (debug_level > CAMERA_INFO)
-        motion_log(-1, 0, "expanding buffer from %d to %d bytes",
-                   (int) buff->size, (int) buff->size + NETCAM_BUFFSIZE);
+    min_size_to_alloc = numbytes - (buff->size - buff->used);
+    real_alloc = ((min_size_to_alloc / NETCAM_BUFFSIZE) * NETCAM_BUFFSIZE);
+
+    if ((min_size_to_alloc - real_alloc) > 0)
+        real_alloc += NETCAM_BUFFSIZE;
+
+    new_size = buff->size + real_alloc;
+    
+    MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: expanding buffer from [%d/%d] to [%d/%d] bytes.",
+               (int) buff->used, (int) buff->size,
+               (int) buff->used, new_size);
 
-    buff->ptr = myrealloc(buff->ptr, buff->size + NETCAM_BUFFSIZE,
+    buff->ptr = myrealloc(buff->ptr, new_size,
                           "netcam_check_buf_size");
-    buff->size += NETCAM_BUFFSIZE;
+    buff->size = new_size;
 }
 
 /**
@@ -1042,6 +1092,8 @@ static void netcam_check_buffsize(netcam
  *     1) If a Content-Length is present, set the variable "remaining"
  *        to be equal to that value, else set it to a "very large"
  *        number.
+ *        WARNING !!! Content-Length *must* to be greater than 0, even more
+ *        a jpeg image cannot be less than 300 bytes or so.
  *     2) While there is more data available from the camera:
  *        a) If there is a "boundary string" specified (from the initial
  *           header):
@@ -1074,27 +1126,27 @@ static int netcam_read_html_jpeg(netcam_
     netcam_buff_ptr buffer;
     size_t remaining;       /* # characters to read */
     size_t maxflush;        /* # chars before boundary */
-    size_t rem, rlen, ix;   /* working vars */
+    size_t rem, rlen, ix;   /* Working vars */
     int retval;
     char *ptr, *bptr, *rptr;
     netcam_buff *xchg;
     struct timeval curtime;
     /*
      * Initialisation - set our local pointers to the context
-     * information
+     * information.
      */
     buffer = netcam->receiving;
-    /* Assure the target buffer is empty */
+    /* Assure the target buffer is empty. */
     buffer->used = 0;
-    /* Prepare for read loop */
+    /* Prepare for read loop. */
     if (buffer->content_length != 0)
         remaining = buffer->content_length;
     else
         remaining = 999999;
 
-    /* Now read in the data */
+    /* Now read in the data. */
     while (remaining) {
-        /* Assure data in input buffer */
+        /* Assure data in input buffer. */
         if (netcam->response->buffer_left <= 0) {
             retval = rbuf_read_bufferful(netcam);
 
@@ -1105,14 +1157,14 @@ static int netcam_read_html_jpeg(netcam_
             netcam->response->buffer_pos = netcam->response->buffer;
         }
 
-        /* If a boundary string is present, take it into account */
+        /* If a boundary string is present, take it into account. */
         bptr = netcam->boundary;
 
         if (bptr) {
             rptr = netcam->response->buffer_pos;
             rlen = netcam->response->buffer_left;
 
-            /* Loop through buffer looking for start of boundary */
+            /* Loop through buffer looking for start of boundary. */
             while (1) {
                 /*
                  * Logic gets a little complicated here.  The
@@ -1130,11 +1182,11 @@ static int netcam_read_html_jpeg(netcam_
                     break;
 
                 if ((ptr = memchr(rptr, *bptr, rlen)) == NULL)
-                    /* boundary not here (normal path) */
+                    /* Boundary not here (normal path) */
                     break;
                 /*
                  * At least the first char was found in the
-                 * buffer - check for the rest
+                 * buffer - check for the rest.
                  */
                 rem = rlen - (ptr - rptr);
                 for (ix = 1; (ix < rem) && (ix < netcam->boundary_length); ix++) {
@@ -1145,19 +1197,18 @@ static int netcam_read_html_jpeg(netcam_
                 if ((ix != netcam->boundary_length) && (ix != rem)) {
                     /*
                      * Not pointing at a boundary string -
-                     * step along input
+                     * step along input.
                      */
                     ix = ptr - rptr + 1;
                     rptr += ix;
                     rlen -= ix;
 
                     if (rlen <= 0)
-                        /* boundary not in buffer - go copy out
-                         */
+                        /* boundary not in buffer - go copy out */
                         break;
                     /*
-                     * not yet decided - continue
-                     * through input
+                     * Not yet decided - continue
+                     * through input.
                      */
                     continue;
                 }
@@ -1172,7 +1223,7 @@ static int netcam_read_html_jpeg(netcam_
                     if ((ptr - netcam->response->buffer) < (int) remaining)
                         remaining = ptr - netcam->response->buffer;
 
-                    /* go copy everything up to boundary */
+                    /* Go copy everything up to boundary. */
                     break;
                 }
 
@@ -1183,7 +1234,7 @@ static int netcam_read_html_jpeg(netcam_
                  * problem mentioned above.
                  *
                  * Assure there is data before potential
-                 * boundary string
+                 * boundary string.
                  */
                 if (ptr != netcam->response->buffer) {
                     /*
@@ -1195,7 +1246,7 @@ static int netcam_read_html_jpeg(netcam_
                      * beginning and get some more input
                      * data.  First we flush the input
                      * buffer up to the beginning of the
-                     * (potential) boundary string
+                     * (potential) boundary string.
                      */
                     ix = ptr - netcam->response->buffer_pos;
                     netcam_check_buffsize(buffer, ix);
@@ -1211,45 +1262,43 @@ static int netcam_read_html_jpeg(netcam_
                      * module netcam_wget.c to do this job!
                      */
 
-                    if (debug_level > CAMERA_INFO) {
-                        motion_log(-1, 0,
-                                   "Potential split boundary - "
-                                   "%d chars flushed, %d "
-                                   "re-positioned", ix,
-                                   (int) netcam->response->buffer_left);
-                    }
+                    MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO,
+                               "%s: Potential split boundary - "
+                               "%d chars flushed, %d "
+                               "re-positioned", ix,
+                               (int) netcam->response->buffer_left);
 
                     memmove(netcam->response->buffer, ptr,
                             netcam->response->buffer_left);
-                }       /* end of boundary split over buffer */
+                }   /* End of boundary split over buffer. */
 
                 retval = netcam_recv(netcam, netcam->response->buffer +
                                      netcam->response->buffer_left,
                                      sizeof(netcam->response->buffer) -
                                      netcam->response->buffer_left);
 
-                if (retval <= 0) { /* this is a fatal error */
-                    motion_log(LOG_ERR, 1, "recv() fail after boundary string");
+                if (retval <= 0) { /* This is a fatal error. */
+                    MOTION_LOG(ERR, TYPE_NETCAM, SHOW_ERRNO, "%s: recv() fail after boundary string");
                     return -1;
                 }
 
-                /* Reset the input buffer pointers */
+                /* Reset the input buffer pointers. */
                 netcam->response->buffer_left = retval + netcam->response->buffer_left;
                 netcam->response->buffer_pos = netcam->response->buffer;
 
-                /* This will cause a 'continue' of the main loop */
+                /* This will cause a 'continue' of the main loop. */
                 bptr = NULL;
 
-                /* Return to do the boundary compare from the start */
+                /* Return to do the boundary compare from the start. */
                 break;
-            }             /* end of while(1) input buffer search */
+            }             /* End of while(1) input buffer search. */
 
-            /* !bptr shows we're processing split boundary */
+            /* !bptr shows we're processing split boundary. */
             if (!bptr)
                 continue;
-        }             /* end of if (bptr) */
+        }   /* end of if (bptr) */
 
-        /* boundary string not present, so just write out as much data as possible */
+        /* boundary string not present, so just write out as much data as possible. */
         if (remaining) {
             maxflush = MINVAL(netcam->response->buffer_left, remaining);
             netcam_check_buffsize(buffer, maxflush);
@@ -1260,14 +1309,13 @@ static int netcam_read_html_jpeg(netcam_
     }
 
     /*
-     * read is complete - set the current 'receiving' buffer atomically
+     * Read is complete - set the current 'receiving' buffer atomically
      * as 'latest', and make the buffer previously in 'latest' become
-     * the new 'receiving'
+     * the new 'receiving'.
      */
     if (gettimeofday(&curtime, NULL) < 0) 
-        motion_log(LOG_ERR, 1, "gettimeofday in netcam_read_jpeg");
+        MOTION_LOG(WRN, TYPE_NETCAM, SHOW_ERRNO, "%s: gettimeofday");
     
-
     netcam->receiving->image_time = curtime;
 
     /*
@@ -1280,8 +1328,8 @@ static int netcam_read_html_jpeg(netcam_
                                  1000000.0 * (curtime.tv_sec - netcam->last_image.tv_sec) +
                                  (curtime.tv_usec- netcam->last_image.tv_usec)) / 10.0;
 
-        if (debug_level > CAMERA_INFO) 
-            motion_log(-1, 0, "Calculated frame time %f", netcam->av_frame_time);
+        MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: Calculated frame time %f", 
+                   netcam->av_frame_time);
     }
     netcam->last_image = curtime;
 
@@ -1300,20 +1348,290 @@ static int netcam_read_html_jpeg(netcam_
 
     pthread_mutex_unlock(&netcam->mutex);
 
-    if (!netcam->caps.streaming) {
+    if (netcam->caps.streaming == NCS_UNSUPPORTED) {
         if (!netcam->connect_keepalive) {
-            if (debug_level > CAMERA_INFO)
-                 motion_log(LOG_DEBUG, 0, "netcam_read_html_jpeg disconnecting netcam since keep-alive not set." );
+            MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: disconnecting "
+                       "netcam since keep-alive not set.");
+
             netcam_disconnect(netcam);
-        } else if (debug_level > CAMERA_INFO) {
-            motion_log(LOG_DEBUG, 0, "netcam_read_html_jpeg leaving netcam connected." );
+        } 
+        MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: leaving netcam connected.");
+    }
+
+    return 0;
+}
+
+/**
+ * netcam_http_request
+ *
+ * This routine initiates a connection on the specified netcam,
+ * for which every parameter has already been set (url, etc).
+ * It uses the HTTP protocol, which is what many IP cameras use.
+ * If this function succeeds, the HTTP response along with the
+ * headers are already processed, and you can start reading contents
+ * from here.
+ *
+ * Parameters:
+ *      netcam          Pointer to a netcam_context structure
+ *
+ * Returns:             0 on success, -1 if an error occurs.
+ */
+static int netcam_http_request(netcam_context_ptr netcam)
+{
+    int ix;
+
+    /*
+     * Our basic initialisation has been completed.  Now we will attempt
+     * to connect with the camera so that we can then get a "header"
+     * in order to find out what kind of camera we are dealing with,
+     * as well as what are the picture dimensions.  Note that for
+     * this initial connection, any failure will cause an error
+     * return from netcam_start (unlike later possible attempts at
+     * re-connecting, if the network connection is later interrupted).
+     */
+    for (ix = 0; ix < MAX_HEADER_RETRIES; ix++) {
+        /*
+         * netcam_connect does an automatic netcam_close, so it's
+         * safe to include it as part of this loop
+         * (Not always true now Keep-Alive is implemented).
+         */
+        MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: about to try to connect, time #%d", 
+                   ix);
+        
+        if (netcam_connect(netcam, 0) != 0) {
+            MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "Failed to open camera - check your config "
+                       "and that netcamera is online");
+
+            /* Fatal error on startup */
+            ix = MAX_HEADER_RETRIES;
+            break;;
         }
+
+        if (netcam_read_first_header(netcam) >= 0)
+            break;
+
+        MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Error reading first header - re-trying");
+    }
+
+    if (ix == MAX_HEADER_RETRIES) {
+        MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Failed to read first camera header "
+                   "- giving up for now");
+        return -1;
     }
 
     return 0;
 }
 
 /**
+ * netcam_mjpg_buffer_refill
+ *
+ * This routing reads content from the MJPG-camera until the response
+ * buffer of the specified netcam_context is full. If the connection is
+ * lost during this operation, it tries to re-connect.
+ *
+ * Parameters:
+ *      netcam          Pointer to a netcam_context structure
+ *
+ * Returns:             The number of read bytes,
+ *                      or -1 if an fatal connection error occurs.
+ */
+static int netcam_mjpg_buffer_refill(netcam_context_ptr netcam)
+{
+    int retval;
+
+    if (netcam->response->buffer_left > 0)
+        return netcam->response->buffer_left;
+
+    while (1) {
+        retval = rbuf_read_bufferful(netcam);
+        if (retval <= 0) { /* If we got 0, we timeoutted. */
+            MOTION_LOG(ALR, TYPE_NETCAM, NO_ERRNO, "%s: Read error,"
+                       " trying to reconnect..");
+            /* We may have lost the connexion */
+            if (netcam_http_request(netcam) < 0) {
+                MOTION_LOG(CRT, TYPE_NETCAM, NO_ERRNO, "%s: lost the cam.");
+                return -1; /* We REALLY lost the cam... bail out for now. */
+            }
+        }
+
+        if (retval > 0)
+            break;
+    }
+
+    netcam->response->buffer_left = retval;
+    netcam->response->buffer_pos = netcam->response->buffer;
+ 
+    MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: Refilled buffer with [%d]"
+               " bytes from the network.", retval); 
+
+    return retval;
+}
+
+/**
+ * netcam_read_mjpg_jpeg
+ *
+ *     This routine reads from a netcam using a MJPG-chunk based 
+ *     protocol, used by Linksys WVC200 for example.
+ *     This implementation has been made by reverse-engineering
+ *     the protocol, so it may contain bugs and should be considered as
+ *     experimental.
+ *
+ * Protocol explanation:
+ *
+ *     The stream consists of JPG pictures, spanned across multiple
+ *     MJPG chunks (in general 3 chunks, altough that's not guaranteed).
+ * 
+ *     Each data chunk can range from 1 to 65535 bytes + a header, altough
+ *     i have not seen anything bigger than 20000 bytes + a header.
+ *
+ *     One MJPG chunk is constituted by a header plus the chunk data.
+ *     The chunk header is of fixed size, and the following data size
+ *     and position in the frame is specified in the chunk header.
+ *
+ *     From what i have seen on WVC200 cameras, the stream always begins
+ *     on JPG frame boundary, so you don't have to worry about beginning
+ *     in the middle of a frame.
+ *
+ *     See netcam.h for the mjpg_header structure and more details.
+ *
+ * Parameters:
+ *      netcam          Pointer to a netcam_context structure
+ *
+ * Returns:             0 if an image was obtained from the camera,
+ *                      or -1 if an error occurred.
+ */
+static int netcam_read_mjpg_jpeg(netcam_context_ptr netcam)
+{
+    netcam_buff_ptr buffer;
+    netcam_buff *xchg;
+    struct timeval curtime;
+    mjpg_header mh;
+    size_t read_bytes;
+    int retval;
+
+    /*
+     * Initialisation - set our local pointers to the context
+     * information.
+     */
+    buffer = netcam->receiving;
+    /* Assure the target buffer is empty. */
+    buffer->used = 0;
+
+    if (netcam_mjpg_buffer_refill(netcam) < 0)
+        return -1;
+
+    /* Loop until we have a complete JPG. */
+    while (1) {
+        read_bytes = 0;
+        while (read_bytes < sizeof(mh)) {
+
+            /* Transfer what we have in buffer in the header structure. */
+            retval = rbuf_flush(netcam, ((char *)&mh) + read_bytes, sizeof(mh) - read_bytes);
+
+            read_bytes += retval;
+
+            MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: Read [%d/%d] header bytes.", 
+                       read_bytes, sizeof(mh));
+
+            /* If we don't have received a full header, refill our buffer. */
+            if (read_bytes < sizeof(mh)) {
+                if (netcam_mjpg_buffer_refill(netcam) < 0)
+                    return -1;
+            }
+        }
+
+        /* Now check the validity of our header. */
+        if (strncmp(mh.mh_magic, MJPG_MH_MAGIC, MJPG_MH_MAGIC_SIZE)) {
+            MOTION_LOG(WRN, TYPE_NETCAM, NO_ERRNO, "%s: Invalid header received,"
+                       " reconnecting");
+            /*
+             * We shall reconnect to restart the stream, and get a chance
+             * to resync.
+             */
+            if (netcam_http_request(netcam) < 0)
+                return -1; /* We lost the cam... bail out. */
+            /* Even there, we need to resync. */
+            buffer->used = 0;
+            continue ;
+        }
+
+        /* Make room for the chunk. */
+        netcam_check_buffsize(buffer, (int) mh.mh_chunksize);
+
+        read_bytes = 0;
+        while (read_bytes < mh.mh_chunksize) {
+            retval = rbuf_flush(netcam, buffer->ptr + buffer->used + read_bytes,
+                                mh.mh_chunksize - read_bytes);
+            read_bytes += retval;
+            MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: Read [%d/%d] chunk bytes,"
+                       " [%d/%d] total", read_bytes, mh.mh_chunksize, 
+                       buffer->used + read_bytes, mh.mh_framesize);
+
+            if (retval < (int) (mh.mh_chunksize - read_bytes)) {
+                /* MOTION_LOG(EMG, TYPE_NETCAM, NO_ERRNO, "Chunk incomplete, going to refill."); */
+                if (netcam_mjpg_buffer_refill(netcam) < 0)
+                    return -1;
+                
+            }
+        }
+        buffer->used += read_bytes;
+
+        MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: Chunk complete,"
+                   " buffer used [%d] bytes.", buffer->used); 
+
+        /* Is our JPG image complete ? */
+        if (mh.mh_framesize == buffer->used) {
+            MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: Image complete,"
+                       " buffer used [%d] bytes.", buffer->used);
+            break;    
+        }
+        /* MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: Rlen now at [%d] bytes", rlen); */
+    }
+
+    /*
+     * read is complete - set the current 'receiving' buffer atomically
+     * as 'latest', and make the buffer previously in 'latest' become
+     * the new 'receiving'.
+     */
+    if (gettimeofday(&curtime, NULL) < 0) 
+        MOTION_LOG(WRN, TYPE_NETCAM, SHOW_ERRNO, "%s: gettimeofday");
+    
+    netcam->receiving->image_time = curtime;
+
+    /*
+     * Calculate our "running average" time for this netcam's
+     * frame transmissions (except for the first time).
+     * Note that the average frame time is held in microseconds.
+     */
+    if (netcam->last_image.tv_sec) {
+        netcam->av_frame_time = (9.0 * netcam->av_frame_time +
+                                 1000000.0 * (curtime.tv_sec - netcam->last_image.tv_sec) +
+                                 (curtime.tv_usec- netcam->last_image.tv_usec)) / 10.0;
+
+        MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: Calculated frame time %f", 
+                   netcam->av_frame_time);
+    }
+    netcam->last_image = curtime;
+
+    pthread_mutex_lock(&netcam->mutex);
+
+    xchg = netcam->latest;
+    netcam->latest = netcam->receiving;
+    netcam->receiving = xchg;
+    netcam->imgcnt++;
+    /*
+     * We have a new frame ready.  We send a signal so that
+     * any thread (e.g. the motion main loop) waiting for the
+     * next frame to become available may proceed.
+     */
+    pthread_cond_signal(&netcam->pic_ready);
+
+    pthread_mutex_unlock(&netcam->mutex);
+
+    return 0;
+}
+
+/**
  * netcam_read_ftp_jpeg
  *
  *      This routine reads from a netcam using the FTP protocol.
@@ -1328,19 +1646,19 @@ static int netcam_read_ftp_jpeg(netcam_c
     netcam_buff *xchg;
     struct timeval curtime;
 
-    /* Point to our working buffer */
+    /* Point to our working buffer. */
     buffer = netcam->receiving;
     buffer->used = 0;
 
-    /* Request the image from the remote server */
+    /* Request the image from the remote server. */
     if (ftp_get_socket(netcam->ftp) <= 0) {
-        motion_log(LOG_ERR, 0, "ftp_get_socket failed in netcam_read_jpeg");
+        MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: ftp_get_socket failed");
         return -1;
     }
 
-    /* Now fetch the image using ftp_read.  Note this is a blocking call */
+    /* Now fetch the image using ftp_read.  Note this is a blocking call. */
     do {
-        /* Assure there's enough room in the buffer */
+        /* Assure there's enough room in the buffer. */
         netcam_check_buffsize(buffer, FTP_BUF_SIZE);
 
         /* Do the read */
@@ -1351,9 +1669,8 @@ static int netcam_read_ftp_jpeg(netcam_c
     } while (len > 0);
 
     if (gettimeofday(&curtime, NULL) < 0) 
-        motion_log(LOG_ERR, 1, "gettimeofday in netcam_read_jpeg");
+        MOTION_LOG(WRN, TYPE_NETCAM, SHOW_ERRNO, "%s: gettimeofday");
     
-
     netcam->receiving->image_time = curtime;
     /*
      * Calculate our "running average" time for this netcam's
@@ -1361,13 +1678,12 @@ static int netcam_read_ftp_jpeg(netcam_c
      * Note that the average frame time is held in microseconds.
      */
     if (netcam->last_image.tv_sec) {
-        netcam->av_frame_time =
-          ((9.0 * netcam->av_frame_time) + 1000000.0 *
-          (curtime.tv_sec - netcam->last_image.tv_sec) +
-          (curtime.tv_usec- netcam->last_image.tv_usec)) / 10.0;
+        netcam->av_frame_time = ((9.0 * netcam->av_frame_time) + 1000000.0 *
+                                 (curtime.tv_sec - netcam->last_image.tv_sec) +
+                                 (curtime.tv_usec- netcam->last_image.tv_usec)) / 10.0;
 
-        if (debug_level > CAMERA_INFO)
-            motion_log(-1, 0, "Calculated frame time %f", netcam->av_frame_time);
+        MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: Calculated frame time %f", 
+                   netcam->av_frame_time);
     }
 
     netcam->last_image = curtime;
@@ -1375,7 +1691,7 @@ static int netcam_read_ftp_jpeg(netcam_c
     /*
      * read is complete - set the current 'receiving' buffer atomically
      * as 'latest', and make the buffer previously in 'latest' become
-     * the new 'receiving'
+     * the new 'receiving'.
      */
     pthread_mutex_lock(&netcam->mutex);
 
@@ -1390,6 +1706,7 @@ static int netcam_read_ftp_jpeg(netcam_c
      * next frame to become available may proceed.
      */
     pthread_cond_signal(&netcam->pic_ready);
+
     pthread_mutex_unlock(&netcam->mutex);
 
     return 0;
@@ -1406,77 +1723,80 @@ static int netcam_read_ftp_jpeg(netcam_c
  */
 static int netcam_read_file_jpeg(netcam_context_ptr netcam)
 {
-    int loop_counter=0;
+    int loop_counter = 0;
+
+    MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: Begin");
 
-    if (debug_level > CAMERA_VERBOSE) 
-        motion_log(-1,0,"Begin %s", __FUNCTION__);
-    
     netcam_buff_ptr buffer;
     int len;
     netcam_buff *xchg;
     struct timeval curtime;
     struct stat statbuf;
 
-    /* Point to our working buffer */
+    /* Point to our working buffer. */
     buffer = netcam->receiving;
     buffer->used = 0;
 
     /*int fstat(int filedes, struct stat *buf);*/
     do {
-
-        if (stat( netcam->file->path, &statbuf)) {
-            motion_log(-1, 0, "stat(%s) error", netcam->file->path );
+        if (stat(netcam->file->path, &statbuf)) {
+            MOTION_LOG(CRT, TYPE_NETCAM, SHOW_ERRNO, "%s: stat(%s) error", 
+                       netcam->file->path);
             return -1;
         }
     
-        if (debug_level > CAMERA_VERBOSE) 
-            motion_log(-1, 0, "statbuf.st_mtime[%d] != last_st_mtime[%d]", statbuf.st_mtime,  netcam->file->last_st_mtime);
-        
-        if (loop_counter>((POLLING_TIMEOUT*1000*1000)/(POLLING_TIME/1000))) { //its waits POLLING_TIMEOUT
-            motion_log(-1, 0, "waiting new file image timeout" );
+        MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: statbuf.st_mtime[%d]"
+                   " != last_st_mtime[%d]", statbuf.st_mtime, 
+                   netcam->file->last_st_mtime);
+
+        /* its waits POLLING_TIMEOUT */
+        if (loop_counter>((POLLING_TIMEOUT*1000*1000)/(POLLING_TIME/1000))) { 
+            MOTION_LOG(CRT, TYPE_NETCAM, NO_ERRNO, "%s: waiting new file image"
+                       " timeout");
             return -1;
         }
 
-        if (debug_level > CAMERA_VERBOSE)
-            motion_log(-1, 0, "delay waiting new file image ");
+        MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: delay waiting new"
+                   " file image ");
         
-        //SLEEP(netcam->timeout.tv_sec, netcam->timeout.tv_usec*1000 ); //its waits 5seconds - READ_TIMEOUT
-        SLEEP( 0, POLLING_TIME ); // its waits 500ms
+        //its waits 5seconds - READ_TIMEOUT
+        //SLEEP(netcam->timeout.tv_sec, netcam->timeout.tv_usec*1000); 
+        SLEEP(0, POLLING_TIME); // its waits 500ms
         /*return -1;*/
         loop_counter++;
 
-    } while (statbuf.st_mtime==netcam->file->last_st_mtime);
+    } while (statbuf.st_mtime == netcam->file->last_st_mtime);
 
     netcam->file->last_st_mtime = statbuf.st_mtime;
-    if (debug_level > CAMERA_INFO) 
-        motion_log(LOG_INFO, 0, "processing new file image - st_mtime "
-                                "%d", netcam->file->last_st_mtime );
     
-
-    /* Assure there's enough room in the buffer */
-    while (buffer->size < (size_t)statbuf.st_size) 
+    MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: processing new file image -"
+               " st_mtime %d", netcam->file->last_st_mtime);
+    
+    /* Assure there's enough room in the buffer. */
+    while (buffer->size < (size_t)statbuf.st_size)
         netcam_check_buffsize(buffer, statbuf.st_size); 
     
 
     /* Do the read */
-    netcam->file->control_file_desc = open( netcam->file->path, O_RDONLY);
-
+    netcam->file->control_file_desc = open(netcam->file->path, O_RDONLY);
     if (netcam->file->control_file_desc < 0) {
-        motion_log(-1, 0, "open(%s) error:%d", netcam->file->path, netcam->file->control_file_desc);
+        MOTION_LOG(CRT, TYPE_NETCAM, NO_ERRNO, "%s: open(%s) error: %d", 
+                   netcam->file->path, netcam->file->control_file_desc);
         return -1;
     }
 
-    if ((len = read(netcam->file->control_file_desc, buffer->ptr + buffer->used, statbuf.st_size)) < 0) {
-        motion_log(-1, 0, "read(%s) error:%d", netcam->file->control_file_desc, len );
+    if ((len = read(netcam->file->control_file_desc, 
+                    buffer->ptr + buffer->used, statbuf.st_size)) < 0) {
+        MOTION_LOG(CRT, TYPE_NETCAM, NO_ERRNO, "%s: read(%s) error: %d", 
+                   netcam->file->control_file_desc, len);
         return -1;
     }
 
     buffer->used += len;
+    close(netcam->file->control_file_desc);
 
-    close( netcam->file->control_file_desc );
-
-    if (gettimeofday(&curtime, NULL) < 0) 
-        motion_log(LOG_ERR, 1, "gettimeofday in netcam_read_jpeg");
+    if (gettimeofday(&curtime, NULL) < 0)
+        MOTION_LOG(WRN, TYPE_NETCAM, SHOW_ERRNO, "%s: gettimeofday");
     
     netcam->receiving->image_time = curtime;
     /*
@@ -1485,13 +1805,12 @@ static int netcam_read_file_jpeg(netcam_
      * Note that the average frame time is held in microseconds.
      */
     if (netcam->last_image.tv_sec) {
-        netcam->av_frame_time =
-          ((9.0 * netcam->av_frame_time) + 1000000.0 *
-          (curtime.tv_sec - netcam->last_image.tv_sec) +
-          (curtime.tv_usec- netcam->last_image.tv_usec)) / 10.0;
+        netcam->av_frame_time = ((9.0 * netcam->av_frame_time) + 1000000.0 *
+                                 (curtime.tv_sec - netcam->last_image.tv_sec) +
+                                 (curtime.tv_usec- netcam->last_image.tv_usec)) / 10.0;
     
-        if (debug_level > CAMERA_INFO)
-            motion_log(-1, 0, "Calculated frame time %f", netcam->av_frame_time);
+        MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: Calculated frame time %f", 
+                   netcam->av_frame_time);
     }
 
     netcam->last_image = curtime;
@@ -1499,7 +1818,7 @@ static int netcam_read_file_jpeg(netcam_
     /*
      * read is complete - set the current 'receiving' buffer atomically
      * as 'latest', and make the buffer previously in 'latest' become
-     * the new 'receiving'
+     * the new 'receiving'.
      */
     pthread_mutex_lock(&netcam->mutex);
 
@@ -1514,11 +1833,9 @@ static int netcam_read_file_jpeg(netcam_
      * next frame to become available may proceed.
      */
     pthread_cond_signal(&netcam->pic_ready);
-
     pthread_mutex_unlock(&netcam->mutex);
 
-    if (debug_level > CAMERA_VERBOSE) 
-        motion_log(-1,0,"End %s", __FUNCTION__);
+    MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: End");
     
     return 0;
 }
@@ -1528,7 +1845,7 @@ tfile_context *file_new_context(void)
 {
     tfile_context *ret;
 
-    /* note that mymalloc will exit on any problem */
+    /* Note that mymalloc will exit on any problem. */
     ret = mymalloc(sizeof(tfile_context));
     if (!ret)
         return ret;
@@ -1537,7 +1854,8 @@ tfile_context *file_new_context(void)
     return ret;
 }
 
-void file_free_context(tfile_context* ctxt) {
+void file_free_context(tfile_context* ctxt) 
+{
     if (ctxt == NULL)
         return;
 
@@ -1562,8 +1880,8 @@ static int netcam_setup_file(netcam_cont
     netcam->file->path = url->path;
     url->path = NULL;
 
-    if (debug_level > CAMERA_INFO)
-        motion_log(LOG_INFO, 0, "netcam_setup_file: netcam->file->path %s",netcam->file->path);
+    MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: netcam->file->path %s", 
+               netcam->file->path);
 
     netcam_url_free(url);
 
@@ -1579,7 +1897,7 @@ static int netcam_setup_file(netcam_cont
  *
  * Parameters
  *
- *      arg     Pointer to the motion context for this camera
+ *      arg     Pointer to the motion context for this camera.
  *
  * Returns:     NULL pointer
  *
@@ -1589,16 +1907,15 @@ static void *netcam_handler_loop(void *a
     int retval;
     int open_error = 0;
     netcam_context_ptr netcam = arg;
-    struct context *cnt = netcam->cnt; /* needed for the SETUP macro :-( */
+    struct context *cnt = netcam->cnt; /* Needed for the SETUP macro :-( */
 
     /* Store the corresponding motion thread number in TLS also for this
-     * thread (necessary for 'motion_log' to function properly).
+     * thread (necessary for 'MOTION_LOG' to function properly).
      */
     pthread_setspecific(tls_key_threadnr, (void *)((unsigned long)cnt->threadnr));
 
-    if (SETUP)
-        motion_log(LOG_INFO, 0, "Camera handler thread [%d]  started", netcam->threadnr);
-
+    MOTION_LOG(ALR, TYPE_NETCAM, NO_ERRNO, "%s: Camera handler thread [%d]"
+               " started", netcam->threadnr);
     /*
      * The logic of our loop is very simple.  If this is a non-
      * streaming camera, we re-establish connection with the camera
@@ -1611,97 +1928,137 @@ static void *netcam_handler_loop(void *a
      */
 
     while (!netcam->finish) {
-        if (netcam->response) {    /* if html input */
-            if (!netcam->caps.streaming) {
+        if (netcam->response) {    /* If html input */
+            if (netcam->caps.streaming == NCS_UNSUPPORTED) {
                 /* Non-streaming ie. jpeg */
-                if (!netcam->connect_keepalive || (netcam->connect_keepalive && netcam->keepalive_timeup)) {
-                    /* If keepalive flag set but time up, time to close this socket */
+                if (!netcam->connect_keepalive || 
+                    (netcam->connect_keepalive && netcam->keepalive_timeup)) {
+                    /* If keepalive flag set but time up, time to close this socket. */
                     if (netcam->connect_keepalive && netcam->keepalive_timeup) {
-                        motion_log(LOG_INFO, 0, "Closing netcam socket as Keep-Alive time is up "
-                                                "(camera sent Close field). A reconnect should happen.");
+                        MOTION_LOG(WRN, TYPE_NETCAM, NO_ERRNO, "%s: Closing netcam socket"
+                                   " as Keep-Alive time is up (camera sent Close field). A reconnect"
+                                   " should happen.");
                         netcam_disconnect(netcam);
                         netcam->keepalive_timeup = FALSE;
                     }
 
-                    /* And the netcam_connect call below will open a new one */
+                    /* And the netcam_connect call below will open a new one. */
                     if (netcam_connect(netcam, open_error) < 0) {
-                        if (!open_error) { /* log first error */
-                            motion_log(LOG_ERR, 0,
-                                       "re-opening camera (non-streaming)");
+                        if (!open_error) { /* Log first error. */
+                            MOTION_LOG(WRN, TYPE_NETCAM, NO_ERRNO,
+                                       "%s: re-opening camera (non-streaming)");
                             open_error = 1;
                         }
-                        /* need to have a dynamic delay here */
-                        SLEEP(5,0);
+                        /* Need to have a dynamic delay here. */
+                        SLEEP(5, 0);
                         continue;
                     }
 
-                    if (open_error) {          /* log re-connection */
-                        motion_log(LOG_ERR, 0, "camera re-connected");
+                    if (open_error) {          /* Log re-connection */
+                        MOTION_LOG(WRN, TYPE_NETCAM, NO_ERRNO,
+                                   "%s: camera re-connected");
                         open_error = 0;
                     }
                 }
-                /* Send our request and look at the response */
+                /* Send our request and look at the response. */
                 if ((retval = netcam_read_first_header(netcam)) != 1) {
                     if (retval > 0) {
-                        motion_log(LOG_ERR, 0, "Unrecognized image header (%d)", retval);
+                        MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Unrecognized image"
+                                   " header (%d)", retval);
                     } else if (retval != -1) {
-                        motion_log(LOG_ERR, 0, "Error in header (%d)", retval);
+                        MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Error in header (%d)", 
+                                   retval);
                     }
-                    /* need to have a dynamic delay here */
+                    /* Need to have a dynamic delay here. */
                     continue;
                 }
-            } else {    /* Streaming */
+            } else if (netcam->caps.streaming == NCS_MULTIPART) {    /* Multipart Streaming */
                 if (netcam_read_next_header(netcam) < 0) {
                     if (netcam_connect(netcam, open_error) < 0) {
-                        if (!open_error) { /* log first error */
-                            motion_log(LOG_ERR, 0, "re-opening camera (streaming)");
+                        if (!open_error) { /* Log first error */
+                            MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO,
+                                       "%s: re-opening camera (streaming)");
                             open_error = 1;
                         }
-                        SLEEP(5,0);
+                        SLEEP(5, 0);
                         continue;
                     }
 
                     if ((retval = netcam_read_first_header(netcam) != 2)) {
                         if (retval > 0) {
-                            motion_log(LOG_ERR, 0, "Unrecognized image header (%d)", retval);
+                            MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO,
+                                      "%s: Unrecognized image header (%d)",  
+                                      retval);
                         } else if (retval != -1) {
-                            motion_log(LOG_ERR, 0, "Error in header (%d)", retval);
+                            MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO,
+                                       "%s: Error in header (%d)", retval);
                         }
-                        /* FIXME need some limit */
+                        /* FIXME need some limit. */
                         continue;
                     }
                 }
-                if (open_error) {          /* log re-connection */
-                    motion_log(LOG_ERR, 0, "camera re-connected");
+                if (open_error) {          /* Log re-connection */
+                    MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO,
+                               "%s: camera re-connected");
                     open_error = 0;
                 }
+            } else if (netcam->caps.streaming == NCS_BLOCK) { /* MJPG-Block streaming */
+                /*
+                 * Since we cannot move in the stream here, because we will read past the
+                 * MJPG-block-header, error handling is done while reading MJPG blocks.
+                 */
             }
         }
-        if (netcam->get_image(netcam) < 0) {
-            motion_log(LOG_ERR, 0, "Error getting jpeg image");
-            /* if FTP connection, attempt to re-connect to server */
-            if (netcam->ftp) {
-                close(netcam->ftp->control_file_desc);
-                if (ftp_connect(netcam) < 0) 
-                    motion_log(LOG_ERR, 0, "Trying to re-connect");
-                
+
+        if (netcam->caps.streaming == NCS_RTSP) {
+            if (netcam->rtsp->format_context == NULL) {      // We must have disconnected.  Try to reconnect
+                if (netcam->rtsp->status == RTSP_CONNECTED){
+                    MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Reconnecting with camera....");
+                }
+                netcam->rtsp->status = RTSP_RECONNECTING;
+                netcam_connect_rtsp(netcam);
+                continue;
+            } else {
+                // We think we are connected...
+                if (netcam->get_image(netcam) < 0) {
+                    if (netcam->rtsp->status == RTSP_CONNECTED){
+                        MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Bad image.  Reconnecting with camera....");
+                    }
+                    //Nope.  We are not or got bad image.  Reconnect
+                    netcam->rtsp->status = RTSP_RECONNECTING;
+                    netcam_connect_rtsp(netcam);
+                    continue;
+                }
+            }
+        }
+
+        if (netcam->caps.streaming != NCS_RTSP) {
+            if (netcam->get_image(netcam) < 0) {
+                MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Error getting jpeg image");
+                /* If FTP connection, attempt to re-connect to server. */
+                if (netcam->ftp) {
+                    close(netcam->ftp->control_file_desc);
+                    if (ftp_connect(netcam) < 0)
+                        MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Trying to re-connect");
+                }
+                continue;
             }
-            continue;
         }
+
         /*
          * FIXME
          * Need to check whether the image was received / decoded
-         * satisfactorily
+         * satisfactorily.
          */
 
         /*
          * If non-streaming, want to synchronize our thread with the
          * motion main-loop.
          */
-        if (!netcam->caps.streaming) {
+        if (netcam->caps.streaming == NCS_UNSUPPORTED) {
             pthread_mutex_lock(&netcam->mutex);
 
-            /* before anything else, check for system shutdown */
+            /* Before anything else, check for system shutdown. */
             if (netcam->finish) {
                 pthread_mutex_unlock(&netcam->mutex);
                 break;
@@ -1722,21 +2079,22 @@ static void *netcam_handler_loop(void *a
 
             pthread_mutex_unlock(&netcam->mutex);
         }
-    /* the loop continues forever, or until motion shutdown */
+    /* The loop continues forever, or until motion shutdown. */
     }
 
-    /* our thread is finished - decrement motion's thread count */
+    /* Our thread is finished - decrement motion's thread count. */
     pthread_mutex_lock(&global_lock);
     threads_running--;
     pthread_mutex_unlock(&global_lock);
 
-    /* log out a termination message */
-    motion_log(LOG_INFO, 0, "netcam camera handler: finish set, exiting");
+    /* Log out a termination message. */
+    MOTION_LOG(ALR, TYPE_NETCAM, NO_ERRNO, "%s: netcam camera handler:"
+               " finish set, exiting");
 
-    /* setting netcam->thread_id to zero shows netcam_cleanup we're done */
+    /* Setting netcam->thread_id to zero shows netcam_cleanup we're done. */
     netcam->thread_id = 0;
 
-    /* signal netcam_cleanup that we're all done */
+    /* Signal netcam_cleanup that we're all done. */
     pthread_mutex_lock(&netcam->mutex);
     pthread_cond_signal(&netcam->exiting);
     pthread_mutex_unlock(&netcam->mutex);
@@ -1745,22 +2103,38 @@ static void *netcam_handler_loop(void *a
     pthread_exit(NULL);
 }
 
-static int netcam_setup_html(netcam_context_ptr netcam, struct url_t *url) {
+/**
+ * netcam_http_build_url
+ *
+ * This routing takes care of the url-processing part of the http protocol.
+ * This includes url scheme and parsing, proxy handling, http-authentication
+ * preparation, response buffer allocation and so on. At the end of this
+ * routine, we are ready to call netcam_http_request().
+ *
+ * Parameters:
+ *      netcam          Pointer to a netcam_context structure
+ *      url             Pointer to a netcam url structure
+ *
+ * Returns:             0 on success,
+ *                      or -1 if an fatal error occurs.
+ */
+static int netcam_http_build_url(netcam_context_ptr netcam, struct url_t *url) 
+{
     struct context *cnt = netcam->cnt;
-    const char *ptr;                  /* working var */
-    char *userpass;                   /* temp pointer to config value */
-    char *encuserpass;                /* temp storage for encoded ver */
-    char *request_pass = NULL;        /* temp storage for base64 conv */
+    const char *ptr;                  /* Working var */
+    char *userpass;                   /* Temp pointer to config value */
+    char *encuserpass;                /* Temp storage for encoded ver */
+    char *request_pass = NULL;        /* Temp storage for base64 conv */
     int ix;
 
-    /* First the http context structure */
+    /* First the http context structure. */
     netcam->response = (struct rbuf *) mymalloc(sizeof(struct rbuf));
     memset(netcam->response, 0, sizeof(struct rbuf));
 
-    if (debug_level > CAMERA_INFO)
-        motion_log(LOG_INFO, 0, "netcam_setup_html: Netcam has flags: HTTP1.0: %s HTTP1.1: %s Keep-Alive %s.", 
-                                netcam->connect_http_10 ? "1":"0", netcam->connect_http_11 ? "1":"0", 
-                                netcam->connect_keepalive ? "ON":"OFF");
+    MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: Netcam has flags:"
+               " HTTP/1.0: %s HTTP/1.1: %s Keep-Alive %s.",  
+               netcam->connect_http_10 ? "1":"0", netcam->connect_http_11 ? "1":"0", 
+               netcam->connect_keepalive ? "ON":"OFF");
 
     /*
      * The network camera may require a username and password.  If
@@ -1775,11 +2149,11 @@ static int netcam_setup_html(netcam_cont
     else
         ptr = url->userpass;
 
-    /* base64_encode needs up to 3 additional chars */
+    /* base64_encode needs up to 3 additional chars. */
     if (ptr) {
         userpass = mymalloc(strlen(ptr) + 3);
         strcpy(userpass, ptr);
-    } else {
+    } else { 
         userpass = NULL;
     }
 
@@ -1792,20 +2166,21 @@ static int netcam_setup_html(netcam_cont
      * concatenate it with the request.
      *
      */
-    /* space for final \r\n plus string terminator */
+
+    /* Space for final \r\n plus string terminator. */
     ix = 3;
 
-    /* See if username / password is required */
-    if (userpass) {         /* if either of the above are non-NULL */
-        /* Allocate space for the base64-encoded string */
+    /* See if username / password is required. */
+    if (userpass) { /* If either of the above are non-NULL. */
+        /* Allocate space for the base64-encoded string. */
         encuserpass = mymalloc(BASE64_LENGTH(strlen(userpass)) + 1);
-        /* Fill in the value */
+        /* Fill in the value. */
         base64_encode(userpass, encuserpass, strlen(userpass));
-        /* Now create the last part (authorization) of the request */
+        /* Now create the last part (authorization) of the request. */
         request_pass = mymalloc(strlen(connect_auth_req) +
                                 strlen(encuserpass) + 1);
         ix += sprintf(request_pass, connect_auth_req, encuserpass);
-        /* free the working variables */
+        /* Free the working variables. */
         free(encuserpass);
     }
 
@@ -1831,16 +2206,19 @@ static int netcam_setup_html(netcam_cont
         ptr = mymalloc(strlen(url->service) + strlen(url->host)
                        + strlen(url->path) + 4);
         sprintf((char *)ptr, "http://%s%s", url->host, url->path);
-        netcam->connect_keepalive=0; /* Disable Keepalive if proxy */
-
-        if (debug_level > CAMERA_INFO)
-            motion_log(LOG_DEBUG, 0, "Removed netcam_keepalive flag due to proxy set." 
-                                     "Proxy is incompatible with Keep-Alive.");
+        
+        netcam->connect_keepalive = FALSE; /* Disable Keepalive if proxy */
+        free((void *)netcam->cnt->conf.netcam_keepalive);
+        netcam->cnt->conf.netcam_keepalive = strdup("off");
+
+        MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: "
+                   "Removed netcam_keepalive flag due to proxy set." 
+                   "Proxy is incompatible with Keep-Alive.");
     } else {
-        /* if no proxy, set as netcam_url path */
+        /* If no proxy, set as netcam_url path. */
         ptr = url->path;
         /*
-         * after generating the connect message the string
+         * After generating the connect message the string
          * will be freed, so we don't want netcam_url_free
          * to free it as well.
          */
@@ -1849,21 +2227,25 @@ static int netcam_setup_html(netcam_cont
 
     ix += strlen(ptr);
 
-       /* Now add the required number of characters for the close header
-        * or Keep-Alive header.  We test the flag which can be unset if
-    * there is a problem (rather than the flag in the conf structure
-    * which is read-only.
-    */
+    /* 
+     * Now add the required number of characters for the close header
+     * or Keep-Alive header.  We test the flag which can be unset if
+     * there is a problem (rather than the flag in the conf structure
+     * which is read-only.
+     */
  
-    if (netcam->connect_keepalive)
+    if (netcam->connect_keepalive) 
         ix += strlen(connect_req_keepalive);
-    else
+    else 
         ix += strlen(connect_req_close);
     
-    /* Point to either the HTTP 1.0 or 1.1 request header set     */
-    /* If the configuration is anything other than 1.1, use 1.0   */
-    /* as a default. This avoids a chance of being left with none */
-    if (netcam->connect_http_11==TRUE)
+
+    /*
+     * Point to either the HTTP 1.0 or 1.1 request header set     
+     * If the configuration is anything other than 1.1, use 1.0   
+     * as a default. This avoids a chance of being left with none.
+     */
+    if (netcam->connect_http_11 == TRUE)
         connect_req = connect_req_http11;
     else
         connect_req = connect_req_http10;
@@ -1875,7 +2257,7 @@ static int netcam_setup_html(netcam_cont
     netcam->connect_request = mymalloc(strlen(connect_req) + ix +
                               strlen(netcam->connect_host));
 
-    /* Now create the request string with an sprintf */
+    /* Now create the request string with an sprintf. */
     sprintf(netcam->connect_request, connect_req, ptr,
             netcam->connect_host); 
 
@@ -1891,73 +2273,110 @@ static int netcam_setup_html(netcam_cont
         free(userpass);
     }
 
-    /* put on the final CRLF onto the request */
+    /* Put on the final CRLF onto the request. */
     strcat(netcam->connect_request, "\r\n");
     free((void *)ptr);
-    netcam_url_free(url);         /* Cleanup the url data */
+    netcam_url_free(url);  /* Cleanup the url data. */
 
-    if (debug_level > CAMERA_INFO) {
-        motion_log(-1, 0, "Camera connect string is ''%s''", netcam->connect_request);
-        motion_log(-1, 0, "End of camera connect string.");
-    }
+    MOTION_LOG(INF , TYPE_NETCAM, NO_ERRNO, "%s: Camera connect"
+               " string is ''%s'' End of camera connect string.",
+               netcam->connect_request);
+    return 0;
+}
 
+/**
+ * netcam_setup_html
+ *      This function will parse the netcam url, connect to the camera,
+ *      set its type to jpeg-based, detect multipart and keep-alive,
+ *      and the get_image method accordingly. The cam can be non-streaming
+ *      or multipart-streaming.
+ *
+ * Parameters
+ *
+ *      netcam  Pointer to the netcam_context for the camera
+ *      url     Pointer to the url of the camera
+ *
+ * Returns:     0 on success (camera link ok) or -1 if an error occurred.
+ *
+ */
+static int netcam_setup_html(netcam_context_ptr netcam, struct url_t *url) 
+{
     /*
-     * Our basic initialisation has been completed.  Now we will attempt
-     * to connect with the camera so that we can then get a "header"
-     * in order to find out what kind of camera we are dealing with,
-     * as well as what are the picture dimensions.  Note that for
-     * this initial connection, any failure will cause an error
-     * return from netcam_start (unlike later possible attempts at
-     * re-connecting, if the network connection is later interrupted).
+     * This netcam is http-based, so build the required URL and
+     * structures, like the connection-string and so on.
      */
-    for (ix = 0; ix < MAX_HEADER_RETRIES; ix++) {
-        /*
-         * netcam_connect does an automatic netcam_close, so it's
-         * safe to include it as part of this loop
-         * (Not always true now Keep-Alive is implemented)
-         */
-        if (debug_level > CAMERA_INFO)
-            motion_log(-1, 0, "netcam_setup_html: about to try to connect, time #%d", ix);
-
-        if (netcam_connect(netcam, 0) != 0) {
-            motion_log(LOG_ERR, 0,"Failed to open camera - check your config and that netcamera is online");
-
-            /* Fatal error on startup */
-            ix = MAX_HEADER_RETRIES;
-            break;;
-        }
-
-        if (netcam_read_first_header(netcam) >= 0)
-            break;
-
-        motion_log(LOG_ERR, 0, "Error reading first header - re-trying");
-    }
-
-    if (ix == MAX_HEADER_RETRIES) {
-        motion_log(LOG_ERR, 0, "Failed to read first camera header - giving up for now");
+    if (netcam_http_build_url(netcam, url) < 0)
         return -1;
-    }
+
+    /*
+     * Then we will send our http request and get headers.
+     */
+    if (netcam_http_request(netcam) < 0)
+         return -1;
 
     /*
      * If this is a streaming camera, we need to position just
-     * past the boundary string and read the image header
+     * past the boundary string and read the image header.
      */
-    if (netcam->caps.streaming) {
+    if (netcam->caps.streaming == NCS_MULTIPART) {
         if (netcam_read_next_header(netcam) < 0) {
-            motion_log(LOG_ERR, 0,
-                       "Failed to read first stream header - giving up for now");
+            MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Failed "
+                       "to read first stream header - "
+                       "giving up for now");
             return -1;
         }
     }
 
-    if (debug_level > CAMERA_INFO)
-        motion_log(-1, 0, "netcam_setup_html: connected, going on to read image.", ix );
+    MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: connected,"
+               " going on to read image.");
 
     netcam->get_image = netcam_read_html_jpeg;
     return 0;
 }
 
-static int netcam_setup_ftp(netcam_context_ptr netcam, struct url_t *url) {
+/**
+ * netcam_setup_mjpg
+ *      This function will parse the netcam url, connect to the camera,
+ *      set its type to MJPG-Streaming, and the get_image method accordingly.
+ *
+ * Parameters
+ *
+ *      netcam  Pointer to the netcam_context for the camera
+ *      url     Pointer to the url of the camera
+ *
+ * Returns:     0 on success (camera link ok) or -1 if an error occurred.
+ *
+ */
+static int netcam_setup_mjpg(netcam_context_ptr netcam, struct url_t *url)
+{
+    /*
+     * This netcam is http-based, so build the required URL and
+     * structures, like the connection-string and so on.
+     */
+    if (netcam_http_build_url(netcam, url) != 0)
+        return -1;
+
+    /* Then we will send our http request and get headers. */
+    if (netcam_http_request(netcam) < 0)
+        return -1;
+
+    /* We have a special type of streaming camera. */
+    netcam->caps.streaming = NCS_BLOCK;
+
+    /*
+     * We are positionned right just at the start of the first MJPG
+     * header, so don't move anymore, initialization complete.
+     */
+    MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: connected,"
+               " going on to read and decode MJPG chunks.");
+
+    netcam->get_image = netcam_read_mjpg_jpeg;
+
+    return 0;
+}
+
+static int netcam_setup_ftp(netcam_context_ptr netcam, struct url_t *url) 
+{
     struct context *cnt = netcam->cnt;
     const char *ptr;
 
@@ -1972,21 +2391,21 @@ static int netcam_setup_ftp(netcam_conte
     netcam->ftp->path = url->path;
     url->path = NULL;
 
-    if (cnt->conf.netcam_userpass != NULL)
+    if (cnt->conf.netcam_userpass != NULL) {
         ptr = cnt->conf.netcam_userpass;
-    else 
-        ptr = url->userpass;  /* don't set this one NULL, gets freed */
-    
+    } else {
+        ptr = url->userpass;  /* Don't set this one NULL, gets freed. */
+    }
 
     if (ptr != NULL) {
         char *cptr;
 
         if ((cptr = strchr(ptr, ':')) == NULL) {
-            netcam->ftp->user = strdup(ptr);
+            netcam->ftp->user = mystrdup(ptr);
         } else {
             netcam->ftp->user = mymalloc((cptr - ptr));
-            memcpy(netcam->ftp->user,ptr,(cptr - ptr));
-            netcam->ftp->passwd = strdup(cptr + 1);
+            memcpy(netcam->ftp->user, ptr,(cptr - ptr));
+            netcam->ftp->passwd = mystrdup(cptr + 1);
         }
     }
 
@@ -2002,7 +2421,8 @@ static int netcam_setup_ftp(netcam_conte
     }
 
     if (ftp_send_type(netcam->ftp, 'I') < 0) {
-        motion_log(LOG_ERR, 0, "Error sending TYPE I to ftp server");
+        MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Error sending"
+                   " TYPE I to ftp server");
         return -1;
     }
 
@@ -2028,19 +2448,23 @@ static int netcam_setup_ftp(netcam_conte
  *      error reply from the system call.
  *
  */
-ssize_t netcam_recv(netcam_context_ptr netcam, void *buffptr, size_t buffsize) {
+ssize_t netcam_recv(netcam_context_ptr netcam, void *buffptr, size_t buffsize) 
+{
     ssize_t retval;
     fd_set fd_r;
     struct timeval selecttime;
 
+    if (netcam->sock < 0)
+        return -1; /* We are not connected, it's impossible to receive data. */
+
     FD_ZERO(&fd_r);
     FD_SET(netcam->sock, &fd_r);
     selecttime = netcam->timeout;
 
     retval = select(FD_SETSIZE, &fd_r, NULL, NULL, &selecttime);
-    if (retval == 0)  /* 0 means timeout */
+    if (retval == 0)              /* 0 means timeout */
         return -1;
-    
+
     return recv(netcam->sock, buffptr, buffsize, 0);
 }
 
@@ -2081,12 +2505,12 @@ void netcam_cleanup(netcam_context_ptr n
      */
     pthread_mutex_lock(&netcam->mutex);
 
-    if (netcam->cnt->netcam == NULL) 
+    if (netcam->cnt->netcam == NULL)
         return;
-    
+
     /*
      * We set the netcam_context pointer in the motion main-loop context
-     * to be NULL, so that this routine won't be called a second time
+     * to be NULL, so that this routine won't be called a second time.
      */
     netcam->cnt->netcam = NULL;
 
@@ -2103,9 +2527,10 @@ void netcam_cleanup(netcam_context_ptr n
      * netcam->mutex locked.
      */
 
-    if (!netcam->caps.streaming) 
+    if (netcam->caps.streaming == NCS_UNSUPPORTED)
         pthread_cond_signal(&netcam->cap_cond);
     
+
     /*
      * Once the camera-handler gets to the end of it's loop (probably as
      * soon as we release netcam->mutex), because netcam->finish has been
@@ -2131,28 +2556,30 @@ void netcam_cleanup(netcam_context_ptr n
         pthread_cond_timedwait(&netcam->exiting, &netcam->mutex, &waittime) != 0) {
         /*
          * Although this shouldn't happen, if it *does* happen we will
-         * log it (just for the programmer's information)
+         * log it (just for the programmer's information).
          */
-        motion_log(-1, 0, "No response from camera "
-                          "handler - it must have already died");
+        MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: No response from camera "
+                   "handler - it must have already died");
         pthread_mutex_lock(&global_lock);
         threads_running--;
         pthread_mutex_unlock(&global_lock);
     }
 
-    /* we don't need any lock anymore, so release it */
+    /* We don't need any lock anymore, so release it. */
     pthread_mutex_unlock(&netcam->mutex);
 
-    /* and cleanup the rest of the netcam_context structure */
+    /* and cleanup the rest of the netcam_context structure. */
     if (netcam->connect_host != NULL) 
         free(netcam->connect_host);
-    
+
     if (netcam->connect_request != NULL) 
         free(netcam->connect_request);
     
+
     if (netcam->boundary != NULL) 
         free(netcam->boundary);
     
+
     if (netcam->latest != NULL) {
         if (netcam->latest->ptr != NULL) 
             free(netcam->latest->ptr);
@@ -2170,7 +2597,7 @@ void netcam_cleanup(netcam_context_ptr n
     if (netcam->jpegbuf != NULL) {
         if (netcam->jpegbuf->ptr != NULL) 
             free(netcam->jpegbuf->ptr);
-        
+    
         free(netcam->jpegbuf);
     }
 
@@ -2179,9 +2606,14 @@ void netcam_cleanup(netcam_context_ptr n
     else 
         netcam_disconnect(netcam);
     
+
     if (netcam->response != NULL) 
         free(netcam->response);
-    
+
+
+    if (netcam->caps.streaming == NCS_RTSP)
+        netcam_shutdown_rtsp(netcam);
+
     pthread_mutex_destroy(&netcam->mutex);
     pthread_cond_destroy(&netcam->cap_cond);
     pthread_cond_destroy(&netcam->pic_ready);
@@ -2216,9 +2648,7 @@ int netcam_next(struct context *cnt, uns
     netcam = cnt->netcam;
 
     if (!netcam->latest->used) {
-        if (debug_level) 
-            motion_log(LOG_INFO, 0, "netcam_next called with no data in buffer");
-        
+        MOTION_LOG(WRN, TYPE_NETCAM, NO_ERRNO, "%s: called with no data in buffer");
         return NETCAM_NOTHING_NEW_ERROR;
     }
 
@@ -2227,23 +2657,34 @@ int netcam_next(struct context *cnt, uns
      * motion main-loop with the camera-handling thread through a signal,
      * together with a flag to say "start your next capture".
      */
-    if (!netcam->caps.streaming) {
+    if (netcam->caps.streaming == NCS_UNSUPPORTED) {
         pthread_mutex_lock(&netcam->mutex);
         netcam->start_capture = 1;
         pthread_cond_signal(&netcam->cap_cond);
         pthread_mutex_unlock(&netcam->mutex);
     }
 
+    if (netcam->caps.streaming == NCS_RTSP) {
+
+        if (netcam->rtsp->status == RTSP_RECONNECTING)
+            return NETCAM_NOTHING_NEW_ERROR;
+
+    	if (netcam_next_rtsp(image , netcam) < 0)
+            return NETCAM_GENERAL_ERROR | NETCAM_JPEG_CONV_ERROR;
+
+    	return 0;
+    }
+
     /*
      * If an error occurs in the JPEG decompression which follows this,
      * jpeglib will return to the code within this 'if'.  Basically, our
      * approach is to just return a NULL (failed) to the caller (an
-     * error message has already been produced by the libjpeg routines)
+     * error message has already been produced by the libjpeg routines).
      */
     if (setjmp(netcam->setjmp_buffer)) 
         return NETCAM_GENERAL_ERROR | NETCAM_JPEG_CONV_ERROR;
     
-    /* If there was no error, process the latest image buffer */
+    /* If there was no error, process the latest image buffer. */
     return netcam_proc_jpeg(netcam, image);
 }
 
@@ -2258,25 +2699,24 @@ int netcam_next(struct context *cnt, uns
  *
  * Parameters:
  *
- *      cnt     Pointer to the motion context structure for this device
+ *      cnt     Pointer to the motion context structure for this device.
  *
- * Returns:     0 on success, -1 on any failure
+ * Returns:     0 on success
+ *              -1 on any failure
+ *              -3 image dimensions are not modulo 16
  */
 
 int netcam_start(struct context *cnt)
 {
-    netcam_context_ptr netcam;        /* local pointer to our context */
-    pthread_attr_t handler_attribute; /* attributes of our handler thread */
-    int retval;                       /* working var */
-    struct url_t url;                 /* for parsing netcam URL */
-
-    if (debug_level > CAMERA_INFO)
-        motion_log(-1, 0, "entered netcam_start()");
+    netcam_context_ptr netcam;        /* Local pointer to our context. */
+    pthread_attr_t handler_attribute; /* Attributes of our handler thread. */
+    int retval;                       /* Working var. */
+    struct url_t url;                 /* For parsing netcam URL. */
 
     memset(&url, 0, sizeof(url));
-    if (SETUP)
-        motion_log(LOG_INFO, 0, "Camera thread starting...");
 
+    MOTION_LOG(ALR, TYPE_NETCAM, NO_ERRNO, "%s: Network Camera thread"
+               " starting... for url (%s)", cnt->conf.netcam_url);
     /*
      * Create a new netcam_context for this camera
      * and clear all the entries.
@@ -2284,8 +2724,8 @@ int netcam_start(struct context *cnt)
     cnt->netcam = (struct netcam_context *)
                    mymalloc(sizeof(struct netcam_context));
     memset(cnt->netcam, 0, sizeof(struct netcam_context));
-    netcam = cnt->netcam;           /* Just for clarity in remaining code */
-    netcam->cnt = cnt;              /* Fill in the "parent" info */
+    netcam = cnt->netcam;           /* Just for clarity in remaining code. */
+    netcam->cnt = cnt;              /* Fill in the "parent" info. */
 
     /*
      * Fill in our new netcam context with all known initial
@@ -2312,24 +2752,23 @@ int netcam_start(struct context *cnt)
     pthread_cond_init(&netcam->pic_ready, NULL);
     pthread_cond_init(&netcam->exiting, NULL);
     
-    /* Initialise the average frame time to the user's value */
+    /* Initialise the average frame time to the user's value. */
     netcam->av_frame_time = 1000000.0 / cnt->conf.frame_limit;
 
-    /*
-     * If a proxy has been specified, parse that URL.
-     */
+    /* If a proxy has been specified, parse that URL. */
     if (cnt->conf.netcam_proxy) {
         netcam_url_parse(&url, cnt->conf.netcam_proxy);
 
         if (!url.host) {
-            motion_log(LOG_ERR, 0, "Invalid netcam_proxy (%s)",
+            MOTION_LOG(CRT, TYPE_NETCAM, NO_ERRNO, "%s: Invalid netcam_proxy (%s)",
                        cnt->conf.netcam_proxy);
             netcam_url_free(&url);
             return -1;
         }
 
         if (url.userpass) {
-            motion_log(LOG_ERR, 0, "Username/password not allowed on a proxy URL");
+            MOTION_LOG(CRT, TYPE_NETCAM, NO_ERRNO, "%s: Username/password"
+                       " not allowed on a proxy URL");
             netcam_url_free(&url);
             return -1;
         }
@@ -2345,13 +2784,12 @@ int netcam_start(struct context *cnt)
         netcam_url_free(&url);  /* Finished with proxy */
     }
 
-    /*
-     * Parse the URL from the configuration data
-     */
+    /* Parse the URL from the configuration data */
     netcam_url_parse(&url, cnt->conf.netcam_url);
 
     if (!url.host) {
-        motion_log(LOG_ERR, 0, "Invalid netcam_url (%s)", cnt->conf.netcam_url);
+        MOTION_LOG(CRT, TYPE_NETCAM, NO_ERRNO, "%s: Invalid netcam_url (%s)", 
+                   cnt->conf.netcam_url);
         netcam_url_free(&url);
         return -1;
     }
@@ -2362,7 +2800,7 @@ int netcam_start(struct context *cnt)
         netcam->connect_port = url.port;
     }
 
-        /* Get HTTP Mode (1.0 default, 1.0 Keep-Alive, 1.1) flag from config
+    /* Get HTTP Mode (1.0 default, 1.0 Keep-Alive, 1.1) flag from config
      * and report its stata for debug reasons.
      * The flags in the conf structure is read only and cannot be 
      * unset if the Keep-Alive needs to be switched off (ie. netcam does
@@ -2370,43 +2808,64 @@ int netcam_start(struct context *cnt)
      * in the context structures (cnt->...) only.
      */
 
-    if (!strcmp(cnt->conf.netcam_http,"keep_alive")) {
+    if (!strcmp(cnt->conf.netcam_keepalive, "force")) {
             netcam->connect_http_10   = TRUE;
             netcam->connect_http_11   = FALSE;
             netcam->connect_keepalive = TRUE;
-    } else if (!strcmp(cnt->conf.netcam_http,"1.0") || !strcmp(cnt->conf.netcam_http,"1.0")) {
+    } else if (!strcmp(cnt->conf.netcam_keepalive, "off")) {
             netcam->connect_http_10   = TRUE;
             netcam->connect_http_11   = FALSE;
             netcam->connect_keepalive = FALSE;
-    } else if (!strcmp(cnt->conf.netcam_http,"1.1")) {
+    } else if (!strcmp(cnt->conf.netcam_keepalive, "on")) {
             netcam->connect_http_10   = FALSE;
             netcam->connect_http_11   = TRUE;
-            netcam->connect_keepalive = TRUE; /* HTTP 1.1 has keepalive by default */
+            netcam->connect_keepalive = TRUE; /* HTTP 1.1 has keepalive by default. */
     }
-    if (debug_level > CAMERA_INFO)
-        motion_log(LOG_INFO, 0, "netcam_start: Netcam_http parameter '%s' converts to flags: HTTP1.0:" 
-                                "%s HTTP1.1: %s Keep-Alive %s.", cnt->conf.netcam_http, 
-                                netcam->connect_http_10 ? "1":"0", netcam->connect_http_11 ? "1":"0", 
-                                netcam->connect_keepalive ? "ON":"OFF");
 
-    /* Initialise the netcam socket to -1 to trigger a connection by the keep-alive logic */
+    MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: Netcam_http parameter '%s'"
+               " converts to flags: HTTP/1.0: %s HTTP/1.1: %s Keep-Alive %s.", 
+               cnt->conf.netcam_keepalive, 
+               netcam->connect_http_10 ? "1":"0", netcam->connect_http_11 ? "1":"0", 
+               netcam->connect_keepalive ? "ON":"OFF");
+
+    /* Initialise the netcam socket to -1 to trigger a connection by the keep-alive logic. */
     netcam->sock = -1;
 
-    if ((url.service) && (!strcmp(url.service, "http")) ){
-        if (debug_level > CAMERA_INFO)
-            motion_log(-1, 0, "netcam_start: now calling netcam_setup_html()");
+    if ((url.service) && (!strcmp(url.service, "http"))) {
+        MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: now calling"
+                   " netcam_setup_html()");
+
         retval = netcam_setup_html(netcam, &url);
-    } else if ((url.service) && (!strcmp(url.service, "ftp")) ){
-        if (debug_level > CAMERA_INFO)
-            motion_log(-1, 0, "netcam_start: now calling netcam_setup_ftp");
+    } else if ((url.service) && (!strcmp(url.service, "ftp"))) {
+        MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: now calling"
+                   " netcam_setup_ftp");
+
         retval = netcam_setup_ftp(netcam, &url);
-    } else if ((url.service) && (!strcmp(url.service, "file")) ){
-        if (debug_level > CAMERA_INFO)
-            motion_log(-1, 0, "netcam_start: now calling netcam_setup_file()");
+    } else if ((url.service) && (!strcmp(url.service, "file"))) {
+        MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: now calling"
+                   " netcam_setup_file()");
+
         retval = netcam_setup_file(netcam, &url);
+    } else if ((url.service) && (!strcmp(url.service, "mjpg"))) {
+        MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: now calling"
+                   " netcam_setup_mjpg()");
+
+        strcpy(url.service, "http"); /* Put back a real URL service. */
+        retval = netcam_setup_mjpg(netcam, &url);
+    } else if ((url.service) && (!strcmp(url.service, "mjpeg"))) {
+        MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: now calling"
+                   " netcam_setup_mjpeg()");
+
+        strcpy(url.service, "http"); /* Put back a real URL service. */
+        retval = netcam_setup_rtsp(netcam, &url);
+    } else if ((url.service) && (!strcmp(url.service, "rtsp"))) {
+        MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: now calling"
+                    " netcam_setup_rtsp()");
+
+        retval = netcam_setup_rtsp(netcam, &url);
     } else {
-        motion_log(LOG_ERR, 0, "Invalid netcam service  '%s' - "
-                               "must be http or ftp", url.service);
+        MOTION_LOG(CRT, TYPE_NETCAM, NO_ERRNO, "%s: Invalid netcam service '%s' - "
+                   "must be http, ftp, mjpg, mjpeg or file.", url.service);
         netcam_url_free(&url);
         return -1;
     }
@@ -2422,41 +2881,48 @@ int netcam_start(struct context *cnt)
      * these to set the required image buffer(s) in our netcam_struct.
      */
     if ((retval = netcam->get_image(netcam)) != 0) {
-        motion_log(LOG_ERR, 0, "Failed trying to read first image - retval:%d", retval );
+        MOTION_LOG(CRT, TYPE_NETCAM, NO_ERRNO, "%s: Failed trying to "
+                   "read first image - retval:%d", retval);
+        netcam->rtsp->status = RTSP_NOTCONNECTED;
         return -1;
     }
 
-    /*
-     * If an error occurs in the JPEG decompression which follows this,
-     * jpeglib will return to the code within this 'if'.  If such an error
-     * occurs during startup, we will just abandon this attempt.
-     */
-    if (setjmp(netcam->setjmp_buffer)) {
-        motion_log(LOG_ERR, 0, "libjpeg decompression failure "
-                               "on first frame - giving up!");
-        return -1;
-    }
 
-    netcam->netcam_tolerant_check = cnt->conf.netcam_tolerant_check;
-    netcam->JFIF_marker = 0;
-    netcam_get_dimensions(netcam);
+    if (netcam->caps.streaming != NCS_RTSP) {
 
-    /* Motion currently requires that image height and width is a
-     * multiple of 16. So we check for this.
-     */
+        /*
+        * If an error occurs in the JPEG decompression which follows this,
+        * jpeglib will return to the code within this 'if'.  If such an error
+        * occurs during startup, we will just abandon this attempt.
+        */
+        if (setjmp(netcam->setjmp_buffer)) {
+            MOTION_LOG(CRT, TYPE_NETCAM, NO_ERRNO, "%s: libjpeg decompression failure "
+                       "on first frame - giving up!");
+            return -1;
+        }
+
+        netcam->netcam_tolerant_check = cnt->conf.netcam_tolerant_check;
+        netcam->JFIF_marker = 0;
+        netcam_get_dimensions(netcam);
+    }
+    /*
+    * Motion currently requires that image height and width is a
+    * multiple of 16. So we check for this.
+    */
     if (netcam->width % 16) {
-        motion_log(LOG_ERR, 0, "netcam image width (%d) is not modulo 16",
-                   netcam->width);
-        return -1;
+        MOTION_LOG(CRT, TYPE_NETCAM, NO_ERRNO, "%s: netcam image width (%d)"
+                   " is not modulo 16", netcam->width);
+        return -3;
     }
 
     if (netcam->height % 16) {
-        motion_log(LOG_ERR, 0, "netcam image height (%d) is not modulo 16",
-                   netcam->height);
-        return -1;
+        MOTION_LOG(CRT, TYPE_NETCAM, NO_ERRNO, "%s: netcam image height (%d)"
+                   " is not modulo 16", netcam->height);
+        return -3;
     }
+    
 
-    /* Fill in camera details into context structure */
+    /* Fill in camera details into context structure. */
     cnt->imgs.width = netcam->width;
     cnt->imgs.height = netcam->height;
     cnt->imgs.size = (netcam->width * netcam->height * 3) / 2;
@@ -2475,7 +2941,8 @@ int netcam_start(struct context *cnt)
 
     if ((retval = pthread_create(&netcam->thread_id, &handler_attribute,
                                  &netcam_handler_loop, netcam)) < 0) {
-        motion_log(LOG_ERR, 1, "Starting camera handler thread [%d]", netcam->threadnr);
+        MOTION_LOG(ALR, TYPE_NETCAM, SHOW_ERRNO, "%s: Starting camera"
+                   " handler thread [%d]", netcam->threadnr);
         return -1;
     }
 
--- motion-3.2.12.orig/netcam.h
+++ motion-3.2.12/netcam.h
@@ -102,6 +102,16 @@ typedef struct file_context {
     time_t    last_st_mtime;       /* time this image was modified */
 } tfile_context;
 
+#define NCS_UNSUPPORTED         0  /* streaming is not supported */
+#define NCS_MULTIPART           1  /* streaming is done via multipart */
+#define NCS_BLOCK               2  /* streaming is done via MJPG-block */
+#define NCS_RTSP                3  /* streaming is done via RTSP */
+
+
+#define RTSP_NOTCONNECTED  0  /* The camera has never connected */
+#define RTSP_CONNECTED     1  /* The camera is currently connected */
+#define RTSP_RECONNECTING  2  /* The camera is trying to reconnect*/
+
 /*
  * struct netcam_context contains all the structures and other data
  * for an individual netcam.
@@ -154,13 +164,15 @@ typedef struct netcam_context {
                                    specified as something else by
                                    the user */
 
-    int connect_http_10;        /* set to TRUE if HTTP 1.0 connection */
+    int connect_http_10;        /* set to TRUE if HTTP 1.0 connection 
+                                   (netcam_keepalive off) */
 
-    int connect_http_11;        /* set to TRUE if HTTP 1.1 connection */
+    int connect_http_11;        /* set to TRUE if HTTP 1.1 connection 
+                                   (netcam_keepalive on)  */
 
-    int connect_keepalive;      /* set to TRUE if connection maintained
-                                       after a request, otherwise FALSE to
-                                       close down the socket each time */
+    int connect_keepalive;      /* set to TRUE if connection maintained after 
+                                   a request, otherwise FALSE to close down 
+                                   the socket each time (netcam_keealive force) */
 
     int keepalive_thisconn;     /* set to TRUE if cam has sent 'Keep-Alive' in this connection */
 
@@ -193,6 +205,9 @@ typedef struct netcam_context {
     struct file_context *file;  /* this structure contains the
                                    context for FILE connection */
 
+    struct rtsp_context *rtsp;  /* this structure contains the
+                                   context for RTSP connection */                                                                       
+
     int (*get_image)(netcam_context_ptr);
                                 /* Function to fetch the image from
                                    the netcam.  It is initialised in
@@ -202,7 +217,7 @@ typedef struct netcam_context {
 
 
     struct netcam_caps {        /* netcam capabilities: */
-        unsigned char streaming;        /*  1 - supported       */
+        unsigned char streaming;        /*  See the NCS_* defines */
         unsigned char content_length;   /*  0 - unsupported     */
     } caps;
 
@@ -229,6 +244,9 @@ typedef struct netcam_context {
     int imgcnt_last;            /* remember last count to check if a new
                                    image arrived */
 
+    int warning_count;          /* simple count of number of warnings 
+                                   since last good frame was received */
+
     int error_count;            /* simple count of number of errors since
                                    last good frame was received */
     
@@ -251,8 +269,29 @@ typedef struct netcam_context {
                                    occurred during decompression*/
 } netcam_context;
 
+#define MJPG_MH_MAGIC          "MJPG"
+#define MJPG_MH_MAGIC_SIZE          4
 
 /*
+ * MJPG Chunk header for MJPG streaming.
+ * Little-endian data is read from the network.
+ */
+typedef struct {
+    char mh_magic[MJPG_MH_MAGIC_SIZE];     /* must contain the string MJP
+                                              not null-terminated. */
+    unsigned int mh_framesize;             /* Total size of the current 
+                                              frame in bytes (~45kb on WVC200) */
+    unsigned short mh_framewidth;          /* Frame width in pixels */
+    unsigned short mh_frameheight;         /* Frame height in pixels */
+    unsigned int mh_frameoffset;           /* Offset of this chunk relative
+                                              to the beginning of frame. */
+    unsigned short mh_chunksize;           /* The size of the chunk data
+                                              following this header. */
+    char mh_reserved[30];                  /* Unknown data, seems to be
+                                              constant between all headers */
+} mjpg_header;
+ 
+/*
  * Declare prototypes for our external entry points
  */
 /*     Within netcam_jpeg.c    */
@@ -263,5 +302,6 @@ int netcam_start (struct context *);
 int netcam_next (struct context *, unsigned char *);
 void netcam_cleanup (struct netcam_context *, int);
 ssize_t netcam_recv(netcam_context_ptr, void *, size_t);
+void netcam_url_free(struct url_t *parse_url);
 
 #endif
--- motion-3.2.12.orig/netcam_ftp.c
+++ motion-3.2.12/netcam_ftp.c
@@ -1,56 +1,53 @@
-/**
-*      Much of the FTP code was inspired by the nanoftp.c module from
-*      libxml2 (Copyright Daniel Veillard, 2003).  The routines have been
-*      modified to fit the needs of the Motion project.
-*
-*      Copyright 2005, William M. Brack
-*      This software is distributed under the GNU Public license Version 2.
-*      See also the file 'COPYING'.
-*
-*/
-#include "motion.h"  /* needs to come first, because _GNU_SOURCE_ set there */
+/*
+ *      Much of the FTP code was inspired by the nanoftp.c module from
+ *      libxml2 (Copyright Daniel Veillard, 2003).  The routines have been
+ *      modified to fit the needs of the Motion project.
+ *
+ *      Copyright 2005, William M. Brack
+ *      This software is distributed under the GNU Public license Version 2.
+ *      See also the file 'COPYING'.
+ *
+ */
+#include "motion.h"  /* Needs to come first, because _GNU_SOURCE_ set there. */
 
 #include <ctype.h>
 #include <netdb.h>
-#include <regex.h>
-#include <sys/socket.h>
 #include <netinet/in.h>
-
 #include "netcam_ftp.h"
 
 /**
 * ftp_new_context
 *
-*      Create a new FTP context structure
+*      Create a new FTP context structure.
 *
 * Parameters
 *
 *       None
 *
-* Returns:     Pointer to the newly-created structure, NULL if error
+* Returns:     Pointer to the newly-created structure, NULL if error.
 *
 */
 ftp_context_pointer ftp_new_context(void)
 {
     ftp_context_pointer ret;
 
-    /* note that mymalloc will exit on any problem */
+    /* Note that mymalloc will exit on any problem. */
     ret = mymalloc(sizeof(ftp_context));
 
     memset(ret, 0, sizeof(ftp_context));
-    ret->control_file_desc = -1;                /* no control connection yet */
-    ret->data_file_desc = -1;                   /* no data connection yet */
+    ret->control_file_desc = -1;                /* No control connection yet. */
+    ret->data_file_desc = -1;                   /* No data connection yet. */
     return ret;
 }
 
 /**
 * ftp_free_context
 *
-*      Free the resources allocated for this context
+*      Free the resources allocated for this context.
 *
 * Parameters
 *
-*      ctxt    Pointer to the ftp_context structure
+*      ctxt    Pointer to the ftp_context structure.
 *
 * Returns:     Nothing
 *
@@ -82,15 +79,16 @@ void ftp_free_context(ftp_context_pointe
 *
 * Parameters:
 *
-*      buf     the buffer containing the response
-*      len     the buffer length
+*      buf     the buffer containing the response.
+*      len     the buffer length.
 *
 * Returns:
 *     0 for errors
 *     +XXX for last line of response
 *     -XXX for response to be continued
 */
-static int ftp_parse_response(char *buf, int len) {
+static int ftp_parse_response(char *buf, int len)
+{
     int val = 0;
 
     if (len < 3)
@@ -126,19 +124,20 @@ static int ftp_parse_response(char *buf,
 /**
 * ftp_get_more
 *
-*      Read more information from the FTP control connection
+*      Read more information from the FTP control connection.
 *
 * Parameters:
 *
-*      ctxt    pointer to an FTP context
+*      ctxt    pointer to an FTP context.
 *
 * Returns the number of bytes read, < 0 indicates an error
 */
-static int ftp_get_more(ftp_context_pointer ctxt) {
+static int ftp_get_more(ftp_context_pointer ctxt)
+{
     int len;
     int size;
 
-    /* Validate that our context structure is valid */
+    /* Validate that our context structure is valid. */
     if ((ctxt == NULL) || (ctxt->control_file_desc < 0))
         return -1;
 
@@ -151,29 +150,24 @@ static int ftp_get_more(ftp_context_poin
     if (ctxt->control_buffer_index > ctxt->control_buffer_used)
         return -1;
 
-    /*
-    * First pack the control buffer
-    */
+    /* First pack the control buffer. */
     if (ctxt->control_buffer_index > 0) {
         memmove(&ctxt->control_buffer[0],
-                &ctxt->control_buffer[ctxt->control_buffer_index],
-                ctxt->control_buffer_used - ctxt->control_buffer_index);
-
+        &ctxt->control_buffer[ctxt->control_buffer_index],
+        ctxt->control_buffer_used - ctxt->control_buffer_index);
         ctxt->control_buffer_used -= ctxt->control_buffer_index;
         ctxt->control_buffer_index = 0;
     }
+
     size = FTP_BUF_SIZE - ctxt->control_buffer_used;
 
-    if (size == 0) 
+    if (size == 0)
         return 0;
-    
 
-    /*
-    * Read the amount left on the control connection
-    */
+    /* Read the amount left on the control connection. */
     if ((len = recv(ctxt->control_file_desc,
-         &ctxt->control_buffer[ctxt->control_buffer_index], size, 0)) < 0) {
-        motion_log(LOG_ERR, 1, "recv failed in ftp_get_more");
+                    &ctxt->control_buffer[ctxt->control_buffer_index], size, 0)) < 0) {
+        MOTION_LOG(ERR, TYPE_NETCAM, SHOW_ERRNO, "%s: recv failed in ftp_get_more");
         close(ctxt->control_file_desc);
         ctxt->control_file_desc = -1;
         return -1;
@@ -196,7 +190,8 @@ static int ftp_get_more(ftp_context_poin
 *
 * Returns the code number
 */
-static int ftp_get_response(ftp_context_pointer ctxt) {
+static int ftp_get_response(ftp_context_pointer ctxt)
+{
     char *ptr, *end;
     int len;
     int res = -1, cur = -1;
@@ -206,17 +201,19 @@ static int ftp_get_response(ftp_context_
 
     get_more:
     /*
-    * Assumes everything up to control_buffer[control_buffer_index] has been read
-    * and analyzed.
-    */
+     * Assumes everything up to control_buffer[control_buffer_index]
+     * has been read and analyzed.
+     */
     len = ftp_get_more(ctxt);
 
-    if (len < 0) 
+    if (len < 0)
         return -1;
-    
-    if ((ctxt->control_buffer_used == 0) && (len == 0)) 
+
+
+    if ((ctxt->control_buffer_used == 0) && (len == 0))
         return -1;
-    
+
+
     ptr = &ctxt->control_buffer[ctxt->control_buffer_index];
     end = &ctxt->control_buffer[ctxt->control_buffer_used];
 
@@ -224,23 +221,22 @@ static int ftp_get_response(ftp_context_
         cur = ftp_parse_response(ptr, end - ptr);
         if (cur > 0) {
             /*
-            * Successfully scanned the control code, skip
-            * till the end of the line, but keep the index to be
-            * able to analyze the result if needed.
-            */
+             * Successfully scanned the control code, skip
+             * till the end of the line, but keep the index to be
+             * able to analyze the result if needed.
+             */
             res = cur;
             ptr += 3;
             ctxt->control_buffer_answer = ptr - ctxt->control_buffer;
-        
-            while ((ptr < end) && (*ptr != '\n')) 
+            while ((ptr < end) && (*ptr != '\n'))
                 ptr++;
-        
-            if (*ptr == '\n') 
+
+            if (*ptr == '\n')
                 ptr++;
-        
-            if (*ptr == '\r') 
+
+            if (*ptr == '\r')
                 ptr++;
-        
+
             break;
         }
 
@@ -252,7 +248,7 @@ static int ftp_get_response(ftp_context_
             goto get_more;
         }
 
-        if (*ptr != '\r') 
+        if (*ptr != '\r')
             ptr++;
     }
 
@@ -265,10 +261,11 @@ static int ftp_get_response(ftp_context_
 }
 
 /**
-* Send the user authentication
+* ftp_send_user
+*       Sends the user authentication.
 */
-
-static int ftp_send_user(ftp_context_pointer ctxt) {
+static int ftp_send_user(ftp_context_pointer ctxt)
+{
     char buf[200];
     int len;
     int res;
@@ -281,20 +278,20 @@ static int ftp_send_user(ftp_context_poi
     buf[sizeof(buf) - 1] = 0;
     len = strlen(buf);
     res = send(ctxt->control_file_desc, buf, len, 0);
-    
+
     if (res < 0) {
-        motion_log(LOG_ERR, 1, "send failed in ftp_send_user");
+        MOTION_LOG(ERR, TYPE_NETCAM, SHOW_ERRNO, "%s: send failed in ftp_send_user");
         return res;
     }
-
     return 0;
 }
 
 /**
-* Send the password authentication
+* ftp_send_passwd
+*       Sends the password authentication.
 */
-
-static int ftp_send_passwd(ftp_context_pointer ctxt) {
+static int ftp_send_passwd(ftp_context_pointer ctxt)
+{
     char buf[200];
     int len;
     int res;
@@ -303,13 +300,13 @@ static int ftp_send_passwd(ftp_context_p
         snprintf(buf, sizeof(buf), "PASS anonymous@\r\n");
     else
         snprintf(buf, sizeof(buf), "PASS %s\r\n", ctxt->passwd);
-    
+
     buf[sizeof(buf) - 1] = 0;
     len = strlen(buf);
     res = send(ctxt->control_file_desc, buf, len, 0);
-    
+
     if (res < 0) {
-        motion_log(LOG_ERR, 1, "send failed in ftp_send_passwd");
+        MOTION_LOG(ERR, TYPE_NETCAM, SHOW_ERRNO, "%s: send failed in ftp_send_passwd");
         return res;
     }
 
@@ -327,9 +324,8 @@ static int ftp_send_passwd(ftp_context_p
 *
 * Returns -1 in case of error, 0 otherwise
 */
-
-
-static int ftp_quit(ftp_context_pointer ctxt) {
+static int ftp_quit(ftp_context_pointer ctxt)
+{
     char buf[200];
     int len, res;
 
@@ -341,7 +337,7 @@ static int ftp_quit(ftp_context_pointer
     res = send(ctxt->control_file_desc, buf, len, 0);
 
     if (res < 0) {
-        motion_log(LOG_ERR, 1, "send failed in ftp_quit");
+        MOTION_LOG(ERR, TYPE_NETCAM, SHOW_ERRNO, "%s: send failed in ftp_quit");
         return res;
     }
 
@@ -351,16 +347,16 @@ static int ftp_quit(ftp_context_pointer
 /**
 * ftp_connect
 *
-*      Tries to open a control connection
+*      Tries to open a control connection.
 *
 * Parameters:
 *
 *      ctxt    an FTP context
 *
-* Returns -1 in case of error, 0 otherwise
+* Returns -1 in case of error, 0 otherwise.
 */
-
-int ftp_connect(netcam_context_ptr netcam) {
+int ftp_connect(netcam_context_ptr netcam)
+{
     ftp_context_pointer ctxt;
     struct hostent *hp;
     int port;
@@ -378,11 +374,9 @@ int ftp_connect(netcam_context_ptr netca
     if (netcam->connect_host == NULL)
         return -1;
 
-    /*
-    * do the blocking DNS query.
-    */
+    /* Do the blocking DNS query. */
     port = netcam->connect_port;
-    
+
     if (port == 0)
         port = 21;
 
@@ -391,48 +385,39 @@ int ftp_connect(netcam_context_ptr netca
     hp = gethostbyname (netcam->connect_host);
 
     if (hp == NULL) {
-        motion_log(LOG_ERR, 1, "gethostbyname failed in ftp_connect");
+        MOTION_LOG(ERR, TYPE_NETCAM, SHOW_ERRNO, "%s: gethostbyname failed in ftp_connect");
         return -1;
     }
 
     if ((unsigned int) hp->h_length >
-        sizeof(((struct sockaddr_in *)&ctxt->ftp_address)->sin_addr)) {
-        motion_log(LOG_ERR, 1, "gethostbyname address mismatch "
-                               "in ftp_connect");
+         sizeof(((struct sockaddr_in *)&ctxt->ftp_address)->sin_addr)) {
+        MOTION_LOG(ERR, TYPE_NETCAM, SHOW_ERRNO, "%s: gethostbyname address mismatch "
+                   "in ftp_connect");
         return -1;
     }
 
-    /*
-    * Prepare the socket
-    */
+    /* Prepare the socket */
     ((struct sockaddr_in *)&ctxt->ftp_address)->sin_family = AF_INET;
-    memcpy (&((struct sockaddr_in *)&ctxt->ftp_address)->sin_addr,
-            hp->h_addr_list[0], hp->h_length);
-
-    ((struct sockaddr_in *)&ctxt->ftp_address)->sin_port =
-    (u_short)htons ((unsigned short)port);
+    memcpy (&((struct sockaddr_in *)&ctxt->ftp_address)->sin_addr, hp->h_addr_list[0], hp->h_length);
+    ((struct sockaddr_in *)&ctxt->ftp_address)->sin_port = (u_short)htons ((unsigned short)port);
     ctxt->control_file_desc = socket (AF_INET, SOCK_STREAM, 0);
     addrlen = sizeof (struct sockaddr_in);
 
     if (ctxt->control_file_desc < 0) {
-        motion_log(LOG_ERR, 1, "socket failed");
+        MOTION_LOG(ERR, TYPE_NETCAM, SHOW_ERRNO, "%s: socket failed");
         return -1;
     }
 
-    /*
-    * Do the connect.
-    */
+    /* Do the connect. */
     if (connect(ctxt->control_file_desc, (struct sockaddr *) &ctxt->ftp_address,
         addrlen) < 0) {
-        motion_log(LOG_ERR, 1, "Failed to create a connection");
+        MOTION_LOG(ERR, TYPE_NETCAM, SHOW_ERRNO, "%s: Failed to create a connection");
         close(ctxt->control_file_desc);
         ctxt->control_file_desc = -1;
         return -1;
     }
 
-    /*
-    * Wait for the HELLO from the server.
-    */
+    /* Wait for the HELLO from the server. */
     res = ftp_get_response(ctxt);
 
     if (res != 2) {
@@ -441,10 +426,9 @@ int ftp_connect(netcam_context_ptr netca
         return -1;
     }
 
-    /*
-    * Do the authentication
-    */
+    /* Do the authentication */
     res = ftp_send_user(ctxt);
+
     if (res < 0) {
         close(ctxt->control_file_desc);
         ctxt->control_file_desc = -1;
@@ -469,7 +453,7 @@ int ftp_connect(netcam_context_ptr netca
     }
 
     res = ftp_send_passwd(ctxt);
-    
+
     if (res < 0) {
         close(ctxt->control_file_desc);
         ctxt->control_file_desc = -1;
@@ -477,20 +461,20 @@ int ftp_connect(netcam_context_ptr netca
     }
 
     res = ftp_get_response(ctxt);
-
     switch (res) {
     case 2:
         break;
     case 3:
-        motion_log(LOG_ERR, 0, "FTP server asking for ACCT on anonymous");
+        MOTION_LOG(WRN, TYPE_NETCAM, NO_ERRNO, "%s: FTP server asking for ACCT on anonymous");
     case 1:
     case 4:
     case 5:
     case -1:
     default:
-        close(ctxt->control_file_desc); ctxt->control_file_desc = -1;
+        close(ctxt->control_file_desc);
         ctxt->control_file_desc = -1;
-        return -1;
+        ctxt->control_file_desc = -1;
+        return-1;
     }
 
     return 0;
@@ -503,12 +487,12 @@ int ftp_connect(netcam_context_ptr netca
 *
 * Parameters:
 *
-*      ctxt    pointer to an FTP context
+*      ctxt    pointer to an FTP context.
 *
 * Returns -1 in case of error, 0 otherwise
 */
-
-static int ftp_get_connection(ftp_context_pointer ctxt) {
+static int ftp_get_connection(ftp_context_pointer ctxt)
+{
     char buf[200], *cur;
     int len, i;
     int res;
@@ -519,16 +503,17 @@ static int ftp_get_connection(ftp_contex
     unsigned int data_address_length;
 
     if (ctxt == NULL)
-        return -1;
+    return -1;
 
-    /* set up a socket for our data address */
+    /* Set up a socket for our data address. */
     if (ctxt->data_file_desc != -1)
-    close(ctxt->data_file_desc);
+        close(ctxt->data_file_desc);
+
     memset (&data_address, 0, sizeof(data_address));
     ctxt->data_file_desc = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
-    
+
     if (ctxt->data_file_desc < 0) {
-        motion_log(LOG_ERR, 1, "socket failed");
+        MOTION_LOG(ERR, TYPE_NETCAM, SHOW_ERRNO, "%s: socket failed");
         return -1;
     }
 
@@ -536,7 +521,7 @@ static int ftp_get_connection(ftp_contex
 
     if (setsockopt(ctxt->data_file_desc, SOL_SOCKET, SO_REUSEADDR,
         (char *)&on, sizeof(on)) < 0) {
-        motion_log(LOG_ERR, 1, "setting socket option SO_REUSEADDR");
+        MOTION_LOG(ERR, TYPE_NETCAM, SHOW_ERRNO, "%s: setting socket option SO_REUSEADDR");
         return -1;
     }
 
@@ -544,19 +529,18 @@ static int ftp_get_connection(ftp_contex
     data_address_length = sizeof (struct sockaddr_in);
 
     if (ctxt->passive) {
-        /* send PASV command over control channel */
+        /* Send PASV command over control channel. */
         snprintf (buf, sizeof(buf), "PASV\r\n");
         len = strlen (buf);
         res = send(ctxt->control_file_desc, buf, len, 0);
-        
+
         if (res < 0) {
-            motion_log(LOG_ERR, 1, "send failed in ftp_get_connection");
+            MOTION_LOG(ERR, TYPE_NETCAM, SHOW_ERRNO, "%s: send failed in ftp_get_connection");
             close(ctxt->data_file_desc);
             ctxt->data_file_desc = -1;
             return res;
         }
-
-        /* check server's answer */
+        /* Check server's answer */
         res = ftp_get_response(ctxt);
 
         if (res != 2) {
@@ -565,93 +549,89 @@ static int ftp_get_connection(ftp_contex
                 ctxt->data_file_desc = -1;
                 return -1;
             } else {
-                /*
-                * retry with an active connection
-                */
+                /* Retry with an active connection. */
                 close(ctxt->data_file_desc);
                 ctxt->data_file_desc = -1;
                 ctxt->passive = 0;
             }
         }
-        /* parse the IP address and port supplied by the server */
+        /* Parse the IP address and port supplied by the server. */
         cur = &ctxt->control_buffer[ctxt->control_buffer_answer];
+
         while (((*cur < '0') || (*cur > '9')) && *cur != '\0')
             cur++;
 
-        if (sscanf (cur, "%u,%u,%u,%u,%u,%u", &temp[0], &temp[1], &temp[2],
+        if (sscanf(cur, "%u,%u,%u,%u,%u,%u", &temp[0], &temp[1], &temp[2],
             &temp[3], &temp[4], &temp[5]) != 6) {
-            motion_log(LOG_ERR, 0, "Invalid answer to PASV");
-            
+            MOTION_LOG(WRN, TYPE_NETCAM, NO_ERRNO, "%s: Invalid answer to PASV");
             if (ctxt->data_file_desc != -1) {
                 close (ctxt->data_file_desc);
                 ctxt->data_file_desc = -1;
             }
-
             return -1;
         }
 
-        for (i=0; i<6; i++)
+        for (i = 0; i < 6; i++)
             ad[i] = (unsigned char) (temp[i] & 0xff) ;
 
         memcpy (&((struct sockaddr_in *)&data_address)->sin_addr, &ad[0], 4);
         memcpy (&((struct sockaddr_in *)&data_address)->sin_port, &ad[4], 2);
 
-        /* Now try to connect to the data port */
+        /* Now try to connect to the data port. */
         if (connect(ctxt->data_file_desc, (struct sockaddr *) &data_address,
             data_address_length) < 0) {
-            motion_log(LOG_ERR, 1, "Failed to create a data connection");
+            MOTION_LOG(ERR, TYPE_NETCAM, SHOW_ERRNO, "%s: Failed to create a data connection");
             close(ctxt->data_file_desc);
             ctxt->data_file_desc = -1;
             return -1;
         }
-
     } else {
         /*
-        * We want to bind to a port to receive the data.  To do this,
-        * we need the address of our host.  One easy way to get it is
-        * to get the info from the control connection that we have
-        * with the remote server
-        */
+         * We want to bind to a port to receive the data.  To do this,
+         * we need the address of our host.  One easy way to get it is
+         * to get the info from the control connection that we have
+         * with the remote server.
+         */
         getsockname(ctxt->control_file_desc, (struct sockaddr *)&data_address,
                     &data_address_length);
         ((struct sockaddr_in *)&data_address)->sin_port = 0;
 
-        /* bind to the socket - should give us a unique port */
+        /* Bind to the socket - should give us a unique port. */
         if (bind(ctxt->data_file_desc, (struct sockaddr *) &data_address,
             data_address_length) < 0) {
-            motion_log(LOG_ERR, 1, "bind failed");
+            MOTION_LOG(ERR, TYPE_NETCAM, SHOW_ERRNO, "%s: bind failed");
             close(ctxt->data_file_desc);
             ctxt->data_file_desc = -1;
             return -1;
         }
 
-        /* we get the port number by reading back in the sockaddr */
+        /* We get the port number by reading back in the sockaddr. */
         getsockname(ctxt->data_file_desc, (struct sockaddr *)&data_address,
                     &data_address_length);
 
-        /* set up a 'listen' on the port to get the server's connection */
+        /* Set up a 'listen' on the port to get the server's connection. */
         if (listen(ctxt->data_file_desc, 1) < 0) {
-            motion_log(LOG_ERR, 1, "listen failed");
+            MOTION_LOG(ERR, TYPE_NETCAM, SHOW_ERRNO, "%s: listen failed");
             close(ctxt->data_file_desc);
             ctxt->data_file_desc = -1;
             return -1;
         }
 
-        /* now generate the PORT command */
+        /* Now generate the PORT command. */
         adp = (unsigned char *) &((struct sockaddr_in *)&data_address)->sin_addr;
         portp = (unsigned char *) &((struct sockaddr_in *)&data_address)->sin_port;
-        snprintf (buf, sizeof(buf), "PORT %d,%d,%d,%d,%d,%d\r\n",
-                  adp[0] & 0xff, adp[1] & 0xff, adp[2] & 0xff, adp[3] & 0xff,
-                  portp[0] & 0xff, portp[1] & 0xff);
+        snprintf(buf, sizeof(buf), "PORT %d,%d,%d,%d,%d,%d\r\n",
+                 adp[0] & 0xff, adp[1] & 0xff, adp[2] & 0xff, adp[3] & 0xff,
+                 portp[0] & 0xff, portp[1] & 0xff);
 
         buf[sizeof(buf) - 1] = 0;
         len = strlen(buf);
 
-        /* send the PORT command to the server */
+        /* Send the PORT command to the server. */
         res = send(ctxt->control_file_desc, buf, len, 0);
 
         if (res < 0) {
-            motion_log(LOG_ERR, 1, "send failed in ftp_get_connection");
+            MOTION_LOG(ERR, TYPE_NETCAM, SHOW_ERRNO, "%s: send failed in ftp_get_connection");
             close(ctxt->data_file_desc);
             ctxt->data_file_desc = -1;
             return res;
@@ -672,16 +652,16 @@ static int ftp_get_connection(ftp_contex
 /**
 * ftp_close_connection
 *
-*      Close the data connection from the server
+*      Close the data connection from the server.
 *
 * Parameters:
 *
-*      ctxt    Pointer to an FTP context
+*      ctxt    Pointer to an FTP context.
 *
 * Returns -1 in case of error, 0 otherwise
 */
-
-static int ftp_close_connection(ftp_context_pointer ctxt) {
+static int ftp_close_connection(ftp_context_pointer ctxt)
+{
     int res;
     fd_set rfd, efd;
     struct timeval tv;
@@ -692,7 +672,7 @@ static int ftp_close_connection(ftp_cont
     close(ctxt->data_file_desc);
     ctxt->data_file_desc = -1;
 
-    /* Check for data on the control channel */
+    /* Check for data on the control channel. */
     tv.tv_sec = 15;
     tv.tv_usec = 0;
     FD_ZERO(&rfd);
@@ -707,13 +687,13 @@ static int ftp_close_connection(ftp_cont
         return -1;
     }
 
-    if (res == 0) {             /* timeout */
+    if (res == 0) {             /* Timeout */
         close(ctxt->control_file_desc);
         ctxt->control_file_desc = -1;
-    } else {                    /* read the response */
+    } else {                    /* Read the response */
         res = ftp_get_response(ctxt);
 
-        if (res != 2) {            /* should be positive completion (2) */
+        if (res != 2) {         /* Should be positive completion (2) */
             close(ctxt->control_file_desc);
             ctxt->control_file_desc = -1;
             return -1;
@@ -734,9 +714,8 @@ static int ftp_close_connection(ftp_cont
 *
 * Returns the socket for the data connection, or <0 in case of error
 */
-
-
-int ftp_get_socket(ftp_context_pointer ctxt) {
+int ftp_get_socket(ftp_context_pointer ctxt)
+{
     char buf[300];
     int res, len;
     int acfd;
@@ -744,28 +723,28 @@ int ftp_get_socket(ftp_context_pointer c
     if ((ctxt == NULL) || (ctxt->path == NULL))
         return -1;
 
-    /* Set up the data connection */
+    /* Set up the data connection. */
     ctxt->data_file_desc = ftp_get_connection(ctxt);
 
     if (ctxt->data_file_desc == -1)
         return -1;
 
-    /* generate a "retrieve" command for the file */
+    /* Generate a "retrieve" command for the file. */
     snprintf(buf, sizeof(buf), "RETR %s\r\n", ctxt->path);
     buf[sizeof(buf) - 1] = 0;
     len = strlen(buf);
 
-    /* send it to the server */
+    /* Send it to the server. */
     res = send(ctxt->control_file_desc, buf, len, 0);
 
     if (res < 0) {
-        motion_log(LOG_ERR, 1, "send failed in ftp_get_socket");
+        MOTION_LOG(ERR, TYPE_NETCAM, SHOW_ERRNO, "%s: send failed in ftp_get_socket");
         close(ctxt->data_file_desc);
         ctxt->data_file_desc = -1;
         return res;
     }
 
-    /* check the answer */
+    /* Check the answer */
     res = ftp_get_response(ctxt);
 
     if (res != 1) {
@@ -775,16 +754,16 @@ int ftp_get_socket(ftp_context_pointer c
     }
 
     /*
-    * if not a passive connection, need to do an accept to get the
-    * connection from the server
-    */
+     * If not a passive connection, need to do an accept to get the
+     * connection from the server.
+     */
     if (!ctxt->passive) {
         struct sockaddr_in data_address;
         unsigned int data_address_length = sizeof(struct sockaddr_in);
 
         if ((acfd = accept(ctxt->data_file_desc, (struct sockaddr *)&data_address,
             &data_address_length)) < 0) {
-            motion_log(LOG_ERR, 1, "accept in ftp_get_socket");
+            MOTION_LOG(ERR, TYPE_NETCAM, SHOW_ERRNO, "%s: accept in ftp_get_socket");
             close(ctxt->data_file_desc);
             ctxt->data_file_desc = -1;
             return -1;
@@ -799,28 +778,29 @@ int ftp_get_socket(ftp_context_pointer c
 /**
 * ftp_send_type
 *
-*     Send a TYPE (either 'I' or 'A') command to the server
+*     Send a TYPE (either 'I' or 'A') command to the server.
 *
 * Parameters
 *
 *      ctxt    pointer to the ftp_context
 *      type    ascii character ('I' or 'A')
 *
-* Returns      0 for success, negative error code for failure
+* Returns      0 for success, negative error code for failure.
 *
 */
-int ftp_send_type(ftp_context_pointer ctxt, char type) {
-    char buf[100], utype;
+int ftp_send_type(ftp_context_pointer ctxt, char type)
+{
+    char buf[100];
     int len, res;
 
-    utype = toupper(type);
-    /* Assure transfer will be in "image" mode */
+    toupper(type);
+    /* Assure transfer will be in "image" mode. */
     snprintf(buf, sizeof(buf), "TYPE I\r\n");
     len = strlen(buf);
     res = send(ctxt->control_file_desc, buf, len, 0);
 
     if (res < 0) {
-        motion_log(LOG_ERR, 1, "send failed in ftp_get_socket");
+        MOTION_LOG(ERR, TYPE_NETCAM, SHOW_ERRNO, "%s: send failed in ftp_get_socket");
         close(ctxt->data_file_desc);
         ctxt->data_file_desc = -1;
         return res;
@@ -852,7 +832,8 @@ int ftp_send_type(ftp_context_pointer ct
 *              0 is an indication of an end of connection.
 *              -1 indicates a parameter error.
 */
-int ftp_read(ftp_context_pointer ctxt, void *dest, int len) {
+int ftp_read(ftp_context_pointer ctxt, void *dest, int len)
+{
     if (ctxt == NULL)
         return -1;
 
@@ -869,7 +850,7 @@ int ftp_read(ftp_context_pointer ctxt, v
 
     if (len <= 0) {
         if (len < 0)
-            motion_log(LOG_ERR, 1, "recv failed in ftp_read");
+            MOTION_LOG(ERR, TYPE_NETCAM, SHOW_ERRNO, "%s: recv failed in ftp_read");
         ftp_close_connection(ctxt);
     }
 
@@ -880,15 +861,16 @@ int ftp_read(ftp_context_pointer ctxt, v
 /**
 * ftp_close
 *
-*      Close the connection and both control and transport
+*      Close the connection and both control and transport.
 *
 * Parameters:
 *
-*      ctxt    Pointer to an FTP context
+*      ctxt    Pointer to an FTP context.
 *
-* Returns -1 in case of error, 0 otherwise
+* Returns -1 in case of error, 0 otherwise.
 */
-int ftp_close(ftp_context_pointer ctxt) {
+int ftp_close(ftp_context_pointer ctxt)
+{
     if (ctxt == NULL)
         return -1;
 
@@ -904,6 +886,5 @@ int ftp_close(ftp_context_pointer ctxt)
     }
 
     ftp_free_context(ctxt);
-
     return 0;
 }
--- motion-3.2.12.orig/netcam_ftp.h
+++ motion-3.2.12/netcam_ftp.h
@@ -1,5 +1,4 @@
-
-/**
+/*
  *      Much of the FTP routines was inspired by the nanoftp.c module from
  *      libxml2 (Copyright Daniel Veillard, 2003).  The routines have been
  *      modified to fit the needs of the Motion project.
@@ -7,7 +6,7 @@
  *      Copyright 2005, William M. Brack
  *      This software is distributed under the GNU Public license Version 2.
  *      See also the file 'COPYING'.
- *      
+ *
  */
 #ifndef _INCLUDE_NETCAM_FTP_H
 #define _INCLUDE_NETCAM_FTP_H
--- motion-3.2.12.orig/netcam_jpeg.c
+++ motion-3.2.12/netcam_jpeg.c
@@ -13,14 +13,13 @@
  */
 
 #include "rotate.h"    /* already includes motion.h */
-
 #include <jpeglib.h>
 #include <jerror.h>
 
 /*
  * netcam_source_mgr is a locally-defined structure to contain elements
  * which are not present in the standard libjpeg (the element 'pub' is a
- * pointer to the standard information)
+ * pointer to the standard information).
  */
 typedef struct {
     struct jpeg_source_mgr pub;
@@ -48,13 +47,11 @@ static void     netcam_error_exit(j_comm
 
 static void netcam_init_source(j_decompress_ptr cinfo)
 {
-    /*
-     * Get our "private" structure from the libjpeg structure
-     */
+    /* Get our "private" structure from the libjpeg structure. */
     netcam_src_ptr  src = (netcam_src_ptr) cinfo->src;
     /*
      * Set the 'start_of_file' flag in our private structure
-     * (used by my_fill_input_buffer)
+     * (used by my_fill_input_buffer).
      */
     src->start_of_file = TRUE;
 }
@@ -84,8 +81,7 @@ static boolean netcam_fill_input_buffer(
         src->buffer = (JOCTET *) src->data;
     } else {
         /* Insert a fake EOI marker - as per jpeglib recommendation */
-        if (debug_level > CAMERA_VERBOSE)
-            motion_log(LOG_INFO, 0, "%s: **fake EOI inserted**", __FUNCTION__);
+        MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: **fake EOI inserted**");
         src->buffer[0] = (JOCTET) 0xFF;
         src->buffer[1] = (JOCTET) JPEG_EOI;    /* 0xD9 */
         nbytes = 2;
@@ -123,23 +119,23 @@ static void netcam_term_source(j_decompr
  *    JPEG library decompression routine.
  *
  * Parameters:
- *    cinfo           pointer to the jpeg decompression object
- *    data            pointer to the image data received from a netcam
- *    length          total size of the image
+ *    cinfo           pointer to the jpeg decompression object.
+ *    data            pointer to the image data received from a netcam.
+ *    length          total size of the image.
  *
  * Returns:             Nothing
- * 
+ *
  */
 static void netcam_memory_src(j_decompress_ptr cinfo, char *data, int length)
 {
     netcam_src_ptr src;
 
-    if (cinfo->src == NULL) {
+    if (cinfo->src == NULL)
         cinfo->src = (struct jpeg_source_mgr *)
                      (*cinfo->mem->alloc_small)
                      ((j_common_ptr) cinfo, JPOOL_PERMANENT,
                       sizeof (netcam_source_mgr));
-    }
+
 
     src = (netcam_src_ptr)cinfo->src;
     src->data = data;
@@ -162,28 +158,27 @@ static void netcam_memory_src(j_decompre
  *
  * Parameters
  *
- *     cinfo           pointer to the decompression control structure
+ *     cinfo           pointer to the decompression control structure.
  *
  * Returns:             does an (ugly) longjmp to get back to netcam_jpeg
- *                      code
+ *                      code.
  *
  */
 static void netcam_error_exit(j_common_ptr cinfo)
 {
-    /* fetch our pre-stored pointer to the netcam context */
+    /* Fetch our pre-stored pointer to the netcam context. */
     netcam_context_ptr netcam = cinfo->client_data;
-    /* output the message associated with the error */
+    /* Output the message associated with the error. */
     (*cinfo->err->output_message)(cinfo);
-    /* set flag to show the decompression had errors */
+    /* Set flag to show the decompression had errors. */
     netcam->jpeg_error |= 1;
-    /* need to "cleanup" the aborted decompression */
+    /* Need to "cleanup" the aborted decompression. */
     jpeg_destroy (cinfo);
 
-    if (debug_level > CAMERA_VERBOSE) 
-        motion_log(LOG_ERR, 0, "%s: netcam->jpeg_error %d", 
-                   __FUNCTION__, netcam->jpeg_error);
-        
-    /* jump back to wherever we started */
+    MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: netcam->jpeg_error %d",
+               netcam->jpeg_error);
+
+    /* Jump back to wherever we started. */
     longjmp(netcam->setjmp_buffer, 1);
 }
 
@@ -196,7 +191,7 @@ static void netcam_error_exit(j_common_p
  *
  * Parameters
  *
- *     cinfo           pointer to the decompression control structure
+ *     cinfo           pointer to the decompression control structure.
  *
  * Returns              Nothing
  *
@@ -204,8 +199,8 @@ static void netcam_error_exit(j_common_p
 static void netcam_output_message(j_common_ptr cinfo)
 {
     char buffer[JMSG_LENGTH_MAX];
-    
-    /* fetch our pre-stored pointer to the netcam context */
+
+    /* Fetch our pre-stored pointer to the netcam context. */
     netcam_context_ptr netcam = cinfo->client_data;
 
     /*
@@ -213,30 +208,23 @@ static void netcam_output_message(j_comm
      * that the jpeg data produced by the camera caused warning
      * messages from libjpeg (JWRN_EXTRANEOUS_DATA).  The following
      * code is to assure that specific warning is ignored.
-     * 
+     *
      * NOTE: It's likely that we will discover other error message
      * codes which we want to ignore.  In that case, we should have
      * some sort of table-lookup to decide which messages we really
      * care about.
      */
-    if ((cinfo->err->msg_code != JWRN_EXTRANEOUS_DATA) && 
-        (cinfo->err->msg_code == JWRN_NOT_SEQUENTIAL) && (!netcam->netcam_tolerant_check))      
+    if ((cinfo->err->msg_code != JWRN_EXTRANEOUS_DATA) &&
+        (cinfo->err->msg_code == JWRN_NOT_SEQUENTIAL) && (!netcam->netcam_tolerant_check))
         netcam->jpeg_error |= 2;    /* Set flag to show problem */
+
     /*
-     * We only display and log errors when debug_level
-     * is non-zero.  The reasoning here is that these kinds
-     * of errors are only produced when the input data is
-     * wrong, and that indicates a network problem rather
-     * than a problem with the content.
+     * Format the message according to library standards.
+     * Write it out to the motion log.
      */
-    if (debug_level > CAMERA_VERBOSE) {
-        /*
-         * Format the message according to library standards.
-         * Write it out to the motion log.
-         */
-        (*cinfo->err->format_message)(cinfo, buffer);
-        motion_log(LOG_ERR, 0, "%s: %s", __FUNCTION__, buffer);
-    }
+     (*cinfo->err->format_message)(cinfo, buffer);
+     MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: %s", buffer);
+
 }
 
 /**
@@ -246,10 +234,10 @@ static void netcam_output_message(j_comm
  *     decompression.
  *
  * Parameters:
- *     netcam          pointer to netcam_context
- *     cinfo           pointer to JPEG decompression context
+ *     netcam          pointer to netcam_context.
+ *     cinfo           pointer to JPEG decompression context.
  *
- * Returns:           Error code
+ * Returns:           Error code.
  */
 static int netcam_init_jpeg(netcam_context_ptr netcam, j_decompress_ptr cinfo)
 {
@@ -263,11 +251,11 @@ static int netcam_init_jpeg(netcam_conte
      */
     pthread_mutex_lock(&netcam->mutex);
 
-    if (netcam->imgcnt_last == netcam->imgcnt) {    /* need to wait */
+    if (netcam->imgcnt_last == netcam->imgcnt) {    /* Need to wait */
         struct timespec waittime;
         struct timeval curtime;
         int retcode;
-    
+
         /*
          * We calculate the delay time (representing the desired frame
          * rate).  This delay time is in *nanoseconds*.
@@ -282,109 +270,121 @@ static int netcam_init_jpeg(netcam_conte
             curtime.tv_usec -= 1000000;
             curtime.tv_sec++;
         }
-        
+
         waittime.tv_sec = curtime.tv_sec;
         waittime.tv_nsec = 1000L * curtime.tv_usec;
-        
+
         do {
             retcode = pthread_cond_timedwait(&netcam->pic_ready,
-                      &netcam->mutex, &waittime);
+                                             &netcam->mutex, &waittime);
         } while (retcode == EINTR);
-        
-        if (retcode) {    /* we assume a non-zero reply is ETIMEOUT */
+
+        if (retcode) {    /* We assume a non-zero reply is ETIMEOUT */
             pthread_mutex_unlock(&netcam->mutex);
-            
-            if (debug_level > CAMERA_WARNINGS)
-                motion_log(-1, 0, "%s: no new pic, no signal rcvd", __FUNCTION__);
-                
+
+            MOTION_LOG(WRN, TYPE_NETCAM, NO_ERRNO,
+                       "%s: no new pic, no signal rcvd");
+
             return NETCAM_GENERAL_ERROR | NETCAM_NOTHING_NEW_ERROR;
         }
-        
-        if (debug_level > CAMERA_VERBOSE)
-            motion_log(-1, 0, "%s: ***new pic delay successful***", __FUNCTION__);
+
+        MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO,
+                   "%s: ***new pic delay successful***");
     }
-    
+
     netcam->imgcnt_last = netcam->imgcnt;
 
-    /* set latest buffer as "current" */
+    /* Set latest buffer as "current". */
     buff = netcam->latest;
     netcam->latest = netcam->jpegbuf;
     netcam->jpegbuf = buff;
     pthread_mutex_unlock(&netcam->mutex);
 
-    /* clear any error flag from previous work */
+    /* Clear any error flag from previous work. */
     netcam->jpeg_error = 0;
-    
+
     buff = netcam->jpegbuf;
-    /* prepare for the decompression */
-    /* Initialize the JPEG decompression object */
+    /*
+     * Prepare for the decompression.
+     * Initialize the JPEG decompression object.
+     */
     jpeg_create_decompress(cinfo);
 
-    /* Set up own error exit routine */
+    /* Set up own error exit routine. */
     cinfo->err = jpeg_std_error(&netcam->jerr);
     cinfo->client_data = netcam;
     netcam->jerr.error_exit = netcam_error_exit;
     netcam->jerr.output_message = netcam_output_message;
 
-    /* Specify the data source as our own routine */
+    /* Specify the data source as our own routine. */
     netcam_memory_src(cinfo, buff->ptr, buff->used);
 
-    /* Read file parameters (rejecting tables-only) */
+    /* Read file parameters (rejecting tables-only). */
     jpeg_read_header(cinfo, TRUE);
 
-    /* Override the desired colour space */
+    /* Override the desired colour space. */
     cinfo->out_color_space = JCS_YCbCr;
 
-    /* Start the decompressor */
+    /* Start the decompressor. */
     jpeg_start_decompress(cinfo);
 
-    if (debug_level > CAMERA_VERBOSE)
-        motion_log(LOG_INFO, 0, "%s: jpeg_error %d", __FUNCTION__, netcam->jpeg_error);
+    MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: jpeg_error %d",
+               netcam->jpeg_error);
 
     return netcam->jpeg_error;
 }
 
+/**
+ * netcam_image_conv
+ *
+ * Parameters:
+ *      netcam          pointer to netcam_context
+ *      cinfo           pointer to JPEG decompression context
+ *      image           pointer to buffer of destination image (yuv420)
+ *
+ * Returns :  netcam->jpeg_error
+ */
 static int netcam_image_conv(netcam_context_ptr netcam,
-                             struct jpeg_decompress_struct *cinfo,
-                             unsigned char *image)
+                               struct jpeg_decompress_struct *cinfo,
+                               unsigned char *image)
 {
-    JSAMPARRAY      line;           /* array of decomp data lines */
-    unsigned char  *wline;          /* will point to line[0] */
-/* Working variables */
+    JSAMPARRAY      line;           /* Array of decomp data lines */
+    unsigned char  *wline;          /* Will point to line[0] */
+    /* Working variables */
     int             linesize, i;
     unsigned char  *upic, *vpic;
     unsigned char  *pic = image;
-    unsigned char   y;              /* switch for decoding YUV data */
+    unsigned char   y;              /* Switch for decoding YUV data */
     unsigned int    width, height;
 
     width = cinfo->output_width;
     height = cinfo->output_height;
 
     if (width && ((width != netcam->width) || (height != netcam->height))) {
-        motion_log(LOG_ERR, 0, 
+        MOTION_LOG(WRN, TYPE_NETCAM, NO_ERRNO,
                    "%s: JPEG image size %dx%d, JPEG was %dx%d",
-                   __FUNCTION__, netcam->width, netcam->height, width, height);
-        jpeg_destroy_decompress (cinfo);
+                    netcam->width, netcam->height, width, height);
+        jpeg_destroy_decompress(cinfo);
         netcam->jpeg_error |= 4;
         return netcam->jpeg_error;
     }
-    /* Set the output pointers (these come from YUV411P definition */
+    /* Set the output pointers (these come from YUV411P definition. */
     upic = pic + width * height;
     vpic = upic + (width * height) / 4;
 
 
-    /* YCbCr format will give us one byte each for YUV */
+    /* YCbCr format will give us one byte each for YUV. */
     linesize = cinfo->output_width * 3;
 
-    /* Allocate space for one line */
+    /* Allocate space for one line. */
     line = (cinfo->mem->alloc_sarray)((j_common_ptr) cinfo, JPOOL_IMAGE,
-            cinfo->output_width * cinfo->output_components, 1);
+                                       cinfo->output_width * cinfo->output_components, 1);
 
     wline = line[0];
     y = 0;
 
     while (cinfo->output_scanline < height) {
-        jpeg_read_scanlines (cinfo, line, 1);
+        jpeg_read_scanlines(cinfo, line, 1);
 
         for (i = 0; i < linesize; i += 3) {
             pic[i / 3] = wline[i];
@@ -393,25 +393,25 @@ static int netcam_image_conv(netcam_cont
                 vpic[(i / 3) / 2] = wline[i + 2];
             }
         }
+
         pic += linesize / 3;
+
         if (y++ & 1) {
             upic += width / 2;
             vpic += width / 2;
         }
     }
 
-    jpeg_finish_decompress (cinfo);
-    jpeg_destroy_decompress (cinfo);
+    jpeg_finish_decompress(cinfo);
+    jpeg_destroy_decompress(cinfo);
 
-    /* rotate as specified */
-    if (netcam->cnt->rotate_data.degrees > 0) 
+    if (netcam->cnt->rotate_data.degrees > 0)
+        /* Rotate as specified */
         rotate_map(netcam->cnt, image);
-    
 
-    if (debug_level > CAMERA_VERBOSE)
-        motion_log(LOG_INFO, 0, "%s: jpeg_error %d", 
-                   __FUNCTION__, netcam->jpeg_error);
- 
+    MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: jpeg_error %d",
+               netcam->jpeg_error);
+
     return netcam->jpeg_error;
 }
 
@@ -422,10 +422,10 @@ static int netcam_image_conv(netcam_cont
  *    suitable for processing by motion.
  *
  * Parameters:
- *    netcam    pointer to the netcam_context structure
- *      image     Pointer to a buffer for the returned image
+ *    netcam    pointer to the netcam_context structure.
+ *     image    pointer to a buffer for the returned image.
  *
- * Returns: 
+ * Returns:
  *
  *      0         Success
  *      non-zero  error code from other routines
@@ -434,55 +434,52 @@ static int netcam_image_conv(netcam_cont
  */
 int netcam_proc_jpeg(netcam_context_ptr netcam, unsigned char *image)
 {
-    struct jpeg_decompress_struct cinfo;    /* decompression control struct */
-    int retval = 0;                         /* value returned to caller */
-    int ret;                                /* working var */
+    struct jpeg_decompress_struct cinfo;    /* Decompression control struct. */
+    int retval = 0;                         /* Value returned to caller. */
+    int ret;                                /* Working var. */
 
     /*
      * This routine is only called from the main thread.
      * We need to "protect" the "latest" image while we
      * decompress it.  netcam_init_jpeg uses
-     * netcam->mutex to do this;
+     * netcam->mutex to do this.
      */
-    if (debug_level > CAMERA_INFO) 
-        motion_log(LOG_INFO, 0, "%s: processing jpeg image - content length "
-                   "%d", __FUNCTION__, netcam->latest->content_length);
-        
+    MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: processing jpeg image"
+               " - content length %d", netcam->latest->content_length);
+
     ret = netcam_init_jpeg(netcam, &cinfo);
-    
+
     if (ret != 0) {
-        if (debug_level > CAMERA_INFO)
-            motion_log(LOG_ERR, 0, "%s: ret %d", __FUNCTION__, ret);
+        MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: ret %d", ret);
         return ret;
-    }    
+    }
 
-    /* Do a sanity check on dimensions
+    /*
+     * Do a sanity check on dimensions
      * If dimensions have changed we throw an
      * error message that will cause
-     * restart of Motion
+     * restart of Motion.
      */
     if (netcam->width) {    /* 0 means not yet init'ed */
         if ((cinfo.output_width != netcam->width) ||
             (cinfo.output_height != netcam->height)) {
             retval = NETCAM_RESTART_ERROR;
-            motion_log(LOG_ERR, 0,
-                       "%s: Camera width/height mismatch "
+            MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Camera width/height mismatch "
                        "with JPEG image - expected %dx%d, JPEG %dx%d",
-                       " retval %d", __FUNCTION__, netcam->width, netcam->height,
+                       " retval %d", netcam->width, netcam->height,
                        cinfo.output_width, cinfo.output_height, retval);
-            return retval;        
+            return retval;
         }
     }
 
-    /* do the conversion */
+    /* Do the conversion */
     ret = netcam_image_conv(netcam, &cinfo, image);
-    
+
     if (ret != 0) {
         retval |= NETCAM_JPEG_CONV_ERROR;
-        if (debug_level > CAMERA_INFO) 
-            motion_log(LOG_ERR, 0, "%s: ret %d retval %d", __FUNCTION__, 
-                       ret, retval);
-    }    
+        MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: ret %d retval %d",
+                   ret, retval);
+    }
 
     return retval;
 }
@@ -491,18 +488,18 @@ int netcam_proc_jpeg(netcam_context_ptr
  * netcam_get_dimensions
  *
  *    This function gets the height and width of the JPEG image
- *    located in the supplied netcam_image_buffer
+ *    located in the supplied netcam_image_buffer.
  *
  * Parameters
  *
- *    netcam     pointer to the netcam context
+ *    netcam     pointer to the netcam context.
  *
- * Returns:   Nothing, but fills in width and height into context
+ * Returns:   Nothing, but fills in width and height into context.
  *
  */
 void netcam_get_dimensions(netcam_context_ptr netcam)
 {
-    struct jpeg_decompress_struct cinfo; /* decompression control struct */
+    struct jpeg_decompress_struct cinfo; /* Decompression control struct. */
     int ret;
 
     ret = netcam_init_jpeg(netcam, &cinfo);
@@ -513,7 +510,6 @@ void netcam_get_dimensions(netcam_contex
 
     jpeg_destroy_decompress(&cinfo);
 
-    if (debug_level > CAMERA_INFO) 
-        motion_log(LOG_ERR, 0, "%s: JFIF_marker %s PRESENT ret %d", 
-                   __FUNCTION__, netcam->JFIF_marker ? "IS" : "NOT", ret);
+    MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: JFIF_marker %s PRESENT ret %d",
+               netcam->JFIF_marker ? "IS" : "NOT", ret);
 }
--- /dev/null
+++ motion-3.2.12/netcam_rtsp.c
@@ -0,0 +1,926 @@
+/***********************************************************
+ *  In the top section are the functions that are used
+ *  when processing the RTSP camera feed.  Since these functions
+ *  are internal to the RTSP module, and many require FFmpeg
+ *  structures in their declarations, they are within the
+ *  HAVE_FFMPEG block that eliminates them entirely when
+ *  FFmpeg is not present.
+ *
+ *  The functions:
+ *      netcam_setup_rtsp
+ *      netcam_connect_rtsp
+ *      netcam_shutdown_rtsp
+ *      netcam_next_rtsp
+ *  are called from netcam.c therefore must be defined even
+ *  if FFmpeg is not present.  They must also not have FFmpeg
+ *  structures in the declarations.  Simple error
+ *  messages are raised if called when no FFmpeg is found.
+ *
+ ***********************************************************/
+
+#include <stdio.h>
+#include "netcam_rtsp.h"
+#include "rotate.h"    /* already includes motion.h */
+
+#ifdef HAVE_FFMPEG
+
+#include "ffmpeg.h"
+
+/**
+ * netcam_check_pixfmt
+ *
+ * Determine whether pix_format is YUV420P
+ */
+int netcam_check_pixfmt(netcam_context_ptr netcam){
+    int retcd;
+
+    retcd = -1;
+
+    if ((netcam->rtsp->codec_context->pix_fmt == PIX_FMT_YUV420P) ||
+        (netcam->rtsp->codec_context->pix_fmt == PIX_FMT_YUVJ420P)) retcd = 0;
+
+    return retcd;
+
+}
+/**
+ * netcam_rtsp_null_context
+ *
+ * Null all the context
+ */
+void netcam_rtsp_null_context(netcam_context_ptr netcam){
+
+    netcam->rtsp->swsctx         = NULL;
+    netcam->rtsp->swsframe_in    = NULL;
+    netcam->rtsp->swsframe_out   = NULL;
+    netcam->rtsp->frame        = NULL;
+    netcam->rtsp->codec_context     = NULL;
+    netcam->rtsp->format_context    = NULL;
+
+}
+/**
+ * netcam_rtsp_close_context
+ *
+ * Close all the context that could be open
+ */
+void netcam_rtsp_close_context(netcam_context_ptr netcam){
+
+    if (netcam->rtsp->swsctx       != NULL) sws_freeContext(netcam->rtsp->swsctx);
+    if (netcam->rtsp->swsframe_in  != NULL) my_frame_free(netcam->rtsp->swsframe_in);
+    if (netcam->rtsp->swsframe_out != NULL) my_frame_free(netcam->rtsp->swsframe_out);
+    if (netcam->rtsp->frame        != NULL) my_frame_free(netcam->rtsp->frame);
+    if (netcam->rtsp->codec_context    != NULL) avcodec_close(netcam->rtsp->codec_context);
+    if (netcam->rtsp->format_context   != NULL) avformat_close_input(&netcam->rtsp->format_context);
+
+    netcam_rtsp_null_context(netcam);
+}
+
+/**
+ * netcam_buffsize_rtsp
+ *
+ * This routine checks whether there is enough room in a buffer to copy
+ * some additional data.  If there is not enough room, it will re-allocate
+ * the buffer and adjust it's size.
+ *
+ * Parameters:
+ *      buff            Pointer to a netcam_image_buffer structure.
+ *      numbytes        The number of bytes to be copied.
+ *
+ * Returns:             Nothing
+ */
+static void netcam_buffsize_rtsp(netcam_buff_ptr buff, size_t numbytes){
+
+    int min_size_to_alloc;
+    int real_alloc;
+    int new_size;
+
+    if ((buff->size - buff->used) >= numbytes)
+        return;
+
+    min_size_to_alloc = numbytes - (buff->size - buff->used);
+    real_alloc = ((min_size_to_alloc / NETCAM_BUFFSIZE) * NETCAM_BUFFSIZE);
+
+    if ((min_size_to_alloc - real_alloc) > 0)
+        real_alloc += NETCAM_BUFFSIZE;
+
+    new_size = buff->size + real_alloc;
+
+    MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: expanding buffer from [%d/%d] to [%d/%d] bytes.",
+               (int) buff->used, (int) buff->size,
+               (int) buff->used, new_size);
+
+    buff->ptr = myrealloc(buff->ptr, new_size,
+                          "netcam_check_buf_size");
+    buff->size = new_size;
+}
+
+/**
+ * decode_packet
+ *
+ * This routine takes in the packet from the read and decodes it into
+ * the frame.  It then takes the frame and copies it into the netcam
+ * buffer
+ *
+ * Parameters:
+ *      packet    The packet that was read from av_read
+ *      buffer    The buffer that is the final destination
+ *      frame     The frame into which we decode the packet
+ *
+ *
+ * Returns:
+ *      Failure    0(zero)
+ *      Success    The size of the frame decoded
+ */
+static int decode_packet(AVPacket *packet, netcam_buff_ptr buffer, AVFrame *frame, AVCodecContext *cc){
+    int check = 0;
+    int frame_size = 0;
+    int ret = 0;
+
+    ret = avcodec_decode_video2(cc, frame, &check, packet);
+    if (ret < 0) {
+        MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Error decoding video packet");
+        return 0;
+    }
+
+    if (check == 0) {
+        return 0;
+    }
+
+    frame_size = avpicture_get_size(cc->pix_fmt, cc->width, cc->height);
+
+    netcam_buffsize_rtsp(buffer, frame_size);
+
+    avpicture_layout((const AVPicture*)frame,cc->pix_fmt,cc->width,cc->height
+                    ,(unsigned char *)buffer->ptr,frame_size );
+
+    buffer->used = frame_size;
+
+    return frame_size;
+}
+
+/**
+ * netcam_open_codec
+ *
+ * This routine opens the codec context for the indicated stream
+ *
+ * Parameters:
+ *      stream_idx  The index of the stream that was found as "best"
+ *      fmt_ctx     The format context that was created upon opening the stream
+ *      type        The type of media type (This is a constant)
+ *
+ *
+ * Returns:
+ *      Failure    Error code from FFmpeg (Negative number)
+ *      Success    0(Zero)
+ */
+static int netcam_open_codec(int *stream_idx, AVFormatContext *fmt_ctx, enum AVMediaType type){
+    int ret;
+    char errstr[128];
+    AVStream *st;
+    AVCodecContext *dec_ctx = NULL;
+    AVCodec *dec = NULL;
+
+    ret = av_find_best_stream(fmt_ctx, type, -1, -1, NULL, 0);
+    if (ret < 0) {
+        av_strerror(ret, errstr, sizeof(errstr));
+		MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Could not find stream in input!: %s",errstr);
+        return ret;
+    }
+
+    *stream_idx = ret;
+    st = fmt_ctx->streams[*stream_idx];
+
+    /* find decoder for the stream */
+    dec_ctx = st->codec;
+    dec = avcodec_find_decoder(dec_ctx->codec_id);
+    if (dec == NULL) {
+        MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Failed to find codec!");
+        return -1;
+    }
+
+    /* Open the codec  */
+    ret = avcodec_open2(dec_ctx, dec, NULL);
+    if (ret < 0) {
+        av_strerror(ret, errstr, sizeof(errstr));
+    	MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Failed to open codec!: %s", errstr);
+        return ret;
+    }
+
+    return 0;
+}
+
+/**
+* rtsp_new_context
+*
+*      Create a new RTSP context structure.
+*
+* Parameters
+*
+*       None
+*
+* Returns:     Pointer to the newly-created structure, NULL if error.
+*
+*/
+struct rtsp_context *rtsp_new_context(void){
+    struct rtsp_context *ret;
+
+    /* Note that mymalloc will exit on any problem. */
+    ret = mymalloc(sizeof(struct rtsp_context));
+
+    memset(ret, 0, sizeof(struct rtsp_context));
+
+    return ret;
+}
+/**
+* netcam_interrupt_rtsp
+*
+*    This function is called during the FFmpeg blocking functions.
+*    These include the opening of the format context as well as the
+*    reading of the packets from the stream.  Since this is called
+*    during all blocking functions, the process uses the readingframe
+*    flag to determine whether to timeout the process.
+*
+* Parameters
+*
+*       ctx   We pass in the rtsp context to use it to look for the
+*             readingframe flag as well as the time that we started
+*             the read attempt.
+*
+* Returns:
+*       Failure    -1(which triggers an interupt)
+*       Success     0(zero which indicates to let process continue)
+*
+*/
+static int netcam_interrupt_rtsp(void *ctx){
+    struct rtsp_context *rtsp = (struct rtsp_context *)ctx;
+
+    if (rtsp->readingframe != 1) {
+        return 0;
+    } else {
+        struct timeval interrupttime;
+        if (gettimeofday(&interrupttime, NULL) < 0) {
+            MOTION_LOG(WRN, TYPE_NETCAM, SHOW_ERRNO, "%s: get interrupt time failed");
+        }
+        if ((interrupttime.tv_sec - rtsp->startreadtime.tv_sec ) > 10){
+            MOTION_LOG(WRN, TYPE_NETCAM, NO_ERRNO, "%s: Reading picture timed out for %s",rtsp->path);
+            return 1;
+        } else{
+            return 0;
+        }
+    }
+
+    //should not be possible to get here
+    return 0;
+}
+/**
+* netcam_read_rtsp_image
+*
+*    This function reads the packet from the camera.
+*    It is called extensively so only absolutely essential
+*    functions and allocations are performed.
+*
+* Parameters
+*
+*       netcam  The netcam context to read from
+*
+* Returns:
+*       Failure    -1
+*       Success     0(zero)
+*
+*/
+int netcam_read_rtsp_image(netcam_context_ptr netcam){
+    struct timeval    curtime;
+    netcam_buff_ptr    buffer;
+    AVPacket           packet;
+    int                size_decoded;
+
+    /* Point to our working buffer. */
+    buffer = netcam->receiving;
+    buffer->used = 0;
+
+    av_init_packet(&packet);
+    packet.data = NULL;
+    packet.size = 0;
+
+    size_decoded = 0;
+
+    if (gettimeofday(&curtime, NULL) < 0) {
+        MOTION_LOG(ERR, TYPE_NETCAM, SHOW_ERRNO, "%s: gettimeofday");
+    }
+    netcam->rtsp->startreadtime = curtime;
+
+    netcam->rtsp->readingframe = 1;
+    while (size_decoded == 0 && av_read_frame(netcam->rtsp->format_context, &packet) >= 0) {
+        if(packet.stream_index != netcam->rtsp->video_stream_index) {
+            av_free_packet(&packet);
+            av_init_packet(&packet);
+            packet.data = NULL;
+            packet.size = 0;
+            // not our packet, skip
+           continue;
+        }
+        size_decoded = decode_packet(&packet, buffer, netcam->rtsp->frame, netcam->rtsp->codec_context);
+
+        av_free_packet(&packet);
+        av_init_packet(&packet);
+        packet.data = NULL;
+        packet.size = 0;
+    }
+    netcam->rtsp->readingframe = 0;
+
+    // at this point, we are finished with the packet
+    av_free_packet(&packet);
+
+    if (size_decoded == 0) {
+        // something went wrong, end of stream? Interupted?
+        netcam_rtsp_close_context(netcam);
+        return -1;
+    }
+
+    /*
+     * read is complete - set the current 'receiving' buffer atomically
+     * as 'latest', and make the buffer previously in 'latest' become
+     * the new 'receiving' and signal pic_ready.
+     */
+    netcam->receiving->image_time = curtime;
+    netcam->last_image = curtime;
+    netcam_buff *xchg;
+
+    pthread_mutex_lock(&netcam->mutex);
+        xchg = netcam->latest;
+        netcam->latest = netcam->receiving;
+        netcam->receiving = xchg;
+        netcam->imgcnt++;
+        pthread_cond_signal(&netcam->pic_ready);
+    pthread_mutex_unlock(&netcam->mutex);
+
+    return 0;
+}
+/**
+* netcam_rtsp_resize_ntc
+*
+*    This function notifies the user of the need to transcode
+*    the netcam image which uses a lot of CPU resources
+*
+* Parameters
+*
+*       netcam  The netcam context to read from
+*
+* Returns:
+*       Failure    -1
+*       Success     0(zero)
+*
+*/
+int netcam_rtsp_resize_ntc(netcam_context_ptr netcam){
+
+    if ((netcam->width  != netcam->rtsp->codec_context->width) ||
+        (netcam->height != netcam->rtsp->codec_context->height) ||
+        (netcam_check_pixfmt(netcam) != 0) ){
+        MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: ");
+        MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: ****************************************************************");
+        MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: The network camera is sending pictures in a different");
+        if ((netcam->width  != netcam->rtsp->codec_context->width) ||
+            (netcam->height != netcam->rtsp->codec_context->height)) {
+            if (netcam_check_pixfmt(netcam) != 0) {
+                MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: size than specified in the config and also a ");
+                MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: different picture format.  The picture is being");
+                MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: transcoded to YUV420P and into the size requested");
+                MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: in the config file.  If possible change netcam to");
+                MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: be in YUV420P format and the size requested in the");
+                MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: config to possibly lower CPU usage.");
+            } else {
+                MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: size than specified in the configuration file.");
+                MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: The picture is being transcoded into the size ");
+                MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: requested in the configuration.  If possible change");
+                MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: netcam or configuration to indicate the same size");
+                MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: to possibly lower CPU usage.");
+            }
+            MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: Netcam: %d x %d => Config: %d x %d"
+            ,netcam->rtsp->codec_context->width,netcam->rtsp->codec_context->height
+            ,netcam->width,netcam->height);
+        } else {
+            MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: format than YUV420P.  The image sent is being ");
+            MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: trancoded to YUV420P.  If possible change netcam ");
+            MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: picture format to YUV420P to possibly lower CPU usage.");
+        }
+        MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: ****************************************************************");
+        MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: ");
+    }
+
+    return 0;
+
+}
+/**
+* netcam_rtsp_open_context
+*
+*    This function opens the format context for the camera.
+*
+* Parameters
+*
+*       netcam  The netcam context to read from
+*
+* Returns:
+*       Failure    -1
+*       Success     0(zero)
+*
+*/
+int netcam_rtsp_open_context(netcam_context_ptr netcam){
+
+    int  retcd;
+    char errstr[128];
+
+    if (netcam->rtsp->path == NULL) {
+        if (netcam->rtsp->status == RTSP_NOTCONNECTED){
+            MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Null path passed to connect (%s)", netcam->rtsp->path);
+        }
+        return -1;
+    }
+
+    // open the network connection
+    AVDictionary *opts = 0;
+    netcam->rtsp->format_context = avformat_alloc_context();
+    netcam->rtsp->format_context->interrupt_callback.callback = netcam_interrupt_rtsp;
+    netcam->rtsp->format_context->interrupt_callback.opaque = netcam->rtsp;
+
+    if (strncmp(netcam->rtsp->path, "http", 4) == 0 ){
+        netcam->rtsp->format_context->iformat = av_find_input_format("mjpeg");
+    } else {
+        if (netcam->cnt->conf.rtsp_uses_tcp) {
+            av_dict_set(&opts, "rtsp_transport", "tcp", 0);
+            if (netcam->rtsp->status == RTSP_NOTCONNECTED)
+                MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: Using tcp transport");
+        } else {
+            av_dict_set(&opts, "rtsp_transport", "udp", 0);
+            av_dict_set(&opts, "max_delay", "500000", 0);  //100000 is the default
+            if (netcam->rtsp->status == RTSP_NOTCONNECTED)
+                MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: Using udp transport");
+        }
+    }
+
+    retcd = avformat_open_input(&netcam->rtsp->format_context, netcam->rtsp->path, NULL, &opts);
+    if (retcd < 0) {
+        if (netcam->rtsp->status == RTSP_NOTCONNECTED){
+            av_strerror(retcd, errstr, sizeof(errstr));
+            MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: unable to open input(%s): %s", netcam->rtsp->path,errstr);
+        }
+        av_dict_free(&opts);
+        //The format context gets freed upon any error from open_input.
+        return retcd;
+    }
+    av_dict_free(&opts);
+
+    // fill out stream information
+    retcd = avformat_find_stream_info(netcam->rtsp->format_context, NULL);
+    if (retcd < 0) {
+        if (netcam->rtsp->status == RTSP_NOTCONNECTED){
+            av_strerror(retcd, errstr, sizeof(errstr));
+            MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: unable to find stream info: %s", errstr);
+        }
+        netcam_rtsp_close_context(netcam);
+        return -1;
+    }
+
+    retcd = netcam_open_codec(&netcam->rtsp->video_stream_index, netcam->rtsp->format_context, AVMEDIA_TYPE_VIDEO);
+    if (retcd < 0) {
+        if (netcam->rtsp->status == RTSP_NOTCONNECTED){
+            av_strerror(retcd, errstr, sizeof(errstr));
+            MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: unable to open codec context: %s", errstr);
+        }
+        netcam_rtsp_close_context(netcam);
+        return -1;
+    }
+
+    netcam->rtsp->codec_context = netcam->rtsp->format_context->streams[netcam->rtsp->video_stream_index]->codec;
+
+    netcam->rtsp->frame = my_frame_alloc();
+    if (netcam->rtsp->frame == NULL) {
+        if (netcam->rtsp->status == RTSP_NOTCONNECTED){
+            MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: unable to allocate frame.  Fatal error.  Check FFmpeg/Libav configuration");
+        }
+        netcam_rtsp_close_context(netcam);
+        return -1;
+    }
+
+    /*
+     *  Validate that the previous steps opened the camera
+     */
+    retcd = netcam_read_rtsp_image(netcam);
+    if (retcd < 0) {
+        if (netcam->rtsp->status == RTSP_NOTCONNECTED){
+            MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Failed to read first image");
+        }
+        netcam_rtsp_close_context(netcam);
+        return -1;
+    }
+
+    return 0;
+
+}
+/**
+* netcam_rtsp_open_sws
+*
+*    This function opens the rescaling context components.
+*
+* Parameters
+*
+*       netcam  The netcam context to read from
+*
+* Returns:
+*       Failure    -1
+*       Success     0(zero)
+*
+*/
+int netcam_rtsp_open_sws(netcam_context_ptr netcam){
+
+    netcam->width  = ((netcam->cnt->conf.width / 8) * 8);
+    netcam->height = ((netcam->cnt->conf.height / 8) * 8);
+
+
+    netcam->rtsp->swsframe_in = my_frame_alloc();
+    if (netcam->rtsp->swsframe_in == NULL) {
+        if (netcam->rtsp->status == RTSP_NOTCONNECTED){
+            MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: unable to allocate frame.  Fatal error.  Check FFmpeg/Libav configuration");
+        }
+        netcam_rtsp_close_context(netcam);
+        return -1;
+    }
+
+    netcam->rtsp->swsframe_out = my_frame_alloc();
+    if (netcam->rtsp->swsframe_out == NULL) {
+        if (netcam->rtsp->status == RTSP_NOTCONNECTED){
+            MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: unable to allocate frame.  Fatal error.  Check FFmpeg/Libav configuration");
+        }
+        netcam_rtsp_close_context(netcam);
+        return -1;
+    }
+
+    /*
+     *  The scaling context is used to change dimensions to config file and
+     *  also if the format sent by the camera is not YUV420.
+     */
+    netcam->rtsp->swsctx = sws_getContext(
+         netcam->rtsp->codec_context->width
+        ,netcam->rtsp->codec_context->height
+        ,netcam->rtsp->codec_context->pix_fmt
+        ,netcam->width
+        ,netcam->height
+        ,PIX_FMT_YUV420P
+        ,SWS_BICUBIC,NULL,NULL,NULL);
+    if (netcam->rtsp->swsctx == NULL) {
+        if (netcam->rtsp->status == RTSP_NOTCONNECTED){
+            MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: unable to allocate scaling context.  Fatal error.  Check FFmpeg/Libav configuration");
+        }
+        netcam_rtsp_close_context(netcam);
+        return -1;
+    }
+
+    netcam->rtsp->swsframe_size = avpicture_get_size(
+            PIX_FMT_YUV420P
+            ,netcam->width
+            ,netcam->height);
+        if (netcam->rtsp->swsframe_size <= 0) {
+            if (netcam->rtsp->status == RTSP_NOTCONNECTED){
+                MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Error determining size of frame out");
+            }
+            netcam_rtsp_close_context(netcam);
+            return -1;
+        }
+
+    return 0;
+
+}
+/**
+* netcam_rtsp_resize
+*
+*    This function reencodes the image to yuv420p with the desired size
+*
+* Parameters
+*
+*       netcam  The netcam context to read from
+*       image   The destination image.
+*
+* Returns:
+*       Failure    -1
+*       Success     0(zero)
+*
+*/
+int netcam_rtsp_resize(unsigned char *image , netcam_context_ptr netcam){
+
+    int      retcd;
+    char     errstr[128];
+    uint8_t *buffer_out;
+
+    retcd = avpicture_fill(
+        (AVPicture*)netcam->rtsp->swsframe_in
+        ,(uint8_t*)netcam->latest->ptr
+        ,netcam->rtsp->codec_context->pix_fmt
+        ,netcam->rtsp->codec_context->width
+        ,netcam->rtsp->codec_context->height);
+    if (retcd < 0) {
+        if (netcam->rtsp->status == RTSP_NOTCONNECTED){
+            av_strerror(retcd, errstr, sizeof(errstr));
+            MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Error allocating picture in: %s", errstr);
+        }
+        netcam_rtsp_close_context(netcam);
+        return -1;
+    }
+
+
+    buffer_out=(uint8_t *)av_malloc(netcam->rtsp->swsframe_size*sizeof(uint8_t));
+
+    retcd = avpicture_fill(
+        (AVPicture*)netcam->rtsp->swsframe_out
+        ,buffer_out
+        ,PIX_FMT_YUV420P
+        ,netcam->width
+        ,netcam->height);
+    if (retcd < 0) {
+        if (netcam->rtsp->status == RTSP_NOTCONNECTED){
+            av_strerror(retcd, errstr, sizeof(errstr));
+            MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Error allocating picture out: %s", errstr);
+        }
+        netcam_rtsp_close_context(netcam);
+        return -1;
+    }
+
+    retcd = sws_scale(
+        netcam->rtsp->swsctx
+        ,(const uint8_t* const *)netcam->rtsp->swsframe_in->data
+        ,netcam->rtsp->swsframe_in->linesize
+        ,0
+        ,netcam->rtsp->codec_context->height
+        ,netcam->rtsp->swsframe_out->data
+        ,netcam->rtsp->swsframe_out->linesize);
+    if (retcd < 0) {
+        if (netcam->rtsp->status == RTSP_NOTCONNECTED){
+            av_strerror(retcd, errstr, sizeof(errstr));
+            MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Error resizing/reformatting: %s", errstr);
+        }
+        netcam_rtsp_close_context(netcam);
+        return -1;
+    }
+
+    retcd = avpicture_layout(
+        (const AVPicture*)netcam->rtsp->swsframe_out
+        ,PIX_FMT_YUV420P
+        ,netcam->width
+        ,netcam->height
+        ,(unsigned char *)image
+        ,netcam->rtsp->swsframe_size );
+    if (retcd < 0) {
+        if (netcam->rtsp->status == RTSP_NOTCONNECTED){
+            av_strerror(retcd, errstr, sizeof(errstr));
+            MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Error putting frame into output buffer: %s", errstr);
+        }
+        netcam_rtsp_close_context(netcam);
+        return -1;
+    }
+
+    av_free(buffer_out);
+
+    return 0;
+
+}
+/*********************************************************
+ *  This ends the section of functions that rely upon FFmpeg
+ ***********************************************************/
+#endif /* End HAVE_FFMPEG */
+
+/**
+* netcam_connect_rtsp
+*
+*    This function initiates the connection to the rtsp camera.
+*
+* Parameters
+*
+*       netcam  The netcam context to open.
+*
+* Returns:
+*       Failure    -1
+*       Success     0(zero)
+*
+*/
+int netcam_connect_rtsp(netcam_context_ptr netcam){
+#ifdef HAVE_FFMPEG
+
+    if (netcam_rtsp_open_context(netcam) < 0) return -1;
+
+    if (netcam_rtsp_open_sws(netcam) < 0) return -1;
+
+    if (netcam_rtsp_resize_ntc(netcam) < 0 ) return -1;
+
+    if (netcam_read_rtsp_image(netcam) < 0) return -1;
+
+    netcam->rtsp->status = RTSP_CONNECTED;
+
+    MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: Camera connected");
+
+    return 0;
+
+#else  /* No FFmpeg/Libav */
+    netcam->rtsp->status = RTSP_NOTCONNECTED;
+    netcam->rtsp->format_context = NULL;
+    MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: FFmpeg/Libav not found on computer.  No RTSP support");
+    return -1;
+#endif /* End #ifdef HAVE_FFMPEG */
+}
+
+/**
+* netcam_shutdown_rtsp
+*
+*    This function closes and frees all the items for rtsp
+*
+* Parameters
+*
+*       netcam  The netcam context to free.
+*
+* Returns:
+*       Failure    nothing
+*       Success    nothing
+*
+*/
+void netcam_shutdown_rtsp(netcam_context_ptr netcam){
+#ifdef HAVE_FFMPEG
+
+    if (netcam->rtsp->status == RTSP_CONNECTED) {
+        netcam_rtsp_close_context(netcam);
+        MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO,"%s: netcam shut down");
+    }
+
+    if (netcam->rtsp->path != NULL) free(netcam->rtsp->path);
+    if (netcam->rtsp->user != NULL) free(netcam->rtsp->user);
+    if (netcam->rtsp->pass != NULL) free(netcam->rtsp->pass);
+
+    free(netcam->rtsp);
+    netcam->rtsp = NULL;
+
+#else  /* No FFmpeg/Libav */
+        MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: FFmpeg/Libav not found on computer.  No RTSP support");
+#endif /* End #ifdef HAVE_FFMPEG */
+}
+
+/**
+* netcam_setup_rtsp
+*
+*    This function sets up all the necessary items for the
+*    rtsp camera.
+*
+* Parameters
+*
+*       netcam  The netcam context to free.
+*       url     The URL of the camera
+*
+* Returns:
+*       Failure    -1
+*       Success    0(zero)
+*
+*/
+int netcam_setup_rtsp(netcam_context_ptr netcam, struct url_t *url){
+#ifdef HAVE_FFMPEG
+
+  struct context *cnt = netcam->cnt;
+  const char *ptr;
+  int ret = -1;
+
+  netcam->caps.streaming = NCS_RTSP;
+
+  netcam->rtsp = rtsp_new_context();
+
+  netcam_rtsp_null_context(netcam);
+
+  if (netcam->rtsp == NULL) {
+    MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: unable to create rtsp context");
+    netcam_shutdown_rtsp(netcam);
+    return -1;
+  }
+
+  /*
+   * Allocate space for a working string to contain the path.
+   * The extra 5 is for "://", ":" and string terminator.
+   */
+
+  // force port to a sane value
+  if (netcam->connect_port > 65536) {
+    netcam->connect_port = 65536;
+  } else if (netcam->connect_port < 0) {
+    netcam->connect_port = 0;
+  }
+
+    if (cnt->conf.netcam_userpass != NULL) {
+        ptr = cnt->conf.netcam_userpass;
+    } else {
+        ptr = url->userpass;  /* Don't set this one NULL, gets freed. */
+    }
+
+    if (ptr != NULL) {
+        char *cptr;
+        if ((cptr = strchr(ptr, ':')) == NULL) {
+            netcam->rtsp->user = mystrdup(ptr);
+        } else {
+            netcam->rtsp->user = mymalloc((cptr - ptr)+2);  //+2 for string terminator
+            memcpy(netcam->rtsp->user, ptr,(cptr - ptr));
+            netcam->rtsp->pass = mystrdup(cptr + 1);
+        }
+    }
+
+    /*
+     *  Need a method to query the path and
+     *  determine the authentication type
+     */
+    if ((netcam->rtsp->user != NULL) && (netcam->rtsp->pass != NULL)) {
+        ptr = mymalloc(strlen(url->service) + strlen(netcam->connect_host)
+	          + 5 + strlen(url->path) + 5
+              + strlen(netcam->rtsp->user) + strlen(netcam->rtsp->pass) + 4 );
+        sprintf((char *)ptr, "%s://%s:%s@%s:%d%s",
+                url->service,netcam->rtsp->user,netcam->rtsp->pass,
+                netcam->connect_host, netcam->connect_port, url->path);
+    }
+    else {
+        ptr = mymalloc(strlen(url->service) + strlen(netcam->connect_host)
+	          + 5 + strlen(url->path) + 5);
+        sprintf((char *)ptr, "%s://%s:%d%s", url->service,
+	        netcam->connect_host, netcam->connect_port, url->path);
+    }
+    netcam->rtsp->path = (char *)ptr;
+
+    netcam_url_free(url);
+
+    /*
+     * Now we need to set some flags
+     */
+    netcam->rtsp->readingframe = 0;
+    netcam->rtsp->status = RTSP_NOTCONNECTED;
+
+    /*
+     * Warn and fix dimensions as needed.
+     */
+    if (netcam->cnt->conf.width % 16) {
+        MOTION_LOG(CRT, TYPE_NETCAM, NO_ERRNO, "%s: Image width (%d) requested is not modulo 16.", netcam->cnt->conf.width);
+        netcam->cnt->conf.width = netcam->cnt->conf.width - (netcam->cnt->conf.width % 16) + 16;
+        MOTION_LOG(CRT, TYPE_NETCAM, NO_ERRNO, "%s: Adjusting width to next higher multiple of 16 (%d).", netcam->cnt->conf.width);
+    }
+    if (netcam->cnt->conf.height % 16) {
+        MOTION_LOG(CRT, TYPE_NETCAM, NO_ERRNO, "%s: Image height (%d) requested is not modulo 16.", netcam->cnt->conf.height);
+        netcam->cnt->conf.height = netcam->cnt->conf.height - (netcam->cnt->conf.height % 16) + 16;
+        MOTION_LOG(CRT, TYPE_NETCAM, NO_ERRNO, "%s: Adjusting height to next higher multiple of 16 (%d).", netcam->cnt->conf.height);
+    }
+    
+    av_register_all();
+    avformat_network_init();
+    avcodec_register_all();
+
+    /*
+     * The RTSP context should be all ready to attempt a connection with
+     * the server, so we try ....
+     */
+    ret = netcam_connect_rtsp(netcam);
+    if (ret < 0){
+        return ret;
+    }
+
+    netcam->get_image = netcam_read_rtsp_image;
+
+  return 0;
+
+#else  /* No FFmpeg/Libav */
+    MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: FFmpeg/Libav not found on computer.  No RTSP support");
+    return -1;
+#endif /* End #ifdef HAVE_FFMPEG */
+}
+
+/**
+* netcam_next_rtsp
+*
+*    This function moves the picture to the image buffer.
+*    If the picture is not in the correct format for size
+*    it will put it into the requested format
+*
+* Parameters
+*
+*       netcam  The netcam context to free.
+*       url     The URL of the camera
+*
+* Returns:
+*       Failure    -1
+*       Success    0(zero)
+*
+*/
+int netcam_next_rtsp(unsigned char *image , netcam_context_ptr netcam){
+#ifdef HAVE_FFMPEG
+
+    if ((netcam->width  != netcam->rtsp->codec_context->width) ||
+        (netcam->height != netcam->rtsp->codec_context->height) ||
+        (netcam_check_pixfmt(netcam) != 0) ){
+        netcam_rtsp_resize(image ,netcam);
+    } else {
+        memcpy(image, netcam->latest->ptr, netcam->latest->used);
+    }
+    if (netcam->cnt->rotate_data.degrees > 0)
+        /* Rotate as specified */
+        rotate_map(netcam->cnt, image);
+
+    return 0;
+#else  /* No FFmpeg/Libav */
+    MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: FFmpeg/Libav not found on computer.  No RTSP support");
+    return -1;
+#endif /* End #ifdef HAVE_FFMPEG */
+}
--- /dev/null
+++ motion-3.2.12/netcam_rtsp.h
@@ -0,0 +1,43 @@
+#include "netcam.h"
+
+#ifdef HAVE_FFMPEG
+
+#include <libavcodec/avcodec.h>
+#include <libavformat/avformat.h>
+#include <libavformat/avio.h>
+#include <libavutil/avutil.h>
+#include <libavutil/imgutils.h>
+#include <libswscale/swscale.h>
+
+#endif /* end HAVE_FFMPEG  */
+
+struct rtsp_context {
+#ifdef HAVE_FFMPEG
+    AVFormatContext*      format_context;
+    AVCodecContext*       codec_context;
+    AVFrame*              frame;
+    AVFrame*              swsframe_in;
+    AVFrame*              swsframe_out;
+    int                   swsframe_size;
+    int                   video_stream_index;
+    char*                 path;
+    char*                 user;
+    char*                 pass;
+    int                   readingframe;
+    int                   status;
+    struct timeval        startreadtime;
+    struct SwsContext*   swsctx;
+
+#else /* Do not have FFmpeg */
+    int*                  format_context;
+    int                   readingframe;
+    int                   status;
+#endif /* end HAVE_FFMPEG  */
+};
+
+struct rtsp_context *rtsp_new_context(void);
+void netcam_shutdown_rtsp(netcam_context_ptr netcam);
+int netcam_connect_rtsp(netcam_context_ptr netcam);
+int netcam_read_rtsp_image(netcam_context_ptr netcam);
+int netcam_setup_rtsp(netcam_context_ptr netcam, struct url_t *url);
+int netcam_next_rtsp(unsigned char *image , netcam_context_ptr netcam);
--- motion-3.2.12.orig/netcam_wget.c
+++ motion-3.2.12/netcam_wget.c
@@ -63,14 +63,15 @@ Foundation, Inc., 675 Mass Ave, Cambridg
    `:', thus you can use it to retrieve, say, HTTP status line.
 
    All trailing whitespace is stripped from the header, and it is
-   zero-terminated.  */
-   
+   zero-terminated.  
+ */
 int header_get(netcam_context_ptr netcam, char **hdr, enum header_get_flags flags)
 {
     int i;
     int bufsize = 80;
 
     *hdr = (char *)mymalloc(bufsize);
+
     for (i = 0; 1; i++) {
         int res;
         /* #### Use DO_REALLOC?  */
@@ -84,9 +85,11 @@ int header_get(netcam_context_ptr netcam
                 if (!((flags & HG_NO_CONTINUATIONS) || i == 0
                     || (i == 1 && (*hdr)[0] == '\r'))) {
                     char next;
-                    /* If the header is non-empty, we need to check if
-                    it continues on to the other line.  We do that by
-                    peeking at the next character.  */
+                    /* 
+                     * If the header is non-empty, we need to check if
+                     * it continues on to the other line.  We do that by
+                     * peeking at the next character.  
+                     */
                     res = rbuf_peek(netcam, &next);
 
                     if (res == 0) {
@@ -96,24 +99,23 @@ int header_get(netcam_context_ptr netcam
                         (*hdr)[i] = '\0';
                         return HG_ERROR;
                     }
-                    /*  If the next character is HT or SP, just continue.  */
-
+                    /* If the next character is HT or SP, just continue. */
                     if (next == '\t' || next == ' ')
                         continue;
                 }
 
-                /* Strip trailing whitespace.  (*hdr)[i] is the newline;
-                decrement I until it points to the last available
-                whitespace.  */
+                /*
+                 * Strip trailing whitespace.  (*hdr)[i] is the newline;
+                 * decrement I until it points to the last available
+                 * whitespace.  
+                 */
                 while (i > 0 && isspace((*hdr)[i - 1]))
                     --i;
                     
                 (*hdr)[i] = '\0';
                 break;
             }
-
         } else if (res == 0) {
-        
             (*hdr)[i] = '\0';
             return HG_EOF;
         } else {
@@ -125,14 +127,17 @@ int header_get(netcam_context_ptr netcam
     return HG_OK;
 }
 
-/* Check whether HEADER begins with NAME and, if yes, skip the `:' and
-   the whitespace, and call PROCFUN with the arguments of HEADER's
-   contents (after the `:' and space) and ARG.  Otherwise, return 0.  */
-int header_process (const char *header, const char *name,
-        int (*procfun)(const char *, void *),
-        void *arg)
+/**
+ * header_process
+ * 
+ *  Check whether HEADER begins with NAME and, if yes, skip the `:' and
+ *  the whitespace, and call PROCFUN with the arguments of HEADER's
+ *  contents (after the `:' and space) and ARG.  Otherwise, return 0. 
+ */
+int header_process(const char *header, const char *name,
+                    int (*procfun)(const char *, void *), void *arg)
 {
-    /* Check whether HEADER matches NAME.  */
+    /* Check whether HEADER matches NAME. */
     while (*name && (tolower (*name) == tolower (*header)))
         ++name, ++header;
 
@@ -143,10 +148,14 @@ int header_process (const char *header,
     return ((*procfun) (header, arg));
 }
 
-/* Helper functions for use with header_process().  */
+/* Helper functions for use with header_process(). */
 
-/* Extract a long integer from HEADER and store it to CLOSURE.  If an
-   error is encountered, return 0, else 1.  */
+/**
+ * header_extract_number
+ * 
+ *  Extract a long integer from HEADER and store it to CLOSURE.  If an
+ *  error is encountered, return 0, else 1.  
+ */
 int header_extract_number(const char *header, void *closure)
 {
     const char *p = header;
@@ -162,7 +171,7 @@ int header_extract_number(const char *he
     /* Skip trailing whitespace. */
     p += skip_lws (p);
 
-    /* We return the value, even if a format error follows */
+    /* We return the value, even if a format error follows. */
     *(long *)closure = result;
 
     /* Indicate failure if trailing garbage is present. */
@@ -172,16 +181,23 @@ int header_extract_number(const char *he
     return 1;
 }
 
-/* Strdup HEADER, and place the pointer to CLOSURE.  */
+/**
+ * header_strdup
+ * 
+ *  Strdup HEADER, and place the pointer to CLOSURE.  
+ */
 int header_strdup(const char *header, void *closure)
 {
-    *(char **)closure = strdup(header);
+    *(char **)closure = mystrdup(header);
     return 1;
 }
 
 
-/* Skip LWS (linear white space), if present.  Returns number of
-   characters to skip.  */
+/**
+ * skip_lws
+ *  Skip LWS (linear white space), if present.  Returns number of
+ *  characters to skip.  
+ */
 int skip_lws(const char *string)
 {
     const char *p = string;
@@ -193,11 +209,13 @@ int skip_lws(const char *string)
 }
 
 
-/*
-    Encode the string S of length LENGTH to base64 format and place it
-    to STORE.  STORE will be 0-terminated, and must point to a writable
-    buffer of at least 1+BASE64_LENGTH(length) bytes.  
-*/
+/**
+ * base64_encode
+ *
+ *   Encode the string S of length LENGTH to base64 format and place it
+ *   to STORE.  STORE will be 0-terminated, and must point to a writable
+ *   buffer of at least 1+BASE64_LENGTH(length) bytes.  
+ */
 void base64_encode(const char *s, char *store, int length)
 {
     /* Conversion table.  */
@@ -215,7 +233,7 @@ void base64_encode(const char *s, char *
     int i;
     unsigned char *p = (unsigned char *)store;
 
-    /* Transform the 3x8 bits to 4x6 bits, as required by base64.  */
+    /* Transform the 3x8 bits to 4x6 bits, as required by base64. */
     for (i = 0; i < length; i += 3) {
         *p++ = tbl[s[0] >> 2];
         *p++ = tbl[((s[0] & 3) << 4) + (s[1] >> 4)];
@@ -224,7 +242,7 @@ void base64_encode(const char *s, char *
         s += 3;
     }
     
-    /* Pad the result if necessary...  */
+    /* Pad the result if necessary... */
     if (i == length + 1)
         *(p - 1) = '=';
     else if (i == length + 2)
@@ -234,6 +252,9 @@ void base64_encode(const char *s, char *
     *p = '\0';
 }
 
+/**
+ * strdupdelim
+ */ 
 char *strdupdelim(const char *beg, const char *end)
 {
     char *res = (char *)mymalloc(end - beg + 1);
@@ -243,6 +264,9 @@ char *strdupdelim(const char *beg, const
     return res;
 }
 
+/**
+ * http_process_type
+ */ 
 int http_process_type(const char *hdr, void *arg)
 {
     char **result = (char **)arg;
@@ -259,8 +283,11 @@ int http_process_type(const char *hdr, v
     return 1;
 }
 
-/* This is a simple implementation of buffering IO-read functions.  */
-
+/**
+ * rbuf_initialize
+ * 
+ *  This is a simple implementation of buffering IO-read functions.  
+ */
 void rbuf_initialize(netcam_context_ptr netcam)
 {
     netcam->response->buffer_pos = netcam->response->buffer;
@@ -273,7 +300,11 @@ int rbuf_read_bufferful(netcam_context_p
                        sizeof (netcam->response->buffer));
 }
 
-/* Like rbuf_readchar(), only don't move the buffer position.  */
+/**
+ * rbuf_peek
+ * 
+ *  Like rbuf_readchar(), only don't move the buffer position.  
+ */
 int rbuf_peek(netcam_context_ptr netcam, char *store)
 {
     if (!netcam->response->buffer_left) {
@@ -282,8 +313,10 @@ int rbuf_peek(netcam_context_ptr netcam,
         res = netcam_recv (netcam, netcam->response->buffer,
                            sizeof (netcam->response->buffer));
 
-        if (res <= 0)
+        if (res <= 0) {
+            *store = '\0';
             return res;
+        }
 
         netcam->response->buffer_left = res;
     }
@@ -292,11 +325,13 @@ int rbuf_peek(netcam_context_ptr netcam,
     return 1;
 }
 
-/* 
-    Flush RBUF's buffer to WHERE.  Flush MAXSIZE bytes at most.
-    Returns the number of bytes actually copied.  If the buffer is
-    empty, 0 is returned.  
-*/
+/**
+ * rbuf_flush
+ * 
+ *   Flush RBUF's buffer to WHERE.  Flush MAXSIZE bytes at most.
+ *   Returns the number of bytes actually copied.  If the buffer is
+ *   empty, 0 is returned.  
+ */
 int rbuf_flush(netcam_context_ptr netcam, char *where, int maxsize)
 {
     if (!netcam->response->buffer_left) {
@@ -313,16 +348,20 @@ int rbuf_flush(netcam_context_ptr netcam
     }
 }
 
-/* Get the HTTP result code */
+/**
+ * http_result_code
+ *
+ *  Get the HTTP result code 
+ */
 int http_result_code(const char *header)
 {
     char *cptr;
 
-    /* assure the header starts out right */
+    /* Assure the header starts out right. */
     if (strncmp(header, "HTTP", 4))
         return -1;
 
-    /* find the space following the HTTP/1.x */
+    /* Find the space following the HTTP/1.x */
     if ((cptr = strchr(header+4, ' ')) == NULL)
         return -1;
 
--- motion-3.2.12.orig/netcam_wget.h
+++ motion-3.2.12/netcam_wget.h
@@ -76,15 +76,15 @@ void base64_encode(const char *, char *,
 char *strdupdelim(const char *, const char *);
 int http_process_type(const char *, void *);
 
-enum { 
+enum {
     HG_OK, 
     HG_ERROR, 
     HG_EOF
 };
 
-enum header_get_flags { 
+enum header_get_flags{
     HG_NONE = 0,
-    HG_NO_CONTINUATIONS = 0x2 
+    HG_NO_CONTINUATIONS = 0x2
 };
 
 int header_get (netcam_context_ptr, char **, enum header_get_flags);
--- motion-3.2.12.orig/picture.c
+++ motion-3.2.12/picture.c
@@ -3,6 +3,7 @@
  *    Various funtions for saving/loading pictures.
  *    Copyright 2002 by Jeroen Vreeken (pe1rxq@amsat.org)
  *    Portions of this file are Copyright by Lionnel Maugis
+ *    Portions of this file are Copyright 2010 by Wim Lewis (wiml@hhhh.org)
  *    This software is distributed under the GNU public license version 2
  *    See also the file 'COPYING'.
  *
@@ -11,12 +12,15 @@
 #include "picture.h"
 #include "event.h"
 
+#include <assert.h>
+
 #undef HAVE_STDLIB_H
 #include <jpeglib.h>
 #include <jerror.h>
 
-/* The following declarations and 5 functions are jpeg related 
- * functions used by put_jpeg_grey_memory and put_jpeg_yuv420p_memory
+/*
+ * The following declarations and 5 functions are jpeg related
+ * functions used by put_jpeg_grey_memory and put_jpeg_yuv420p_memory.
  */
 typedef struct {
     struct jpeg_destination_mgr pub;
@@ -59,7 +63,7 @@ static GLOBAL(void) _jpeg_mem_dest(j_com
     if (cinfo->dest == NULL) {
         cinfo->dest = (struct jpeg_destination_mgr *)
                       (*cinfo->mem->alloc_small)((j_common_ptr)cinfo, JPOOL_PERMANENT,
-                      sizeof(mem_destination_mgr));
+                       sizeof(mem_destination_mgr));
     }
 
     dest = (mem_dest_ptr) cinfo->dest;
@@ -79,20 +83,340 @@ static GLOBAL(int) _jpeg_mem_size(j_comp
     return dest->jpegsize;
 }
 
+/* EXIF image data is always in TIFF format, even if embedded in another
+ * file type. This consists of a constant header (TIFF file header,
+ * IFD header) followed by the tags in the IFD and then the data
+ * from any tags which do not fit inline in the IFD.
+ *
+ * The tags we write in the main IFD are:
+ *  0x010E   Image description
+ *  0x8769   Exif sub-IFD
+ *  0x882A   Time zone of time stamps
+ * and in the Exif sub-IFD:
+ *  0x9000   Exif version
+ *  0x9003   File date and time
+ *  0x9291   File date and time subsecond info
+ * But we omit any empty IFDs.
+ */
+
+#define TIFF_TAG_IMAGE_DESCRIPTION    0x010E
+#define TIFF_TAG_DATETIME             0x0132
+#define TIFF_TAG_EXIF_IFD             0x8769
+#define TIFF_TAG_TZ_OFFSET            0x882A
+
+#define EXIF_TAG_EXIF_VERSION         0x9000
+#define EXIF_TAG_ORIGINAL_DATETIME    0x9003
+#define EXIF_TAG_SUBJECT_AREA         0x9214
+#define EXIF_TAG_TIFF_DATETIME_SS     0x9290
+#define EXIF_TAG_ORIGINAL_DATETIME_SS 0x9291
+
+#define TIFF_TYPE_ASCII  2  /* ASCII text */
+#define TIFF_TYPE_USHORT 3  /* Unsigned 16-bit int */
+#define TIFF_TYPE_LONG   4  /* Unsigned 32-bit int */
+#define TIFF_TYPE_UNDEF  7  /* Byte blob */
+#define TIFF_TYPE_SSHORT 8  /* Signed 16-bit int */
+
+static const char exif_marker_start[14] = {
+    'E', 'x', 'i', 'f', 0, 0,   /* EXIF marker signature */
+    'M', 'M', 0, 42,            /* TIFF file header (big-endian) */
+    0, 0, 0, 8,                 /* Offset to first toplevel IFD */
+};
+
+static const char exif_version_tag[12] = {
+    0x90, 0x00,                 /* EXIF version tag, 0x9000 */
+    0x00, 0x07,                 /* Data type 7 = "unknown" (raw byte blob) */
+    0x00, 0x00, 0x00, 0x04,     /* Data length */
+    0x30, 0x32, 0x32, 0x30      /* Inline data, EXIF version 2.2 */
+};
+
+static const char exif_subifd_tag[8] = {
+    0x87, 0x69,                 /* EXIF Sub-IFD tag */
+    0x00, 0x04,                 /* Data type 4 = uint32 */
+    0x00, 0x00, 0x00, 0x01,     /* Number of values */
+};
+
+static const char exif_tzoffset_tag[12] = {
+    0x88, 0x2A,                 /* TIFF/EP time zone offset tag */
+    0x00, 0x08,                 /* Data type 8 = sint16 */
+    0x00, 0x00, 0x00, 0x01,     /* Number of values */
+    0, 0, 0, 0                  /* Dummy data */
+};
+
+static void put_uint16(JOCTET *buf, unsigned value)
+{
+    buf[0] = ( value & 0xFF00 ) >> 8;
+    buf[1] = ( value & 0x00FF );
+}
+
+static void put_sint16(JOCTET *buf, int value)
+{
+    buf[0] = ( value & 0xFF00 ) >> 8;
+    buf[1] = ( value & 0x00FF );
+}
+
+static void put_uint32(JOCTET *buf, unsigned value)
+{
+    buf[0] = ( value & 0xFF000000 ) >> 24;
+    buf[1] = ( value & 0x00FF0000 ) >> 16;
+    buf[2] = ( value & 0x0000FF00 ) >> 8;
+    buf[3] = ( value & 0x000000FF );
+}
+
+struct tiff_writing {
+    JOCTET * const base;
+    JOCTET *buf;
+    unsigned data_offset;
+};
+
+static void put_direntry(struct tiff_writing *into, const char *data, unsigned length)
+{
+    if (length <= 4) {
+	    /* Entries that fit in the directory entry are stored there */
+	    memset(into->buf, 0, 4);
+	    memcpy(into->buf, data, length);
+    } else {
+	    /* Longer entries are stored out-of-line */
+	    unsigned offset = into->data_offset;
+
+        while ((offset & 0x03) != 0) {  /* Alignment */
+	        into->base[offset] = 0;
+	        offset ++;
+	    }
+
+	    put_uint32(into->buf, offset);
+	    memcpy(into->base + offset, data, length);
+	    into->data_offset = offset + length;
+    }
+}
+
+static void put_stringentry(struct tiff_writing *into, unsigned tag, const char *str, int with_nul)
+{
+    unsigned stringlength = strlen(str) + (with_nul?1:0);
+
+    put_uint16(into->buf, tag);
+    put_uint16(into->buf + 2, TIFF_TYPE_ASCII);
+    put_uint32(into->buf + 4, stringlength);
+    into->buf += 8;
+    put_direntry(into, str, stringlength);
+    into->buf += 4;
+}
+
+static void put_subjectarea(struct tiff_writing *into, const struct coord *box)
+{
+    put_uint16(into->buf    , EXIF_TAG_SUBJECT_AREA);
+    put_uint16(into->buf + 2, TIFF_TYPE_USHORT);
+    put_uint32(into->buf + 4, 4 /* Four USHORTs */);
+    put_uint32(into->buf + 8, into->data_offset);
+    into->buf += 12;
+    JOCTET *ool = into->base + into->data_offset;
+    put_uint16(ool  , box->x); /* Center.x */
+    put_uint16(ool+2, box->y); /* Center.y */
+    put_uint16(ool+4, box->width);
+    put_uint16(ool+6, box->height);
+    into->data_offset += 8;
+}
+
+/*
+ * put_jpeg_exif writes the EXIF APP1 chunk to the jpeg file.
+ * It must be called after jpeg_start_compress() but before
+ * any image data is written by jpeg_write_scanlines().
+ */
+static void put_jpeg_exif(j_compress_ptr cinfo,
+			  const struct context *cnt,
+			  const struct tm *timestamp,
+			  const struct coord *box)
+{
+    /* description, datetime, and subtime are the values that are actually
+     * put into the EXIF data
+    */
+    char *description, *datetime, *subtime;
+    char datetime_buf[22];
+
+    if (timestamp) {
+	/* Exif requires this exact format */
+	    snprintf(datetime_buf, 21, "%04d:%02d:%02d %02d:%02d:%02d",
+		        timestamp->tm_year + 1900,
+		        timestamp->tm_mon + 1,
+		        timestamp->tm_mday,
+		        timestamp->tm_hour,
+		        timestamp->tm_min,
+		        timestamp->tm_sec);
+	    datetime = datetime_buf;
+    } else {
+	    datetime = NULL;
+    }
+
+    // TODO: Extract subsecond timestamp from somewhere, but only
+    // use as much of it as is indicated by conf->frame_limit
+    subtime = NULL;
+
+    if (cnt->conf.exif_text) {
+	    description = malloc(PATH_MAX);
+	    mystrftime(cnt, description, PATH_MAX-1,
+		        cnt->conf.exif_text,
+		        timestamp, NULL, 0);
+    } else {
+	    description = NULL;
+    }
+
+    /* Calculate an upper bound on the size of the APP1 marker so
+     * we can allocate a buffer for it.
+     */
+
+    /* Count up the number of tags and max amount of OOL data */
+    int ifd0_tagcount = 0;
+    int ifd1_tagcount = 0;
+    unsigned datasize = 0;
+
+    if (description) {
+	    ifd0_tagcount ++;
+	    datasize += 5 + strlen(description); /* Add 5 for NUL and alignment */
+    }
+
+    if (datetime) {
+	/* We write this to both the TIFF datetime tag (which most programs
+	 * treat as "last-modified-date") and the EXIF "time of creation of
+	 * original image" tag (which many programs ignore). This is
+	 * redundant but seems to be the thing to do.
+	 */
+	    ifd0_tagcount++;
+	    ifd1_tagcount++;
+	    /* We also write the timezone-offset tag in IFD0 */
+	    ifd0_tagcount++;
+	    /* It would be nice to use the same offset for both tags' values,
+	    * but I don't want to write the bookkeeping for that right now */
+	    datasize += 2 * (5 + strlen(datetime));
+    }
+
+    if (subtime) {
+	    ifd1_tagcount++;
+	    datasize += 5 + strlen(subtime);
+    }
+
+    if (box) {
+	    ifd1_tagcount++;
+	    datasize += 2 * 4;  /* Four 16-bit ints */
+    }
+
+    if (ifd1_tagcount > 0) {
+	    /* If we're writing the Exif sub-IFD, account for the
+	    * two tags that requires */
+	    ifd0_tagcount ++; /* The tag in IFD0 that points to IFD1 */
+	    ifd1_tagcount ++; /* The EXIF version tag */
+    }
+
+    /* Each IFD takes 12 bytes per tag, plus six more (the tag count and the
+     * pointer to the next IFD, always zero in our case)
+     */
+    unsigned int ifds_size =
+	( ifd1_tagcount > 0 ? ( 12 * ifd1_tagcount + 6 ) : 0 ) +
+	( ifd0_tagcount > 0 ? ( 12 * ifd0_tagcount + 6 ) : 0 );
+
+    if (ifds_size == 0) {
+	    /* We're not actually going to write any information. */
+	    return;
+    }
+
+    unsigned int buffer_size = 6 /* EXIF marker signature */ +
+                               8 /* TIFF file header */ +
+                               ifds_size /* the tag directories */ +
+                               datasize;
+
+    JOCTET *marker = malloc(buffer_size);
+    memcpy(marker, exif_marker_start, 14); /* EXIF and TIFF headers */
+
+    struct tiff_writing writing = (struct tiff_writing) {
+	.base = marker + 6, /* base address for intra-TIFF offsets */
+	.buf = marker + 14, /* current write position */
+	.data_offset = 8 + ifds_size, /* where to start storing data */
+    };
+
+    /* Write IFD 0 */
+    /* Note that tags are stored in numerical order */
+    put_uint16(writing.buf, ifd0_tagcount);
+    writing.buf += 2;
+
+    if (description)
+	    put_stringentry(&writing, TIFF_TAG_IMAGE_DESCRIPTION, description, 0);
+
+    if (datetime)
+	    put_stringentry(&writing, TIFF_TAG_DATETIME, datetime, 1);
+
+    if (ifd1_tagcount > 0) {
+	    /* Offset of IFD1 - TIFF header + IFD0 size. */
+	    unsigned ifd1_offset = 8 + 6 + ( 12 * ifd0_tagcount );
+	    memcpy(writing.buf, exif_subifd_tag, 8);
+	    put_uint32(writing.buf + 8, ifd1_offset);
+	    writing.buf += 12;
+    }
+
+    if (datetime) {
+        memcpy(writing.buf, exif_tzoffset_tag, 12);
+        put_sint16(writing.buf+8, timestamp->tm_gmtoff / 3600);
+        writing.buf += 12;
+    }
+
+    put_uint32(writing.buf, 0); /* Next IFD offset = 0 (no next IFD) */
+    writing.buf += 4;
+
+    /* Write IFD 1 */
+    if (ifd1_tagcount > 0) {
+	    /* (remember that the tags in any IFD must be in numerical order
+	    * by tag) */
+	    put_uint16(writing.buf, ifd1_tagcount);
+	    memcpy(writing.buf + 2, exif_version_tag, 12); /* tag 0x9000 */
+	    writing.buf += 14;
+
+	    if (datetime)
+	        put_stringentry(&writing, EXIF_TAG_ORIGINAL_DATETIME, datetime, 1);
+
+        if (box)
+	        put_subjectarea(&writing, box);
+
+        if (subtime)
+	        put_stringentry(&writing, EXIF_TAG_ORIGINAL_DATETIME_SS, subtime, 0);
 
-/* put_jpeg_yuv420p_memory converts an input image in the YUV420P format into a jpeg image and puts
- * it in a memory buffer.
+	    put_uint32(writing.buf, 0); /* Next IFD = 0 (no next IFD) */
+	    writing.buf += 4;
+    }
+
+    /* We should have met up with the OOL data */
+    assert( (writing.buf - writing.base) == 8 + ifds_size );
+
+    /* The buffer is complete; write it out */
+    unsigned marker_len = 6 + writing.data_offset;
+
+    /* assert we didn't underestimate the original buffer size */
+    assert(marker_len <= buffer_size);
+
+    /* EXIF data lives in a JPEG APP1 marker */
+    jpeg_write_marker(cinfo, JPEG_APP0 + 1, marker, marker_len);
+
+    if (description)
+	    free(description);
+
+    free(marker);
+}
+
+/**
+ * put_jpeg_yuv420p_memory
+ *      Converts an input image in the YUV420P format into a jpeg image and puts
+ *      it in a memory buffer.
  * Inputs:
  * - image_size is the size of the input image buffer.
  * - input_image is the image in YUV420P format.
  * - width and height are the dimensions of the image
  * - quality is the jpeg encoding quality 0-100%
+ *
  * Output:
  * - dest_image is a pointer to the jpeg image buffer
- * Returns buffer size of jpeg image     
+ *
+ * Returns buffer size of jpeg image
  */
 static int put_jpeg_yuv420p_memory(unsigned char *dest_image, int image_size,
-                                   unsigned char *input_image, int width, int height, int quality)
+				   unsigned char *input_image, int width, int height, int quality,
+				   struct context *cnt, struct tm *tm, struct coord *box)
+
 {
     int i, j, jpeg_image_size;
 
@@ -106,21 +430,20 @@ static int put_jpeg_yuv420p_memory(unsig
     data[1] = cb;
     data[2] = cr;
 
-    cinfo.err = jpeg_std_error(&jerr);  // errors get written to stderr 
-    
+    cinfo.err = jpeg_std_error(&jerr);  // Errors get written to stderr
+
     jpeg_create_compress(&cinfo);
     cinfo.image_width = width;
     cinfo.image_height = height;
     cinfo.input_components = 3;
-    jpeg_set_defaults (&cinfo);
+    jpeg_set_defaults(&cinfo);
 
     jpeg_set_colorspace(&cinfo, JCS_YCbCr);
 
-    cinfo.raw_data_in = TRUE; // supply downsampled data
+    cinfo.raw_data_in = TRUE; // Supply downsampled data
 #if JPEG_LIB_VERSION >= 70
-#warning using JPEG_LIB_VERSION >= 70
-    cinfo.do_fancy_downsampling = FALSE;  // fix segfaulst with v7
-#endif    
+    cinfo.do_fancy_downsampling = FALSE;  // Fix segfault with v7
+#endif
     cinfo.comp_info[0].h_samp_factor = 2;
     cinfo.comp_info[0].v_samp_factor = 2;
     cinfo.comp_info[1].h_samp_factor = 1;
@@ -131,16 +454,19 @@ static int put_jpeg_yuv420p_memory(unsig
     jpeg_set_quality(&cinfo, quality, TRUE);
     cinfo.dct_method = JDCT_FASTEST;
 
-    _jpeg_mem_dest(&cinfo, dest_image, image_size);    // data written to mem
-    
-    jpeg_start_compress (&cinfo, TRUE);
+    _jpeg_mem_dest(&cinfo, dest_image, image_size);  // Data written to mem
+
+    jpeg_start_compress(&cinfo, TRUE);
+
+    put_jpeg_exif(&cinfo, cnt, tm, box);
 
     for (j = 0; j < height; j += 16) {
         for (i = 0; i < 16; i++) {
             y[i] = input_image + width * (i + j);
-            if (i%2 == 0) {
-                cb[i/2] = input_image + width * height + width / 2 * ((i + j) / 2);
-                cr[i/2] = input_image + width * height + width * height / 4 + width / 2 * ((i + j) / 2);
+
+            if (i % 2 == 0) {
+                cb[i / 2] = input_image + width * height + width / 2 * ((i + j) /2);
+                cr[i / 2] = input_image + width * height + width * height / 4 + width / 2 * ((i + j) / 2);
             }
         }
         jpeg_write_raw_data(&cinfo, data, 16);
@@ -149,22 +475,26 @@ static int put_jpeg_yuv420p_memory(unsig
     jpeg_finish_compress(&cinfo);
     jpeg_image_size = _jpeg_mem_size(&cinfo);
     jpeg_destroy_compress(&cinfo);
-    
+
     return jpeg_image_size;
 }
 
-/* put_jpeg_grey_memory converts an input image in the grayscale format into a jpeg image
+/**
+ * put_jpeg_grey_memory
+ *      Converts an input image in the grayscale format into a jpeg image.
+ *
  * Inputs:
  * - image_size is the size of the input image buffer.
  * - input_image is the image in grayscale format.
  * - width and height are the dimensions of the image
  * - quality is the jpeg encoding quality 0-100%
+ *
  * Output:
  * - dest_image is a pointer to the jpeg image buffer
- * Returns buffer size of jpeg image     
+ *
+ * Returns buffer size of jpeg image.
  */
-static int put_jpeg_grey_memory(unsigned char *dest_image, int image_size, 
-                                unsigned char *input_image, int width, int height, int quality)
+static int put_jpeg_grey_memory(unsigned char *dest_image, int image_size, unsigned char *input_image, int width, int height, int quality)
 {
     int y, dest_image_size;
     JSAMPROW row_ptr[1];
@@ -175,24 +505,26 @@ static int put_jpeg_grey_memory(unsigned
     jpeg_create_compress(&cjpeg);
     cjpeg.image_width = width;
     cjpeg.image_height = height;
-    cjpeg.input_components = 1; /* one colour component */
+    cjpeg.input_components = 1; /* One colour component */
     cjpeg.in_color_space = JCS_GRAYSCALE;
 
     jpeg_set_defaults(&cjpeg);
 
     jpeg_set_quality(&cjpeg, quality, TRUE);
     cjpeg.dct_method = JDCT_FASTEST;
-    _jpeg_mem_dest(&cjpeg, dest_image, image_size);  // data written to mem
+    _jpeg_mem_dest(&cjpeg, dest_image, image_size);  // Data written to mem
 
     jpeg_start_compress (&cjpeg, TRUE);
 
+    put_jpeg_exif(&cjpeg, NULL, NULL, NULL);
+
     row_ptr[0] = input_image;
-    
+
     for (y = 0; y < height; y++) {
         jpeg_write_scanlines(&cjpeg, row_ptr, 1);
         row_ptr[0] += width;
     }
-    
+
     jpeg_finish_compress(&cjpeg);
     dest_image_size = _jpeg_mem_size(&cjpeg);
     jpeg_destroy_compress(&cjpeg);
@@ -200,20 +532,27 @@ static int put_jpeg_grey_memory(unsigned
     return dest_image_size;
 }
 
-/* put_jpeg_yuv420p_file converts an YUV420P coded image to a jpeg image and writes
- * it to an already open file.
+/**
+ * put_jpeg_yuv420p_file
+ *      Converts an YUV420P coded image to a jpeg image and writes
+ *      it to an already open file.
+ *
  * Inputs:
  * - image is the image in YUV420P format.
  * - width and height are the dimensions of the image
  * - quality is the jpeg encoding quality 0-100%
+ *
  * Output:
  * - The jpeg is written directly to the file given by the file pointer fp
+ *
  * Returns nothing
  */
-static void put_jpeg_yuv420p_file(FILE *fp, unsigned char *image, int width, 
-            int height, int quality)
+static void put_jpeg_yuv420p_file(FILE *fp,
+				  unsigned char *image, int width, int height,
+				  int quality,
+				  struct context *cnt, struct tm *tm, struct coord *box)
 {
-    int i,j;
+    int i, j;
 
     JSAMPROW y[16],cb[16],cr[16]; // y[2][5] = color sample of row 2 and pixel column 5; (one plane)
     JSAMPARRAY data[3]; // t[0][2][5] = color sample 0 of row 2 and column 5
@@ -225,8 +564,8 @@ static void put_jpeg_yuv420p_file(FILE *
     data[1] = cb;
     data[2] = cr;
 
-    cinfo.err = jpeg_std_error(&jerr);  // errors get written to stderr 
-    
+    cinfo.err = jpeg_std_error(&jerr);  // Errors get written to stderr
+
     jpeg_create_compress(&cinfo);
     cinfo.image_width = width;
     cinfo.image_height = height;
@@ -235,11 +574,10 @@ static void put_jpeg_yuv420p_file(FILE *
 
     jpeg_set_colorspace(&cinfo, JCS_YCbCr);
 
-    cinfo.raw_data_in = TRUE; // supply downsampled data
+    cinfo.raw_data_in = TRUE; // Supply downsampled data
 #if JPEG_LIB_VERSION >= 70
-#warning using JPEG_LIB_VERSION >= 70
-    cinfo.do_fancy_downsampling = FALSE;  // fix segfaulst with v7
-#endif    
+    cinfo.do_fancy_downsampling = FALSE;  // Fix segfault with v7
+#endif
     cinfo.comp_info[0].h_samp_factor = 2;
     cinfo.comp_info[0].v_samp_factor = 2;
     cinfo.comp_info[1].h_samp_factor = 1;
@@ -250,15 +588,17 @@ static void put_jpeg_yuv420p_file(FILE *
     jpeg_set_quality(&cinfo, quality, TRUE);
     cinfo.dct_method = JDCT_FASTEST;
 
-    jpeg_stdio_dest(&cinfo, fp);        // data written to file
+    jpeg_stdio_dest(&cinfo, fp);        // Data written to file
     jpeg_start_compress(&cinfo, TRUE);
 
+    put_jpeg_exif(&cinfo, cnt, tm, box);
+
     for (j = 0; j < height; j += 16) {
         for (i = 0; i < 16; i++) {
             y[i] = image + width * (i + j);
             if (i % 2 == 0) {
                 cb[i / 2] = image + width * height + width / 2 * ((i + j) / 2);
-                cr[i / 2] = image + width * height + width * height / 4 + width / 2 * ((i + j) /2);
+                cr[i / 2] = image + width * height + width * height / 4 + width / 2 * ((i + j) / 2);
             }
         }
         jpeg_write_raw_data(&cinfo, data, 16);
@@ -269,14 +609,18 @@ static void put_jpeg_yuv420p_file(FILE *
 }
 
 
-/* put_jpeg_grey_file converts an greyscale image to a jpeg image and writes
- * it to an already open file.
+/**
+ * put_jpeg_grey_file
+ *      Converts an greyscale image to a jpeg image and writes
+ *      it to an already open file.
+ *
  * Inputs:
  * - image is the image in greyscale format.
  * - width and height are the dimensions of the image
  * - quality is the jpeg encoding quality 0-100%
  * Output:
  * - The jpeg is written directly to the file given by the file pointer fp
+ *
  * Returns nothing
  */
 static void put_jpeg_grey_file(FILE *picture, unsigned char *image, int width, int height, int quality)
@@ -290,7 +634,7 @@ static void put_jpeg_grey_file(FILE *pic
     jpeg_create_compress(&cjpeg);
     cjpeg.image_width = width;
     cjpeg.image_height = height;
-    cjpeg.input_components = 1; /* one colour component */
+    cjpeg.input_components = 1; /* One colour component */
     cjpeg.in_color_space = JCS_GRAYSCALE;
 
     jpeg_set_defaults(&cjpeg);
@@ -301,6 +645,8 @@ static void put_jpeg_grey_file(FILE *pic
 
     jpeg_start_compress(&cjpeg, TRUE);
 
+    put_jpeg_exif(&cjpeg, NULL, NULL, NULL);
+
     row_ptr[0] = image;
 
     for (y = 0; y < height; y++) {
@@ -313,13 +659,17 @@ static void put_jpeg_grey_file(FILE *pic
 }
 
 
-/* put_ppm_bgr24_file converts an greyscale image to a PPM image and writes
- * it to an already open file.
+/**
+ * put_ppm_bgr24_file
+ *      Converts an greyscale image to a PPM image and writes
+ *      it to an already open file.
  * Inputs:
  * - image is the image in YUV420P format.
  * - width and height are the dimensions of the image
+ *
  * Output:
  * - The PPM is written directly to the file given by the file pointer fp
+ *
  * Returns nothing
  */
 static void put_ppm_bgr24_file(FILE *picture, unsigned char *image, int width, int height)
@@ -329,25 +679,25 @@ static void put_ppm_bgr24_file(FILE *pic
     unsigned char *u = image + width * height;
     unsigned char *v = u + (width * height) / 4;
     int r, g, b;
-    int warningkiller;
     unsigned char rgb[3];
-    
-    /*    ppm header
-     *    width height
-     *    maxval
+
+    /*
+     *  ppm header
+     *  width height
+     *  maxval
      */
     fprintf(picture, "P6\n");
     fprintf(picture, "%d %d\n", width, height);
     fprintf(picture, "%d\n", 255);
     for (y = 0; y < height; y++) {
-        
+
         for (x = 0; x < width; x++) {
-            r = 76283* (((int)*l) - 16) + 104595 * (((int)*u) - 128);
-            g = 76283* (((int)*l) - 16)- 53281 * (((int)*u) - 128)-25625*(((int)*v)-128);
-            b = 76283* (((int)*l) - 16) + 132252 * (((int)*v) - 128);
-            r = r>>16;
-            g = g>>16;
-            b = b>>16;
+            r = 76283 * (((int)*l) - 16)+104595*(((int)*u) - 128);
+            g = 76283 * (((int)*l) - 16)- 53281*(((int)*u) - 128) - 25625 * (((int)*v) - 128);
+            b = 76283 * (((int)*l) - 16) + 132252 * (((int)*v) - 128);
+            r = r >> 16;
+            g = g >> 16;
+            b = b >> 16;
             if (r < 0)
                 r = 0;
             else if (r > 255)
@@ -371,7 +721,7 @@ static void put_ppm_bgr24_file(FILE *pic
                 v++;
             }
             /* ppm is rgb not bgr */
-            warningkiller = fwrite(rgb, 1, 3, picture);
+            fwrite(rgb, 1, 3, picture);
         }
         if (y & 1) {
             u -= width / 2;
@@ -380,97 +730,131 @@ static void put_ppm_bgr24_file(FILE *pic
     }
 }
 
-/* copy smartmask as an overlay into motion images and movies */
+/**
+ * overlay_smartmask
+ *      Copies smartmask as an overlay into motion images and movies.
+ *
+ * Returns nothing.
+ */
 void overlay_smartmask(struct context *cnt, unsigned char *out)
 {
     int i, x, v, width, height, line;
     struct images *imgs = &cnt->imgs;
     unsigned char *smartmask = imgs->smartmask_final;
     unsigned char *out_y, *out_u, *out_v;
-    
+
     i = imgs->motionsize;
     v = i + ((imgs->motionsize) / 4);
     width = imgs->width;
     height = imgs->height;
 
-    /* set V to 255 to make smartmask appear red */
+    /* Set V to 255 to make smartmask appear red. */
     out_v = out + v;
     out_u = out + i;
-    for (i = 0; i < height; i += 2){
+    for (i = 0; i < height; i += 2) {
         line = i * width;
-        for (x = 0; x < width; x += 2){
-            if (smartmask[line + x] == 0 ||
-                smartmask[line + x + 1] == 0 ||
+        for (x = 0; x < width; x += 2) {
+            if (smartmask[line + x] == 0 || smartmask[line + x + 1] == 0 ||
                 smartmask[line + width + x] == 0 ||
-                smartmask[line + width + x + 1] == 0){
-                    *out_v = 255;
-                    *out_u = 128;
+                smartmask[line + width + x + 1] == 0) {
+
+                *out_v = 255;
+                *out_u = 128;
             }
             out_v++;
             out_u++;
         }
     }
     out_y = out;
-    /* set colour intensity for smartmask */
-    for (i = 0; i < imgs->motionsize; i++){
+    /* Set colour intensity for smartmask. */
+    for (i = 0; i < imgs->motionsize; i++) {
         if (smartmask[i] == 0)
             *out_y = 0;
         out_y++;
     }
 }
 
-/* copy fixed mask as an overlay into motion images and movies */
+/**
+ * overlay_fixed_mask
+ *      Copies fixed mask as green overlay into motion images and movies.
+ *
+ * Returns nothing.
+ */
 void overlay_fixed_mask(struct context *cnt, unsigned char *out)
 {
-    int i;
+    int i, x, v, width, height, line;
     struct images *imgs = &cnt->imgs;
-    unsigned char *motion_img = imgs->out;
     unsigned char *mask = imgs->mask;
-    int pixel;
-    
-    /* set y to mask + motion-pixel to keep motion pixels visible on grey background*/
-    for (i = 0; i < imgs->motionsize; i++){
-        pixel = 255 - mask[i] + motion_img[i];
-        if (pixel > 255)
-            *out = 255;
-        else
-            *out = pixel;
-        out++;
+    unsigned char *out_y, *out_u, *out_v;
+
+    i = imgs->motionsize;
+    v = i + ((imgs->motionsize) / 4);
+    width = imgs->width;
+    height = imgs->height;
+
+    /* Set U and V to 0 to make fixed mask appear green. */
+    out_v = out + v;
+    out_u = out + i;
+    for (i = 0; i < height; i += 2) {
+        line = i * width;
+        for (x = 0; x < width; x += 2) {
+            if (mask[line + x] == 0 || mask[line + x + 1] == 0 ||
+                mask[line + width + x] == 0 ||
+                mask[line + width + x + 1] == 0) {
+
+                *out_v = 0;
+                *out_u = 0;
+            }
+            out_v++;
+            out_u++;
+        }
+    }
+    out_y = out;
+    /* Set colour intensity for mask. */
+    for (i = 0; i < imgs->motionsize; i++) {
+        if (mask[i] == 0)
+            *out_y = 0;
+        out_y++;
     }
 }
 
-/* copy largest label as an overlay into motion images and movies */
+/**
+ * overlay_largest_label
+ *      Copies largest label as an overlay into motion images and movies.
+ *
+ * Returns nothing.
+ */
 void overlay_largest_label(struct context *cnt, unsigned char *out)
 {
     int i, x, v, width, height, line;
     struct images *imgs = &cnt->imgs;
     int *labels = imgs->labels;
     unsigned char *out_y, *out_u, *out_v;
-    
+
     i = imgs->motionsize;
     v = i + ((imgs->motionsize) / 4);
     width = imgs->width;
     height = imgs->height;
 
-    /* set U to 255 to make label appear blue */
+    /* Set U to 255 to make label appear blue. */
     out_u = out + i;
     out_v = out + v;
-    for (i = 0; i < height; i += 2){
+    for (i = 0; i < height; i += 2) {
         line = i * width;
-        for (x = 0; x < width; x += 2){
-            if (labels[line + x] & 32768 ||
-                labels[line + x + 1] & 32768 ||
+        for (x = 0; x < width; x += 2) {
+            if (labels[line + x] & 32768 || labels[line + x + 1] & 32768 ||
                 labels[line + width + x] & 32768 ||
                 labels[line + width + x + 1] & 32768) {
-                    *out_u = 255;
-                    *out_v = 128;
+
+                *out_u = 255;
+                *out_v = 128;
             }
             out_u++;
             out_v++;
         }
     }
     out_y = out;
-    /* set intensity for coloured label to have better visibility */
+    /* Set intensity for coloured label to have better visibility. */
     for (i = 0; i < imgs->motionsize; i++) {
         if (*labels++ & 32768)
             *out_y = 0;
@@ -478,30 +862,35 @@ void overlay_largest_label(struct contex
     }
 }
 
-/* put_picture_mem is used for the webcam feature. Depending on the image type
- * (colour YUV420P or greyscale) the corresponding put_jpeg_X_memory function is called.
+/**
+ * put_picture_mem
+ *      Is used for the webcam feature. Depending on the image type
+ *      (colour YUV420P or greyscale) the corresponding put_jpeg_X_memory function is called.
  * Inputs:
  * - cnt is the global context struct and only cnt->imgs.type is used.
  * - image_size is the size of the input image buffer
  * - *image points to the image buffer that contains the YUV420P or Grayscale image about to be put
  * - quality is the jpeg quality setting from the config file.
+ *
  * Output:
  * - **dest_image is a pointer to a pointer that points to the destination buffer in which the
  *   converted image it put
- * Function returns the dest_image_size if successful. Otherwise 0.
- */ 
+ *
+ * Returns the dest_image_size if successful. Otherwise 0.
+ */
 int put_picture_memory(struct context *cnt, unsigned char* dest_image, int image_size,
                        unsigned char *image, int quality)
 {
     switch (cnt->imgs.type) {
     case VIDEO_PALETTE_YUV420P:
         return put_jpeg_yuv420p_memory(dest_image, image_size, image,
-                                       cnt->imgs.width, cnt->imgs.height, quality);
+                                       cnt->imgs.width, cnt->imgs.height, quality, cnt, &(cnt->current_image->timestamp_tm), &(cnt->current_image->location));
     case VIDEO_PALETTE_GREY:
         return put_jpeg_grey_memory(dest_image, image_size, image,
                                     cnt->imgs.width, cnt->imgs.height, quality);
     default:
-        motion_log(LOG_ERR, 0, "Unknow image type %d", cnt->imgs.type);            
+        MOTION_LOG(WRN, TYPE_ALL, NO_ERRNO, "%s: Unknow image type %d",
+                   cnt->imgs.type);
     }
 
     return 0;
@@ -509,18 +898,19 @@ int put_picture_memory(struct context *c
 
 void put_picture_fd(struct context *cnt, FILE *picture, unsigned char *image, int quality)
 {
-    if (cnt->conf.ppm) {
+    if (cnt->imgs.picture_type == IMAGE_TYPE_PPM) {
         put_ppm_bgr24_file(picture, image, cnt->imgs.width, cnt->imgs.height);
     } else {
         switch (cnt->imgs.type) {
         case VIDEO_PALETTE_YUV420P:
-            put_jpeg_yuv420p_file(picture, image, cnt->imgs.width, cnt->imgs.height, quality);
+            put_jpeg_yuv420p_file(picture, image, cnt->imgs.width, cnt->imgs.height, quality, cnt, &(cnt->current_image->timestamp_tm), &(cnt->current_image->location));
             break;
         case VIDEO_PALETTE_GREY:
             put_jpeg_grey_file(picture, image, cnt->imgs.width, cnt->imgs.height, quality);
             break;
-        default :
-            motion_log(LOG_ERR, 0, "Unknow image type %d", cnt->imgs.type);
+        default:
+            MOTION_LOG(WRN, TYPE_ALL, NO_ERRNO, "%s: Unknow image type %d",
+                       cnt->imgs.type);
         }
     }
 }
@@ -530,61 +920,67 @@ void put_picture(struct context *cnt, ch
 {
     FILE *picture;
 
-    picture = myfopen(file, "w");
+    picture = myfopen(file, "w", BUFSIZE_1MEG);
     if (!picture) {
-        /* Report to syslog - suggest solution if the problem is access rights to target dir */
+        /* Report to syslog - suggest solution if the problem is access rights to target dir. */
         if (errno ==  EACCES) {
-            motion_log(LOG_ERR, 1,
-                       "Can't write picture to file %s - check access rights to target directory", file);
-            motion_log(LOG_ERR, 1, "Thread is going to finish due to this fatal error");
+            MOTION_LOG(ERR, TYPE_ALL, SHOW_ERRNO,
+                       "%s: Can't write picture to file %s - check access rights to target directory\n"
+                       "Thread is going to finish due to this fatal error", file);
             cnt->finish = 1;
             cnt->restart = 0;
             return;
         } else {
-            /* If target dir is temporarily unavailable we may survive */
-            motion_log(LOG_ERR, 1, "Can't write picture to file %s", file);
+            /* If target dir is temporarily unavailable we may survive. */
+            MOTION_LOG(ERR, TYPE_ALL, SHOW_ERRNO, "%s: Can't write picture to file %s", file);
             return;
         }
     }
 
     put_picture_fd(cnt, picture, image, cnt->conf.quality);
-    fclose(picture);
+    myfclose(picture);
     event(cnt, EVENT_FILECREATE, NULL, file, (void *)(unsigned long)ftype, NULL);
 }
 
-/* Get the pgm file used as fixed mask */
+/**
+ * get_pgm
+ *      Get the pgm file used as fixed mask
+ *
+ */
 unsigned char *get_pgm(FILE *picture, int width, int height)
 {
-    int x = 0 ,y = 0, maxval;
+    int x = 0 , y = 0, maxval;
     char line[256];
     unsigned char *image;
 
-    line[255]=0;
-    
+    line[255] = 0;
+
     if (!fgets(line, 255, picture)) {
-        motion_log(LOG_ERR, 1, "Could not read from ppm file");
+        MOTION_LOG(ERR, TYPE_ALL, SHOW_ERRNO, "%s: Could not read from ppm file");
         return NULL;
     }
-    
+
     if (strncmp(line, "P5", 2)) {
-        motion_log(LOG_ERR, 1, "This is not a ppm file, starts with '%s'", line);
+        MOTION_LOG(ERR, TYPE_ALL, SHOW_ERRNO, "%s: This is not a ppm file, starts with '%s'",
+                   line);
         return NULL;
     }
-    
-    /* skip comment */
+
+    /* Skip comment */
     line[0] = '#';
     while (line[0] == '#')
         if (!fgets(line, 255, picture))
             return NULL;
 
-    /* check size */
+    /* Check size */
     if (sscanf(line, "%d %d", &x, &y) != 2) {
-        motion_log(LOG_ERR, 1, "Failed reading size in pgm file");
+        MOTION_LOG(ERR, TYPE_ALL, SHOW_ERRNO, "%s: Failed reading size in pgm file");
         return NULL;
     }
-    
+
     if (x != width || y != height) {
-        motion_log(LOG_ERR, 1, "Wrong image size %dx%d should be %dx%d", x, y, width, height);
+        MOTION_LOG(ERR, TYPE_ALL, SHOW_ERRNO, "%s: Wrong image size %dx%d should be %dx%d",
+                   x, y, width, height);
         return NULL;
     }
 
@@ -593,119 +989,137 @@ unsigned char *get_pgm(FILE *picture, in
     while (line[0] == '#')
         if (!fgets(line, 255, picture))
             return NULL;
-    
+
     if (sscanf(line, "%d", &maxval) != 1) {
-        motion_log(LOG_ERR, 1, "Failed reading maximum value in pgm file");
+        MOTION_LOG(ERR, TYPE_ALL, SHOW_ERRNO, "%s: Failed reading maximum value in pgm file");
         return NULL;
     }
-    
-    /* read data */
-    
+
+    /* Read data */
+
     image = mymalloc(width * height);
-    
+
     for (y = 0; y < height; y++) {
         if ((int)fread(&image[y * width], 1, width, picture) != width)
-            motion_log(LOG_ERR, 1, "Failed reading image data from pgm file");
-        
+            MOTION_LOG(ERR, TYPE_ALL, SHOW_ERRNO, "%s: Failed reading image data from pgm file");
+
         for (x = 0; x < width; x++)
             image[y * width + x] = (int)image[y * width + x] * 255 / maxval;
-        
-    }    
+
+    }
 
     return image;
 }
 
-/* If a mask file is asked for but does not exist this function
- * creates an empty mask file in the right binary pgm format and
- * and the right size - easy to edit with Gimp or similar tool.
+/**
+ * put_fixed_mask
+ *      If a mask file is asked for but does not exist this function
+ *      creates an empty mask file in the right binary pgm format and
+ *      and the right size - easy to edit with Gimp or similar tool.
+ *
+ * Returns nothing.
  */
 void put_fixed_mask(struct context *cnt, const char *file)
 {
     FILE *picture;
 
-    picture = myfopen(file, "w");
-    
+    picture = myfopen(file, "w", BUFSIZE_1MEG);
     if (!picture) {
-        /* Report to syslog - suggest solution if the problem is access rights to target dir */
+        /* Report to syslog - suggest solution if the problem is access rights to target dir. */
         if (errno ==  EACCES) {
-            motion_log(LOG_ERR, 1,
-                       "can't write mask file %s - check access rights to target directory", file);
+            MOTION_LOG(ERR, TYPE_ALL, SHOW_ERRNO,
+                       "%s: can't write mask file %s - check access rights to target directory",
+                       file);
         } else {
-            /* If target dir is temporarily unavailable we may survive */
-            motion_log(LOG_ERR, 1, "can't write mask file %s", file);
+            /* If target dir is temporarily unavailable we may survive. */
+            MOTION_LOG(ERR, TYPE_ALL, SHOW_ERRNO, "%s: can't write mask file %s", file);
         }
         return;
     }
+    memset(cnt->imgs.out, 255, cnt->imgs.motionsize); /* Initialize to unset */
 
-    memset(cnt->imgs.out, 255, cnt->imgs.motionsize); /* initialize to unset */
-    
-    /* Write pgm-header */
+    /* Write pgm-header. */
     fprintf(picture, "P5\n");
     fprintf(picture, "%d %d\n", cnt->conf.width, cnt->conf.height);
     fprintf(picture, "%d\n", 255);
-    
-    /* write pgm image data at once */
+
+    /* Write pgm image data at once. */
     if ((int)fwrite(cnt->imgs.out, cnt->conf.width, cnt->conf.height, picture) != cnt->conf.height) {
-        motion_log(LOG_ERR, 1, "Failed writing default mask as pgm file");
+        MOTION_LOG(ERR, TYPE_ALL, SHOW_ERRNO, "%s: Failed writing default mask as pgm file");
         return;
     }
-    
-    fclose(picture);
 
-    motion_log(LOG_ERR, 0, "Creating empty mask %s",cnt->conf.mask_file);
-    motion_log(LOG_ERR, 0, "Please edit this file and re-run motion to enable mask feature");
+    myfclose(picture);
+
+    MOTION_LOG(ERR, TYPE_ALL, NO_ERRNO, "%s: Creating empty mask %s\nPlease edit this file and "
+               "re-run motion to enable mask feature", cnt->conf.mask_file);
 }
 
-/* save preview_shot */
+/**
+ * preview_save
+ *      save preview_shot
+ *
+ * Returns nothing.
+ */
 void preview_save(struct context *cnt)
 {
-#ifdef HAVE_FFMPEG
-    int use_jpegpath;
+    int use_imagepath;
     int basename_len;
-#endif /* HAVE_FFMPEG */
-    const char *jpegpath;
+    const char *imagepath;
     char previewname[PATH_MAX];
     char filename[PATH_MAX];
     struct image_data *saved_current_image;
 
     if (cnt->imgs.preview_image.diffs) {
-        /* Save current global context */
+        /* Save current global context. */
         saved_current_image = cnt->current_image;
-        /* Set global context to the image we are processing */
+        /* Set global context to the image we are processing. */
         cnt->current_image = &cnt->imgs.preview_image;
 
+        /* Use filename of movie i.o. jpeg_filename when set to 'preview'. */
+        use_imagepath = strcmp(cnt->conf.imagepath, "preview");
+
 #ifdef HAVE_FFMPEG
-        /* Use filename of movie i.o. jpeg_filename when set to 'preview' */
-        use_jpegpath = strcmp(cnt->conf.jpegpath, "preview");
-    
-        if (cnt->ffmpeg_new && !use_jpegpath) {
-            /* Replace avi/mpg with jpg/ppm and keep the rest of the filename */
-            basename_len = strlen(cnt->newfilename) - 3;
-            strncpy(previewname, cnt->newfilename, basename_len);
+        if ((cnt->ffmpeg_output || (cnt->conf.useextpipe && cnt->extpipe))
+            && !use_imagepath) {
+#else
+        if ((cnt->conf.useextpipe && cnt->extpipe) && !use_imagepath) {
+#endif
+            if (cnt->conf.useextpipe && cnt->extpipe) {
+                basename_len = strlen(cnt->extpipefilename) + 1;
+                strncpy(previewname, cnt->extpipefilename, basename_len);
+                previewname[basename_len - 1] = '.';
+            } else {
+                /* Replace avi/mpg with jpg/ppm and keep the rest of the filename. */
+                basename_len = strlen(cnt->newfilename) - 3;
+                strncpy(previewname, cnt->newfilename, basename_len);
+            }
+
             previewname[basename_len] = '\0';
             strcat(previewname, imageext(cnt));
             put_picture(cnt, previewname, cnt->imgs.preview_image.image , FTYPE_IMAGE);
-        } else
-#endif /* HAVE_FFMPEG */
-        {
-            /* Save best preview-shot also when no movies are recorded or jpegpath
-             * is used. Filename has to be generated - nothing available to reuse! */
-            //printf("preview_shot: different filename or picture only!\n");
-
-            /* conf.jpegpath would normally be defined but if someone deleted it by control interface
-             * it is better to revert to the default than fail */
-            if (cnt->conf.jpegpath)
-                jpegpath = cnt->conf.jpegpath;
+        } else {
+            /*
+             * Save best preview-shot also when no movies are recorded or imagepath
+             * is used. Filename has to be generated - nothing available to reuse!
+             */
+            MOTION_LOG(NTC, TYPE_ALL, NO_ERRNO, "%s: different filename or picture only!");
+            /*
+             * conf.imagepath would normally be defined but if someone deleted it by
+             * control interface it is better to revert to the default than fail.
+             */
+            if (cnt->conf.imagepath)
+                imagepath = cnt->conf.imagepath;
             else
-                jpegpath = (char *)DEF_JPEGPATH;
-            
-            mystrftime(cnt, filename, sizeof(filename), jpegpath, &cnt->imgs.preview_image.timestamp_tm, NULL, 0);
+                imagepath = (char *)DEF_IMAGEPATH;
+
+            mystrftime(cnt, filename, sizeof(filename), imagepath, &cnt->imgs.preview_image.timestamp_tm, NULL, 0);
             snprintf(previewname, PATH_MAX, "%s/%s.%s", cnt->conf.filepath, filename, imageext(cnt));
 
             put_picture(cnt, previewname, cnt->imgs.preview_image.image, FTYPE_IMAGE);
         }
 
-        /* restore global context values */
+        /* Restore global context values. */
         cnt->current_image = saved_current_image;
     }
 }
--- motion-3.2.12.orig/picture.h
+++ motion-3.2.12/picture.h
@@ -18,7 +18,7 @@ void put_fixed_mask(struct context *, co
 void overlay_largest_label(struct context *, unsigned char *);
 void put_picture_fd(struct context *, FILE *, unsigned char *, int);
 int put_picture_memory(struct context *, unsigned char*, int, unsigned char *, int);
-void put_picture(struct context *, char *, unsigned char *, int );
+void put_picture(struct context *, char *, unsigned char *, int);
 unsigned char *get_pgm(FILE *, int, int);
 void preview_save(struct context *);
 
--- motion-3.2.12.orig/pwc-ioctl.h
+++ motion-3.2.12/pwc-ioctl.h
@@ -45,11 +45,11 @@
    specified in the Video4Linux API.
 
    The #define names are built up like follows:
-   VIDIOC		VIDeo IOCtl prefix
-         PWC		Philps WebCam
+   VIDIOC        VIDeo IOCtl prefix
+         PWC        Philps WebCam
             G           optional: Get
             S           optional: Set
-             ... 	the function
+             ...     the function
  */
 
 #if (!defined(BSD))
@@ -64,13 +64,13 @@ typedef __u16 __le16;
 #endif /* ( !BSD ) */
 
  /* Enumeration of image sizes */
-#define PSZ_SQCIF	0x00
-#define PSZ_QSIF	0x01
-#define PSZ_QCIF	0x02
-#define PSZ_SIF		0x03
-#define PSZ_CIF		0x04
-#define PSZ_VGA		0x05
-#define PSZ_MAX		6
+#define PSZ_SQCIF   0x00
+#define PSZ_QSIF    0x01
+#define PSZ_QCIF    0x02
+#define PSZ_SIF     0x03
+#define PSZ_CIF     0x04
+#define PSZ_VGA     0x05
+#define PSZ_MAX     6
 
 
 /* The frame rate is encoded in the video_window.flags parameter using
@@ -82,40 +82,40 @@ typedef __u16 __le16;
    In 'Snapshot' mode the camera freezes its automatic exposure and colour
    balance controls.
  */
-#define PWC_FPS_SHIFT		16
-#define PWC_FPS_MASK		0x00FF0000
-#define PWC_FPS_FRMASK		0x003F0000
-#define PWC_FPS_SNAPSHOT	0x00400000
-#define PWC_QLT_MASK		0x03000000
-#define PWC_QLT_SHIFT		24
+#define PWC_FPS_SHIFT       16
+#define PWC_FPS_MASK        0x00FF0000
+#define PWC_FPS_FRMASK      0x003F0000
+#define PWC_FPS_SNAPSHOT    0x00400000
+#define PWC_QLT_MASK        0x03000000
+#define PWC_QLT_SHIFT       24
 
 
 /* structure for transferring x & y coordinates */
 struct pwc_coord
 {
-	int x, y;		/* guess what */
-	int size;		/* size, or offset */
+    int x, y;        /* guess what */
+    int size;        /* size, or offset */
 };
 
 
 /* Used with VIDIOCPWCPROBE */
 struct pwc_probe
 {
-	char name[32];
-	int type;
+    char name[32];
+    int type;
 };
 
 struct pwc_serial
 {
-	char serial[30];	/* String with serial number. Contains terminating 0 */
+    char serial[30];    /* String with serial number. Contains terminating 0 */
 };
-	
+    
 /* pwc_whitebalance.mode values */
-#define PWC_WB_INDOOR		0
-#define PWC_WB_OUTDOOR		1
-#define PWC_WB_FL		2
-#define PWC_WB_MANUAL		3
-#define PWC_WB_AUTO		4
+#define PWC_WB_INDOOR        0
+#define PWC_WB_OUTDOOR       1
+#define PWC_WB_FL            2
+#define PWC_WB_MANUAL        3
+#define PWC_WB_AUTO          4
 
 /* Used with VIDIOCPWC[SG]AWB (Auto White Balance). 
    Set mode to one of the PWC_WB_* values above.
@@ -127,9 +127,9 @@ struct pwc_serial
 */   
 struct pwc_whitebalance
 {
-	int mode;
-	int manual_red, manual_blue;	/* R/W */
-	int read_red, read_blue;	/* R/O */
+    int mode;
+    int manual_red, manual_blue;  /* R/W */
+    int read_red, read_blue;      /* R/O */
 };
 
 /* 
@@ -139,29 +139,29 @@ struct pwc_whitebalance
 */
 struct pwc_wb_speed
 {
-	int control_speed;
-	int control_delay;
+    int control_speed;
+    int control_delay;
 
 };
 
 /* Used with VIDIOCPWC[SG]LED */
 struct pwc_leds
 {
-	int led_on;			/* Led on-time; range = 0..25000 */
-	int led_off;			/* Led off-time; range = 0..25000  */
+    int led_on;             /* Led on-time; range = 0..25000 */
+    int led_off;            /* Led off-time; range = 0..25000  */
 };
 
 /* Image size (used with GREALSIZE) */
 struct pwc_imagesize
 {
-	int width;
-	int height;
+    int width;
+    int height;
 };
 
 /* Defines and structures for Motorized Pan & Tilt */
-#define PWC_MPT_PAN		0x01
-#define PWC_MPT_TILT		0x02
-#define PWC_MPT_TIMEOUT		0x04 /* for status */
+#define PWC_MPT_PAN        0x01
+#define PWC_MPT_TILT       0x02
+#define PWC_MPT_TIMEOUT    0x04 /* for status */
 
 /* Set angles; when absolute != 0, the angle is absolute and the 
    driver calculates the relative offset for you. This can only
@@ -170,24 +170,24 @@ struct pwc_imagesize
  */   
 struct pwc_mpt_angles
 {
-	int absolute;		/* write-only */
-	int pan;		/* degrees * 100 */
-	int tilt;		/* degress * 100 */
+    int absolute;   /* write-only */
+    int pan;        /* degrees * 100 */
+    int tilt;       /* degress * 100 */
 };
 
 /* Range of angles of the camera, both horizontally and vertically.
  */
 struct pwc_mpt_range
 {
-	int pan_min, pan_max;		/* degrees * 100 */
-	int tilt_min, tilt_max;
+    int pan_min, pan_max;        /* degrees * 100 */
+    int tilt_min, tilt_max;
 };
 
 struct pwc_mpt_status
 {
-	int status;
-	int time_pan;
-	int time_tilt;
+    int status;
+    int time_pan;
+    int time_tilt;
 };
 
 
@@ -197,30 +197,30 @@ struct pwc_mpt_status
  */   
 struct pwc_video_command
 {
-	int type;		/* camera type (645, 675, 730, etc.) */
-	int release;		/* release number */
+    int type;                       /* camera type (645, 675, 730, etc.) */
+    int release;                    /* release number */
 
-        int size;		/* one of PSZ_* */
-        int alternate;
-	int command_len;	/* length of USB video command */
-	unsigned char command_buf[13];	/* Actual USB video command */
-	int bandlength;		/* >0 = compressed */
-	int frame_size;		/* Size of one (un)compressed frame */
+    int size;                       /* one of PSZ_* */
+    int alternate;
+    int command_len;                /* length of USB video command */
+    unsigned char command_buf[13];  /* Actual USB video command */
+    int bandlength;                 /* >0 = compressed */
+    int frame_size;                 /* Size of one (un)compressed frame */
 };
 
 /* Flags for PWCX subroutines. Not all modules honour all flags. */
-#define PWCX_FLAG_PLANAR	0x0001
-#define PWCX_FLAG_BAYER		0x0008
+#define PWCX_FLAG_PLANAR    0x0001
+#define PWCX_FLAG_BAYER     0x0008
 
 
 /* IOCTL definitions */
 
  /* Restore user settings */
-#define VIDIOCPWCRUSER		_IO('v', 192)
+#define VIDIOCPWCRUSER        _IO('v', 192)
  /* Save user settings */
-#define VIDIOCPWCSUSER		_IO('v', 193)
+#define VIDIOCPWCSUSER        _IO('v', 193)
  /* Restore factory settings */
-#define VIDIOCPWCFACTORY	_IO('v', 194)
+#define VIDIOCPWCFACTORY      _IO('v', 194)
 
  /* You can manipulate the compression factor. A compression preference of 0
     means use uncompressed modes when available; 1 is low compression, 2 is
@@ -230,13 +230,13 @@ struct pwc_video_command
     the preferred mode is not available.
   */
  /* Set preferred compression quality (0 = uncompressed, 3 = highest compression) */
-#define VIDIOCPWCSCQUAL		_IOW('v', 195, int)
+#define VIDIOCPWCSCQUAL       _IOW('v', 195, int)
  /* Get preferred compression quality */
-#define VIDIOCPWCGCQUAL		_IOR('v', 195, int)
+#define VIDIOCPWCGCQUAL       _IOR('v', 195, int)
 
 
 /* Retrieve serial number of camera */
-#define VIDIOCPWCGSERIAL	_IOR('v', 198, struct pwc_serial)
+#define VIDIOCPWCGSERIAL      _IOR('v', 198, struct pwc_serial)
 
  /* This is a probe function; since so many devices are supported, it
     becomes difficult to include all the names in programs that want to
@@ -248,61 +248,60 @@ struct pwc_video_command
     same. If so, you can be assured it is a Philips (OEM) cam and the type
     is valid.
  */
-#define VIDIOCPWCPROBE		_IOR('v', 199, struct pwc_probe)
+#define VIDIOCPWCPROBE        _IOR('v', 199, struct pwc_probe)
 
  /* Set AGC (Automatic Gain Control); int < 0 = auto, 0..65535 = fixed */
-#define VIDIOCPWCSAGC		_IOW('v', 200, int)
+#define VIDIOCPWCSAGC         _IOW('v', 200, int)
  /* Get AGC; int < 0 = auto; >= 0 = fixed, range 0..65535 */
-#define VIDIOCPWCGAGC		_IOR('v', 200, int)
+#define VIDIOCPWCGAGC         _IOR('v', 200, int)
  /* Set shutter speed; int < 0 = auto; >= 0 = fixed, range 0..65535 */
-#define VIDIOCPWCSSHUTTER	_IOW('v', 201, int)
+#define VIDIOCPWCSSHUTTER     _IOW('v', 201, int)
 
  /* Color compensation (Auto White Balance) */
-#define VIDIOCPWCSAWB           _IOW('v', 202, struct pwc_whitebalance)
-#define VIDIOCPWCGAWB           _IOR('v', 202, struct pwc_whitebalance)
+#define VIDIOCPWCSAWB         _IOW('v', 202, struct pwc_whitebalance)
+#define VIDIOCPWCGAWB         _IOR('v', 202, struct pwc_whitebalance)
 
  /* Auto WB speed */
-#define VIDIOCPWCSAWBSPEED	_IOW('v', 203, struct pwc_wb_speed)
-#define VIDIOCPWCGAWBSPEED	_IOR('v', 203, struct pwc_wb_speed)
+#define VIDIOCPWCSAWBSPEED    _IOW('v', 203, struct pwc_wb_speed)
+#define VIDIOCPWCGAWBSPEED    _IOR('v', 203, struct pwc_wb_speed)
 
  /* LEDs on/off/blink; int range 0..65535 */
-#define VIDIOCPWCSLED           _IOW('v', 205, struct pwc_leds)
-#define VIDIOCPWCGLED           _IOR('v', 205, struct pwc_leds)
+#define VIDIOCPWCSLED         _IOW('v', 205, struct pwc_leds)
+#define VIDIOCPWCGLED         _IOR('v', 205, struct pwc_leds)
 
   /* Contour (sharpness); int < 0 = auto, 0..65536 = fixed */
-#define VIDIOCPWCSCONTOUR	_IOW('v', 206, int)
-#define VIDIOCPWCGCONTOUR	_IOR('v', 206, int)
+#define VIDIOCPWCSCONTOUR     _IOW('v', 206, int)
+#define VIDIOCPWCGCONTOUR     _IOR('v', 206, int)
 
   /* Backlight compensation; 0 = off, otherwise on */
-#define VIDIOCPWCSBACKLIGHT	_IOW('v', 207, int)
-#define VIDIOCPWCGBACKLIGHT	_IOR('v', 207, int)
+#define VIDIOCPWCSBACKLIGHT   _IOW('v', 207, int)
+#define VIDIOCPWCGBACKLIGHT   _IOR('v', 207, int)
 
   /* Flickerless mode; = 0 off, otherwise on */
-#define VIDIOCPWCSFLICKER	_IOW('v', 208, int)
-#define VIDIOCPWCGFLICKER	_IOR('v', 208, int)  
+#define VIDIOCPWCSFLICKER     _IOW('v', 208, int)
+#define VIDIOCPWCGFLICKER     _IOR('v', 208, int)  
 
   /* Dynamic noise reduction; 0 off, 3 = high noise reduction */
-#define VIDIOCPWCSDYNNOISE	_IOW('v', 209, int)
-#define VIDIOCPWCGDYNNOISE	_IOR('v', 209, int)
+#define VIDIOCPWCSDYNNOISE    _IOW('v', 209, int)
+#define VIDIOCPWCGDYNNOISE    _IOR('v', 209, int)
 
  /* Real image size as used by the camera; tells you whether or not there's a gray border around the image */
-#define VIDIOCPWCGREALSIZE	_IOR('v', 210, struct pwc_imagesize)
+#define VIDIOCPWCGREALSIZE    _IOR('v', 210, struct pwc_imagesize)
 
  /* Motorized pan & tilt functions */ 
-#define VIDIOCPWCMPTRESET	_IOW('v', 211, int)
-#define VIDIOCPWCMPTGRANGE	_IOR('v', 211, struct pwc_mpt_range)
-#define VIDIOCPWCMPTSANGLE	_IOW('v', 212, struct pwc_mpt_angles)
-#define VIDIOCPWCMPTGANGLE	_IOR('v', 212, struct pwc_mpt_angles)
-#define VIDIOCPWCMPTSTATUS	_IOR('v', 213, struct pwc_mpt_status)
+#define VIDIOCPWCMPTRESET     _IOW('v', 211, int)
+#define VIDIOCPWCMPTGRANGE    _IOR('v', 211, struct pwc_mpt_range)
+#define VIDIOCPWCMPTSANGLE    _IOW('v', 212, struct pwc_mpt_angles)
+#define VIDIOCPWCMPTGANGLE    _IOR('v', 212, struct pwc_mpt_angles)
+#define VIDIOCPWCMPTSTATUS    _IOR('v', 213, struct pwc_mpt_status)
 
  /* Get the USB set-video command; needed for initializing libpwcx */
-#define VIDIOCPWCGVIDCMD	_IOR('v', 215, struct pwc_video_command)
+#define VIDIOCPWCGVIDCMD      _IOR('v', 215, struct pwc_video_command)
 struct pwc_table_init_buffer {
    int len;
    char *buffer;
-
 };
-#define VIDIOCPWCGVIDTABLE	_IOR('v', 216, struct pwc_table_init_buffer)
+#define VIDIOCPWCGVIDTABLE    _IOR('v', 216, struct pwc_table_init_buffer)
 
 /*
  * This is private command used when communicating with v4l2.
@@ -323,13 +322,13 @@ struct pwc_table_init_buffer {
 #define V4L2_CID_PRIVATE_NOISE_REDUCTION (V4L2_CID_PRIVATE_BASE + 8)
 
 struct pwc_raw_frame {
-   __le16 type;		/* type of the webcam */
-   __le16 vbandlength;	/* Size of 4lines compressed (used by the decompressor) */
-   __u8   cmd[4];	/* the four byte of the command (in case of nala,
-			   only the first 3 bytes is filled) */
-   __u8   rawframe[0];	/* frame_size = H/4*vbandlength */
+   __le16 type;           /* type of the webcam */
+   __le16 vbandlength;    /* Size of 4lines compressed (used by the decompressor) */
+   __u8   cmd[4];         /* the four byte of the command (in case of nala,
+                             only the first 3 bytes is filled) */
+   __u8   rawframe[0];    /* frame_size = H/4*vbandlength */
 } __attribute__ ((packed));
 
-#endif	/*  MOTION_V4L2 && (! BSD ) */
+#endif    /*  MOTION_V4L2 && (! BSD ) */
 
 #endif
--- motion-3.2.12.orig/pwc-ioctl.h-10.0.10
+++ motion-3.2.12/pwc-ioctl.h-10.0.10
@@ -45,13 +45,14 @@
    specified in the Video4Linux API.
 
    The #define names are built up like follows:
-   VIDIOC		VIDeo IOCtl prefix
-         PWC		Philps WebCam
+   VIDIOC        VIDeo IOCtl prefix
+         PWC        Philps WebCam
             G           optional: Get
             S           optional: Set
-             ... 	the function
+             ...     the function
  */
 
+#if (!defined(BSD))
 #include <linux/types.h>
 #include <linux/version.h>
 
@@ -60,14 +61,16 @@
 typedef __u16 __le16;
 #endif
 
+#endif /* ( !BSD ) */
+
  /* Enumeration of image sizes */
-#define PSZ_SQCIF	0x00
-#define PSZ_QSIF	0x01
-#define PSZ_QCIF	0x02
-#define PSZ_SIF		0x03
-#define PSZ_CIF		0x04
-#define PSZ_VGA		0x05
-#define PSZ_MAX		6
+#define PSZ_SQCIF   0x00
+#define PSZ_QSIF    0x01
+#define PSZ_QCIF    0x02
+#define PSZ_SIF     0x03
+#define PSZ_CIF     0x04
+#define PSZ_VGA     0x05
+#define PSZ_MAX     6
 
 
 /* The frame rate is encoded in the video_window.flags parameter using
@@ -79,40 +82,40 @@ typedef __u16 __le16;
    In 'Snapshot' mode the camera freezes its automatic exposure and colour
    balance controls.
  */
-#define PWC_FPS_SHIFT		16
-#define PWC_FPS_MASK		0x00FF0000
-#define PWC_FPS_FRMASK		0x003F0000
-#define PWC_FPS_SNAPSHOT	0x00400000
-#define PWC_QLT_MASK		0x03000000
-#define PWC_QLT_SHIFT		24
+#define PWC_FPS_SHIFT       16
+#define PWC_FPS_MASK        0x00FF0000
+#define PWC_FPS_FRMASK      0x003F0000
+#define PWC_FPS_SNAPSHOT    0x00400000
+#define PWC_QLT_MASK        0x03000000
+#define PWC_QLT_SHIFT       24
 
 
 /* structure for transferring x & y coordinates */
 struct pwc_coord
 {
-	int x, y;		/* guess what */
-	int size;		/* size, or offset */
+    int x, y;        /* guess what */
+    int size;        /* size, or offset */
 };
 
 
 /* Used with VIDIOCPWCPROBE */
 struct pwc_probe
 {
-	char name[32];
-	int type;
+    char name[32];
+    int type;
 };
 
 struct pwc_serial
 {
-	char serial[30];	/* String with serial number. Contains terminating 0 */
+    char serial[30];    /* String with serial number. Contains terminating 0 */
 };
-	
+    
 /* pwc_whitebalance.mode values */
-#define PWC_WB_INDOOR		0
-#define PWC_WB_OUTDOOR		1
-#define PWC_WB_FL		2
-#define PWC_WB_MANUAL		3
-#define PWC_WB_AUTO		4
+#define PWC_WB_INDOOR        0
+#define PWC_WB_OUTDOOR       1
+#define PWC_WB_FL            2
+#define PWC_WB_MANUAL        3
+#define PWC_WB_AUTO          4
 
 /* Used with VIDIOCPWC[SG]AWB (Auto White Balance). 
    Set mode to one of the PWC_WB_* values above.
@@ -124,9 +127,9 @@ struct pwc_serial
 */   
 struct pwc_whitebalance
 {
-	int mode;
-	int manual_red, manual_blue;	/* R/W */
-	int read_red, read_blue;	/* R/O */
+    int mode;
+    int manual_red, manual_blue;  /* R/W */
+    int read_red, read_blue;      /* R/O */
 };
 
 /* 
@@ -136,29 +139,29 @@ struct pwc_whitebalance
 */
 struct pwc_wb_speed
 {
-	int control_speed;
-	int control_delay;
+    int control_speed;
+    int control_delay;
 
 };
 
 /* Used with VIDIOCPWC[SG]LED */
 struct pwc_leds
 {
-	int led_on;			/* Led on-time; range = 0..25000 */
-	int led_off;			/* Led off-time; range = 0..25000  */
+    int led_on;             /* Led on-time; range = 0..25000 */
+    int led_off;            /* Led off-time; range = 0..25000  */
 };
 
 /* Image size (used with GREALSIZE) */
 struct pwc_imagesize
 {
-	int width;
-	int height;
+    int width;
+    int height;
 };
 
 /* Defines and structures for Motorized Pan & Tilt */
-#define PWC_MPT_PAN		0x01
-#define PWC_MPT_TILT		0x02
-#define PWC_MPT_TIMEOUT		0x04 /* for status */
+#define PWC_MPT_PAN        0x01
+#define PWC_MPT_TILT       0x02
+#define PWC_MPT_TIMEOUT    0x04 /* for status */
 
 /* Set angles; when absolute != 0, the angle is absolute and the 
    driver calculates the relative offset for you. This can only
@@ -167,24 +170,24 @@ struct pwc_imagesize
  */   
 struct pwc_mpt_angles
 {
-	int absolute;		/* write-only */
-	int pan;		/* degrees * 100 */
-	int tilt;		/* degress * 100 */
+    int absolute;   /* write-only */
+    int pan;        /* degrees * 100 */
+    int tilt;       /* degress * 100 */
 };
 
 /* Range of angles of the camera, both horizontally and vertically.
  */
 struct pwc_mpt_range
 {
-	int pan_min, pan_max;		/* degrees * 100 */
-	int tilt_min, tilt_max;
+    int pan_min, pan_max;        /* degrees * 100 */
+    int tilt_min, tilt_max;
 };
 
 struct pwc_mpt_status
 {
-	int status;
-	int time_pan;
-	int time_tilt;
+    int status;
+    int time_pan;
+    int time_tilt;
 };
 
 
@@ -194,30 +197,30 @@ struct pwc_mpt_status
  */   
 struct pwc_video_command
 {
-	int type;		/* camera type (645, 675, 730, etc.) */
-	int release;		/* release number */
+    int type;                       /* camera type (645, 675, 730, etc.) */
+    int release;                    /* release number */
 
-        int size;		/* one of PSZ_* */
-        int alternate;
-	int command_len;	/* length of USB video command */
-	unsigned char command_buf[13];	/* Actual USB video command */
-	int bandlength;		/* >0 = compressed */
-	int frame_size;		/* Size of one (un)compressed frame */
+    int size;                       /* one of PSZ_* */
+    int alternate;
+    int command_len;                /* length of USB video command */
+    unsigned char command_buf[13];  /* Actual USB video command */
+    int bandlength;                 /* >0 = compressed */
+    int frame_size;                 /* Size of one (un)compressed frame */
 };
 
 /* Flags for PWCX subroutines. Not all modules honour all flags. */
-#define PWCX_FLAG_PLANAR	0x0001
-#define PWCX_FLAG_BAYER		0x0008
+#define PWCX_FLAG_PLANAR    0x0001
+#define PWCX_FLAG_BAYER     0x0008
 
 
 /* IOCTL definitions */
 
  /* Restore user settings */
-#define VIDIOCPWCRUSER		_IO('v', 192)
+#define VIDIOCPWCRUSER        _IO('v', 192)
  /* Save user settings */
-#define VIDIOCPWCSUSER		_IO('v', 193)
+#define VIDIOCPWCSUSER        _IO('v', 193)
  /* Restore factory settings */
-#define VIDIOCPWCFACTORY	_IO('v', 194)
+#define VIDIOCPWCFACTORY      _IO('v', 194)
 
  /* You can manipulate the compression factor. A compression preference of 0
     means use uncompressed modes when available; 1 is low compression, 2 is
@@ -227,13 +230,13 @@ struct pwc_video_command
     the preferred mode is not available.
   */
  /* Set preferred compression quality (0 = uncompressed, 3 = highest compression) */
-#define VIDIOCPWCSCQUAL		_IOW('v', 195, int)
+#define VIDIOCPWCSCQUAL       _IOW('v', 195, int)
  /* Get preferred compression quality */
-#define VIDIOCPWCGCQUAL		_IOR('v', 195, int)
+#define VIDIOCPWCGCQUAL       _IOR('v', 195, int)
 
 
 /* Retrieve serial number of camera */
-#define VIDIOCPWCGSERIAL	_IOR('v', 198, struct pwc_serial)
+#define VIDIOCPWCGSERIAL      _IOR('v', 198, struct pwc_serial)
 
  /* This is a probe function; since so many devices are supported, it
     becomes difficult to include all the names in programs that want to
@@ -245,61 +248,60 @@ struct pwc_video_command
     same. If so, you can be assured it is a Philips (OEM) cam and the type
     is valid.
  */
-#define VIDIOCPWCPROBE		_IOR('v', 199, struct pwc_probe)
+#define VIDIOCPWCPROBE        _IOR('v', 199, struct pwc_probe)
 
  /* Set AGC (Automatic Gain Control); int < 0 = auto, 0..65535 = fixed */
-#define VIDIOCPWCSAGC		_IOW('v', 200, int)
+#define VIDIOCPWCSAGC         _IOW('v', 200, int)
  /* Get AGC; int < 0 = auto; >= 0 = fixed, range 0..65535 */
-#define VIDIOCPWCGAGC		_IOR('v', 200, int)
+#define VIDIOCPWCGAGC         _IOR('v', 200, int)
  /* Set shutter speed; int < 0 = auto; >= 0 = fixed, range 0..65535 */
-#define VIDIOCPWCSSHUTTER	_IOW('v', 201, int)
+#define VIDIOCPWCSSHUTTER     _IOW('v', 201, int)
 
  /* Color compensation (Auto White Balance) */
-#define VIDIOCPWCSAWB           _IOW('v', 202, struct pwc_whitebalance)
-#define VIDIOCPWCGAWB           _IOR('v', 202, struct pwc_whitebalance)
+#define VIDIOCPWCSAWB         _IOW('v', 202, struct pwc_whitebalance)
+#define VIDIOCPWCGAWB         _IOR('v', 202, struct pwc_whitebalance)
 
  /* Auto WB speed */
-#define VIDIOCPWCSAWBSPEED	_IOW('v', 203, struct pwc_wb_speed)
-#define VIDIOCPWCGAWBSPEED	_IOR('v', 203, struct pwc_wb_speed)
+#define VIDIOCPWCSAWBSPEED    _IOW('v', 203, struct pwc_wb_speed)
+#define VIDIOCPWCGAWBSPEED    _IOR('v', 203, struct pwc_wb_speed)
 
  /* LEDs on/off/blink; int range 0..65535 */
-#define VIDIOCPWCSLED           _IOW('v', 205, struct pwc_leds)
-#define VIDIOCPWCGLED           _IOR('v', 205, struct pwc_leds)
+#define VIDIOCPWCSLED         _IOW('v', 205, struct pwc_leds)
+#define VIDIOCPWCGLED         _IOR('v', 205, struct pwc_leds)
 
   /* Contour (sharpness); int < 0 = auto, 0..65536 = fixed */
-#define VIDIOCPWCSCONTOUR	_IOW('v', 206, int)
-#define VIDIOCPWCGCONTOUR	_IOR('v', 206, int)
+#define VIDIOCPWCSCONTOUR     _IOW('v', 206, int)
+#define VIDIOCPWCGCONTOUR     _IOR('v', 206, int)
 
   /* Backlight compensation; 0 = off, otherwise on */
-#define VIDIOCPWCSBACKLIGHT	_IOW('v', 207, int)
-#define VIDIOCPWCGBACKLIGHT	_IOR('v', 207, int)
+#define VIDIOCPWCSBACKLIGHT   _IOW('v', 207, int)
+#define VIDIOCPWCGBACKLIGHT   _IOR('v', 207, int)
 
   /* Flickerless mode; = 0 off, otherwise on */
-#define VIDIOCPWCSFLICKER	_IOW('v', 208, int)
-#define VIDIOCPWCGFLICKER	_IOR('v', 208, int)  
+#define VIDIOCPWCSFLICKER     _IOW('v', 208, int)
+#define VIDIOCPWCGFLICKER     _IOR('v', 208, int)  
 
   /* Dynamic noise reduction; 0 off, 3 = high noise reduction */
-#define VIDIOCPWCSDYNNOISE	_IOW('v', 209, int)
-#define VIDIOCPWCGDYNNOISE	_IOR('v', 209, int)
+#define VIDIOCPWCSDYNNOISE    _IOW('v', 209, int)
+#define VIDIOCPWCGDYNNOISE    _IOR('v', 209, int)
 
  /* Real image size as used by the camera; tells you whether or not there's a gray border around the image */
-#define VIDIOCPWCGREALSIZE	_IOR('v', 210, struct pwc_imagesize)
+#define VIDIOCPWCGREALSIZE    _IOR('v', 210, struct pwc_imagesize)
 
  /* Motorized pan & tilt functions */ 
-#define VIDIOCPWCMPTRESET	_IOW('v', 211, int)
-#define VIDIOCPWCMPTGRANGE	_IOR('v', 211, struct pwc_mpt_range)
-#define VIDIOCPWCMPTSANGLE	_IOW('v', 212, struct pwc_mpt_angles)
-#define VIDIOCPWCMPTGANGLE	_IOR('v', 212, struct pwc_mpt_angles)
-#define VIDIOCPWCMPTSTATUS	_IOR('v', 213, struct pwc_mpt_status)
+#define VIDIOCPWCMPTRESET     _IOW('v', 211, int)
+#define VIDIOCPWCMPTGRANGE    _IOR('v', 211, struct pwc_mpt_range)
+#define VIDIOCPWCMPTSANGLE    _IOW('v', 212, struct pwc_mpt_angles)
+#define VIDIOCPWCMPTGANGLE    _IOR('v', 212, struct pwc_mpt_angles)
+#define VIDIOCPWCMPTSTATUS    _IOR('v', 213, struct pwc_mpt_status)
 
  /* Get the USB set-video command; needed for initializing libpwcx */
-#define VIDIOCPWCGVIDCMD	_IOR('v', 215, struct pwc_video_command)
+#define VIDIOCPWCGVIDCMD      _IOR('v', 215, struct pwc_video_command)
 struct pwc_table_init_buffer {
    int len;
    char *buffer;
-
 };
-#define VIDIOCPWCGVIDTABLE	_IOR('v', 216, struct pwc_table_init_buffer)
+#define VIDIOCPWCGVIDTABLE    _IOR('v', 216, struct pwc_table_init_buffer)
 
 /*
  * This is private command used when communicating with v4l2.
@@ -307,6 +309,8 @@ struct pwc_table_init_buffer {
  * use interface offer by v4l2.
  */
 
+#if (defined(MOTION_V4L2)) && (!defined(BSD))
+
 #define V4L2_CID_PRIVATE_SAVE_USER       (V4L2_CID_PRIVATE_BASE + 0)
 #define V4L2_CID_PRIVATE_RESTORE_USER    (V4L2_CID_PRIVATE_BASE + 1)
 #define V4L2_CID_PRIVATE_RESTORE_FACTORY (V4L2_CID_PRIVATE_BASE + 2)
@@ -318,12 +322,13 @@ struct pwc_table_init_buffer {
 #define V4L2_CID_PRIVATE_NOISE_REDUCTION (V4L2_CID_PRIVATE_BASE + 8)
 
 struct pwc_raw_frame {
-   __le16 type;		/* type of the webcam */
-   __le16 vbandlength;	/* Size of 4lines compressed (used by the decompressor) */
-   __u8   cmd[4];	/* the four byte of the command (in case of nala,
-			   only the first 3 bytes is filled) */
-   __u8   rawframe[0];	/* frame_size = H/4*vbandlength */
+   __le16 type;           /* type of the webcam */
+   __le16 vbandlength;    /* Size of 4lines compressed (used by the decompressor) */
+   __u8   cmd[4];         /* the four byte of the command (in case of nala,
+                             only the first 3 bytes is filled) */
+   __u8   rawframe[0];    /* frame_size = H/4*vbandlength */
 } __attribute__ ((packed));
 
+#endif    /*  MOTION_V4L2 && (! BSD ) */
 
 #endif
--- motion-3.2.12.orig/rotate.c
+++ motion-3.2.12/rotate.c
@@ -4,13 +4,13 @@
  *    Module for handling image rotation.
  *
  *    Copyright 2004-2005, Per Jonsson (per@pjd.nu)
- *    
+ *
  *    This software is distributed under the GNU Public license
  *    Version 2.  See also the file 'COPYING'.
  *
  *    Image rotation is a feature of Motion that can be used when the
  *    camera is mounted upside-down or on the side. The module only
- *    supports rotation in multiples of 90 degrees. Using rotation 
+ *    supports rotation in multiples of 90 degrees. Using rotation
  *    increases the Motion CPU usage slightly.
  *
  *    Version history:
@@ -21,8 +21,8 @@
  *                       - fix for __bswap_32 macro collision
  *                       - fixed bug where initialization would be
  *                         incomplete for invalid degrees of rotation
- *                       - now uses motion_log for error reporting
- *      v4 (26-Oct-2004) - new fix for width/height from imgs/conf due to 
+ *                       - now uses MOTION_LOG for error reporting
+ *      v4 (26-Oct-2004) - new fix for width/height from imgs/conf due to
  *                         earlier misinterpretation
  *      v3 (11-Oct-2004) - cleanup of width/height from imgs/conf
  *      v2 (26-Sep-2004) - separation of capture/internal dimensions
@@ -49,30 +49,30 @@ typedef unsigned TYPE_32BIT __uint32;
 
 /**
  * The code below is copied (with modification) from bits/byteswap.h. It provides
- * a macro/function named rot__bswap_32 that swaps the bytes in a 32-bit integer, 
+ * a macro/function named rot__bswap_32 that swaps the bytes in a 32-bit integer,
  * preferably using the bswap assembler instruction if configure found support
  * for it.
  *
  * It would be neater to simply include byteswap.h and use the bswap_32 macro
  * defined there, but the problem is that the bswap asm instruction would then
- * only be used for certain processor architectures, excluding athlon (and 
+ * only be used for certain processor architectures, excluding athlon (and
  * probably athlon64 as well). Moreover, byteswap.h doesn't seem to exist on
  * FreeBSD. So, we rely on the HAVE_BSWAP macro defined by configure instead.
  *
- * Note that the macro names have been prefixed with "rot" in order to avoid 
- * collision since we have the include chain rotate.h -> motion.h -> netcam.h -> 
+ * Note that the macro names have been prefixed with "rot" in order to avoid
+ * collision since we have the include chain rotate.h -> motion.h -> netcam.h ->
  * netinet/in.h -> ... -> byteswap.h -> bits/byteswap.h.
  */
 
 /* Swap bytes in 32 bit value. This is used as a fallback and for constants. */
-#define rot__bswap_constant_32(x)                                   \
-    ((((x) & 0xff000000) >> 24) | (((x) & 0x00ff0000) >>  8) |      \
+#define rot__bswap_constant_32(x)                               \
+    ((((x) & 0xff000000) >> 24) | (((x) & 0x00ff0000) >>  8) |  \
      (((x) & 0x0000ff00) <<  8) | (((x) & 0x000000ff) << 24))
 
 #ifdef __GNUC__
 #    if (__GNUC__ >= 2) && (i386 || __i386 || __i386__)
-/* We're on an Intel-compatible platform, so we can use inline Intel assembler 
- * for the swapping. 
+/* We're on an Intel-compatible platform, so we can use inline Intel assembler
+ * for the swapping.
  */
 #        ifndef HAVE_BSWAP
 /* Bswap is not available, we have to use three instructions instead. */
@@ -108,7 +108,7 @@ typedef unsigned TYPE_32BIT __uint32;
 #    endif
 #else
 /* Not a GNU compiler. */
-static inline __uint32 rot__bswap_32(__uint32 __bsx) 
+static inline __uint32 rot__bswap_32(__uint32 __bsx)
 {
     return __bswap_constant_32 (__bsx);
 }
@@ -123,18 +123,18 @@ static inline __uint32 rot__bswap_32(__u
 
 /**
  * reverse_inplace_quad
- * 
+ *
  *  Reverses a block of memory in-place, 4 bytes at a time. This function
  *  requires the __uint32 type, which is 32 bits wide.
  *
  * Parameters:
- * 
+ *
  *   src  - the memory block to reverse
  *   size - the size (in bytes) of the memory block
  *
  * Returns: nothing
  */
-static void reverse_inplace_quad(unsigned char *src, int size) 
+static void reverse_inplace_quad(unsigned char *src, int size)
 {
     __uint32 *nsrc = (__uint32 *)src;              /* first quad */
     __uint32 *ndst = (__uint32 *)(src + size - 4); /* last quad */
@@ -149,13 +149,13 @@ static void reverse_inplace_quad(unsigne
 
 /**
  * rot90cw
- * 
- *  Performs a 90 degrees clockwise rotation of the memory block pointed to 
- *  by src. The rotation is NOT performed in-place; dst must point to a 
+ *
+ *  Performs a 90 degrees clockwise rotation of the memory block pointed to
+ *  by src. The rotation is NOT performed in-place; dst must point to a
  *  receiving memory block the same size as src.
  *
  * Parameters:
- * 
+ *
  *   src    - pointer to the memory block (image) to rotate clockwise
  *   dst    - where to put the rotated memory block
  *   size   - the size (in bytes) of the memory blocks (both src and dst)
@@ -165,7 +165,7 @@ static void reverse_inplace_quad(unsigne
  * Returns: nothing
  */
 static void rot90cw(unsigned char *src, register unsigned char *dst, int size,
-                    int width, int height) 
+                    int width, int height)
 {
     unsigned char *endp;
     register unsigned char *base;
@@ -174,21 +174,21 @@ static void rot90cw(unsigned char *src,
     endp = src + size;
     for (base = endp - width; base < endp; base++) {
         src = base;
-        for (j = 0; j < height; j++, src -= width) 
+        for (j = 0; j < height; j++, src -= width)
             *dst++ = *src;
-        
+
     }
 }
 
 /**
  * rot90ccw
- * 
+ *
  *  Performs a 90 degrees counterclockwise rotation of the memory block pointed
- *  to by src. The rotation is not performed in-place; dst must point to a 
- *  receiving memory block the same size as src. 
+ *  to by src. The rotation is not performed in-place; dst must point to a
+ *  receiving memory block the same size as src.
  *
  * Parameters:
- * 
+ *
  *   src    - pointer to the memory block (image) to rotate counterclockwise
  *   dst    - where to put the rotated memory block
  *   size   - the size (in bytes) of the memory blocks (both src and dst)
@@ -198,7 +198,7 @@ static void rot90cw(unsigned char *src,
  * Returns: nothing
  */
 static inline void rot90ccw(unsigned char *src, register unsigned char *dst,
-                            int size, int width, int height) 
+                            int size, int width, int height)
 {
     unsigned char *endp;
     register unsigned char *base;
@@ -206,48 +206,50 @@ static inline void rot90ccw(unsigned cha
 
     endp = src + size;
     dst = dst + size - 1;
-    for(base = endp - width; base < endp; base++) {
+    for (base = endp - width; base < endp; base++) {
         src = base;
-        for(j = 0; j < height; j++, src -= width) 
+        for (j = 0; j < height; j++, src -= width)
             *dst-- = *src;
-        
+
     }
 }
 
 /**
  * rotate_init
- * 
+ *
  *  Initializes rotation data - allocates memory and determines which function
  *  to use for 180 degrees rotation.
  *
  * Parameters:
- * 
+ *
  *   cnt - the current thread's context structure
  *
  * Returns: nothing
  */
-void rotate_init(struct context *cnt) 
+void rotate_init(struct context *cnt)
 {
     int size;
-    
+
     /* Make sure temp_buf isn't freed if it hasn't been allocated. */
     cnt->rotate_data.temp_buf = NULL;
 
-    /* Assign the value in conf.rotate_deg to rotate_data.degrees. This way,
+    /*
+     * Assign the value in conf.rotate_deg to rotate_data.degrees. This way,
      * we have a value that is safe from changes caused by motion-control.
      */
     if ((cnt->conf.rotate_deg % 90) > 0) {
-        motion_log(LOG_ERR, 0, "Config option \"rotate\" not a multiple of 90: %d",
+        MOTION_LOG(WRN, TYPE_ALL, NO_ERRNO, "%s: Config option \"rotate\" not a multiple of 90: %d",
                    cnt->conf.rotate_deg);
-        cnt->conf.rotate_deg = 0;     /* disable rotation */
-        cnt->rotate_data.degrees = 0; /* force return below */
+        cnt->conf.rotate_deg = 0;     /* Disable rotation. */
+        cnt->rotate_data.degrees = 0; /* Force return below. */
     } else {
-        cnt->rotate_data.degrees = cnt->conf.rotate_deg % 360; /* range: 0..359 */
+        cnt->rotate_data.degrees = cnt->conf.rotate_deg % 360; /* Range: 0..359 */
     }
 
-    /* Upon entrance to this function, imgs.width and imgs.height contain the
-     * capture dimensions (as set in the configuration file, or read from a 
-     * netcam source). 
+    /*
+     * Upon entrance to this function, imgs.width and imgs.height contain the
+     * capture dimensions (as set in the configuration file, or read from a
+     * netcam source).
      *
      * If rotating 90 or 270 degrees, the capture dimensions and output dimensions
      * are not the same. Capture dimensions will be contained in cap_width and
@@ -265,86 +267,88 @@ void rotate_init(struct context *cnt)
         cnt->imgs.height = cnt->rotate_data.cap_width;
     }
 
-    /* If we're not rotating, let's exit once we have setup the capture dimensions
+    /*
+     * If we're not rotating, let's exit once we have setup the capture dimensions
      * and output dimensions properly.
      */
-    if (cnt->rotate_data.degrees == 0) 
+    if (cnt->rotate_data.degrees == 0)
         return;
-    
 
-    switch(cnt->imgs.type) {
+    switch (cnt->imgs.type) {
     case VIDEO_PALETTE_YUV420P:
-        /* For YUV 4:2:0 planar, the memory block used for 90/270 degrees
-         * rotation needs to be width x height x 1.5 bytes large. 
+        /*
+         * For YUV 4:2:0 planar, the memory block used for 90/270 degrees
+         * rotation needs to be width x height x 1.5 bytes large.
          */
         size = cnt->imgs.width * cnt->imgs.height * 3 / 2;
         break;
     case VIDEO_PALETTE_GREY:
-        /* For greyscale, the memory block used for 90/270 degrees rotation
+        /*
+         * For greyscale, the memory block used for 90/270 degrees rotation
          * needs to be width x height bytes large.
          */
         size = cnt->imgs.width * cnt->imgs.height;
         break;
     default:
         cnt->rotate_data.degrees = 0;
-        motion_log(LOG_ERR, 0, "Unsupported palette (%d), rotation is disabled",
-                   cnt->imgs.type);
+        MOTION_LOG(WRN, TYPE_ALL, NO_ERRNO, "%s: Unsupported palette (%d), rotation is disabled",
+                    cnt->imgs.type);
         return;
     }
 
-    /* Allocate memory if rotating 90 or 270 degrees, because those rotations 
+    /*
+     * Allocate memory if rotating 90 or 270 degrees, because those rotations
      * cannot be performed in-place (they can, but it would be too slow).
      */
-    if ((cnt->rotate_data.degrees == 90) || (cnt->rotate_data.degrees == 270)) 
+    if ((cnt->rotate_data.degrees == 90) || (cnt->rotate_data.degrees == 270))
         cnt->rotate_data.temp_buf = mymalloc(size);
-    
 }
 
-/** 
+/**
  * rotate_deinit
- * 
- *  Frees resources previously allocated by rotate_init. 
+ *
+ *  Frees resources previously allocated by rotate_init.
  *
  * Parameters:
- * 
+ *
  *   cnt - the current thread's context structure
  *
  * Returns: nothing
  */
-void rotate_deinit(struct context *cnt) 
+void rotate_deinit(struct context *cnt)
 {
-    if (cnt->rotate_data.temp_buf) 
+    if (cnt->rotate_data.temp_buf)
         free(cnt->rotate_data.temp_buf);
-    
 }
 
 /**
  * rotate_map
- * 
+ *
  *  Main entry point for rotation. This is the function that is called from
  *  video.c/video_freebsd.c to perform the rotation.
  *
  * Parameters:
- * 
+ *
  *   map - pointer to the image/data to rotate
  *   cnt - the current thread's context structure
  *
- * Returns: 
- * 
+ * Returns:
+ *
  *   0  - success
  *   -1 - failure (shouldn't happen)
  */
 int rotate_map(struct context *cnt, unsigned char *map)
 {
-    /* The image format is either YUV 4:2:0 planar, in which case the pixel 
+    /*
+     * The image format is either YUV 4:2:0 planar, in which case the pixel
      * data is divided in three parts:
      *    Y - width x height bytes
      *    U - width x height / 4 bytes
      *    V - as U
-     * or, it is in greyscale, in which case the pixel data simply consists 
+     * or, it is in greyscale, in which case the pixel data simply consists
      * of width x height bytes.
      */
-    int wh, wh4 = 0, w2 = 0, h2 = 0;  /* width*height, width*height/4 etc. */
+    int wh, wh4 = 0, w2 = 0, h2 = 0;  /* width * height, width * height / 4 etc. */
     int size, deg;
     int width, height;
 
@@ -352,7 +356,8 @@ int rotate_map(struct context *cnt, unsi
     width = cnt->rotate_data.cap_width;
     height = cnt->rotate_data.cap_height;
 
-    /* Pre-calculate some stuff:
+    /*
+     * Pre-calculate some stuff:
      *  wh   - size of the Y plane, or the entire greyscale image
      *  size - size of the entire memory block
      *  wh4  - size of the U plane, and the V plane
@@ -360,7 +365,6 @@ int rotate_map(struct context *cnt, unsi
      *  h2   - as w2, but height instead
      */
     wh = width * height;
-    
     if (cnt->imgs.type == VIDEO_PALETTE_YUV420P) {
         size = wh * 3 / 2;
         wh4 = wh / 4;
@@ -372,26 +376,25 @@ int rotate_map(struct context *cnt, unsi
 
     switch (deg) {
     case 90:
-        /* first do the Y part */
+        /* First do the Y part */
         rot90cw(map, cnt->rotate_data.temp_buf, wh, width, height);
-
         if (cnt->imgs.type == VIDEO_PALETTE_YUV420P) {
-            /* then do U and V */
+            /* Then do U and V */
             rot90cw(map + wh, cnt->rotate_data.temp_buf + wh, wh4, w2, h2);
             rot90cw(map + wh + wh4, cnt->rotate_data.temp_buf + wh + wh4,
                     wh4, w2, h2);
         }
-        
-        /* then copy back from the temp buffer to map */
+
+        /* Then copy back from the temp buffer to map. */
         memcpy(map, cnt->rotate_data.temp_buf, size);
         break;
-        
+
     case 180:
-        /* 180 degrees is easy - just reverse the data within
+        /*
+         * 180 degrees is easy - just reverse the data within
          * Y, U and V.
          */
         reverse_inplace_quad(map, wh);
-
         if (cnt->imgs.type == VIDEO_PALETTE_YUV420P) {
             reverse_inplace_quad(map + wh, wh4);
             reverse_inplace_quad(map + wh + wh4, wh4);
@@ -399,25 +402,25 @@ int rotate_map(struct context *cnt, unsi
         break;
 
     case 270:
-        /* first do the Y part */
-        rot90ccw(map, cnt->rotate_data.temp_buf, wh, width, height);
 
+        /* First do the Y part */
+        rot90ccw(map, cnt->rotate_data.temp_buf, wh, width, height);
         if (cnt->imgs.type == VIDEO_PALETTE_YUV420P) {
-            /* then do U and V */
+            /* Then do U and V */
             rot90ccw(map + wh, cnt->rotate_data.temp_buf + wh, wh4, w2, h2);
-            rot90ccw(map + wh + wh4, cnt->rotate_data.temp_buf + wh + wh4, 
+            rot90ccw(map + wh + wh4, cnt->rotate_data.temp_buf + wh + wh4,
                      wh4, w2, h2);
         }
-        
-        /* then copy back from the temp buffer to map */
+
+        /* Then copy back from the temp buffer to map. */
         memcpy(map, cnt->rotate_data.temp_buf, size);
         break;
-        
+
     default:
-        /* invalid */
+        /* Invalid */
         return -1;
     }
-    
+
     return 0;
 }
 
--- /dev/null
+++ motion-3.2.12/sdl.c
@@ -0,0 +1,181 @@
+/*
+ *    sdl.c
+ *
+ *    sdl functions for motion.
+ *    Copyright 2009 by Peter Holik (peter@holik.at)
+ *    This software is distributed under the GNU public license version 2
+ *    See also the file 'COPYING'.
+ */
+#include "sdl.h"
+#include <SDL/SDL.h>
+
+static int cur_width;
+static int cur_height;
+static int is_full_screen;
+static int fs_screen_width;
+static int fs_screen_height;
+
+static SDL_Surface *screen;
+static SDL_Overlay *overlay;
+
+static int sdl_video_open(int width, int height)
+{
+    int flags = SDL_HWSURFACE | SDL_ASYNCBLIT | SDL_HWACCEL;
+    int w,h;
+
+    if (is_full_screen) flags |= SDL_FULLSCREEN;
+    else                flags |= SDL_RESIZABLE;
+
+    if (is_full_screen && fs_screen_width) {
+        w = fs_screen_width;
+        h = fs_screen_height;
+    } else if (width > fs_screen_width || height > fs_screen_height) {
+        w = fs_screen_width;
+        h = fs_screen_height;
+    } else {
+        w = width;
+        h = height;
+    }
+    /* 32 because framebuffer is usually initalized to 8 and
+       you have to use fbset with -depth to make it working */
+    screen = SDL_SetVideoMode(w, h, 32, flags);
+
+    if (!screen) {
+        MOTION_LOG(ERR, TYPE_ALL, SHOW_ERRNO,"%s: Unable to set video mode: %s",
+                   SDL_GetError());
+        return -1;
+    }
+
+    MOTION_LOG(ERR, TYPE_ALL, NO_ERRNO, "%s: SDL dimension %d x %d fullscreen %d BytesPerPixel %d",
+                screen->w, screen->h, is_full_screen,
+               screen->format->BytesPerPixel);
+
+    SDL_WM_SetCaption("motion", "motion");
+    SDL_ShowCursor(SDL_DISABLE);
+
+    if (cur_width != width || cur_height != height) {
+        cur_width  = width;
+        cur_height = height;
+
+        if (overlay) SDL_FreeYUVOverlay(overlay);
+
+        overlay = SDL_CreateYUVOverlay(cur_width, cur_height,
+                                   SDL_YV12_OVERLAY, screen);
+        if (!overlay) {
+            MOTION_LOG(ERR, TYPE_ALL, SHOW_ERRNO, "%s: Could not create overlay: %s",
+                        SDL_GetError());
+            sdl_stop();
+        } else
+            MOTION_LOG(ERR, TYPE_ALL, NO_ERRNO, "%s: SDL created %dx%dx%d %s overlay",
+                        overlay->w,overlay->h,overlay->planes,
+                       overlay->hw_overlay?"hardware":"software");
+    }
+    return overlay == NULL;
+}
+
+int sdl_start(int width, int height)
+{
+    //putenv("SDL_NOMOUSE=1");
+    setenv("SDL_NOMOUSE", "1", 1);
+
+    if (screen) return 0;
+
+    MOTION_LOG(ERR, TYPE_ALL, NO_ERRNO, "%s: SDL start");
+
+    if (SDL_Init(SDL_INIT_VIDEO)) {
+        MOTION_LOG(ERR, TYPE_ALL, SHOW_ERRNO, "%s: Could not initialize SDL - %s",
+                    SDL_GetError());
+        return -1;
+    }
+    const SDL_VideoInfo *vi = SDL_GetVideoInfo();
+    fs_screen_width  = vi->current_w;
+    fs_screen_height = vi->current_h;
+
+    if (sdl_video_open(width, height)) return -1;
+
+    SDL_EventState(SDL_ACTIVEEVENT, SDL_IGNORE);
+    SDL_EventState(SDL_MOUSEMOTION, SDL_IGNORE);
+    SDL_EventState(SDL_SYSWMEVENT, SDL_IGNORE);
+    SDL_EventState(SDL_USEREVENT, SDL_IGNORE);
+    SDL_EventState(SDL_MOUSEBUTTONDOWN, SDL_IGNORE);
+    SDL_EventState(SDL_MOUSEBUTTONUP, SDL_IGNORE);
+    SDL_EventState(SDL_KEYUP, SDL_IGNORE);
+    SDL_EventState(SDL_JOYBUTTONDOWN, SDL_IGNORE);
+    SDL_EventState(SDL_JOYBUTTONUP, SDL_IGNORE);
+    SDL_EventState(SDL_JOYAXISMOTION, SDL_IGNORE);
+    SDL_EventState(SDL_JOYBALLMOTION, SDL_IGNORE);
+    SDL_EventState(SDL_JOYHATMOTION, SDL_IGNORE);
+    SDL_EventState(SDL_VIDEORESIZE, SDL_IGNORE);
+
+    return 0;
+}
+
+void sdl_put(unsigned char *image, int width, int height)
+{
+    SDL_Event event;
+
+    if (screen && overlay) {
+        SDL_Rect rect;
+        float aspect_ratio = (float)width / height;
+        int pic_width, pic_height;
+
+        if (width != cur_width || height != cur_height)
+            sdl_video_open(width, height);
+
+        if (SDL_MUSTLOCK(screen))
+            if (SDL_LockSurface(screen) < 0) return;
+
+        SDL_LockYUVOverlay(overlay);
+        memcpy(overlay->pixels[0], image, width * height);
+        memcpy(overlay->pixels[2], image + (width * height), (width * height / 4));
+        memcpy(overlay->pixels[1], image + (width * height * 5 / 4), (width * height / 4));
+        SDL_UnlockYUVOverlay(overlay);
+
+        if (SDL_MUSTLOCK(screen))
+            SDL_UnlockSurface(screen);
+
+        pic_height = screen->h;
+        pic_width = pic_height * aspect_ratio;
+        if (pic_width > screen->w) {
+            pic_width = screen->w;
+            pic_height = pic_width / aspect_ratio;
+        }
+        rect.x = (screen->w - pic_width) / 2;
+        rect.y = (screen->h - pic_height) / 2;
+        rect.w = pic_width;
+        rect.h = pic_height;
+
+        if (SDL_DisplayYUVOverlay(overlay, &rect))
+            MOTION_LOG(ERR, TYPE_ALL, SHOW_ERRNO, "%s: SDL_DisplayYUVOverlay: %s",
+                        SDL_GetError());
+
+        if (SDL_PollEvent(&event)) {
+            if ((event.type == SDL_QUIT ||
+                (event.type == SDL_KEYDOWN &&
+                 event.key.keysym.sym == SDLK_ESCAPE)))
+                sdl_stop();
+            else if (event.type == SDL_KEYDOWN && event.key.keysym.sym == SDLK_f) {
+                is_full_screen = !is_full_screen;
+                sdl_video_open(width, height);
+            }
+            else if (event.type == SDL_VIDEORESIZE)
+                screen = SDL_SetVideoMode(event.resize.w, event.resize.h,
+                                          screen->format->BitsPerPixel,
+                                          screen->flags);
+        }
+    }
+}
+
+void sdl_stop(void)
+{
+    if (screen) {
+        MOTION_LOG(ERR, TYPE_ALL, NO_ERRNO, "%s: SDL quit");
+        SDL_ShowCursor(SDL_ENABLE);
+        if (overlay) {
+            SDL_FreeYUVOverlay(overlay);
+            overlay = NULL;
+        }
+        SDL_Quit();
+        screen = NULL;
+    }
+}
--- /dev/null
+++ motion-3.2.12/sdl.h
@@ -0,0 +1,17 @@
+/*  sdl.h
+ *
+ *  Include file for sdl.c
+ *      Copyright 2009 by Peter Holik (peter@holik.at)
+ *      This software is distributed under the GNU public license version 2
+ *      See also the file 'COPYING'.
+ */
+#ifndef _INCLUDE_SDL_H
+#define _INCLUDE_SDL_H
+
+#include "motion.h"
+
+int sdl_start(int width, int height);
+void sdl_put(unsigned char *image, int width, int height);
+void sdl_stop(void);
+
+#endif
--- /dev/null
+++ motion-3.2.12/stream.c
@@ -0,0 +1,1221 @@
+/*
+ *    stream.c (based in webcam.c)
+ *    Streaming using jpeg images over a multipart/x-mixed-replace stream
+ *    Copyright (C) 2002 Jeroen Vreeken (pe1rxq@amsat.org)
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include "md5.h"
+#include "picture.h"
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+#include <ctype.h>
+#include <sys/fcntl.h>
+
+#define STREAM_REALM       "Motion Stream Security Access"
+#define KEEP_ALIVE_TIMEOUT 100
+
+typedef void* (*auth_handler)(void*);
+struct auth_param {
+    struct context *cnt;
+    int sock;
+    int sock_flags;
+    int* thread_count;
+    struct config *conf;
+};
+
+pthread_mutex_t stream_auth_mutex;
+
+/**
+ * set_sock_timeout
+ *
+ * Returns : 0 or 1 on timeout
+ */
+static int set_sock_timeout(int sock, int sec)
+{
+    struct timeval tv;
+
+    tv.tv_sec = sec;
+    tv.tv_usec = 0;
+
+    if (setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (char*) &tv, sizeof(tv))) {
+        MOTION_LOG(ERR, TYPE_STREAM, SHOW_ERRNO, "%s: set socket timeout failed");
+        return 1;
+    }
+    return 0;
+}
+
+/**
+ * read_http_request
+ *
+ *
+ * Returns : 1 on success or 0 if any error happens
+ */
+static int read_http_request(int sock, char* buffer, int buflen, char* uri, int uri_len)
+{
+    int nread = 0;
+    int ret,readb = 1;
+    char method[10] = {'\0'};
+    char url[512] = {'\0'};
+    char protocol[10] = {'\0'};
+
+    static const char *bad_request_response_raw =
+        "HTTP/1.0 400 Bad Request\r\n"
+        "Content-type: text/plain\r\n\r\n"
+        "Bad Request\n";
+
+    static const char *bad_method_response_template_raw =
+        "HTTP/1.0 501 Method Not Implemented\r\n"
+        "Content-type: text/plain\r\n\r\n"
+        "Method Not Implemented\n";
+
+    static const char *timeout_response_template_raw =
+        "HTTP/1.0 408 Request Timeout\r\n"
+        "Content-type: text/plain\r\n\r\n"
+        "Request Timeout\n";
+
+    buffer[0] = '\0';
+
+    while ((strstr(buffer, "\r\n\r\n") == NULL) && (readb != 0) && (nread < buflen)) {
+
+        readb = read(sock, buffer+nread, buflen - nread);
+
+        if (readb == -1) {
+            nread = -1;
+            break;
+        }
+
+        nread += readb;
+
+        if (nread > buflen) {
+            MOTION_LOG(ERR, TYPE_STREAM, SHOW_ERRNO, "%s: motion-stream End buffer reached"
+                      " waiting for buffer ending");
+            break;
+        }
+
+        buffer[nread] = '\0';
+    }
+
+    /*
+     * Make sure the last read didn't fail. If it did, there's a
+     * problem with the connection, so give up.
+     */
+    if (nread == -1) {
+        if(errno == EAGAIN) { // Timeout
+            ret = write(sock, timeout_response_template_raw, strlen(timeout_response_template_raw));
+            return 0;
+        }
+
+        MOTION_LOG(ERR, TYPE_STREAM, SHOW_ERRNO, "%s: motion-stream READ give up!");
+        return 0;
+    }
+
+    ret = sscanf(buffer, "%9s %511s %9s", method, url, protocol);
+
+    if (ret != 3) {
+        ret = write(sock, bad_request_response_raw, sizeof(bad_request_response_raw));
+        return 0;
+    }
+
+    /* Check Protocol */
+    if (strcmp(protocol, "HTTP/1.0") && strcmp (protocol, "HTTP/1.1")) {
+        /* We don't understand this protocol. Report a bad response. */
+        ret = write(sock, bad_request_response_raw, sizeof(bad_request_response_raw));
+        return 0;
+    }
+
+    if (strcmp(method, "GET")) {
+        /*
+         * This server only implements the GET method. If client
+         * uses other method, report the failure.
+         */
+        char response[1024];
+        snprintf(response, sizeof(response), bad_method_response_template_raw, method);
+        ret = write(sock, response, strlen (response));
+
+        return 0;
+    }
+
+    if(uri)
+        strncpy(uri, url, uri_len);
+
+    return 1;
+}
+
+static void stream_add_client(struct stream *list, int sc);
+
+/**
+ * handle_basic_auth
+ *
+ *
+ */
+static void* handle_basic_auth(void* param)
+{
+    struct auth_param *p = (struct auth_param*)param;
+    char buffer[1024] = {'\0'};
+    ssize_t length = 1023;
+    char *auth, *h, *authentication;
+    static const char *request_auth_response_template=
+        "HTTP/1.0 401 Authorization Required\r\n"
+        "Server: Motion/"VERSION"\r\n"
+        "Max-Age: 0\r\n"
+        "Expires: 0\r\n"
+        "Cache-Control: no-cache, private\r\n"
+        "Pragma: no-cache\r\n"
+        "WWW-Authenticate: Basic realm=\""STREAM_REALM"\"\r\n\r\n";
+
+    pthread_mutex_lock(&stream_auth_mutex);
+    p->thread_count++;
+    pthread_mutex_unlock(&stream_auth_mutex);
+
+    if (!read_http_request(p->sock,buffer, length, NULL, 0))
+        goto Invalid_Request;
+
+
+    auth = strstr(buffer, "Authorization: Basic");
+
+    if (!auth)
+        goto Error;
+
+    auth += sizeof("Authorization: Basic");
+    h = strstr(auth, "\r\n");
+
+    if(!h)
+        goto Error;
+
+    *h='\0';
+
+    if (p->conf->stream_authentication != NULL) {
+
+        char *userpass = NULL;
+        size_t auth_size = strlen(p->conf->stream_authentication);
+
+        authentication = (char *) mymalloc(BASE64_LENGTH(auth_size) + 1);
+        userpass = mymalloc(auth_size + 4);
+        /* base64_encode can read 3 bytes after the end of the string, initialize it. */
+        memset(userpass, 0, auth_size + 4);
+        strcpy(userpass, p->conf->stream_authentication);
+        base64_encode(userpass, authentication, auth_size);
+        free(userpass);
+
+        if (strcmp(auth, authentication)) {
+            free(authentication);
+            goto Error;
+        }
+        free(authentication);
+    }
+
+    // OK - Access
+
+    /* Set socket to non blocking */
+    if (fcntl(p->sock, F_SETFL, p->sock_flags) < 0) {
+        MOTION_LOG(ERR, TYPE_STREAM, SHOW_ERRNO, "%s: fcntl");
+        goto Error;
+    }
+
+    /* Lock the mutex */
+    pthread_mutex_lock(&stream_auth_mutex);
+
+    stream_add_client(&p->cnt->stream, p->sock);
+    p->cnt->stream_count++;
+    p->thread_count--;
+
+    /* Unlock the mutex */
+    pthread_mutex_unlock(&stream_auth_mutex);
+
+    free(p);
+    pthread_exit(NULL);
+
+Error:
+    if (write(p->sock, request_auth_response_template, strlen (request_auth_response_template)) < 0)
+        MOTION_LOG(DBG, TYPE_STREAM, SHOW_ERRNO, "%s: write failure 1:handle_basic_auth");
+
+Invalid_Request:
+    close(p->sock);
+
+    pthread_mutex_lock(&stream_auth_mutex);
+    p->thread_count--;
+    pthread_mutex_unlock(&stream_auth_mutex);
+
+    free(p);
+    pthread_exit(NULL);
+}
+
+
+#define HASHLEN 16
+typedef char HASH[HASHLEN];
+#define HASHHEXLEN 32
+typedef char HASHHEX[HASHHEXLEN+1];
+#define IN
+#define OUT
+/**
+ * CvtHex
+ *      Calculates H(A1) as per HTTP Digest spec -- taken from RFC 2617.
+ */
+static void CvtHex(IN HASH Bin, OUT HASHHEX Hex)
+{
+    unsigned short i;
+    unsigned char j;
+
+    for (i = 0; i < HASHLEN; i++) {
+        j = (Bin[i] >> 4) & 0xf;
+        if (j <= 9)
+            Hex[i*2] = (j + '0');
+         else
+            Hex[i*2] = (j + 'a' - 10);
+        j = Bin[i] & 0xf;
+        if (j <= 9)
+            Hex[i*2+1] = (j + '0');
+         else
+            Hex[i*2+1] = (j + 'a' - 10);
+    };
+    Hex[HASHHEXLEN] = '\0';
+};
+
+/**
+ * DigestCalcHA1
+ *      Calculates H(A1) as per spec.
+ */
+static void DigestCalcHA1(
+    IN char * pszAlg,
+    IN char * pszUserName,
+    IN char * pszRealm,
+    IN char * pszPassword,
+    IN char * pszNonce,
+    IN char * pszCNonce,
+    OUT HASHHEX SessionKey
+    )
+{
+    MD5_CTX Md5Ctx;
+    HASH HA1;
+
+    MD5Init(&Md5Ctx);
+    MD5Update(&Md5Ctx, (unsigned char *)pszUserName, strlen(pszUserName));
+    MD5Update(&Md5Ctx, (unsigned char *)":", 1);
+    MD5Update(&Md5Ctx, (unsigned char *)pszRealm, strlen(pszRealm));
+    MD5Update(&Md5Ctx, (unsigned char *)":", 1);
+    MD5Update(&Md5Ctx, (unsigned char *)pszPassword, strlen(pszPassword));
+    MD5Final((unsigned char *)HA1, &Md5Ctx);
+
+    if (strcmp(pszAlg, "md5-sess") == 0) {
+        MD5Init(&Md5Ctx);
+        MD5Update(&Md5Ctx, (unsigned char *)HA1, HASHLEN);
+        MD5Update(&Md5Ctx, (unsigned char *)":", 1);
+        MD5Update(&Md5Ctx, (unsigned char *)pszNonce, strlen(pszNonce));
+        MD5Update(&Md5Ctx, (unsigned char *)":", 1);
+        MD5Update(&Md5Ctx, (unsigned char *)pszCNonce, strlen(pszCNonce));
+        MD5Final((unsigned char *)HA1, &Md5Ctx);
+    };
+    CvtHex(HA1, SessionKey);
+};
+
+/**
+ * DigestCalcResponse
+ *      Calculates request-digest/response-digest as per HTTP Digest spec.
+ */
+static void DigestCalcResponse(
+    IN HASHHEX HA1,           /* H(A1) */
+    IN char * pszNonce,       /* nonce from server */
+    IN char * pszNonceCount,  /* 8 hex digits */
+    IN char * pszCNonce,      /* client nonce */
+    IN char * pszQop,         /* qop-value: "", "auth", "auth-int" */
+    IN char * pszMethod,      /* method from the request */
+    IN char * pszDigestUri,   /* requested URL */
+    IN HASHHEX HEntity,       /* H(entity body) if qop="auth-int" */
+    OUT HASHHEX Response      /* request-digest or response-digest */
+    )
+{
+    MD5_CTX Md5Ctx;
+    HASH HA2;
+    HASH RespHash;
+    HASHHEX HA2Hex;
+
+    // Calculate H(A2)
+    MD5Init(&Md5Ctx);
+    MD5Update(&Md5Ctx, (unsigned char *)pszMethod, strlen(pszMethod));
+    MD5Update(&Md5Ctx, (unsigned char *)":", 1);
+    MD5Update(&Md5Ctx, (unsigned char *)pszDigestUri, strlen(pszDigestUri));
+
+    if (strcmp(pszQop, "auth-int") == 0) {
+        MD5Update(&Md5Ctx, (unsigned char *)":", 1);
+        MD5Update(&Md5Ctx, (unsigned char *)HEntity, HASHHEXLEN);
+    }
+    MD5Final((unsigned char *)HA2, &Md5Ctx);
+    CvtHex(HA2, HA2Hex);
+
+    // Calculate response
+    MD5Init(&Md5Ctx);
+    MD5Update(&Md5Ctx, (unsigned char *)HA1, HASHHEXLEN);
+    MD5Update(&Md5Ctx, (unsigned char *)":", 1);
+    MD5Update(&Md5Ctx, (unsigned char *)pszNonce, strlen(pszNonce));
+    MD5Update(&Md5Ctx, (unsigned char *)":", 1);
+
+    if (*pszQop) {
+        MD5Update(&Md5Ctx, (unsigned char *)pszNonceCount, strlen(pszNonceCount));
+        MD5Update(&Md5Ctx, (unsigned char *)":", 1);
+        MD5Update(&Md5Ctx, (unsigned char *)pszCNonce, strlen(pszCNonce));
+        MD5Update(&Md5Ctx, (unsigned char *)":", 1);
+        MD5Update(&Md5Ctx, (unsigned char *)pszQop, strlen(pszQop));
+        MD5Update(&Md5Ctx, (unsigned char *)":", 1);
+    }
+    MD5Update(&Md5Ctx, (unsigned char *)HA2Hex, HASHHEXLEN);
+    MD5Final((unsigned char *)RespHash, &Md5Ctx);
+    CvtHex(RespHash, Response);
+};
+
+
+/**
+ * handle_md5_digest
+ *
+ *
+ */
+static void* handle_md5_digest(void* param)
+{
+    struct auth_param *p = (struct auth_param*)param;
+    char buffer[1024] = {'\0'};
+    ssize_t length = 1023;
+    char *auth, *h, *username, *realm, *uri, *nonce, *response;
+    int username_len, realm_len, uri_len, nonce_len, response_len;
+#define SERVER_NONCE_LEN 17
+    char server_nonce[SERVER_NONCE_LEN];
+#define SERVER_URI_LEN 512
+    char server_uri[SERVER_URI_LEN];
+    char* server_user = NULL, *server_pass = NULL;
+    unsigned int rand1,rand2;
+    HASHHEX HA1;
+    HASHHEX HA2 = "";
+    HASHHEX server_response;
+    static const char *request_auth_response_template=
+        "HTTP/1.0 401 Authorization Required\r\n"
+        "Server: Motion/"VERSION"\r\n"
+        "Max-Age: 0\r\n"
+        "Expires: 0\r\n"
+        "Cache-Control: no-cache, private\r\n"
+        "Pragma: no-cache\r\n"
+        "WWW-Authenticate: Digest";
+    static const char *auth_failed_html_template=
+        "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\r\n"
+        "<HTML><HEAD>\r\n"
+        "<TITLE>401 Authorization Required</TITLE>\r\n"
+        "</HEAD><BODY>\r\n"
+        "<H1>Authorization Required</H1>\r\n"
+        "This server could not verify that you are authorized to access the document "
+        "requested.  Either you supplied the wrong credentials (e.g., bad password), "
+        "or your browser doesn't understand how to supply the credentials required.\r\n"
+        "</BODY></HTML>\r\n";
+    static const char *internal_error_template=
+        "HTTP/1.0 500 Internal Server Error\r\n"
+        "Server: Motion/"VERSION"\r\n"
+        "Content-Type: text/html\r\n"
+        "Connection: Close\r\n\r\n"
+        "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\r\n"
+        "<HTML><HEAD>\r\n"
+        "<TITLE>500 Internal Server Error</TITLE>\r\n"
+        "</HEAD><BODY>\r\n"
+        "<H1>500 Internal Server Error</H1>\r\n"
+        "</BODY></HTML>\r\n";
+
+    pthread_mutex_lock(&stream_auth_mutex);
+    p->thread_count++;
+    pthread_mutex_unlock(&stream_auth_mutex);
+
+    set_sock_timeout(p->sock, KEEP_ALIVE_TIMEOUT);
+    srand(time(NULL));
+    rand1 = (unsigned int)(42000000.0 * rand() / (RAND_MAX + 1.0));
+    rand2 = (unsigned int)(42000000.0 * rand() / (RAND_MAX + 1.0));
+    snprintf(server_nonce, SERVER_NONCE_LEN, "%08x%08x", rand1, rand2);
+
+    if (!p->conf->stream_authentication) {
+        MOTION_LOG(ERR, TYPE_STREAM, SHOW_ERRNO, "%s: Error no authentication data");
+        goto InternalError;
+    }
+    h = strstr(p->conf->stream_authentication, ":");
+
+    if (!h) {
+        MOTION_LOG(ERR, TYPE_STREAM, SHOW_ERRNO, "%s: Error no authentication data (no ':' found)");
+        goto InternalError;
+    }
+
+    server_user = (char*)malloc((h - p->conf->stream_authentication) + 1);
+    server_pass = (char*)malloc(strlen(h) + 1);
+
+    if (!server_user || !server_pass) {
+        MOTION_LOG(ERR, TYPE_STREAM, SHOW_ERRNO, "%s: Error malloc failed");
+        goto InternalError;
+    }
+
+    strncpy(server_user, p->conf->stream_authentication, h-p->conf->stream_authentication);
+    server_user[h - p->conf->stream_authentication] = '\0';
+    strncpy(server_pass, h + 1, strlen(h + 1));
+    server_pass[strlen(h + 1)] = '\0';
+
+    while(1) {
+        if(!read_http_request(p->sock, buffer, length, server_uri, SERVER_URI_LEN - 1))
+            goto Invalid_Request;
+
+        auth = strstr(buffer, "Authorization: Digest");
+        if(!auth)
+            goto Error;
+
+        auth += sizeof("Authorization: Digest");
+        h = strstr(auth, "\r\n");
+
+        if (!h)
+            goto Error;
+        *h = '\0';
+
+        // Username
+        h=strstr(auth, "username=\"");
+
+        if (!h)
+            goto Error;
+
+        username = h + 10;
+        h = strstr(username + 1, "\"");
+
+        if (!h)
+            goto Error;
+
+        username_len = h - username;
+
+        // Realm
+        h = strstr(auth, "realm=\"");
+        if (!h)
+            goto Error;
+
+        realm = h + 7;
+        h = strstr(realm + 1, "\"");
+
+        if (!h)
+            goto Error;
+
+        realm_len = h - realm;
+
+        // URI
+        h = strstr(auth, "uri=\"");
+
+        if (!h)
+            goto Error;
+
+        uri = h + 5;
+        h = strstr(uri + 1, "\"");
+
+        if (!h)
+            goto Error;
+
+        uri_len = h - uri;
+
+        // Nonce
+        h = strstr(auth, "nonce=\"");
+
+        if (!h)
+            goto Error;
+
+        nonce = h + 7;
+        h = strstr(nonce + 1, "\"");
+
+        if (!h)
+            goto Error;
+
+        nonce_len = h - nonce;
+
+        // Response
+        h = strstr(auth, "response=\"");
+
+        if (!h)
+            goto Error;
+
+        response = h + 10;
+        h = strstr(response + 1, "\"");
+
+        if (!h)
+            goto Error;
+
+        response_len = h - response;
+
+        username[username_len] = '\0';
+        realm[realm_len] = '\0';
+        uri[uri_len] = '\0';
+        nonce[nonce_len] = '\0';
+        response[response_len] = '\0';
+
+        DigestCalcHA1((char*)"md5", server_user, (char*)STREAM_REALM, server_pass, (char*)server_nonce, (char*)NULL, HA1);
+        DigestCalcResponse(HA1, server_nonce, NULL, NULL, (char*)"", (char*)"GET", server_uri, HA2, server_response);
+
+        if (strcmp(server_response, response) == 0)
+            break;
+Error:
+        rand1 = (unsigned int)(42000000.0 * rand() / (RAND_MAX + 1.0));
+        rand2 = (unsigned int)(42000000.0 * rand() / (RAND_MAX + 1.0));
+        snprintf(server_nonce, SERVER_NONCE_LEN, "%08x%08x", rand1, rand2);
+        snprintf(buffer, length, "%s realm=\""STREAM_REALM"\", nonce=\"%s\"\r\n"
+                "Content-Type: text/html\r\n"
+                "Keep-Alive: timeout=%i\r\n"
+                "Connection: keep-alive\r\n"
+                "Content-Length: %Zu\r\n\r\n",
+                request_auth_response_template, server_nonce,
+                KEEP_ALIVE_TIMEOUT, strlen(auth_failed_html_template));
+        if (write(p->sock, buffer, strlen(buffer)) < 0)
+            MOTION_LOG(DBG, TYPE_STREAM, SHOW_ERRNO, "%s: write failure 1:handle_md5_digest");
+        if (write(p->sock, auth_failed_html_template, strlen(auth_failed_html_template)) < 0)
+            MOTION_LOG(DBG, TYPE_STREAM, SHOW_ERRNO, "%s: write failure 2:handle_md5_digest");
+    }
+
+    // OK - Access
+
+    /* Set socket to non blocking */
+    if (fcntl(p->sock, F_SETFL, p->sock_flags) < 0) {
+        MOTION_LOG(ERR, TYPE_STREAM, SHOW_ERRNO, "%s: fcntl");
+        goto Error;
+    }
+
+    if(server_user)
+        free(server_user);
+
+    if(server_pass)
+        free(server_pass);
+
+    /* Lock the mutex */
+    pthread_mutex_lock(&stream_auth_mutex);
+
+    stream_add_client(&p->cnt->stream, p->sock);
+    p->cnt->stream_count++;
+
+    p->thread_count--;
+    /* Unlock the mutex */
+    pthread_mutex_unlock(&stream_auth_mutex);
+
+    free(p);
+    pthread_exit(NULL);
+
+InternalError:
+    if(server_user)
+        free(server_user);
+
+    if(server_pass)
+        free(server_pass);
+
+    if (write(p->sock, internal_error_template, strlen(internal_error_template)) < 0)
+      MOTION_LOG(DBG, TYPE_STREAM, SHOW_ERRNO, "%s: write failure 3:handle_md5_digest");
+
+Invalid_Request:
+    close(p->sock);
+
+    pthread_mutex_lock(&stream_auth_mutex);
+    p->thread_count--;
+    pthread_mutex_unlock(&stream_auth_mutex);
+
+    free(p);
+    pthread_exit(NULL);
+}
+
+/**
+ * do_client_auth
+ *
+ *
+ */
+static void do_client_auth(struct context *cnt, int sc)
+{
+    pthread_t thread_id;
+    pthread_attr_t attr;
+    auth_handler handle_func;
+    struct auth_param* handle_param = NULL;
+    int flags;
+    static int first_call = 0;
+    static int thread_count = 0;
+
+    if(first_call == 0) {
+        first_call = 1;
+        /* Initialize the mutex */
+        pthread_mutex_init(&stream_auth_mutex, NULL);
+    }
+
+    switch(cnt->conf.stream_auth_method)
+    {
+    case 1: // Basic
+      handle_func = handle_basic_auth;
+      break;
+    case 2: // MD5 Digest
+      handle_func = handle_md5_digest;
+      break;
+    default:
+      MOTION_LOG(ERR, TYPE_STREAM, SHOW_ERRNO, "%s: Error unknown stream authentication method");
+      goto Error;
+      break;
+    }
+
+    handle_param = mymalloc(sizeof(struct auth_param));
+    handle_param->cnt = cnt;
+    handle_param->sock = sc;
+    handle_param->conf = &cnt->conf;
+    handle_param->thread_count = &thread_count;
+
+    /* Set socket to blocking */
+    if ((flags = fcntl(sc, F_GETFL, 0)) < 0) {
+        MOTION_LOG(ERR, TYPE_STREAM, SHOW_ERRNO, "%s: fcntl");
+        goto Error;
+    }
+    handle_param->sock_flags = flags;
+
+    if (fcntl(sc, F_SETFL, flags & (~O_NONBLOCK)) < 0) {
+        MOTION_LOG(ERR, TYPE_STREAM, SHOW_ERRNO, "%s: fcntl");
+        goto Error;
+    }
+
+    if (thread_count >= DEF_MAXSTREAMS)
+        goto Error;
+
+    if (pthread_attr_init(&attr)) {
+        MOTION_LOG(ERR, TYPE_STREAM, SHOW_ERRNO, "%s: Error pthread_attr_init");
+        goto Error;
+    }
+
+    if (pthread_create(&thread_id, &attr, handle_func, handle_param)) {
+        MOTION_LOG(ERR, TYPE_STREAM, SHOW_ERRNO, "%s: Error pthread_create");
+        goto Error;
+    }
+    pthread_detach(thread_id);
+
+    if (pthread_attr_destroy(&attr))
+        MOTION_LOG(ERR, TYPE_STREAM, SHOW_ERRNO, "%s: Error pthread_attr_destroy");
+
+    return;
+
+Error:
+    close(sc);
+    if(handle_param)
+        free(handle_param);
+}
+
+/**
+ * http_bindsock
+ *      Sets up a TCP/IP socket for incoming requests. It is called only during
+ *      initialisation of Motion from the function stream_init
+ *      The function sets up a a socket on the port number given by _port_.
+ *      If the parameter _local_ is not zero the socket is setup to only accept connects from localhost.
+ *      Otherwise any client IP address is accepted. The function returns an integer representing the socket.
+ *
+ * Returns: socket descriptor or -1 if any error happens
+ */
+int http_bindsock(int port, int local, int ipv6_enabled)
+{
+    int sl = -1, optval;
+    struct addrinfo hints, *res = NULL, *ressave = NULL;
+    char portnumber[10], hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];
+
+    snprintf(portnumber, sizeof(portnumber), "%u", port);
+    memset(&hints, 0, sizeof(struct addrinfo));
+
+    /* Use the AI_PASSIVE flag, which indicates we are using this address for a listen() */
+    hints.ai_flags = AI_PASSIVE;
+#if defined(BSD)
+    hints.ai_family = AF_INET;
+#else
+    if (!ipv6_enabled)
+        hints.ai_family = AF_INET;
+    else
+        hints.ai_family = AF_UNSPEC;
+#endif
+    hints.ai_socktype = SOCK_STREAM;
+
+    optval = getaddrinfo(local ? "localhost" : NULL, portnumber, &hints, &res);
+
+    if (optval != 0) {
+        MOTION_LOG(CRT, TYPE_STREAM, SHOW_ERRNO, "%s: getaddrinfo() for motion-stream socket failed: %s",
+                   gai_strerror(optval));
+
+        if (res != NULL)
+            freeaddrinfo(res);
+        return -1;
+    }
+
+    ressave = res;
+
+    while (res) {
+        /* Create socket */
+        sl = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
+
+        getnameinfo(res->ai_addr, res->ai_addrlen, hbuf,
+                    sizeof(hbuf), sbuf, sizeof(sbuf), NI_NUMERICHOST | NI_NUMERICSERV);
+
+        if (sl >= 0) {
+            optval = 1;
+            /* Reuse Address */
+            setsockopt(sl, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(int));
+
+            MOTION_LOG(NTC, TYPE_STREAM, NO_ERRNO, "%s: motion-stream testing : %s addr: %s port: %s",
+                       res->ai_family == AF_INET ? "IPV4":"IPV6", hbuf, sbuf);
+
+            if (bind(sl, res->ai_addr, res->ai_addrlen) == 0) {
+                MOTION_LOG(NTC, TYPE_STREAM, NO_ERRNO, "%s: motion-stream Bound : %s addr: %s port: %s",
+                           res->ai_family == AF_INET ? "IPV4":"IPV6", hbuf, sbuf);
+                break;
+            }
+
+            MOTION_LOG(CRT, TYPE_STREAM, SHOW_ERRNO, "%s: motion-stream bind() failed, retrying");
+            close(sl);
+            sl = -1;
+        }
+        MOTION_LOG(ERR, TYPE_STREAM, SHOW_ERRNO, "%s: motion-stream socket failed, retrying");
+        res = res->ai_next;
+    }
+
+    freeaddrinfo(ressave);
+
+    if (sl < 0) {
+        MOTION_LOG(CRT, TYPE_STREAM, SHOW_ERRNO, "%s: motion-stream creating socket/bind ERROR");
+        return -1;
+    }
+
+
+    if (listen(sl, DEF_MAXWEBQUEUE) == -1) {
+        MOTION_LOG(CRT, TYPE_STREAM, SHOW_ERRNO, "%s: motion-stream listen() ERROR");
+        close(sl);
+        sl = -1;
+    }
+
+    return sl;
+}
+
+/**
+ * http_acceptsock
+ *
+ *
+ * Returns: socket descriptor or -1 if any error happens.
+ */
+static int http_acceptsock(int sl)
+{
+    int sc;
+    unsigned long i;
+    struct sockaddr_storage sin;
+    socklen_t addrlen = sizeof(sin);
+
+    if ((sc = accept(sl, (struct sockaddr *)&sin, &addrlen)) >= 0) {
+        i = 1;
+        ioctl(sc, FIONBIO, &i);
+        return sc;
+    }
+
+    MOTION_LOG(CRT, TYPE_STREAM, SHOW_ERRNO, "%s: motion-stream accept()");
+
+    return -1;
+}
+
+
+/**
+ * stream_flush
+ *      Sends any outstanding data to all connected clients.
+ *      It continuously goes through the client list until no data is able
+ *      to be sent (either because there isn't any, or because the clients
+ *      are not able to accept it).
+ */
+static void stream_flush(struct stream *list, int *stream_count, int lim)
+{
+    int written;            /* The number of bytes actually written. */
+    struct stream *client;  /* Pointer to the client being served. */
+    int workdone = 0;       /* Flag set any time data is successfully
+                               written. */
+
+    client = list->next;
+
+    while (client) {
+
+        /* If data waiting for client, try to send it. */
+        if (client->tmpbuffer) {
+
+            /*
+             * We expect that list->filepos < list->tmpbuffer->size
+             * should always be true.  The check is more for safety,
+             * in case of trouble is some other part of the code.
+             * Note that if it is false, the following section will
+             * clean up.
+             */
+            if (client->filepos < client->tmpbuffer->size) {
+
+                /*
+                 * Here we are finally ready to write out the
+                 * data.  Remember that (because the socket
+                 * has been set non-blocking) we may only
+                 * write out part of the buffer.  The var
+                 * 'filepos' contains how much of the buffer
+                 * has already been written.
+                 */
+                written = write(client->socket,
+                          client->tmpbuffer->ptr + client->filepos,
+                          client->tmpbuffer->size - client->filepos);
+
+                /*
+                 * If any data has been written, update the
+                 * data pointer and set the workdone flag.
+                 */
+                if (written > 0) {
+                    client->filepos += written;
+                    workdone = 1;
+                }
+            } else
+                written = 0;
+
+            /*
+             * If we have written the entire buffer to the socket,
+             * or if there was some error (other than EAGAIN, which
+             * means the system couldn't take it), this request is
+             * finished.
+             */
+            if ((client->filepos >= client->tmpbuffer->size) ||
+                (written < 0 && errno != EAGAIN)) {
+                /* If no other clients need this buffer, free it. */
+                if (--client->tmpbuffer->ref <= 0) {
+                    free(client->tmpbuffer->ptr);
+                    free(client->tmpbuffer);
+                }
+
+                /* Mark this client's buffer as empty. */
+                client->tmpbuffer = NULL;
+                client->nr++;
+            }
+
+            /*
+             * If the client is no longer connected, or the total
+             * number of frames already sent to this client is
+             * greater than our configuration limit, disconnect
+             * the client and free the stream struct.
+             */
+            if ((written < 0 && errno != EAGAIN) ||
+                (lim && !client->tmpbuffer && client->nr > lim)) {
+                void *tmp;
+
+                close(client->socket);
+
+                if (client->next)
+                    client->next->prev = client->prev;
+
+                client->prev->next = client->next;
+                tmp = client;
+                client = client->prev;
+                free(tmp);
+                (*stream_count)--;
+            }
+        }   /* End if (client->tmpbuffer) */
+
+        /*
+         * Step the the next client in the list.  If we get to the
+         * end of the list, check if anything was written during
+         * that loop; (if so) reset the 'workdone' flag and go back
+         * to the beginning.
+         */
+        client = client->next;
+
+        if (!client && workdone) {
+            client = list->next;
+            workdone = 0;
+        }
+    }   /* End while (client) */
+}
+
+/**
+ * stream_tmpbuffer
+ *      Routine to create a new "tmpbuffer", which is a common
+ *      object used by all clients connected to a single camera.
+ *
+ * Returns: new allocated stream_buffer.
+ */
+static struct stream_buffer *stream_tmpbuffer(int size)
+{
+    struct stream_buffer *tmpbuffer = mymalloc(sizeof(struct stream_buffer));
+    tmpbuffer->ref = 0;
+    tmpbuffer->ptr = mymalloc(size);
+
+    return tmpbuffer;
+}
+
+/**
+ * stream_add_client
+ *
+ *
+ */
+static void stream_add_client(struct stream *list, int sc)
+{
+    struct stream *new = mymalloc(sizeof(struct stream));
+    static const char header[] = "HTTP/1.0 200 OK\r\n"
+                                 "Server: Motion/"VERSION"\r\n"
+                                 "Connection: close\r\n"
+                                 "Max-Age: 0\r\n"
+                                 "Expires: 0\r\n"
+                                 "Cache-Control: no-cache, private\r\n"
+                                 "Pragma: no-cache\r\n"
+                                 "Content-Type: multipart/x-mixed-replace; "
+                                 "boundary=BoundaryString\r\n\r\n";
+
+    memset(new, 0, sizeof(struct stream));
+    new->socket = sc;
+
+    if ((new->tmpbuffer = stream_tmpbuffer(sizeof(header))) == NULL) {
+        MOTION_LOG(ERR, TYPE_STREAM, SHOW_ERRNO, "%s: Error creating tmpbuffer in stream_add_client");
+    } else {
+        memcpy(new->tmpbuffer->ptr, header, sizeof(header)-1);
+        new->tmpbuffer->size = sizeof(header)-1;
+    }
+
+    new->prev = list;
+    new->next = list->next;
+
+    if (new->next)
+        new->next->prev = new;
+
+    list->next = new;
+}
+
+/**
+ * stream_add_write
+ *
+ *
+ */
+static void stream_add_write(struct stream *list, struct stream_buffer *tmpbuffer, unsigned int fps)
+{
+    struct timeval curtimeval;
+    unsigned long int curtime;
+
+    gettimeofday(&curtimeval, NULL);
+    curtime = curtimeval.tv_usec + 1000000L * curtimeval.tv_sec;
+
+    while (list->next) {
+        list = list->next;
+
+        if (list->tmpbuffer == NULL && ((curtime - list->last) >= 1000000L / fps)) {
+            list->last = curtime;
+            list->tmpbuffer = tmpbuffer;
+            tmpbuffer->ref++;
+            list->filepos = 0;
+        }
+    }
+
+    if (tmpbuffer->ref <= 0) {
+        free(tmpbuffer->ptr);
+        free(tmpbuffer);
+    }
+}
+
+
+/**
+ * stream_check_write
+ *      We walk through the chain of stream structs until we reach the end.
+ *      Here we check if the tmpbuffer points to NULL.
+ *      We return 1 if it finds a list->tmpbuffer which is a NULL pointer which would
+ *      be the next client ready to be sent a new image. If not a 0 is returned.
+ *
+ * Returns:
+ */
+static int stream_check_write(struct stream *list)
+{
+    while (list->next) {
+        list = list->next;
+
+        if (list->tmpbuffer == NULL)
+            return 1;
+    }
+    return 0;
+}
+
+
+/**
+ * stream_init
+ *      This function is called from motion.c for each motion thread starting up.
+ *      The function setup the incoming tcp socket that the clients connect to.
+ *      The function returns an integer representing the socket.
+ *
+ * Returns: stream socket descriptor.
+ */
+int stream_init(struct context *cnt)
+{
+    cnt->stream.socket = http_bindsock(cnt->conf.stream_port, cnt->conf.stream_localhost,
+                                       cnt->conf.ipv6_enabled);
+    cnt->stream.next = NULL;
+    cnt->stream.prev = NULL;
+    return cnt->stream.socket;
+}
+
+/**
+ * stream_stop
+ *      This function is called from the motion_loop when it ends
+ *      and motion is terminated or restarted.
+ */
+void stream_stop(struct context *cnt)
+{
+    struct stream *list;
+    struct stream *next = cnt->stream.next;
+
+    MOTION_LOG(NTC, TYPE_STREAM, NO_ERRNO, "%s: Closing motion-stream listen socket"
+               " & active motion-stream sockets");
+
+    close(cnt->stream.socket);
+    cnt->stream.socket = -1;
+
+    while (next) {
+        list = next;
+        next = list->next;
+
+        if (list->tmpbuffer) {
+            free(list->tmpbuffer->ptr);
+            free(list->tmpbuffer);
+        }
+
+        close(list->socket);
+        free(list);
+    }
+
+    MOTION_LOG(NTC, TYPE_STREAM, NO_ERRNO, "%s: Closed motion-stream listen socket"
+               " & active motion-stream sockets");
+}
+
+/*
+ * stream_put
+ *      Is the starting point of the stream loop. It is called from
+ *      the motion_loop with the argument 'image' pointing to the latest frame.
+ *      If config option 'stream_motion' is 'on' this function is called once
+ *      per second (frame 0) and when Motion is detected excl pre_capture.
+ *      If config option 'stream_motion' is 'off' this function is called once
+ *      per captured picture frame.
+ *      It is always run in setup mode for each picture frame captured and with
+ *      the special setup image.
+ *      The function does two things:
+ *          It looks for possible waiting new clients and adds them.
+ *          It sends latest picture frame to all connected clients.
+ *      Note: Clients that have disconnected are handled in the stream_flush()
+ *          function.
+ */
+void stream_put(struct context *cnt, unsigned char *image)
+{
+    struct timeval timeout;
+    struct stream_buffer *tmpbuffer;
+    fd_set fdread;
+    int sl = cnt->stream.socket;
+    int sc;
+    /* Tthe following string has an extra 16 chars at end for length. */
+    const char jpeghead[] = "--BoundaryString\r\n"
+                            "Content-type: image/jpeg\r\n"
+                            "Content-Length:                ";
+    int headlength = sizeof(jpeghead) - 1;    /* Don't include terminator. */
+    char len[20];    /* Will be used for sprintf, must be >= 16 */
+
+    /*
+     * Timeout struct used to timeout the time we wait for a client
+     * and we do not wait at all.
+     */
+    timeout.tv_sec = 0;
+    timeout.tv_usec = 0;
+    FD_ZERO(&fdread);
+    FD_SET(cnt->stream.socket, &fdread);
+
+    /*
+     * If we have not reached the max number of allowed clients per
+     * thread we will check to see if new clients are waiting to connect.
+     * If this is the case we add the client as a new stream struct and
+     * add this to the end of the chain of stream structs that are linked
+     * to each other.
+     */
+    if ((cnt->stream_count < DEF_MAXSTREAMS) &&
+        (select(sl + 1, &fdread, NULL, NULL, &timeout) > 0)) {
+        sc = http_acceptsock(sl);
+        if (cnt->conf.stream_auth_method == 0) {
+            stream_add_client(&cnt->stream, sc);
+            cnt->stream_count++;
+        } else  {
+            do_client_auth(cnt, sc);
+        }
+    }
+
+    /* Lock the mutex */
+    if (cnt->conf.stream_auth_method != 0)
+        pthread_mutex_lock(&stream_auth_mutex);
+
+
+    /* Call flush to send any previous partial-sends which are waiting. */
+    stream_flush(&cnt->stream, &cnt->stream_count, cnt->conf.stream_limit);
+
+    /* Check if any clients have available buffers. */
+    if (stream_check_write(&cnt->stream)) {
+        /*
+         * Yes - create a new tmpbuffer for current image.
+         * Note that this should create a buffer which is *much* larger
+         * than necessary, but it is difficult to estimate the
+         * minimum size actually required.
+         */
+        tmpbuffer = stream_tmpbuffer(cnt->imgs.size);
+
+        /* Check if allocation was ok. */
+        if (tmpbuffer) {
+            int imgsize;
+
+            /*
+             * We need a pointer that points to the picture buffer
+             * just after the mjpeg header. We create a working pointer wptr
+             * to be used in the call to put_picture_memory which we can change
+             * and leave tmpbuffer->ptr intact.
+             */
+            unsigned char *wptr = tmpbuffer->ptr;
+
+            /*
+             * For web protocol, our image needs to be preceded
+             * with a little HTTP, so we put that into the buffer
+             * first.
+             */
+            memcpy(wptr, jpeghead, headlength);
+
+            /* Update our working pointer to point past header. */
+            wptr += headlength;
+
+            /* Create a jpeg image and place into tmpbuffer. */
+            tmpbuffer->size = put_picture_memory(cnt, wptr, cnt->imgs.size, image,
+                                                 cnt->conf.stream_quality);
+
+            /* Fill in the image length into the header. */
+            imgsize = sprintf(len, "%9ld\r\n\r\n", tmpbuffer->size);
+            memcpy(wptr - imgsize, len, imgsize);
+
+            /* Append a CRLF for good measure. */
+            memcpy(wptr + tmpbuffer->size, "\r\n", 2);
+
+            /*
+             * Now adjust tmpbuffer->size to reflect the
+             * header at the beginning and the extra CRLF
+             * at the end.
+             */
+            tmpbuffer->size += headlength + 2;
+
+            /*
+             * And finally put this buffer to all clients with
+             * no outstanding data from previous frames.
+             */
+            stream_add_write(&cnt->stream, tmpbuffer, cnt->conf.stream_maxrate);
+        } else {
+            MOTION_LOG(ERR, TYPE_STREAM, SHOW_ERRNO, "%s: Error creating tmpbuffer");
+        }
+    }
+
+    /*
+     * Now we call flush again.  This time (assuming some clients were
+     * ready for the new frame) the new data will be written out.
+     */
+    stream_flush(&cnt->stream, &cnt->stream_count, cnt->conf.stream_limit);
+
+    /* Unlock the mutex */
+    if (cnt->conf.stream_auth_method != 0)
+        pthread_mutex_unlock(&stream_auth_mutex);
+
+    return;
+}
--- /dev/null
+++ motion-3.2.12/stream.h
@@ -0,0 +1,45 @@
+/*
+ *      stream.h
+ *      
+ *      Include file for stream.c
+ *      Copyright (C) 2002 Jeroen Vreeken (pe1rxq@amsat.org)
+ *
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this program; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#ifndef _INCLUDE_STREAM_H_
+#define _INCLUDE_STREAM_H_
+
+struct stream_buffer {
+    unsigned char *ptr;
+    int ref;
+    long size;
+};
+
+struct stream {
+    int socket;
+    FILE *fwrite;
+    struct stream_buffer *tmpbuffer;
+    long filepos;
+    int nr;
+    unsigned long int last;
+    struct stream *prev;
+    struct stream *next;
+};
+
+int stream_init(struct context *);
+void stream_put(struct context *, unsigned char *);
+void stream_stop(struct context *);
+
+#endif /* _INCLUDE_STREAM_H_ */
--- /dev/null
+++ motion-3.2.12/thread1.conf
@@ -0,0 +1,57 @@
+# /usr/local/etc/thread1.conf
+#
+# This config file was generated by motion 3.2.12-4ppa01 
+
+
+
+###########################################################
+# Capture device options
+############################################################
+
+# Videodevice to be used for capturing  (default /dev/video0)
+# for FreeBSD default is /dev/bktr0 
+videodevice /dev/video0
+
+# The video input to be used (default: -1)
+# Should normally be set to 1 for video/TV cards, and -1 for USB cameras 
+input -1
+
+# Draw a user defined text on the images using same options as C function strftime(3)
+# Default: Not defined = no text
+# Text is placed in lower left corner
+text_left CAMERA 1
+
+
+############################################################
+# Target Directories and filenames For Images And Films
+# For the options snapshot_, picture_, mpeg_ and timelapse_filename
+# you can use conversion specifiers
+# %Y = year, %m = month, %d = date,
+# %H = hour, %M = minute, %S = second,
+# %v = event, %q = frame number, %t = thread (camera) number,
+# %D = changed pixels, %N = noise level,
+# %i and %J = width and height of motion area,
+# %K and %L = X and Y coordinates of motion center
+# %C = value defined by text_event
+# Quotation marks round string are allowed.
+############################################################
+
+# Target base directory for pictures and films
+# Recommended to use absolute patch. (Default: current working directory)
+target_dir /usr/local/apache2/htdocs/cam1
+
+
+############################################################
+# Live Stream Server
+############################################################
+
+# The mini-http server listens to this port for requests (default: 0 = disabled)
+stream_port 8081
+
+# Command to be executed when a picture (.ppm|.jpg) is saved (default: none)
+# The filename of the picture is appended as an argument for the command.
+on_picture_save /usr/local/motion-extras/camparse1.pl
+
+# Command to be executed when a movie file (.mpg|.avi) is closed. (default: none)
+# Filename of movie is appended as an argument for the command.
+on_movie_end /usr/local/motion-extras/mpegparse1.pl 
--- motion-3.2.12.orig/thread1.conf.in
+++ motion-3.2.12/thread1.conf.in
@@ -12,9 +12,9 @@
 # for FreeBSD default is /dev/bktr0 
 videodevice /dev/video0
 
-# The video input to be used (default: 8)
-# Should normally be set to 1 for video/TV cards, and 8 for USB cameras 
-input 8
+# The video input to be used (default: -1)
+# Should normally be set to 1 for video/TV cards, and -1 for USB cameras 
+input -1
 
 # Draw a user defined text on the images using same options as C function strftime(3)
 # Default: Not defined = no text
@@ -24,7 +24,7 @@ text_left CAMERA 1
 
 ############################################################
 # Target Directories and filenames For Images And Films
-# For the options snapshot_, jpeg_, mpeg_ and timelapse_filename
+# For the options snapshot_, picture_, mpeg_ and timelapse_filename
 # you can use conversion specifiers
 # %Y = year, %m = month, %d = date,
 # %H = hour, %M = minute, %S = second,
@@ -42,11 +42,11 @@ target_dir /usr/local/apache2/htdocs/cam
 
 
 ############################################################
-# Live Webcam Server
+# Live Stream Server
 ############################################################
 
 # The mini-http server listens to this port for requests (default: 0 = disabled)
-webcam_port 8081
+stream_port 8081
 
 # Command to be executed when a picture (.ppm|.jpg) is saved (default: none)
 # The filename of the picture is appended as an argument for the command.
--- /dev/null
+++ motion-3.2.12/thread2.conf
@@ -0,0 +1,58 @@
+# /usr/local/etc/thread2.conf
+#
+# This config file was generated by motion 3.2.12-4ppa01
+
+
+
+###########################################################
+# Capture device options
+############################################################
+
+# Videodevice to be used for capturing  (default /dev/video0)
+# for FreeBSD default is /dev/bktr0 
+videodevice /dev/video1
+
+# The video input to be used (default: -1)
+# Should normally be set to 1 for video/TV cards, and -1 for USB cameras 
+input 1
+
+# Draw a user defined text on the images using same options as C function strftime(3)
+# Default: Not defined = no text
+# Text is placed in lower left corner
+text_left CAMERA 2
+
+
+############################################################
+# Target Directories and filenames For Images And Films
+# For the options snapshot_, picture_, mpeg_ and timelapse_filename
+# you can use conversion specifiers
+# %Y = year, %m = month, %d = date,
+# %H = hour, %M = minute, %S = second,
+# %v = event, %q = frame number, %t = thread (camera) number,
+# %D = changed pixels, %N = noise level,
+# %i and %J = width and height of motion area,
+# %K and %L = X and Y coordinates of motion center
+# %C = value defined by text_event
+# Quotation marks round string are allowed.
+############################################################
+
+# Target base directory for pictures and films
+# Recommended to use absolute patch. (Default: current working directory)
+target_dir /usr/local/apache2/htdocs/cam2
+
+
+############################################################
+# Live Stream Server
+############################################################
+
+# The mini-http server listens to this port for requests (default: 0 = disabled)
+stream_port 8082
+
+# Command to be executed when a picture (.ppm|.jpg) is saved (default: none)
+# The filename of the picture is appended as an argument for the command.
+on_picture_save /usr/local/motion-extras/camparse2.pl
+
+# Command to be executed when a movie file (.mpg|.avi) is closed. (default: none)
+# Filename of movie is appended as an argument for the command.
+on_movie_end /usr/local/motion-extras/mpegparse2.pl 
+
--- motion-3.2.12.orig/thread2.conf.in
+++ motion-3.2.12/thread2.conf.in
@@ -12,8 +12,8 @@
 # for FreeBSD default is /dev/bktr0 
 videodevice /dev/video1
 
-# The video input to be used (default: 8)
-# Should normally be set to 1 for video/TV cards, and 8 for USB cameras 
+# The video input to be used (default: -1)
+# Should normally be set to 1 for video/TV cards, and -1 for USB cameras 
 input 1
 
 # Draw a user defined text on the images using same options as C function strftime(3)
@@ -24,7 +24,7 @@ text_left CAMERA 2
 
 ############################################################
 # Target Directories and filenames For Images And Films
-# For the options snapshot_, jpeg_, mpeg_ and timelapse_filename
+# For the options snapshot_, picture_, mpeg_ and timelapse_filename
 # you can use conversion specifiers
 # %Y = year, %m = month, %d = date,
 # %H = hour, %M = minute, %S = second,
@@ -42,11 +42,11 @@ target_dir /usr/local/apache2/htdocs/cam
 
 
 ############################################################
-# Live Webcam Server
+# Live Stream Server
 ############################################################
 
 # The mini-http server listens to this port for requests (default: 0 = disabled)
-webcam_port 8082
+stream_port 8082
 
 # Command to be executed when a picture (.ppm|.jpg) is saved (default: none)
 # The filename of the picture is appended as an argument for the command.
--- /dev/null
+++ motion-3.2.12/thread3.conf
@@ -0,0 +1,60 @@
+# /usr/local/etc/thread3.conf
+#
+# This config file was generated by motion 3.2.12-4ppa01 
+
+
+
+###########################################################
+# Capture device options
+############################################################
+
+# Videodevice to be used for capturing  (default /dev/video0)
+# for FreeBSD default is /dev/bktr0 
+videodevice /dev/video2
+
+# The video input to be used (default: -1)
+# Should normally be set to 1 for video/TV cards, and -1 for USB cameras 
+input -1
+
+# Draw a user defined text on the images using same options as C function strftime(3)
+# Default: Not defined = no text
+# Text is placed in lower left corner
+text_left CAMERA 3
+
+
+############################################################
+# Target Directories and filenames For Images And Films
+# For the options snapshot_, picture_, mpeg_ and timelapse_filename
+# you can use conversion specifiers
+# %Y = year, %m = month, %d = date,
+# %H = hour, %M = minute, %S = second,
+# %v = event, %q = frame number, %t = thread (camera) number,
+# %D = changed pixels, %N = noise level,
+# %i and %J = width and height of motion area,
+# %K and %L = X and Y coordinates of motion center
+# %C = value defined by text_event
+# Quotation marks round string are allowed.
+############################################################
+
+# Target base directory for pictures and films
+# Recommended to use absolute patch. (Default: current working directory)
+target_dir /usr/local/apache2/htdocs/cam3
+
+
+############################################################
+# Live Stream Server
+############################################################
+
+# The mini-http server listens to this port for requests (default: 0 = disabled)
+stream_port 8083
+
+# Command to be executed when a picture (.ppm|.jpg) is saved (default: none)
+# The filename of the picture is appended as an argument for the command.
+on_picture_save /usr/local/motion-extras/camparse3.pl
+
+# Command to be executed when a movie file (.mpg|.avi) is closed. (default: none)
+# Filename of movie is appended as an argument for the command.
+on_movie_end /usr/local/motion-extras/mpegparse3.pl 
+
+
+
--- motion-3.2.12.orig/thread3.conf.in
+++ motion-3.2.12/thread3.conf.in
@@ -12,9 +12,9 @@
 # for FreeBSD default is /dev/bktr0 
 videodevice /dev/video2
 
-# The video input to be used (default: 8)
-# Should normally be set to 1 for video/TV cards, and 8 for USB cameras 
-input 8
+# The video input to be used (default: -1)
+# Should normally be set to 1 for video/TV cards, and -1 for USB cameras 
+input -1
 
 # Draw a user defined text on the images using same options as C function strftime(3)
 # Default: Not defined = no text
@@ -24,7 +24,7 @@ text_left CAMERA 3
 
 ############################################################
 # Target Directories and filenames For Images And Films
-# For the options snapshot_, jpeg_, mpeg_ and timelapse_filename
+# For the options snapshot_, picture_, mpeg_ and timelapse_filename
 # you can use conversion specifiers
 # %Y = year, %m = month, %d = date,
 # %H = hour, %M = minute, %S = second,
@@ -42,11 +42,11 @@ target_dir /usr/local/apache2/htdocs/cam
 
 
 ############################################################
-# Live Webcam Server
+# Live Stream Server
 ############################################################
 
 # The mini-http server listens to this port for requests (default: 0 = disabled)
-webcam_port 8083
+stream_port 8083
 
 # Command to be executed when a picture (.ppm|.jpg) is saved (default: none)
 # The filename of the picture is appended as an argument for the command.
--- /dev/null
+++ motion-3.2.12/thread4.conf
@@ -0,0 +1,62 @@
+# /usr/local/etc/thread4.conf
+#
+# This config file was generated by motion 3.2.12-4ppa01 
+
+###########################################################
+# Capture device options
+############################################################
+
+# URL to use if you are using a network camera, size will be autodetected (incl http:// ftp:// or file:///)
+# Must be a URL that returns single jpeg pictures or a raw mjpeg stream. Default: Not defined
+netcam_url http://192.168.1.6:8093/
+
+# The setting for keep-alive of network socket, should improve performance on compatible net cameras.
+# off:   The historical implementation using HTTP/1.0, closing the socket after each http request.
+# force: Use HTTP/1.0 requests with keep alive header to reuse the same connection.
+# on:    Use HTTP/1.1 requests that support keep alive as default.
+# Default: off
+netcam_keepalive force
+
+# Set less strict jpeg checks for network cameras with a poor/buggy firmware.
+# Default: off
+netcam_tolerant_check on
+
+# Draw a user defined text on the images using same options as C function strftime(3)
+# Default: Not defined = no text
+# Text is placed in lower left corner
+text_left CAMERA 4
+
+############################################################
+# Target Directories and filenames For Images And Films
+# For the options snapshot_, picture_, mpeg_ and timelapse_filename
+# you can use conversion specifiers
+# %Y = year, %m = month, %d = date,
+# %H = hour, %M = minute, %S = second,
+# %v = event, %q = frame number, %t = thread (camera) number,
+# %D = changed pixels, %N = noise level,
+# %i and %J = width and height of motion area,
+# %K and %L = X and Y coordinates of motion center
+# %C = value defined by text_event
+# Quotation marks round string are allowed.
+############################################################
+
+# Target base directory for pictures and films
+# Recommended to use absolute patch. (Default: current working directory)
+target_dir /usr/local/apache2/htdocs/cam4
+
+
+############################################################
+# Live Stream Server
+############################################################
+
+# The mini-http server listens to this port for requests (default: 0 = disabled)
+stream_port 8084
+
+# Command to be executed when a picture (.ppm|.jpg) is saved (default: none)
+# The filename of the picture is appended as an argument for the command.
+on_picture_save /usr/local/motion-extras/camparse4.pl
+
+# Command to be executed when a movie file (.mpg|.avi) is closed. (default: none)
+# Filename of movie is appended as an argument for the command.
+on_movie_end /usr/local/motion-extras/mpegparse4.pl 
+
--- motion-3.2.12.orig/thread4.conf.in
+++ motion-3.2.12/thread4.conf.in
@@ -11,11 +11,11 @@
 netcam_url http://192.168.1.6:8093/
 
 # The setting for keep-alive of network socket, should improve performance on compatible net cameras.
-# 1.0:         The historical implementation using HTTP/1.0, closing the socket after each http request.
-# keep_alive:  Use HTTP/1.0 requests with keep alive header to reuse the same connection.
-# 1.1:         Use HTTP/1.1 requests that support keep alive as default.
-# Default: 1.0
-netcam_http keep_alive
+# off:   The historical implementation using HTTP/1.0, closing the socket after each http request.
+# force: Use HTTP/1.0 requests with keep alive header to reuse the same connection.
+# on:    Use HTTP/1.1 requests that support keep alive as default.
+# Default: off
+netcam_keepalive force
 
 # Set less strict jpeg checks for network cameras with a poor/buggy firmware.
 # Default: off
@@ -26,10 +26,9 @@ netcam_tolerant_check on
 # Text is placed in lower left corner
 text_left CAMERA 4
 
-
 ############################################################
 # Target Directories and filenames For Images And Films
-# For the options snapshot_, jpeg_, mpeg_ and timelapse_filename
+# For the options snapshot_, picture_, mpeg_ and timelapse_filename
 # you can use conversion specifiers
 # %Y = year, %m = month, %d = date,
 # %H = hour, %M = minute, %S = second,
@@ -47,11 +46,11 @@ target_dir /usr/local/apache2/htdocs/cam
 
 
 ############################################################
-# Live Webcam Server
+# Live Stream Server
 ############################################################
 
 # The mini-http server listens to this port for requests (default: 0 = disabled)
-webcam_port 8084
+stream_port 8084
 
 # Command to be executed when a picture (.ppm|.jpg) is saved (default: none)
 # The filename of the picture is appended as an argument for the command.
--- motion-3.2.12.orig/track.c
+++ motion-3.2.12/track.c
@@ -7,10 +7,9 @@
  */
 
 #include <math.h>
-#include <termios.h>
 #include "motion.h"
 
-#ifndef WITHOUT_V4L
+#if defined(HAVE_LINUX_VIDEODEV_H) && (!defined(WITHOUT_V4L))
 #include "pwc-ioctl.h"
 #endif
 
@@ -22,50 +21,67 @@ struct trackoptions track_template = {
     motory:         0,              /* int motory */
     maxx:           0,              /* int maxx; */
     maxy:           0,              /* int maxy; */
+    minx:           0,              /* int minx; */
+    miny:           0,              /* int miny; */
+    homex:          128,            /* int homex; */
+    homey:          128,            /* int homey; */
+    motorx_reverse: 0,              /* int reversed x servo; */
+    motory_reverse: 0,              /* int reversed y servo; */
     speed:          TRACK_SPEED,    /* speed */
     stepsize:       TRACK_STEPSIZE, /* stepsize */
     active:         0,              /* auto tracking active */
     minmaxfound:    0,              /* flag for minmax values stored for pwc based camera */
-    step_angle_x:   10,             /* step angle in degrees X-axis that camera moves during auto tracking */
-    step_angle_y:   10,             /* step angle in degrees Y-axis that camera moves during auto tracking */
+    step_angle_x:   10,             /* UVC step angle in degrees X-axis that camera moves during auto tracking */
+    step_angle_y:   10,             /* UVC step angle in degrees Y-axis that camera moves during auto tracking */
     move_wait:      10              /* number of frames to disable motion detection after camera moving */
 };
 
 
+
+
 /* Add your own center and move functions here: */
-static unsigned short int stepper_center(struct context *, int xoff, int yoff ATTRIBUTE_UNUSED);
-static unsigned short int stepper_move(struct context *, struct coord *, struct images *);
-static unsigned short int iomojo_center(struct context *, int xoff, int yoff);
-static unsigned short int iomojo_move(struct context *, int dev, struct coord *, struct images *);
-#ifndef WITHOUT_V4L
-static unsigned short int lqos_center(struct context *, int dev, int xoff, int yoff);
-static unsigned short int lqos_move(struct context *, int dev, struct coord *, struct images *, 
-                                    unsigned short int);
+
+static unsigned int servo_position(struct context *cnt, unsigned int motor);
+
+static unsigned int servo_center(struct context *cnt, int xoff, int yoff ATTRIBUTE_UNUSED);
+static unsigned int stepper_center(struct context *cnt, int xoff, int yoff ATTRIBUTE_UNUSED);
+static unsigned int iomojo_center(struct context *cnt, int xoff, int yoff);
+
+static unsigned int stepper_move(struct context *cnt, struct coord *cent, struct images *imgs);
+static unsigned int servo_move(struct context *cnt, struct coord *cent,
+                                     struct images *imgs, unsigned int manual);
+static unsigned int iomojo_move(struct context *cnt, int dev, struct coord *cent, struct images *imgs);
+
+#if defined(HAVE_LINUX_VIDEODEV_H) && (!defined(WITHOUT_V4L))
+static unsigned int lqos_center(struct context *cnt, int dev, int xoff, int yoff);
+static unsigned int lqos_move(struct context *cnt, int dev, struct coord *cent,
+                                    struct images *imgs, unsigned int manual);
 #ifdef MOTION_V4L2
-static unsigned short int uvc_center(struct context *, int dev, int xoff, int yoff);
-static unsigned short int uvc_move(struct context *, int dev, struct coord *, struct images *, 
-                                   unsigned short int);
+static unsigned int uvc_center(struct context *cnt, int dev, int xoff, int yoff);
+static unsigned int uvc_move(struct context *cnt, int dev, struct coord *cent,
+                                   struct images *imgs, unsigned int manual);
 #endif /* MOTION_V4L2 */
 #endif /* WITHOUT_V4L */
 
 /* Add a call to your functions here: */
-unsigned short int track_center(struct context *cnt, int dev ATTRIBUTE_UNUSED, 
-                                unsigned short int manual, int xoff, int yoff)
+unsigned int track_center(struct context *cnt, int dev ATTRIBUTE_UNUSED,
+                                unsigned int manual, int xoff, int yoff)
 {
     if (!manual && !cnt->track.active)
         return 0;
 
     if (cnt->track.type == TRACK_TYPE_STEPPER) {
-        unsigned short int ret;
+        unsigned int ret;
         ret = stepper_center(cnt, xoff, yoff);
         if (!ret) {
-                motion_log(LOG_ERR, 1, "track_center: internal error (stepper_center)");
-                return 0;        
-        } else {
-            return ret;    
-        }    
+            MOTION_LOG(ERR, TYPE_TRACK, SHOW_ERRNO, "%s: internal error");
+            return 0;
+        }
+        else return ret;
+    } else if (cnt->track.type == TRACK_TYPE_SERVO) {
+        return servo_center(cnt, xoff, yoff);
     }
-#ifndef WITHOUT_V4L    
+#if defined(HAVE_LINUX_VIDEODEV_H) && (!defined(WITHOUT_V4L))
     else if (cnt->track.type == TRACK_TYPE_PWC)
         return lqos_center(cnt, dev, xoff, yoff);
 #ifdef MOTION_V4L2
@@ -78,22 +94,25 @@ unsigned short int track_center(struct c
     else if (cnt->track.type == TRACK_TYPE_GENERIC)
         return 10; // FIX ME. I chose to return something reasonable.
 
-    motion_log(LOG_ERR, 1, "track_center: internal error, %hu is not a known track-type", 
+    MOTION_LOG(ERR, TYPE_TRACK, SHOW_ERRNO, "%s: internal error, %hu is not a known track-type",
                cnt->track.type);
 
     return 0;
 }
 
 /* Add a call to your functions here: */
-unsigned short int track_move(struct context *cnt, int dev, struct coord *cent, 
-                              struct images *imgs, unsigned short int manual)
+unsigned int track_move(struct context *cnt, int dev, struct coord *cent, struct images *imgs,
+                              unsigned int manual)
 {
+
     if (!manual && !cnt->track.active)
         return 0;
 
     if (cnt->track.type == TRACK_TYPE_STEPPER)
         return stepper_move(cnt, cent, imgs);
-#ifndef WITHOUT_V4L
+    else if (cnt->track.type == TRACK_TYPE_SERVO)
+        return servo_move(cnt, cent, imgs, manual);
+#if defined(HAVE_LINUX_VIDEODEV_H) && (!defined(WITHOUT_V4L))
     else if (cnt->track.type == TRACK_TYPE_PWC)
         return lqos_move(cnt, dev, cent, imgs, manual);
 #ifdef MOTION_V4L2
@@ -106,22 +125,20 @@ unsigned short int track_move(struct con
     else if (cnt->track.type == TRACK_TYPE_GENERIC)
         return cnt->track.move_wait; // FIX ME. I chose to return something reasonable.
 
-    motion_log(LOG_ERR, 1, "track_move: internal error, %hu is not a known track-type", 
+    MOTION_LOG(WRN, TYPE_TRACK, SHOW_ERRNO, "%s: internal error, %hu is not a known track-type",
                cnt->track.type);
 
     return 0;
 }
 
-
 /******************************************************************************
     Stepper motor on serial port
-    http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionTracking
-    http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionTrackerAPI
+    http://www.lavrsen.dk/twiki/bin/view/Motion/MotionTracking
+    http://www.lavrsen.dk/twiki/bin/view/Motion/MotionTrackerAPI
 ******************************************************************************/
 
-
-static unsigned short int stepper_command(struct context *cnt, unsigned short int motor, 
-                                          unsigned short int command, unsigned short int data)
+static unsigned int stepper_command(struct context *cnt, unsigned int motor,
+                                    unsigned int command, unsigned int data)
 {
     char buffer[3];
     time_t timeout = time(NULL);
@@ -131,15 +148,15 @@ static unsigned short int stepper_comman
     buffer[2] = data;
 
     if (write(cnt->track.dev, buffer, 3) != 3) {
-        motion_log(LOG_ERR, 1, "stepper_command port %s dev fd %i, motor %hu command %hu data %hu",
-                               cnt->track.port, cnt->track.dev, motor, command, data);
+        MOTION_LOG(NTC, TYPE_TRACK, SHOW_ERRNO, "%s: port %s dev fd %i, motor %hu command %hu data %hu",
+                   cnt->track.port, cnt->track.dev, motor, command, data);
         return 0;
     }
 
     while (read(cnt->track.dev, buffer, 1) != 1 && time(NULL) < timeout + 1);
 
     if (time(NULL) >= timeout + 2) {
-        motion_log(LOG_ERR, 1, "Status byte timeout!");
+        MOTION_LOG(ERR, TYPE_TRACK, SHOW_ERRNO, "%s: Status byte timeout!");
         return 0;
     }
 
@@ -147,43 +164,46 @@ static unsigned short int stepper_comman
 }
 
 
-static unsigned short int stepper_status(struct context *cnt,  unsigned short int motor)
+static unsigned int stepper_status(struct context *cnt, unsigned int motor)
 {
     return stepper_command(cnt, motor, STEPPER_COMMAND_STATUS, 0);
 }
 
 
-static unsigned short int stepper_center(struct context *cnt, int x_offset, int y_offset)
+static unsigned int stepper_center(struct context *cnt, int x_offset, int y_offset)
 {
     struct termios adtio;
 
     if (cnt->track.dev < 0) {
-        motion_log(LOG_INFO, 0, "Try to open serial device %s", cnt->track.port);
-        
-        if ((cnt->track.dev=open(cnt->track.port, O_RDWR | O_NOCTTY)) < 0) {
-            motion_log(LOG_ERR, 1, "Unable to open serial device %s", cnt->track.port);
+        MOTION_LOG(NTC, TYPE_TRACK, NO_ERRNO, "%s: Try to open serial device %s", cnt->track.port);
+
+        if ((cnt->track.dev = open(cnt->track.port, O_RDWR | O_NOCTTY)) < 0) {
+            MOTION_LOG(ERR, TYPE_TRACK, SHOW_ERRNO, "%s: Unable to open serial device %s",
+                       cnt->track.port);
             return 0;
         }
 
         bzero (&adtio, sizeof(adtio));
-        adtio.c_cflag = STEPPER_BAUDRATE | CS8 | CLOCAL | CREAD;
-        adtio.c_iflag = IGNPAR;
-        adtio.c_oflag = 0;
-        adtio.c_lflag = 0;    /* non-canon, no echo */
+        adtio.c_cflag= STEPPER_BAUDRATE | CS8 | CLOCAL | CREAD;
+        adtio.c_iflag= IGNPAR;
+        adtio.c_oflag= 0;
+        adtio.c_lflag= 0;    /* non-canon, no echo */
         adtio.c_cc[VTIME] = 0;    /* timer unused */
         adtio.c_cc[VMIN] = 0;    /* blocking read until 1 char */
         tcflush (cnt->track.dev, TCIFLUSH);
 
         if (tcsetattr(cnt->track.dev, TCSANOW, &adtio) < 0) {
-            motion_log(LOG_ERR, 1, "Unable to initialize serial device %s", cnt->track.port);
+            MOTION_LOG(ERR, TYPE_TRACK, SHOW_ERRNO, "%s: Unable to initialize serial device %s",
+                       cnt->track.port);
+            cnt->track.dev = -1;
             return 0;
         }
-        motion_log(LOG_INFO, 0, "Opened serial device %s and initialize, fd %i", 
+        MOTION_LOG(NTC, TYPE_TRACK, NO_ERRNO, "%s: Opened serial device %s and initialize, fd %i",
                    cnt->track.port, cnt->track.dev);
     }
 
     /* x-axis */
-    
+
     stepper_command(cnt, cnt->track.motorx, STEPPER_COMMAND_SPEED, cnt->track.speed);
     stepper_command(cnt, cnt->track.motorx, STEPPER_COMMAND_LEFT_N, cnt->track.maxx);
 
@@ -200,33 +220,36 @@ static unsigned short int stepper_center
     stepper_command(cnt, cnt->track.motory, STEPPER_COMMAND_UP_N, cnt->track.maxy);
 
     while (stepper_status(cnt, cnt->track.motory) & STEPPER_STATUS_UP)
-    
+
     stepper_command(cnt, cnt->track.motory, STEPPER_COMMAND_DOWN_N,
                     cnt->track.maxy / 2 + y_offset * cnt->track.stepsize);
-        
+
     while (stepper_status(cnt, cnt->track.motory) & STEPPER_STATUS_DOWN);
-    
+
     return cnt->track.move_wait;
 }
 
-static unsigned short int stepper_move(struct context *cnt, struct coord *cent, 
-                                       struct images *imgs)
+static unsigned int stepper_move(struct context *cnt,
+                                       struct coord *cent, struct images *imgs)
 {
-    unsigned short int command = 0, data = 0;
+    unsigned int command = 0, data = 0;
 
     if (cnt->track.dev < 0) {
-        motion_log(LOG_INFO, 0, "No device %s started yet , trying stepper_center()", cnt->track.port);    
-        if (!stepper_center(cnt, 0, 0)){
-            motion_log(LOG_ERR, 1, "Stepper_center() failed to initialize stepper device on %s , fd [%i].", 
-                                    cnt->track.port, cnt->track.dev);    
+        MOTION_LOG(WRN, TYPE_TRACK, NO_ERRNO, "%s: No device %s started yet , trying stepper_center()",
+                   cnt->track.port);
+
+        if (!stepper_center(cnt, 0, 0)) {
+            MOTION_LOG(ERR, TYPE_TRACK, SHOW_ERRNO, "%s: failed to initialize stepper device on %s , fd [%i].",
+                       cnt->track.port, cnt->track.dev);
             return 0;
         }
-        motion_log(LOG_INFO, 0, "stepper_center() succeed , device started %s , fd [%i]", 
-                   cnt->track.port, cnt->track.dev);    
+
+        MOTION_LOG(NTC, TYPE_TRACK, NO_ERRNO, "%s: succeed , device started %s , fd [%i]",
+                    cnt->track.port, cnt->track.dev);
     }
 
     /* x-axis */
-    
+
     if (cent->x < imgs->width / 2) {
         command = STEPPER_COMMAND_LEFT_N;
         data = imgs->width / 2 - cent->x;
@@ -239,8 +262,7 @@ static unsigned short int stepper_move(s
 
     data = data * cnt->track.stepsize / imgs->width;
 
-    if (data) 
-        stepper_command(cnt, cnt->track.motorx, command, data);
+    if (data) stepper_command(cnt, cnt->track.motorx, command, data);
 
     /* y-axis */
 
@@ -253,24 +275,347 @@ static unsigned short int stepper_move(s
         command = STEPPER_COMMAND_DOWN_N;
         data = cent->y - imgs->height / 2;
     }
-    
+
     data = data * cnt->track.stepsize / imgs->height;
 
-    if (data) 
-        stepper_command(cnt, cnt->track.motory, command, data);    
-    
-    
+    if (data)
+        stepper_command(cnt, cnt->track.motory, command, data);
+
+
+    return cnt->track.move_wait;
+}
+
+/******************************************************************************
+ *   Servo motor on serial port
+ *   http://www.lavrsen.dk/twiki/bin/view/Motion/MotionTracking
+ *   http://www.lavrsen.dk/twiki/bin/view/Motion/MotionTrackerServoAPI
+ ******************************************************************************/
+
+static int servo_open(struct context *cnt)
+{
+    struct termios adtio;
+
+    if ((cnt->track.dev = open(cnt->track.port, O_RDWR | O_NOCTTY)) < 0) {
+        MOTION_LOG(ERR, TYPE_TRACK, SHOW_ERRNO, "%s: Unable to open serial device %s",
+                   cnt->track.port);
+        return 0;
+    }
+
+    bzero (&adtio, sizeof(adtio));
+    adtio.c_cflag= SERVO_BAUDRATE | CS8 | CLOCAL | CREAD;
+    adtio.c_iflag= IGNPAR;
+    adtio.c_oflag= 0;
+    adtio.c_lflag= 0;       /* non-canon, no echo */
+    adtio.c_cc[VTIME] = 0;  /* timer unused */
+    adtio.c_cc[VMIN] = 0;   /* blocking read until 1 char */
+    tcflush (cnt->track.dev, TCIFLUSH);
+
+    if (tcsetattr(cnt->track.dev, TCSANOW, &adtio) < 0) {
+        MOTION_LOG(ERR, TYPE_TRACK, NO_ERRNO, "%s: Unable to initialize serial device %s",
+                   cnt->track.port);
+        cnt->track.dev = -1;
+        return 0;
+    }
+
+    MOTION_LOG(NTC, TYPE_TRACK, NO_ERRNO, "%s: Opened serial device %s and initialize, fd %i",
+               cnt->track.port, cnt->track.dev);
+
+    return 1;
+}
+
+
+static unsigned int servo_command(struct context *cnt, unsigned int motor,
+                                  unsigned int command, unsigned int data)
+{
+    unsigned char buffer[3];
+    time_t timeout = time(NULL);
+
+    buffer[0] = motor;
+    buffer[1] = command;
+    buffer[2] = data;
+
+
+    MOTION_LOG(NTC, TYPE_TRACK, NO_ERRNO, "%s: SENDS port %s dev fd %i, motor %hu command %hu data %hu",
+               cnt->track.port, cnt->track.dev, buffer[0], buffer[1], buffer[2]);
+
+    if (write(cnt->track.dev, buffer, 3) != 3) {
+        MOTION_LOG(NTC, TYPE_TRACK, NO_ERRNO, "%s: port %s dev fd %i, motor %hu command %hu data %hu",
+                   cnt->track.port, cnt->track.dev, motor, command, data);
+        return 0;
+    }
+
+    while (read(cnt->track.dev, buffer, 1) != 1 && time(NULL) < timeout + 1);
+
+    if (time(NULL) >= timeout + 2) {
+        MOTION_LOG(ERR, TYPE_TRACK, NO_ERRNO, "%s: Status byte timeout!");
+        return 0;
+    }
+
+    MOTION_LOG(NTC, TYPE_TRACK, NO_ERRNO, "%s: Command return %d", buffer[0]);
+
+
+    return buffer[0];
+}
+
+
+static unsigned int servo_position(struct context *cnt, unsigned int motor)
+{
+    unsigned int ret = 0;
+
+    ret = servo_command(cnt, motor, SERVO_COMMAND_POSITION, 0);
+
+    return ret;
+}
+
+
+/**
+ * servo_move
+ *      Does relative movements to current position.
+ *
+ */
+static unsigned int servo_move(struct context *cnt, struct coord *cent,
+                                     struct images *imgs, unsigned int manual)
+{
+    unsigned int command = 0;
+    unsigned int data = 0;
+    unsigned int position;
+
+    /* If device is not open yet , open and center */
+    if (cnt->track.dev < 0) {
+        if (!servo_center(cnt, 0, 0)) {
+            MOTION_LOG(ERR, TYPE_TRACK, NO_ERRNO, "%s: Problem opening servo!");
+            return 0;
+        }
+    }
+
+    MOTION_LOG(NTC, TYPE_TRACK, NO_ERRNO, "%s: cent->x %d, cent->y %d, reversex %d,"
+               "reversey %d manual %d", cent->x , cent->y,
+               cnt->track.motorx_reverse, cnt->track.motory_reverse, manual);
+
+    if (manual) {
+        int offset;
+
+        if (cent->x) {
+            position = servo_position(cnt, cnt->track.motorx);
+            offset = cent->x * cnt->track.stepsize;
+
+
+            if ((cnt->track.motorx_reverse && (offset > 0)) ||
+                (!cnt->track.motorx_reverse && (offset < 0)))
+                command = SERVO_COMMAND_LEFT_N;
+            else
+                command = SERVO_COMMAND_RIGHT_N;
+
+            data = abs(offset);
+
+            if ((data + position > (unsigned)cnt->track.maxx) ||
+                (position - offset < (unsigned)cnt->track.minx)) {
+                MOTION_LOG(ERR, TYPE_TRACK, NO_ERRNO, "%s: x %d value out of range! (%d - %d)",
+                           data, cnt->track.minx, cnt->track.maxx);
+                return 0;
+            }
+
+            /* Set Speed , TODO : it should be done only when speed changes */
+            servo_command(cnt, cnt->track.motorx, SERVO_COMMAND_SPEED, cnt->track.speed);
+            servo_command(cnt, cnt->track.motorx, command, data);
+        }
+
+
+        if (cent->y) {
+            position = servo_position(cnt, cnt->track.motory);
+            offset = cent->y * cnt->track.stepsize;
+
+            if ((cnt->track.motory_reverse && (offset > 0)) ||
+                (!cnt->track.motory_reverse && (offset < 0)))
+                command = SERVO_COMMAND_UP_N;
+            else
+                command = SERVO_COMMAND_DOWN_N;
+
+            data = abs(offset);
+
+            if ((data + position > (unsigned)cnt->track.maxy) ||
+                (position - offset < (unsigned)cnt->track.miny)) {
+                MOTION_LOG(ERR, TYPE_TRACK, NO_ERRNO, "%s: y %d value out of range! (%d - %d)",
+                           data, cnt->track.miny, cnt->track.maxy);
+                return 0;
+            }
+
+            /* Set Speed , TODO : it should be done only when speed changes */
+            servo_command(cnt, cnt->track.motory, SERVO_COMMAND_SPEED, cnt->track.speed);
+            servo_command(cnt, cnt->track.motory, command, data);
+        }
+
+    } else {
+        /***** x-axis *****/
+
+        /* Move left */
+        if (cent->x < imgs->width / 2) {
+            if (cnt->track.motorx_reverse)
+                command = SERVO_COMMAND_RIGHT_N;
+            else
+                command = SERVO_COMMAND_LEFT_N;
+            data = imgs->width / 2 - cent->x;
+        }
+
+        /* Move right */
+        if (cent->x > imgs->width / 2) {
+            if (cnt->track.motorx_reverse)
+                command = SERVO_COMMAND_LEFT_N;
+            else
+                command = SERVO_COMMAND_RIGHT_N;
+            data = cent->x - imgs->width / 2;
+        }
+
+
+        MOTION_LOG(NTC, TYPE_TRACK, NO_ERRNO, "%s: X offset %d", data);
+
+        data = data * cnt->track.stepsize / imgs->width;
+
+        if (data && command) {
+
+            // TODO: need to get position to avoid overflow limits
+            position = servo_position(cnt, cnt->track.motorx);
+
+            if ((position + data > (unsigned)cnt->track.maxx) ||
+                (position - data < (unsigned)cnt->track.minx)) {
+                MOTION_LOG(ERR, TYPE_TRACK, NO_ERRNO, "%s: x %d value out of range! (%d - %d)",
+                           data, cnt->track.minx, cnt->track.maxx);
+                return 0;
+            }
+
+            /* Set Speed , TODO : it should be done only when speed changes */
+
+            servo_command(cnt, cnt->track.motorx, SERVO_COMMAND_SPEED, cnt->track.speed);
+            servo_command(cnt, cnt->track.motorx, command, data);
+
+            MOTION_LOG(NTC, TYPE_TRACK, NO_ERRNO, "%s: X cent->x %d, cent->y %d, reversex %d,"
+                       "reversey %d motorx %d data %d command %d",
+                       cent->x, cent->y, cnt->track.motorx_reverse,
+                       cnt->track.motory_reverse, cnt->track.motorx, data, command);
+        }
+
+        /***** y-axis *****/
+
+        /* Move down */
+        if (cent->y < imgs->height / 2) {
+            if (cnt->track.motory_reverse)
+                command = SERVO_COMMAND_UP_N;
+            else
+                command = SERVO_COMMAND_DOWN_N;
+            data = imgs->height / 2 - cent->y;
+        }
+
+        /* Move up */
+        if (cent->y > imgs->height / 2) {
+            if (cnt->track.motory_reverse)
+                command = SERVO_COMMAND_DOWN_N;
+            else
+                command = SERVO_COMMAND_UP_N;
+            data = cent->y - imgs->height / 2;
+        }
+
+        MOTION_LOG(NTC, TYPE_TRACK, NO_ERRNO, "%s: Y offset %d", data);
+
+        data = data * cnt->track.stepsize / imgs->height;
+
+        if (data && command) {
+
+            // TODO: need to get position to avoid overflow limits
+            position = servo_position(cnt, cnt->track.motory);
+
+            if ((position + data > (unsigned)cnt->track.maxy) ||
+                (position - data < (unsigned)cnt->track.miny)) {
+                MOTION_LOG(ERR, TYPE_TRACK, NO_ERRNO, "%s: y %d value out of range! (%d - %d)",
+                           data, cnt->track.miny, cnt->track.maxy);
+                return 0;
+            }
+
+            /* Set Speed , TODO : it should be done only when speed changes */
+            servo_command(cnt, cnt->track.motory, SERVO_COMMAND_SPEED, cnt->track.speed);
+            servo_command(cnt, cnt->track.motory, command, data);
+
+            MOTION_LOG(NTC, TYPE_TRACK, NO_ERRNO, "%s: Y cent->x %d, cent->y %d, reversex %d,"
+                       "reversey %d motory %d data %d command %d",
+                        cent->x, cent->y, cnt->track.motorx_reverse,
+                        cnt->track.motory_reverse, cnt->track.motory, command);
+        }
+    }
+
     return cnt->track.move_wait;
 }
 
+#if 0
+static unsigned int servo_status(struct context *cnt, unsigned int motor)
+{
+    return servo_command(cnt, motor, SERVO_COMMAND_STATUS, 0);
+}
+#endif
+
+/**
+ * servo_center
+ *      Moves servo to home position.
+ *      Does absolute movements ( offsets relative to home position ).
+ *
+ *      Note : Using Clockwise as a convention for right , left , up , down
+ *              so left minx , right maxx , down miny , up maxy
+ *
+ */
+
+static unsigned int servo_center(struct context *cnt, int x_offset, int y_offset)
+{
+    int x_offset_abs;
+    int y_offset_abs;
+
+    /* If device is not open yet */
+    if (cnt->track.dev < 0) {
+        if (!servo_open(cnt)) {
+            MOTION_LOG(ERR, TYPE_TRACK, NO_ERRNO, "%s: Problem opening servo!");
+            return 0;
+        }
+    }
+
+    MOTION_LOG(NTC, TYPE_TRACK, NO_ERRNO, "%s: X-offset %d, Y-offset %d, x-position %d. y-position %d,"
+               "reversex %d, reversey %d , stepsize %d", x_offset, y_offset,
+               cnt->track.homex + (x_offset * cnt->track.stepsize),
+               cnt->track.homey + (y_offset * cnt->track.stepsize),
+               cnt->track.motorx_reverse, cnt->track.motory_reverse,
+               cnt->track.stepsize);
+
+    /* x-axis */
+    if (cnt->track.motorx_reverse)
+        x_offset_abs = (128 - cnt->track.homex) - (x_offset * cnt->track.stepsize) + 128;
+    else
+        x_offset_abs = cnt->track.homex + (x_offset * cnt->track.stepsize);
+
+    if (x_offset_abs <= cnt->track.maxx  && x_offset_abs >= cnt->track.minx) {
+        /* Set Speed , TODO : it should be done only when speed changes */
+        servo_command(cnt, cnt->track.motorx, SERVO_COMMAND_SPEED, cnt->track.speed);
+        servo_command(cnt, cnt->track.motorx, SERVO_COMMAND_ABSOLUTE, x_offset_abs);
+    }
+
+    /* y-axis */
+    if (cnt->track.motory_reverse)
+        y_offset_abs = (128 - cnt->track.homey) - (y_offset * cnt->track.stepsize) + 128;
+    else
+        y_offset_abs = cnt->track.homey + (y_offset * cnt->track.stepsize);
+
+    if (y_offset_abs <= cnt->track.maxy && y_offset_abs >= cnt->track.minx) {
+        /* Set Speed , TODO : it should be done only when speed changes */
+        servo_command(cnt, cnt->track.motory, SERVO_COMMAND_SPEED, cnt->track.speed);
+        servo_command(cnt, cnt->track.motory, SERVO_COMMAND_ABSOLUTE, y_offset_abs);
+    }
+
+    return cnt->track.move_wait;
+}
+
+
 /******************************************************************************
 
     Iomojo Smilecam on serial port
 
 ******************************************************************************/
 
-static char iomojo_command(struct context *cnt, char *command, 
-                           unsigned short int len, unsigned short int ret)
+static char iomojo_command(struct context *cnt, char *command, int len, unsigned int ret)
 {
     char buffer[1];
     time_t timeout = time(NULL);
@@ -280,9 +625,9 @@ static char iomojo_command(struct contex
 
     if (ret) {
         while (read(cnt->track.dev, buffer, 1) != 1 && time(NULL) < timeout + 2);
-        
+
         if (time(NULL) >= timeout + 2) {
-            motion_log(LOG_ERR, 1, "Return byte timeout!");
+            MOTION_LOG(ERR, TYPE_TRACK, SHOW_ERRNO, "%s: Return byte timeout!");
             return 0;
         }
     }
@@ -290,36 +635,37 @@ static char iomojo_command(struct contex
     return buffer[0];
 }
 
-static void iomojo_setspeed(struct context *cnt, unsigned short int speed)
+static void iomojo_setspeed(struct context *cnt, unsigned int speed)
 {
     char command[3];
-    
+
     command[0] = IOMOJO_SETSPEED_CMD;
     command[1] = cnt->track.iomojo_id;
     command[2] = speed;
-    
+
     if (iomojo_command(cnt, command, 3, 1) != IOMOJO_SETSPEED_RET)
-        motion_log(LOG_ERR, 1, "Unable to set camera speed");
+        MOTION_LOG(ERR, TYPE_TRACK, SHOW_ERRNO, "%s: Unable to set camera speed");
 }
 
 static void iomojo_movehome(struct context *cnt)
 {
     char command[2];
-    
+
     command[0] = IOMOJO_MOVEHOME;
     command[1] = cnt->track.iomojo_id;
 
     iomojo_command(cnt, command, 2, 0);
 }
 
-static unsigned short int iomojo_center(struct context *cnt, int x_offset, int y_offset)
+static unsigned int iomojo_center(struct context *cnt, int x_offset, int y_offset)
 {
     struct termios adtio;
     char command[5], direction = 0;
 
-    if (cnt->track.dev<0) {
-        if ((cnt->track.dev=open(cnt->track.port, O_RDWR | O_NOCTTY)) < 0) {
-            motion_log(LOG_ERR, 1, "Unable to open serial device %s", cnt->track.port);
+    if (cnt->track.dev < 0) {
+        if ((cnt->track.dev = open(cnt->track.port, O_RDWR | O_NOCTTY)) < 0) {
+            MOTION_LOG(ERR, TYPE_TRACK, SHOW_ERRNO, "%s: Unable to open serial device %s",
+                       cnt->track.port);
             return 0;
         }
 
@@ -332,7 +678,8 @@ static unsigned short int iomojo_center(
         adtio.c_cc[VMIN] = 0;   /* blocking read until 1 char */
         tcflush(cnt->track.dev, TCIFLUSH);
         if (tcsetattr(cnt->track.dev, TCSANOW, &adtio) < 0) {
-            motion_log(LOG_ERR, 1, "Unable to initialize serial device %s", cnt->track.port);
+            MOTION_LOG(ERR, TYPE_TRACK, SHOW_ERRNO, "%s: Unable to initialize serial device %s",
+                       cnt->track.port);
             return 0;
         }
     }
@@ -341,16 +688,16 @@ static unsigned short int iomojo_center(
     iomojo_movehome(cnt);
 
     if (x_offset || y_offset) {
-        if (x_offset > 0)
+        if (x_offset > 0) {
             direction |= IOMOJO_DIRECTION_RIGHT;
-        else {
+        } else {
             direction |= IOMOJO_DIRECTION_LEFT;
             x_offset *= -1;
         }
 
-        if (y_offset > 0)
+        if (y_offset > 0) {
             direction |= IOMOJO_DIRECTION_UP;
-        else {
+        } else {
             direction |= IOMOJO_DIRECTION_DOWN;
             y_offset *= -1;
         }
@@ -369,19 +716,19 @@ static unsigned short int iomojo_center(
         iomojo_command(cnt, command, 5, 0);
     }
 
-    motion_log(LOG_INFO, 0, "iomojo_center() succeed");
+    MOTION_LOG(NTC, TYPE_TRACK, NO_ERRNO, "%s: succeed");
 
     return cnt->track.move_wait;
 }
 
-static unsigned short int iomojo_move(struct context *cnt, int dev, 
-                                      struct coord *cent, struct images *imgs)
+static unsigned int iomojo_move(struct context *cnt, int dev, struct coord *cent,
+                                      struct images *imgs)
 {
     char command[5];
     int direction = 0;
     int nx = 0, ny = 0;
     int i;
-    
+
     if (dev < 0)
         if (!iomojo_center(cnt, 0, 0))
             return 0;
@@ -428,7 +775,6 @@ static unsigned short int iomojo_move(st
             i = 25 * ny / 90;
         else
             i = 25 * nx / 90;
-
         return i;
     }
 
@@ -440,8 +786,8 @@ static unsigned short int iomojo_move(st
     Logitech QuickCam Orbit camera tracking code by folkert@vanheusden.com
 
 ******************************************************************************/
-#ifndef WITHOUT_V4L
-static unsigned short int lqos_center(struct context *cnt, int dev, int x_angle, int y_angle)
+#if defined(HAVE_LINUX_VIDEODEV_H) && (!defined(WITHOUT_V4L))
+static unsigned int lqos_center(struct context *cnt, int dev, int x_angle, int y_angle)
 {
     int reset = 3;
     struct pwc_mpt_angles pma;
@@ -450,48 +796,48 @@ static unsigned short int lqos_center(st
     if (cnt->track.dev == -1) {
 
         if (ioctl(dev, VIDIOCPWCMPTRESET, &reset) == -1) {
-            motion_log(LOG_ERR, 1, "Failed to reset pwc camera to starting position! Reason");
+            MOTION_LOG(ERR, TYPE_TRACK, SHOW_ERRNO, "%s: Failed to reset pwc camera to starting position! Reason");
             return 0;
         }
 
-        SLEEP(6,0)
+        SLEEP(6, 0);
 
         if (ioctl(dev, VIDIOCPWCMPTGRANGE, &pmr) == -1) {
-            motion_log(LOG_ERR, 1, "failed VIDIOCPWCMPTGRANGE");
+            MOTION_LOG(ERR, TYPE_TRACK, SHOW_ERRNO, "%s: failed VIDIOCPWCMPTGRANGE");
             return 0;
         }
 
         cnt->track.dev = dev;
         cnt->track.minmaxfound = 1;
-        cnt->track.panmin = pmr.pan_min;
-        cnt->track.panmax = pmr.pan_max;
-        cnt->track.tiltmin = pmr.tilt_min;
-        cnt->track.tiltmax = pmr.tilt_max;
+        cnt->track.minx = pmr.pan_min;
+        cnt->track.maxx = pmr.pan_max;
+        cnt->track.miny = pmr.tilt_min;
+        cnt->track.maxy = pmr.tilt_max;
     }
 
     if (ioctl(dev, VIDIOCPWCMPTGANGLE, &pma) == -1)
-        motion_log(LOG_ERR, 1, "ioctl VIDIOCPWCMPTGANGLE");
-    
+        MOTION_LOG(ERR, TYPE_TRACK, SHOW_ERRNO, "%s: ioctl VIDIOCPWCMPTGANGLE");
+
     pma.absolute = 1;
 
-    if (x_angle * 100 < cnt->track.panmax && x_angle * 100 > cnt->track.panmin)
+    if (x_angle * 100 < cnt->track.maxx && x_angle * 100 > cnt->track.minx)
         pma.pan = x_angle * 100;
 
-    if (y_angle * 100 < cnt->track.tiltmax && y_angle * 100 > cnt->track.tiltmin)
+    if (y_angle * 100 < cnt->track.maxy && y_angle * 100 > cnt->track.miny)
         pma.tilt = y_angle * 100;
 
     if (ioctl(dev, VIDIOCPWCMPTSANGLE, &pma) == -1) {
-        motion_log(LOG_ERR, 1, "Failed to pan/tilt pwc camera! Reason");
+        MOTION_LOG(ERR, TYPE_TRACK, SHOW_ERRNO, "%s: Failed to pan/tilt pwc camera! Reason");
         return 0;
     }
 
-    motion_log(LOG_INFO, 0, "lqos_center succeed");
+    MOTION_LOG(NTC, TYPE_TRACK, NO_ERRNO, "%s: succeed");
 
     return cnt->track.move_wait;
 }
 
-static unsigned short int lqos_move(struct context *cnt, int dev, struct coord *cent, 
-                                    struct images *imgs, unsigned short int manual)
+static unsigned int lqos_move(struct context *cnt, int dev, struct coord *cent,
+                                    struct images *imgs, unsigned int manual)
 {
     int delta_x = cent->x - (imgs->width / 2);
     int delta_y = cent->y - (imgs->height / 2);
@@ -501,9 +847,9 @@ static unsigned short int lqos_move(stru
 
     /* If we are on auto track we calculate delta, otherwise we use user input in degrees times 100 */
     if (!manual) {
-        if (delta_x > imgs->width * 3 / 8 && delta_x < imgs->width * 5 / 8)
+        if (delta_x > imgs->width * 3/8 && delta_x < imgs->width * 5/8)
             return 0;
-        if (delta_y > imgs->height * 3 / 8 && delta_y < imgs->height * 5 / 8)
+        if (delta_y > imgs->height * 3/8 && delta_y < imgs->height * 5/8)
             return 0;
 
         move_x_degrees = delta_x * cnt->track.step_angle_x * 100 / (imgs->width / 2);
@@ -512,46 +858,48 @@ static unsigned short int lqos_move(stru
         move_x_degrees = cent->x * 100;
         move_y_degrees = cent->y * 100;
     }
-    
+
     /* If we never checked for the min/max values for pan/tilt we do it now */
     if (cnt->track.minmaxfound == 0) {
         if (ioctl(dev, VIDIOCPWCMPTGRANGE, &pmr) == -1) {
-            motion_log(LOG_ERR, 1, "failed VIDIOCPWCMPTGRANGE");
+            MOTION_LOG(ERR, TYPE_TRACK, SHOW_ERRNO, "%s: failed VIDIOCPWCMPTGRANGE");
             return 0;
         }
         cnt->track.minmaxfound = 1;
-        cnt->track.panmin = pmr.pan_min;
-        cnt->track.panmax = pmr.pan_max;
-        cnt->track.tiltmin = pmr.tilt_min;
-        cnt->track.tiltmax = pmr.tilt_max;
+        cnt->track.minx = pmr.pan_min;
+        cnt->track.maxx = pmr.pan_max;
+        cnt->track.miny = pmr.tilt_min;
+        cnt->track.maxy = pmr.tilt_max;
     }
 
     /* Get current camera position */
     if (ioctl(dev, VIDIOCPWCMPTGANGLE, &pma) == -1)
-        motion_log(LOG_ERR, 1, "ioctl VIDIOCPWCMPTGANGLE");
+        MOTION_LOG(ERR, TYPE_TRACK, SHOW_ERRNO, "%s: ioctl VIDIOCPWCMPTGANGLE");
+
 
+    /*
+     * Check current position of camera and see if we need to adjust
+     * values down to what is left to move
+     */
+    if (move_x_degrees < 0 && (cnt->track.minx - pma.pan) > move_x_degrees)
+        move_x_degrees = (cnt->track.minx - pma.pan);
 
-    /* Check current position of camera and see if we need to adjust
-       values down to what is left to move */
-    if (move_x_degrees<0 && (cnt->track.panmin - pma.pan) > move_x_degrees)
-        move_x_degrees = (cnt->track.panmin - pma.pan);
+    if (move_x_degrees > 0 && (cnt->track.maxx - pma.pan) < move_x_degrees)
+        move_x_degrees = (cnt->track.maxx - pma.pan);
 
-    if (move_x_degrees>0 && (cnt->track.panmax - pma.pan) < move_x_degrees)
-        move_x_degrees = (cnt->track.panmax - pma.pan);
+    if (move_y_degrees < 0 && (cnt->track.miny - pma.tilt) > move_y_degrees)
+        move_y_degrees = (cnt->track.miny - pma.tilt);
 
-    if (move_y_degrees<0 && (cnt->track.tiltmin - pma.tilt) > move_y_degrees)
-        move_y_degrees = (cnt->track.tiltmin - pma.tilt);
+    if (move_y_degrees > 0 && (cnt->track.maxy - pma.tilt) < move_y_degrees)
+        move_y_degrees = (cnt->track.maxy - pma.tilt);
 
-    if (move_y_degrees>0 && (cnt->track.tiltmax - pma.tilt) < move_y_degrees)
-        move_y_degrees = (cnt->track.tiltmax - pma.tilt);
-        
     /* Move camera relative to current position */
     pma.absolute = 0;
     pma.pan = move_x_degrees;
     pma.tilt = move_y_degrees;
 
     if (ioctl(dev, VIDIOCPWCMPTSANGLE, &pma) == -1) {
-        motion_log(LOG_ERR, 1, "Failed to pan/tilt pwc camera! Reason");
+        MOTION_LOG(ERR, TYPE_TRACK, SHOW_ERRNO, "%s: Failed to pan/tilt pwc camera! Reason");
         return 0;
     }
 
@@ -560,14 +908,14 @@ static unsigned short int lqos_move(stru
 /******************************************************************************
 
     Logitech QuickCam Sphere camera tracking code by oBi
-    
-    Modify by Dirk Wesenberg(Munich) 30.03.07 
-    - for new API in uvcvideo 
+
+    Modify by Dirk Wesenberg(Munich) 30.03.07
+    - for new API in uvcvideo
     - add Trace-steps for investigation
 ******************************************************************************/
 #ifdef MOTION_V4L2
 
-static unsigned short int uvc_center(struct context *cnt, int dev, int x_angle, int y_angle)
+static unsigned int uvc_center(struct context *cnt, int dev, int x_angle, int y_angle)
 {
     /* CALC ABSOLUTE MOVING : Act.Position +/- delta to request X and Y */
     int move_x_degrees = 0, move_y_degrees = 0;
@@ -590,41 +938,40 @@ static unsigned short int uvc_center(str
         control_s.value = (unsigned char) reset;
 
         if (ioctl(dev, VIDIOC_S_CTRL, &control_s) < 0) {
-            motion_log(LOG_ERR, 1, "Failed to reset UVC camera to starting position! Reason");
+            MOTION_LOG(ERR, TYPE_TRACK, SHOW_ERRNO, "%s: Failed to reset UVC camera to starting position! Reason");
             return 0;
         }
-        motion_log(LOG_DEBUG, 0, "Reseting UVC camera to starting position");
 
-        SLEEP(8, 0)
+        MOTION_LOG(NTC, TYPE_TRACK, NO_ERRNO, "%s: Reseting UVC camera to starting position");
+
+        SLEEP(8, 0);
 
         /* Get camera range */
         struct v4l2_queryctrl queryctrl;
-
         queryctrl.id = V4L2_CID_PAN_RELATIVE;
 
         if (ioctl(dev, VIDIOC_QUERYCTRL, &queryctrl) < 0) {
-            motion_log(LOG_ERR, 1, "ioctl querycontrol");
+            MOTION_LOG(ERR, TYPE_TRACK, SHOW_ERRNO, "%s: ioctl querycontrol");
             return 0;
         }
 
-        motion_log(LOG_DEBUG, 0, "Getting camera range");
-        
+        MOTION_LOG(NTC, TYPE_TRACK, NO_ERRNO, "%s: Getting camera range");
 
-        /* DWe 30.03.07 The orig request failed : 
-        * must be VIDIOC_G_CTRL separate for pan and tilt or via VIDIOC_G_EXT_CTRLS - now for 1st manual 
-        * Range X = -70 to +70 degrees              
-        * Y = -30 to +30 degrees  
-        */    
-        
-//        //get mininum
-//        pan.value = queryctrl.minimum;
-
-        cnt->track.panmin = -4480 / INCPANTILT;
-        cnt->track.tiltmin = -1920 / INCPANTILT;
-//        //get maximum
-        cnt->track.panmax = 4480 / INCPANTILT; 
-        cnt->track.tiltmax = 1920 / INCPANTILT;
-//        pan.value = queryctrl.maximum;
+       /* DWe 30.03.07 The orig request failed :
+        * must be VIDIOC_G_CTRL separate for pan and tilt or via VIDIOC_G_EXT_CTRLS - now for 1st manual
+        * Range X = -70 to +70 degrees
+        * Y = -30 to +30 degrees
+        */
+
+        //get mininum
+        //pan.value = queryctrl.minimum;
+
+        cnt->track.minx = -4480 / INCPANTILT;
+        cnt->track.miny = -1920 / INCPANTILT;
+        //get maximum
+        cnt->track.maxx = 4480 / INCPANTILT;
+        cnt->track.maxy = 1920 / INCPANTILT;
+        //pan.value = queryctrl.maximum;
 
         cnt->track.dev = dev;
         cnt->track.pan_angle = 0;
@@ -635,130 +982,139 @@ static unsigned short int uvc_center(str
 
     struct v4l2_control control_s;
 
-    motion_log(LOG_DEBUG, 0, "INPUT_PARAM_ABS pan_min %d,pan_max %d,tilt_min %d,tilt_max %d ", 
-               cnt->track.panmin, cnt->track.panmax, cnt->track.tiltmin, cnt->track.tiltmax );
-    motion_log(LOG_DEBUG, 0, "INPUT_PARAM_ABS X_Angel %d, Y_Angel %d ", x_angle, y_angle);
+    MOTION_LOG(DBG, TYPE_TRACK, NO_ERRNO, "%s: INPUT_PARAM_ABS pan_min %d,pan_max %d,tilt_min %d,tilt_max %d ",
+               cnt->track.minx, cnt->track.maxx, cnt->track.miny, cnt->track.maxy);
+    MOTION_LOG(DBG, TYPE_TRACK, NO_ERRNO, "%s: INPUT_PARAM_ABS X_Angel %d, Y_Angel %d ",
+               x_angle, y_angle);
 
-    if (x_angle <= cnt->track.panmax && x_angle >= cnt->track.panmin)
+    if (x_angle <= cnt->track.maxx && x_angle >= cnt->track.minx)
         move_x_degrees = x_angle - (cnt->track.pan_angle);
 
-    if (y_angle <= cnt->track.tiltmax && y_angle >= cnt->track.tiltmin)
+    if (y_angle <= cnt->track.maxy && y_angle >= cnt->track.miny)
         move_y_degrees = y_angle - (cnt->track.tilt_angle);
-            
+
 
     /*
-    tilt up: - value
-    tilt down: + value
-    pan left: - value
-    pan right: + value
-    */
+     * tilt up: - value
+     * tilt down: + value
+     * pan left: - value
+     * pan right: + value
+     */
     pan.s16.pan = -move_x_degrees * INCPANTILT;
     pan.s16.tilt = -move_y_degrees * INCPANTILT;
-    
-    motion_log(LOG_DEBUG, 0, "For_SET_ABS move_X %d,move_Y %d", move_x_degrees, move_y_degrees);
-        
-    /* DWe 30.03.07 Must be broken in diff calls, because 
-        - one call for both is not accept via VIDIOC_S_CTRL -> maybe via VIDIOC_S_EXT_CTRLS
-        - The Webcam or uvcvideo does not like a call with a zero-move 
-    */
-    
+
+    MOTION_LOG(DBG, TYPE_TRACK, NO_ERRNO, "%s: For_SET_ABS move_X %d,move_Y %d",
+               move_x_degrees, move_y_degrees);
+
+    /* DWe 30.03.07 Must be broken in diff calls, because
+     * one call for both is not accept via VIDIOC_S_CTRL -> maybe via VIDIOC_S_EXT_CTRLS
+     * The Webcam or uvcvideo does not like a call with a zero-move
+     */
+
     if (move_x_degrees != 0) {
         control_s.id = V4L2_CID_PAN_RELATIVE;
-    //    control_s.value = pan.value;
+        //control_s.value = pan.value;
         control_s.value = pan.s16.pan;
+
         if (ioctl(dev, VIDIOC_S_CTRL, &control_s) < 0) {
-            motion_log(LOG_ERR, 1, "Failed to move UVC camera!");
+            MOTION_LOG(ERR, TYPE_TRACK, SHOW_ERRNO, "%s: Failed to move UVC camera!");
             return 0;
         }
     }
 
-    /* DWe 30.03.07 We must wait a little,before we set the next CMD, otherwise PAN is mad ... */     
-    if ((move_x_degrees != 0) && (move_y_degrees != 0)) 
-        SLEEP (1,0);
-       
-    
+    /* DWe 30.03.07 We must wait a little,before we set the next CMD, otherwise PAN is mad ... */
+    if ((move_x_degrees != 0) && (move_y_degrees != 0))
+        SLEEP(1, 0);
+
     if (move_y_degrees != 0) {
         control_s.id = V4L2_CID_TILT_RELATIVE;
-    //    control_s.value = pan.value;
+        //control_s.value = pan.value;
         control_s.value = pan.s16.tilt;
+
         if (ioctl(dev, VIDIOC_S_CTRL, &control_s) < 0) {
-            motion_log(LOG_ERR, 1, "Failed to move UVC camera!");
+            MOTION_LOG(ERR, TYPE_TRACK, SHOW_ERRNO, "%s: Failed to move UVC camera!");
             return 0;
-        }    
-    
+        }
     }
 
-    motion_log(LOG_DEBUG, 0,"Found MINMAX = %d", cnt->track.minmaxfound); 
+    MOTION_LOG(NTC, TYPE_TRACK, NO_ERRNO, "%s: Found MINMAX = %d",
+               cnt->track.minmaxfound);
 
     if (cnt->track.dev != -1) {
-        motion_log(LOG_DEBUG, 0," Before_ABS_Y_Angel : x= %d , Y= %d , ", 
-                   cnt->track.pan_angle, cnt->track.tilt_angle );
-        if (move_x_degrees != -1)  
+        MOTION_LOG(DBG, TYPE_TRACK, NO_ERRNO, "%s: Before_ABS_Y_Angel : x= %d , Y= %d, ",
+                   cnt->track.pan_angle, cnt->track.tilt_angle);
+
+        if (move_x_degrees != -1) {
             cnt->track.pan_angle += move_x_degrees;
-        
-        if (move_x_degrees != -1)  
+        }
+
+        if (move_x_degrees != -1) {
             cnt->track.tilt_angle += move_y_degrees;
-        
-        motion_log(LOG_DEBUG, 0," After_ABS_Y_Angel : x= %d , Y= %d , ", 
-                   cnt->track.pan_angle, cnt->track.tilt_angle );    
+        }
+
+        MOTION_LOG(NTC, TYPE_TRACK, NO_ERRNO, "%s: After_ABS_Y_Angel : x= %d , Y= %d",
+                   cnt->track.pan_angle, cnt->track.tilt_angle);
     }
 
     return cnt->track.move_wait;
 }
 
-static unsigned short int uvc_move(struct context *cnt, int dev, struct coord *cent, 
-                                   struct images *imgs, unsigned short int manual)
+static unsigned int uvc_move(struct context *cnt, int dev, struct coord *cent,
+                                   struct images *imgs, unsigned int manual)
 {
     /* RELATIVE MOVING : Act.Position +/- X and Y */
-    
+
     int delta_x = cent->x - (imgs->width / 2);
     int delta_y = cent->y - (imgs->height / 2);
     int move_x_degrees, move_y_degrees;
-    
-    /* DWe 30.03.07 Does the request of act.position from WebCam work ? luvcview shows at every position 180 :( */
-    /*        Now we init the Web by call Reset, so we can sure, that we are at x/y = 0,0                 */
-    /*         Don't worry, if the WebCam make a sound - over End at PAN  - hmmm, should it be normal ...? */
-    /*         PAN Value 7777 in relative will init also a want reset for CAM - it will be "0" after that  */  
+
+    /*
+     *  DWe 30.03.07 Does the request of act.position from WebCam work ? luvcview shows at every position 180 :(
+     *        Now we init the Web by call Reset, so we can sure, that we are at x/y = 0,0
+     *        Don't worry, if the WebCam make a sound - over End at PAN  - hmmm, should it be normal ...?
+     *        PAN Value 7777 in relative will init also a want reset for CAM - it will be "0" after that
+     */
     if ((cnt->track.minmaxfound != 1) || (cent->x == 7777)) {
-        unsigned short int reset = 3; //0-non reset, 1-reset pan, 2-reset tilt, 3-reset pan&tilt
+        unsigned int reset = 3; //0-non reset, 1-reset pan, 2-reset tilt, 3-reset pan&tilt
         struct v4l2_control control_s;
 
         control_s.id = V4L2_CID_PANTILT_RESET;
         control_s.value = (unsigned char) reset;
 
         if (ioctl(dev, VIDIOC_S_CTRL, &control_s) < 0) {
-            motion_log(LOG_ERR, 1, "Failed to reset UVC camera to starting position! Reason");
+            MOTION_LOG(ERR, TYPE_TRACK, SHOW_ERRNO, "%s: Failed to reset UVC camera to starting position! Reason");
             return 0;
         }
 
-        motion_log(LOG_DEBUG, 0, "Reseting UVC camera to starting position");
-        
+        MOTION_LOG(NTC, TYPE_TRACK, NO_ERRNO, "%s: Reseting UVC camera to starting position");
+
         /* set the "helpvalue" back to null because after reset CAM should be in x=0 and not 70 */
         cent->x = 0;
-        SLEEP(8,0);
-        
-        /* DWe 30.03.07 The orig request failed : 
-        * must be VIDIOC_G_CTRL separate for pan and tilt or via VIDIOC_G_EXT_CTRLS - now for 1st manual 
-        * Range X = -70 to +70 degrees              
-        *    Y = -30 to +30 degrees  
-        */    
-
-        cnt->track.panmin = -4480 / INCPANTILT;
-        cnt->track.tiltmin = -1920 / INCPANTILT;
-        cnt->track.panmax = 4480 / INCPANTILT; 
-        cnt->track.tiltmax = 1920 / INCPANTILT;
+        SLEEP(8, 0);
+
+        /*
+         * DWe 30.03.07 The orig request failed :
+         * must be VIDIOC_G_CTRL separate for pan and tilt or via VIDIOC_G_EXT_CTRLS - now for 1st manual
+         * Range X = -70 to +70 degrees
+         *       Y = -30 to +30 degrees
+         */
+
+        cnt->track.minx = -4480 / INCPANTILT;
+        cnt->track.miny = -1920 / INCPANTILT;
+        cnt->track.maxx = 4480 / INCPANTILT;
+        cnt->track.maxy = 1920 / INCPANTILT;
         cnt->track.dev = dev;
         cnt->track.pan_angle = 0;
         cnt->track.tilt_angle = 0;
         cnt->track.minmaxfound = 1;
     }
 
-    
+
     /* If we are on auto track we calculate delta, otherwise we use user input in degrees */
     if (!manual) {
-        if (delta_x > imgs->width * 3 / 8 && delta_x < imgs->width * 5 / 8)
+        if (delta_x > imgs->width * 3/8 && delta_x < imgs->width * 5/8)
             return 0;
-        if (delta_y > imgs->height * 3 / 8 && delta_y < imgs->height * 5 / 8)
+        if (delta_y > imgs->height * 3/8 && delta_y < imgs->height * 5/8)
             return 0;
 
         move_x_degrees = delta_x * cnt->track.step_angle_x / (imgs->width / 2);
@@ -780,91 +1136,92 @@ static unsigned short int uvc_move(struc
     union pantilt pan;
 
     if (cnt->track.minmaxfound == 1) {
-    /* Check current position of camera and see if we need to adjust
-    values down to what is left to move */
-        if (move_x_degrees<0 && (cnt->track.panmin - cnt->track.pan_angle) > move_x_degrees)
-            move_x_degrees = (cnt->track.panmin - cnt->track.pan_angle);
-
-        if (move_x_degrees>0 && (cnt->track.panmax - cnt->track.pan_angle) < move_x_degrees)
-            move_x_degrees = (cnt->track.panmax - cnt->track.pan_angle);
-
-        if (move_y_degrees<0 && (cnt->track.tiltmin - cnt->track.tilt_angle) > move_y_degrees)
-            move_y_degrees = (cnt->track.tiltmin - cnt->track.tilt_angle);
-
-        if (move_y_degrees>0 && (cnt->track.tiltmax - cnt->track.tilt_angle) < move_y_degrees)
-            move_y_degrees = (cnt->track.tiltmax - cnt->track.tilt_angle);
-    }
-
+    /*
+     * Check current position of camera and see if we need to adjust
+     * values down to what is left to move
+     */
+        if (move_x_degrees < 0 && (cnt->track.minx - cnt->track.pan_angle) > move_x_degrees)
+            move_x_degrees = cnt->track.minx - cnt->track.pan_angle;
+
+        if (move_x_degrees > 0 && (cnt->track.maxx - cnt->track.pan_angle) < move_x_degrees)
+            move_x_degrees = cnt->track.maxx - cnt->track.pan_angle;
+
+        if (move_y_degrees < 0 && (cnt->track.miny - cnt->track.tilt_angle) > move_y_degrees)
+            move_y_degrees = cnt->track.miny - cnt->track.tilt_angle;
+
+        if (move_y_degrees > 0 && (cnt->track.maxy - cnt->track.tilt_angle) < move_y_degrees)
+            move_y_degrees = cnt->track.maxy - cnt->track.tilt_angle;
+    }
+
+    MOTION_LOG(DBG, TYPE_TRACK, NO_ERRNO, "For_SET_REL pan_min %d,pan_max %d,tilt_min %d,tilt_max %d",
+               cnt->track.minx, cnt->track.maxx, cnt->track.miny, cnt->track.maxy);
+    MOTION_LOG(DBG, TYPE_TRACK, NO_ERRNO, "For_SET_REL track_pan_Angel %d, track_tilt_Angel %d",
+               cnt->track.pan_angle, cnt->track.tilt_angle);
+    MOTION_LOG(DBG, TYPE_TRACK, NO_ERRNO, "For_SET_REL move_X %d,move_Y %d", move_x_degrees, move_y_degrees);
 
-    motion_log(LOG_DEBUG, 0, "For_SET_REL pan_min %d,pan_max %d,tilt_min %d,tilt_max %d ", 
-               cnt->track.panmin, cnt->track.panmax, cnt->track.tiltmin, cnt->track.tiltmax );
-    motion_log(LOG_DEBUG, 0, "For_SET_REL track_pan_Angel %d, track_tilt_Angel %d ", 
-               cnt->track.pan_angle, cnt->track.tilt_angle);    
-    motion_log(LOG_DEBUG, 0, "For_SET_REL move_X %d,move_Y %d", 
-               move_x_degrees, move_y_degrees);
     /*
-    tilt up: - value
-    tilt down: + value
-    pan left: - value
-    pan right: + value
-    */
+     * tilt up: - value
+     * tilt down: + value
+     * pan left: - value
+     * pan right: + value
+     */
 
     pan.s16.pan = -move_x_degrees * INCPANTILT;
     pan.s16.tilt = -move_y_degrees * INCPANTILT;
-    
-    /* DWe 30.03.07 Must be broken in diff calls, because 
-           - one call for both is not accept via VIDIOC_S_CTRL -> maybe via VIDIOC_S_EXT_CTRLS
-           - The Webcam or uvcvideo does not like a call with a zero-move 
-        */
+
+    /* DWe 30.03.07 Must be broken in diff calls, because
+     * one call for both is not accept via VIDIOC_S_CTRL -> maybe via VIDIOC_S_EXT_CTRLS
+     * The Webcam or uvcvideo does not like a call with a zero-move
+     */
 
     if (move_x_degrees != 0) {
 
         control_s.id = V4L2_CID_PAN_RELATIVE;
 
         control_s.value = pan.s16.pan;
-        motion_log(LOG_DEBUG, 0," dev %d,addr= %d, control_S= %d,Wert= %d,", 
-                   dev,VIDIOC_S_CTRL, &control_s, pan.s16.pan ); 
+        MOTION_LOG(DBG, TYPE_TRACK, NO_ERRNO, " dev %d, addr= %d, control_S= %d, Wert= %d",
+                   dev, VIDIOC_S_CTRL, &control_s, pan.s16.pan);
 
-        if (ioctl(dev, VIDIOC_S_CTRL, &control_s) < 0) { 
-             motion_log(LOG_ERR, 1, "Failed to move UVC camera!");
+        if (ioctl(dev, VIDIOC_S_CTRL, &control_s) < 0) {
+            MOTION_LOG(ERR, TYPE_TRACK, SHOW_ERRNO, "%s: Failed to move UVC camera!");
             return 0;
         }
     }
-    
-    /* DWe 30.03.07 We must wait a little,before we set the next CMD, otherwise PAN is mad ... */     
-    if ((move_x_degrees != 0) && (move_y_degrees != 0)) 
-        SLEEP (1,0);
-       
+
+    /* DWe 30.03.07 We must wait a little,before we set the next CMD, otherwise PAN is mad ... */
+    if ((move_x_degrees != 0) && (move_y_degrees != 0))
+        SLEEP (1, 0);
 
 
     if (move_y_degrees != 0) {
 
         control_s.id = V4L2_CID_TILT_RELATIVE;
+
         control_s.value = pan.s16.tilt;
-        motion_log(LOG_DEBUG, 0," dev %d,addr= %d, control_S= %d, Wert= %d, ", 
-                   dev,VIDIOC_S_CTRL, &control_s, pan.s16.tilt); 
+        MOTION_LOG(DBG, TYPE_TRACK, NO_ERRNO, " dev %d,addr= %d, control_S= %d, Wert= %d",
+                   dev, VIDIOC_S_CTRL, &control_s, pan.s16.tilt);
 
         if (ioctl(dev, VIDIOC_S_CTRL, &control_s) < 0) {
-            motion_log(LOG_ERR, 1, "Failed to move UVC camera!");
+            MOTION_LOG(ERR, TYPE_TRACK, SHOW_ERRNO, "%s: Failed to move UVC camera!");
             return 0;
         }
     }
-    
-  
-    motion_log(LOG_DEBUG, 0,"Found MINMAX = %d", cnt->track.minmaxfound); 
-    
+
+    MOTION_LOG(DBG, TYPE_TRACK, NO_ERRNO, "%s: Found MINMAX = %d",
+                cnt->track.minmaxfound);
+
     if (cnt->track.minmaxfound == 1) {
-        motion_log(LOG_DEBUG, 0," Before_REL_Y_Angel : x= %d , Y= %d", 
+        MOTION_LOG(DBG, TYPE_TRACK, NO_ERRNO, "Before_REL_Y_Angel : x= %d , Y= %d",
                    cnt->track.pan_angle, cnt->track.tilt_angle);
-        
-        if (move_x_degrees != 0) 
+
+        if (move_x_degrees != 0)
             cnt->track.pan_angle += -pan.s16.pan / INCPANTILT;
-            
+
         if (move_y_degrees != 0)
             cnt->track.tilt_angle += -pan.s16.tilt / INCPANTILT;
-            
-         motion_log(LOG_DEBUG, 0," After_REL_Y_Angel : x= %d , Y= %d", 
-                    cnt->track.pan_angle, cnt->track.tilt_angle);
+
+        MOTION_LOG(DBG, TYPE_TRACK, NO_ERRNO, "After_REL_Y_Angel : x= %d , Y= %d",
+                   cnt->track.pan_angle, cnt->track.tilt_angle);
     }
 
     return cnt->track.move_wait;
--- motion-3.2.12.orig/track.h
+++ motion-3.2.12/track.h
@@ -10,40 +10,43 @@
 #define _INCLUDE_TRACK_H
 
 #include "alg.h"
+#include <termios.h>
 
 struct trackoptions {
     int dev;
     /* Config options: */
-    unsigned short int type;
+    unsigned int type;
     char *port;
-    unsigned short int motorx;
-    unsigned short int motory;
-    unsigned short int maxx;
-    unsigned short int maxy;
-    unsigned short int stepsize;
-    unsigned short int speed;
-    unsigned short int iomojo_id;
-    unsigned short int active;
-    int panmin;
-    int panmax;
-    int tiltmin;
-    int tiltmax;
-    unsigned short int minmaxfound;
-    unsigned short int step_angle_x;
-    unsigned short int step_angle_y;
-    unsigned short int move_wait;
-    // UVC
+    unsigned int motorx;
+    unsigned int motory;
+    int maxx;
+    int maxy;
+    int minx;
+    int miny;
+    unsigned int stepsize;
+    unsigned int speed;
+    unsigned int homex;
+    unsigned int homey;
+    unsigned int iomojo_id;
+    unsigned int active;
+    unsigned int motorx_reverse;
+    unsigned int motory_reverse;
+    unsigned int minmaxfound;
+    unsigned int step_angle_x;
+    unsigned int step_angle_y;
+    unsigned int move_wait;
+    /* UVC */
     int pan_angle; // degrees
     int tilt_angle; // degrees
 };
 
 extern struct trackoptions track_template;
 
-unsigned short int track_center(struct context *, int, unsigned short int, int, int);
-unsigned short int track_move(struct context *, int, struct coord *, struct images *, unsigned short int);
+unsigned int track_center(struct context *, int, unsigned int, int, int);
+unsigned int track_move(struct context *, int, struct coord *, struct images *, unsigned int);
 
 /*
-    Some default values:
+ * Some default values:
  */
 #define TRACK_SPEED             255
 #define TRACK_STEPSIZE          40
@@ -53,9 +56,10 @@ unsigned short int track_move(struct con
 #define TRACK_TYPE_PWC          3
 #define TRACK_TYPE_GENERIC      4
 #define TRACK_TYPE_UVC          5
+#define TRACK_TYPE_SERVO        6
 
 /*
-    Some defines for the Serial stepper motor:
+ * Some defines for the Serial stepper motor:
  */
 
 #define STEPPER_BAUDRATE        B9600
@@ -87,8 +91,53 @@ unsigned short int track_move(struct con
 #define STEPPER_COMMAND_DOWN    4
 
 
+
 /*
-    Some defines for the Iomojo Smilecam:
+ * Some defines for the Serial servo motor:
+ */
+
+/*
+ * Controlling:
+ * Three bytes are sent to the servo - BYTE1=SERVO_COMMAND BYTE2=COMMAND BYTE3=DATA
+ * eg, sending the command    01 02 08    would Command SERVO_COMMAND1 to move LEFT a total of 8 STEPS
+ *
+ * An extra command 0x08 has been added but here is the basic command set.
+ *
+ * 0x00 STATUS   - Current status byte will be returned, data byte ignored
+ * 0x01 LEFT_N   - Servo will take N Steps to the Left until it reaches the Servos safety limit
+ * 0x02 RIGHT_N  - Servo will take N Steps to the Right until it reaches the Servos safety limit
+ * 0x03 LEFT     - Servo will move to Left most position, data byte ignored.
+ * 0x04 RIGHT    - Servo will move to Right most position, data byte ignored.
+ * 0x05 SWEEP    - Servo will sweep between its extremes, data byte ignored.
+ * 0x06 STOP     -  Servo will Stop, data byte ignored
+ * 0x07 SPEED    - Set servos speed between 0 and 255.
+ * 0x08 ABSOLUTE - Set servo to absolute position between 0 and 255
+ * 0x09 POSITION - Get servo to absolute position between 0 and 255
+ * */
+
+#define SERVO_BAUDRATE        B9600
+
+#define SERVO_COMMAND_STATUS   0 
+#define SERVO_COMMAND_LEFT_N   1
+#define SERVO_COMMAND_RIGHT_N  2
+#define SERVO_COMMAND_LEFT     3
+#define SERVO_COMMAND_RIGHT    4
+#define SERVO_COMMAND_SWEEP    5
+#define SERVO_COMMAND_STOP     6
+#define SERVO_COMMAND_SPEED    7
+#define SERVO_COMMAND_ABSOLUTE 8
+#define SERVO_COMMAND_POSITION 9
+
+
+#define SERVO_COMMAND_UP_N     1
+#define SERVO_COMMAND_DOWN_N   2
+#define SERVO_COMMAND_UP       3
+#define SERVO_COMMAND_DOWN     4
+
+
+
+/*
+ * Some defines for the Iomojo Smilecam:
  */
 
 #define IOMOJO_BAUDRATE    B19200
@@ -109,14 +158,14 @@ unsigned short int track_move(struct con
 #ifndef WITHOUT_V4L
 
 /*
-    Defines for the Logitech QuickCam Orbit/Sphere USB webcam
-*/
+ * Defines for the Logitech QuickCam Orbit/Sphere USB webcam
+ */
 
 #define LQOS_VERTICAL_DEGREES   180
 #define LQOS_HORIZONAL_DEGREES  120
 
 /*
- * UVC
+ * UVC 
  */
 
 #ifdef MOTION_V4L2
--- motion-3.2.12.orig/version.sh
+++ motion-3.2.12/version.sh
@@ -3,4 +3,6 @@
 SNV_VERSION=`cd "$1" && LC_ALL=C svn info 2> /dev/null | grep Revision | cut -d' ' -f2`
 test $SNV_VERSION || SNV_VERSION=`cd "$1" && grep revision .svn/entries 2>/dev/null | cut -d '"' -f2`
 test $SNV_VERSION || SNV_VERSION=UNKNOWN
-echo -n "3.2.12"
+SNV_VERSION=`git show -s --format=%h`
+echo -n "3.2.12-4ppa01"
+
--- motion-3.2.12.orig/video.c
+++ motion-3.2.12/video.c
@@ -1,4 +1,5 @@
-/*    video.c
+/*
+ *    video.c
  *
  *    Video stream functions for motion.
  *    Copyright 2000 by Jeroen Vreeken (pe1rxq@amsat.org)
@@ -6,20 +7,15 @@
  *    See also the file 'COPYING'.
  *
  */
-#ifndef WITHOUT_V4L
-
 /* Common stuff: */
 #include "rotate.h"     /* already includes motion.h */
 #include "video.h"
 
+#if defined(HAVE_LINUX_VIDEODEV_H) && !defined(WITHOUT_V4L)
 
-/* for the v4l stuff: */
-#include <sys/mman.h>
-#include <math.h>
-#include <sys/utsname.h>
-#include <dirent.h>
-
-
+/**
+ * v4l_picture_controls
+ */
 static void v4l_picture_controls(struct context *cnt, struct video_dev *viddev)
 {
     int dev = viddev->fd;
@@ -29,7 +25,7 @@ static void v4l_picture_controls(struct
     if (cnt->conf.contrast && cnt->conf.contrast != viddev->contrast) {
 
         if (ioctl(dev, VIDIOCGPICT, &vid_pic) == -1)
-            motion_log(LOG_ERR, 1, "ioctl (VIDIOCGPICT)");
+            MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: ioctl (VIDIOCGPICT)");
 
         make_change = 1;
         vid_pic.contrast = cnt->conf.contrast * 256;
@@ -39,8 +35,8 @@ static void v4l_picture_controls(struct
     if (cnt->conf.saturation && cnt->conf.saturation != viddev->saturation) {
 
         if (!make_change) {
-            if (ioctl(dev, VIDIOCGPICT, &vid_pic) == -1)
-                motion_log(LOG_ERR, 1, "ioctl (VIDIOCGPICT)");
+            if (ioctl(dev, VIDIOCGPICT, &vid_pic)==-1)
+                MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: ioctl (VIDIOCGPICT)");
         }
 
         make_change = 1;
@@ -52,7 +48,7 @@ static void v4l_picture_controls(struct
 
         if (!make_change) {
             if (ioctl(dev, VIDIOCGPICT, &vid_pic) == -1)
-                motion_log(LOG_ERR, 1, "ioctl (VIDIOCGPICT)");
+                MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: ioctl (VIDIOCGPICT)");
         }
 
         make_change = 1;
@@ -67,71 +63,72 @@ static void v4l_picture_controls(struct
         int fps;
 
         if (ioctl(dev, VIDIOCGWIN, &vw) == -1) { 
-            motion_log(LOG_ERR, 1, "%s: ioctl VIDIOCGWIN", __FUNCTION__);
+            MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: ioctl VIDIOCGWIN");
         } else {
             fps = vw.flags  >> PWC_FPS_SHIFT;
-            motion_log(LOG_DEBUG, 0, "%s: Get Current framerate %d .. trying %d", 
-                       __FUNCTION__, fps, cnt->conf.frame_limit);
+            MOTION_LOG(INF, TYPE_VIDEO, NO_ERRNO, "%s: Get Current framerate %d .. trying %d", 
+                       fps, cnt->conf.frame_limit);
         }
 
         fps = cnt->conf.frame_limit;
         vw.flags = fps << PWC_FPS_SHIFT;
-
+    
         if (ioctl(dev, VIDIOCSWIN, &vw) == -1) {
-            motion_log(LOG_ERR, 1, "%s: ioctl VIDIOCSWIN", __FUNCTION__);                
+            MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: ioctl VIDIOCSWIN");                
         } else if (ioctl(dev, VIDIOCGWIN, &vw) == -1) {
-            motion_log(LOG_ERR, 1, "%s: ioctl VIDIOCGWIN", __FUNCTION__);
+            MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: ioctl VIDIOCGWIN");
         } else {
             fps = vw.flags  >> PWC_FPS_SHIFT;
-            motion_log(LOG_DEBUG, 0, "%s: Set new framerate %d", __FUNCTION__, fps);
+            MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: Set new framerate %d", fps);
         }  
 
         viddev->fps = fps;        
     }    
 #endif
 
-
     if (cnt->conf.autobright) {
         
         if (vid_do_autobright(cnt, viddev)) {
-            /* If we already read the VIDIOGPICT - we should not do it again */
+            /* If we already read the VIDIOGPICT - we should not do it again. */
             if (!make_change) {
                 if (ioctl(dev, VIDIOCGPICT, &vid_pic) == -1)
-                    motion_log(LOG_ERR, 1, "ioctl (VIDIOCGPICT)");
+                    MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: ioctl (VIDIOCGPICT)");
             }
                     
             vid_pic.brightness = viddev->brightness * 256;
             make_change = 1;
         }
     
-    } else {
-        if (cnt->conf.brightness && cnt->conf.brightness != viddev->brightness) {
-            if (!make_change) {
-                if (ioctl(dev, VIDIOCGPICT, &vid_pic) == -1)
-                    motion_log(LOG_ERR, 1, "ioctl (VIDIOCGPICT)");
-            }
-    
-            make_change = 1;
-            vid_pic.brightness = cnt->conf.brightness * 256;
-            viddev->brightness = cnt->conf.brightness;
-        }
+    } else if (cnt->conf.brightness && cnt->conf.brightness != viddev->brightness) {
+        
+        if ((!make_change) && (ioctl(dev, VIDIOCGPICT, &vid_pic) == -1))
+            MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: ioctl (VIDIOCGPICT)");
+        
+        make_change = 1;
+        vid_pic.brightness = cnt->conf.brightness * 256;
+        viddev->brightness = cnt->conf.brightness;
     }
 
     if (make_change) {
         if (ioctl(dev, VIDIOCSPICT, &vid_pic) == -1)
-            motion_log(LOG_ERR, 1, "ioctl (VIDIOCSPICT)");
+            MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: ioctl (VIDIOCSPICT)");
     }
 }
 
-
-
-/*******************************************************************************************
+/*******************************************************************************
     Video4linux capture routines
-*/
+********************************************************************************/
 
-
-unsigned char *v4l_start(struct context *cnt, struct video_dev *viddev, int width, int height,
-                                int input, int norm, unsigned long freq, int tuner_number)
+/**
+ * v4l_start
+ *      Initialize video device to start capturing and allocates memory map 
+ *      for video device.
+ *      
+ * Returns mmapped buffer for video device or NULL if any error happens.
+ *
+ */ 
+unsigned char *v4l_start(struct video_dev *viddev, int width, int height,int input, 
+                         int norm, unsigned long freq, int tuner_number)
 {
     int dev = viddev->fd;
     struct video_capability vid_caps;
@@ -142,7 +139,7 @@ unsigned char *v4l_start(struct context
     void *map;
 
     if (ioctl (dev, VIDIOCGCAP, &vid_caps) == -1) {
-        motion_log(LOG_ERR, 1, "ioctl (VIDIOCGCAP)");
+        MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: ioctl (VIDIOCGCAP)");
         return NULL;
     }
 
@@ -154,12 +151,14 @@ unsigned char *v4l_start(struct context
         vid_chnl.channel = input;
 
         if (ioctl (dev, VIDIOCGCHAN, &vid_chnl) == -1) {
-            motion_log(LOG_ERR, 1, "ioctl (VIDIOCGCHAN)");
+            MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: ioctl (VIDIOCGCHAN) Input %d", 
+                        input);
         } else {
             vid_chnl.channel = input;
             vid_chnl.norm    = norm;
             if (ioctl (dev, VIDIOCSCHAN, &vid_chnl) == -1) {
-                motion_log(LOG_ERR, 1, "ioctl (VIDIOCSCHAN)");
+                MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: ioctl (VIDIOCSCHAN) Input %d"
+                           " Standard method %d", input, norm);
                 return NULL;
             }
         }
@@ -169,28 +168,29 @@ unsigned char *v4l_start(struct context
         memset(&vid_tuner, 0, sizeof(struct video_tuner));
         vid_tuner.tuner = tuner_number;
         if (ioctl (dev, VIDIOCGTUNER, &vid_tuner) == -1) {
-            motion_log(LOG_ERR, 1, "ioctl (VIDIOCGTUNER)");
+            MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: ioctl (VIDIOCGTUNER) tuner %d", 
+                       tuner_number);
         } else {
-            if (vid_tuner.flags & VIDEO_TUNER_LOW) {
+            if (vid_tuner.flags & VIDEO_TUNER_LOW) 
                 freq = freq * 16; /* steps of 1/16 KHz */
-            } else {
-                freq = (freq * 10) / 625;
-            }
-
+            else 
+                freq = freq * 10 / 625;
+            
             if (ioctl(dev, VIDIOCSFREQ, &freq) == -1) {
-                motion_log(LOG_ERR, 1, "ioctl (VIDIOCSFREQ)");
+                MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: ioctl (VIDIOCSFREQ)"
+                           " Frequency %ul", freq);
                 return NULL;
             }
 
-            if (cnt->conf.setup_mode)
-                motion_log(-1, 0, "Frequency set");
+            MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: Set Tuner to %d Frequency set to %ul", 
+                       tuner_number, freq);
         }
     }
 
     if (ioctl (dev, VIDIOCGMBUF, &vid_buf) == -1) {
-        motion_log(LOG_ERR, 0, "ioctl(VIDIOCGMBUF) - Error device does not support memory map");
-        motion_log(LOG_ERR, 0, "V4L capturing using read is deprecated!");
-        motion_log(LOG_ERR, 0, "Motion only supports mmap.");
+        MOTION_LOG(ERR, TYPE_VIDEO, NO_ERRNO, "%s: ioctl(VIDIOCGMBUF) - Error device"
+                   " does not support memory map\n V4L capturing using read is deprecated!\n"
+                   "Motion only supports mmap.");
         return NULL;
     } else {
         map = mmap(0, vid_buf.size, PROT_READ|PROT_WRITE, MAP_SHARED, dev, 0);
@@ -206,7 +206,7 @@ unsigned char *v4l_start(struct context
         }
 
         if (MAP_FAILED == map) {
-            motion_log(LOG_ERR,1,"MAP_FAILED");
+            MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: MAP_FAILED");
             return NULL;
         }
 
@@ -215,32 +215,35 @@ unsigned char *v4l_start(struct context
         vid_mmap.frame = viddev->v4l_curbuffer;
         vid_mmap.width = width;
         vid_mmap.height = height;
+
         if (ioctl(dev, VIDIOCMCAPTURE, &vid_mmap) == -1) {
-            motion_log(LOG_DEBUG, 1, "Failed with YUV420P, trying YUV422 palette");
+            MOTION_LOG(WRN, TYPE_VIDEO, SHOW_ERRNO, "%s: Failed with YUV420P, "
+                       "trying YUV422 palette");
             viddev->v4l_fmt = VIDEO_PALETTE_YUV422;
             vid_mmap.format = viddev->v4l_fmt;
-
             /* Try again... */
             if (ioctl(dev, VIDIOCMCAPTURE, &vid_mmap) == -1) {
-                motion_log(LOG_DEBUG, 1, "Failed with YUV422, trying YUYV palette");
+                MOTION_LOG(WRN, TYPE_VIDEO, SHOW_ERRNO, "%s: Failed with YUV422,"
+                           " trying YUYV palette");
                 viddev->v4l_fmt = VIDEO_PALETTE_YUYV;
                 vid_mmap.format = viddev->v4l_fmt;
                 
                 if (ioctl(dev, VIDIOCMCAPTURE, &vid_mmap) == -1) {
-                    motion_log(LOG_DEBUG, 1, "Failed with YUYV, trying RGB24 palette");
+                    MOTION_LOG(WRN, TYPE_VIDEO, SHOW_ERRNO, "%s: Failed with YUYV, trying RGB24 palette"); 
                     viddev->v4l_fmt = VIDEO_PALETTE_RGB24;
                     vid_mmap.format = viddev->v4l_fmt;
-
                     /* Try again... */
+                
                     if (ioctl(dev, VIDIOCMCAPTURE, &vid_mmap) == -1) {
-                        motion_log(LOG_DEBUG, 1, "Failed with RGB24, trying GREYSCALE palette");
+                        MOTION_LOG(WRN, TYPE_VIDEO, SHOW_ERRNO, "%s: Failed with RGB24, trying"
+                                   "GREYSCALE palette");
                         viddev->v4l_fmt = VIDEO_PALETTE_GREY;
                         vid_mmap.format = viddev->v4l_fmt;
 
                         /* Try one last time... */
                         if (ioctl(dev, VIDIOCMCAPTURE, &vid_mmap) == -1) {
-                            motion_log(LOG_ERR, 1, "Failed with all supported palettes "
-                                                    "- giving up");
+                            MOTION_LOG(CRT, TYPE_VIDEO, SHOW_ERRNO, "%s: Failed with all supported palettes "
+                                       "- giving up");
                             return NULL;
                         }
                     }
@@ -252,23 +255,23 @@ unsigned char *v4l_start(struct context
     switch (viddev->v4l_fmt) {
     case VIDEO_PALETTE_YUV420P:
         viddev->v4l_bufsize = (width * height * 3) / 2;
-        motion_log(LOG_DEBUG, 0, "Using VIDEO_PALETTE_YUV420P palette");
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: Using VIDEO_PALETTE_YUV420P palette");
         break;
     case VIDEO_PALETTE_YUV422:
         viddev->v4l_bufsize = (width * height * 2);
-        motion_log(LOG_DEBUG, 0, "Using VIDEO_PALETTE_YUV422 palette");
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: Using VIDEO_PALETTE_YUV422 palette");
         break;
     case VIDEO_PALETTE_YUYV:
         viddev->v4l_bufsize = (width * height * 2);
-        motion_log(LOG_DEBUG, 0, "Using VIDEO_PALETTE_YUYV palette");
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: Using VIDEO_PALETTE_YUYV palette");
         break;
     case VIDEO_PALETTE_RGB24:
         viddev->v4l_bufsize = (width * height * 3);
-        motion_log(LOG_DEBUG, 0, "Using VIDEO_PALETTE_RGB24 palette");
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: Using VIDEO_PALETTE_RGB24 palette");
         break;
     case VIDEO_PALETTE_GREY:
         viddev->v4l_bufsize = width * height;
-        motion_log(LOG_DEBUG, 0, "Using VIDEO_PALETTE_GREY palette");
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: Using VIDEO_PALETTE_GREY palette");
         break;
     }
 
@@ -278,7 +281,7 @@ unsigned char *v4l_start(struct context
 
 /**
  * v4l_next
- *                v4l_next fetches a video frame from a v4l device
+ *                Fetches a video frame from a v4l device
  *
  * Parameters:
  *     viddev     Pointer to struct containing video device handle amd device parameters
@@ -299,7 +302,7 @@ int v4l_next(struct video_dev *viddev, u
     struct video_mmap vid_mmap;
     unsigned char *cap_map;
 
-    sigset_t set, old;
+    sigset_t  set, old;
 
     /* MMAP method is used */
     vid_mmap.format = viddev->v4l_fmt;
@@ -324,7 +327,8 @@ int v4l_next(struct video_dev *viddev, u
     vid_mmap.frame = viddev->v4l_curbuffer;
 
     if (ioctl(dev, VIDIOCMCAPTURE, &vid_mmap) == -1) {
-        motion_log(LOG_ERR, 1, "mcapture error in proc %d", getpid());
+        MOTION_LOG(ALR, TYPE_VIDEO, SHOW_ERRNO, "%s: mcapture error in proc %d", 
+                   getpid());
         sigprocmask (SIG_UNBLOCK, &old, NULL);
         return V4L_FATAL_ERROR;
     }
@@ -332,11 +336,12 @@ int v4l_next(struct video_dev *viddev, u
     vid_mmap.frame = frame;
 
     if (ioctl(dev, VIDIOCSYNC, &vid_mmap.frame) == -1) {
-        motion_log(LOG_ERR, 1, "sync error in proc %d", getpid());
+        MOTION_LOG(ALR, TYPE_VIDEO, SHOW_ERRNO, "%s: sync error in proc %d", 
+                   getpid());
         sigprocmask (SIG_UNBLOCK, &old, NULL);
     }
 
-    pthread_sigmask (SIG_UNBLOCK, &old, NULL);        /*undo the signal blocking*/
+    pthread_sigmask (SIG_UNBLOCK, &old, NULL);   /*undo the signal blocking*/
 
     switch (viddev->v4l_fmt) {
     case VIDEO_PALETTE_RGB24:
@@ -353,35 +358,59 @@ int v4l_next(struct video_dev *viddev, u
     return 0;
 }
 
-void v4l_set_input(struct context *cnt, struct video_dev *viddev, unsigned char *map, int width, 
-                   int height, int input, int norm, int skip, unsigned long freq, int tuner_number)
+/**
+ * v4l_set_input
+ *          Sets input for video device, adjust picture controls. 
+ *          If needed skip frames for round robin.
+ *
+ * Parameters:
+ *      cnt     Pointer to context struct
+ *      viddev  Pointer to struct containing video device handle amd device parameters
+ *      map     Pointer to the buffer in which the function puts the new image
+ *      width   Width of image in pixels
+ *      height  Height of image in pixels
+ *      conf    Pointer to config struct
+ *
+ * Returns nothing
+ */ 
+void v4l_set_input(struct context *cnt, struct video_dev *viddev, unsigned char *map, 
+                   int width, int height, struct config *conf)
 {
     int dev = viddev->fd;
-    int i;
     struct video_channel vid_chnl;
     struct video_tuner vid_tuner;
-    unsigned long frequnits = freq;
+    unsigned long frequnits , freq;
+    int input = conf->input;
+    int norm = conf->norm;
+    int tuner_number = conf->tuner_number;
     
-    if (input != viddev->input || width != viddev->width || height != viddev->height ||
-        freq != viddev->freq || tuner_number != viddev->tuner_number) {
+    frequnits = freq = conf->frequency;
 
+    if (input != viddev->input || width != viddev->width || height != viddev->height ||
+        freq != viddev->freq || tuner_number != viddev->tuner_number || norm != viddev->norm) {
+        unsigned int skip = conf->roundrobin_skip, i;      
+        
         if (freq) {
             memset(&vid_tuner, 0, sizeof(struct video_tuner));
-
             vid_tuner.tuner = tuner_number;
+
             if (ioctl (dev, VIDIOCGTUNER, &vid_tuner) == -1) {
-                motion_log(LOG_ERR, 1, "ioctl (VIDIOCGTUNER)");
+                MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: ioctl (VIDIOCGTUNER) tuner number %d", 
+                           tuner_number);
             } else {
                 if (vid_tuner.flags & VIDEO_TUNER_LOW) 
                     frequnits = freq * 16; /* steps of 1/16 KHz */
                 else 
                     frequnits = (freq * 10) / 625;
                 
-
                 if (ioctl(dev, VIDIOCSFREQ, &frequnits) == -1) {
-                    motion_log(LOG_ERR, 1, "ioctl (VIDIOCSFREQ)");
+                    MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: ioctl (VIDIOCSFREQ) Frequency %ul", 
+                               frequnits);
                     return;
                 }
+
+                 MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: Set Tuner to %d Frequency to %ul",
+                            tuner_number, frequnits);
             }
         }
 
@@ -389,233 +418,35 @@ void v4l_set_input(struct context *cnt,
         vid_chnl.channel = input;
         
         if (ioctl (dev, VIDIOCGCHAN, &vid_chnl) == -1) {
-            motion_log(LOG_ERR, 1, "ioctl (VIDIOCGCHAN)");
+            MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: ioctl (VIDIOCGCHAN) Input %d", 
+                       input);
         } else {
             vid_chnl.channel = input;
             vid_chnl.norm = norm;
+            
             if (ioctl (dev, VIDIOCSCHAN, &vid_chnl) == -1) {
-                motion_log(LOG_ERR, 1, "ioctl (VIDIOCSCHAN)");
+                MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: ioctl (VIDIOCSCHAN) Input %d"
+                           " Standard method %d", input, norm);
                 return;
-            }
+            } 
+
+            MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: Set Input to %d Standard method to %d", 
+                       input, norm);
         }
 
         v4l_picture_controls(cnt, viddev);
-        viddev->input = input;
-        viddev->width = width;
-        viddev->height = height;
-        viddev->freq =freq;
-        viddev->tuner_number = tuner_number;
+        conf->input = viddev->input = input;
+        conf->width = viddev->width = width;
+        conf->height = viddev->height = height;
+        conf->frequency = viddev->freq = freq;
+        conf->tuner_number = viddev->tuner_number = tuner_number;
+        conf->norm = viddev->norm = norm;
         /* skip a few frames if needed */
         for (i = 0; i < skip; i++)
             v4l_next(viddev, map, width, height);
-
     } else {
         /* No round robin - we only adjust picture controls */
         v4l_picture_controls(cnt, viddev);
     }
 }
-
-static int v4l_open_vidpipe(void)
-{
-    int pipe_fd = -1;
-    char pipepath[255];
-    char buffer[255];
-    char *major;
-    char *minor;
-    struct utsname uts;
-
-    if (uname(&uts) < 0) {
-        motion_log(LOG_ERR, 1, "Unable to execute uname");
-        return -1;
-    }
-    major = strtok(uts.release, ".");
-    minor = strtok(NULL, ".");
-    
-    if ((major == NULL) || (minor == NULL) || (strcmp(major, "2"))) {
-        motion_log(LOG_ERR, 1, "Unable to decipher OS version");
-        return -1;
-    }
-
-    if (strcmp(minor, "5") < 0) {
-        FILE *vloopbacks;
-        char *loop;
-        char *input;
-        char *istatus;
-        char *output;
-        char *ostatus;
-
-        vloopbacks = fopen("/proc/video/vloopback/vloopbacks", "r");
-    
-        if (!vloopbacks) {
-            motion_log(LOG_ERR, 1, "Failed to open '/proc/video/vloopback/vloopbacks'");
-            return -1;
-        }
-        
-        /* Read vloopback version*/
-        if (!fgets(buffer, 255, vloopbacks)) {
-            motion_log(LOG_ERR, 1, "Unable to read vloopback version");
-            return -1;
-        }
-        
-        fprintf(stderr,"\t%s", buffer);
-        
-        /* Read explanation line */
-        
-        if (!fgets(buffer, 255, vloopbacks)) {
-            motion_log(LOG_ERR, 1, "Unable to read vloopback explanation line");
-            return -1;
-        }
-        
-        while (fgets(buffer, 255, vloopbacks)) {
-            if (strlen(buffer) > 1) {
-                buffer[strlen(buffer)-1] = 0;
-                loop=strtok(buffer, "\t");
-                input=strtok(NULL, "\t");
-                istatus=strtok(NULL, "\t");
-                output=strtok(NULL, "\t");
-                ostatus=strtok(NULL, "\t");
-                if (istatus[0] == '-') {
-                    snprintf(pipepath, 255, "/dev/%s", input);
-                    pipe_fd = open(pipepath, O_RDWR);
-                    if (pipe_fd >= 0) {
-                        motion_log(-1, 0, "\tInput:  /dev/%s", input);
-                        motion_log(-1, 0, "\tOutput: /dev/%s", output);
-                        break;
-                    }
-                }
-            }
-        }
-        fclose(vloopbacks);
-    } else {
-        DIR *dir;
-        struct dirent *dirp;
-        const char prefix[] = "/sys/class/video4linux/";
-        char *ptr, *io;
-        int fd;
-        int low = 9999;
-        int tfd;
-        int tnum;
-
-        if ((dir=opendir(prefix)) == NULL) {
-            motion_log(LOG_ERR, 1, "Failed to open '%s'", prefix);
-            return -1;
-        }
-
-        while ((dirp=readdir(dir)) != NULL) {
-            if (!strncmp(dirp->d_name, "video", 5)) {
-                strncpy(buffer, prefix, sizeof(buffer));
-                strncat(buffer, dirp->d_name, sizeof(buffer) - strlen(buffer));
-                strncat(buffer, "/name", sizeof(buffer) - strlen(buffer));
-                if ((fd = open(buffer, O_RDONLY)) >= 0) {
-                    if ((read(fd, buffer, sizeof(buffer)-1)) < 0) {
-                        close(fd);
-                        continue;
-                    }
-
-                    ptr = strtok(buffer, " ");
-
-                    if (strcmp(ptr,"Video")) {
-                        close(fd);
-                        continue;
-                    }
-
-                    major = strtok(NULL, " ");
-                    minor = strtok(NULL, " ");
-                    io  = strtok(NULL, " \n");
-
-                    if (strcmp(major, "loopback") || strcmp(io, "input")) {
-                        close(fd);
-                        continue;
-                    }
-
-                    if ((ptr=strtok(buffer, " ")) == NULL) {
-                        close(fd);
-                        continue;
-                    }
-
-                    tnum = atoi(minor);
-
-                    if (tnum < low) {
-                        strcpy(buffer, "/dev/");
-                        strncat(buffer, dirp->d_name, sizeof(buffer) - strlen(buffer));
-                        if ((tfd=open(buffer, O_RDWR)) >= 0) {
-                            strncpy(pipepath, buffer, sizeof(pipepath));
-
-                            if (pipe_fd >= 0) 
-                                close(pipe_fd);
-                            
-                            pipe_fd = tfd;
-                            low = tnum;
-                        }
-                    }
-                    close(fd);
-                }
-            }
-        }
-        closedir(dir);
-
-        if (pipe_fd >= 0)
-            motion_log(-1, 0, "Opened input of %s", pipepath);
-    }
-
-    return pipe_fd;
-}
-
-static int v4l_startpipe(const char *dev_name, int width, int height, int type)
-{
-    int dev;
-    struct video_picture vid_pic;
-    struct video_window vid_win;
-
-    if (!strcmp(dev_name, "-"))
-        dev = v4l_open_vidpipe();
-    else
-        dev = open(dev_name, O_RDWR);
-    
-    if (dev < 0)
-        return -1;
-
-    if (ioctl(dev, VIDIOCGPICT, &vid_pic) == -1) {
-        motion_log(LOG_ERR, 1, "ioctl (VIDIOCGPICT)");
-        return -1;
-    }
-
-    vid_pic.palette = type;
-
-    if (ioctl(dev, VIDIOCSPICT, &vid_pic) == -1) {
-        motion_log(LOG_ERR, 1, "ioctl (VIDIOCSPICT)");
-        return -1;
-    }
-
-    if (ioctl(dev, VIDIOCGWIN, &vid_win) == -1) {
-        motion_log(LOG_ERR, 1, "ioctl (VIDIOCGWIN)");
-        return -1;
-    }
-
-    vid_win.height = height;
-    vid_win.width = width;
-
-    if (ioctl(dev, VIDIOCSWIN, &vid_win) == -1) {
-        motion_log(LOG_ERR, 1, "ioctl (VIDIOCSWIN)");
-        return -1;
-    }
-
-    return dev;
-}
-
-static int v4l_putpipe (int dev, unsigned char *image, int size)
-{
-    return write(dev, image, size);
-}
-
-
-int vid_startpipe(const char *dev_name, int width, int height, int type)
-{
-    return v4l_startpipe(dev_name, width, height, type);
-}
-
-int vid_putpipe (int dev, unsigned char *image, int size)
-{
-    return v4l_putpipe(dev, image, size);
-}
-#endif /*WITHOUT_V4L*/
+#endif /* !WITHOUT_V4L */
--- motion-3.2.12.orig/video.h
+++ motion-3.2.12/video.h
@@ -1,6 +1,6 @@
-/*    video.h
+/*	video.h
  *
- *    Include file for video.c
+ *	Include file for video.c
  *      Copyright 2000 by Jeroen Vreeken (pe1rxq@amsat.org)
  *      This software is distributed under the GNU public license version 2
  *      See also the file 'COPYING'.
@@ -11,30 +11,42 @@
 #define _INCLUDE_VIDEO_H
 
 #define _LINUX_TIME_H 1
-#ifndef WITHOUT_V4L
-#include <linux/videodev.h>
 #include <sys/mman.h>
+
+
+#if defined(HAVE_LINUX_VIDEODEV_H) && (!defined(WITHOUT_V4L))
+#include <linux/videodev.h>
+#include "vloopback_motion.h"
 #include "pwc-ioctl.h"
 #endif
 
 /* video4linux stuff */
-#define NORM_DEFAULT            0
-#define NORM_PAL                0
-#define NORM_NTSC               1
-#define NORM_SECAM              2
-#define NORM_PAL_NC             3
-#define IN_DEFAULT              8
-#define IN_TV                   0
-#define IN_COMPOSITE            1
-#define IN_COMPOSITE2           2
-#define IN_SVIDEO               3
+#define NORM_DEFAULT    0
+#define NORM_PAL        0
+#define NORM_NTSC       1
+#define NORM_SECAM      2
+#define NORM_PAL_NC     3
+#define IN_DEFAULT     -1
+#define IN_TV           0
+#define IN_COMPOSITE    1
+#define IN_COMPOSITE2   2
+#define IN_SVIDEO       3
 
 /* video4linux error codes */
-#define V4L_GENERAL_ERROR    0x01    /* binary 000001 */
-#define V4L_BTTVLOST_ERROR   0x05    /* binary 000101 */
-#define V4L_FATAL_ERROR        -1
+#define V4L_GENERAL_ERROR    0x01	/* binary 000001 */
+#define V4L_BTTVLOST_ERROR   0x05	/* binary 000101 */
+#define V4L_FATAL_ERROR      -1
+
+#define VIDEO_DEVICE "/dev/video0"
+
+typedef struct video_image_buff {
+    unsigned char *ptr;
+    int content_length;
+    size_t size;                    /* total allocated size */
+    size_t used;                    /* bytes already used */
+    struct timeval image_time;      /* time this image was received */
+} video_buff;
 
-#define VIDEO_DEVICE            "/dev/video0"
 
 struct video_dev {
     struct video_dev *next;
@@ -42,6 +54,7 @@ struct video_dev {
     int fd;
     const char *video_device;
     int input;
+    int norm;
     int width;
     int height;
     int brightness;
@@ -62,7 +75,7 @@ struct video_dev {
     /* v4l */
     int v4l2;
     void *v4l2_private;
-
+    
     int size_map;
     int v4l_fmt;
     unsigned char *v4l_buffers[2];
@@ -73,39 +86,35 @@ struct video_dev {
 };
 
 /* video functions, video_common.c */
-int vid_start(struct context *);
-int vid_next(struct context *, unsigned char *map);
+int vid_start(struct context *cnt);
+int vid_next(struct context *cnt, unsigned char *map);
 void vid_close(struct context *cnt);
 void vid_cleanup(void);
 void vid_init(void);
 void conv_yuv422to420p(unsigned char *map, unsigned char *cap_map, int width, int height);
 void conv_uyvyto420p(unsigned char *map, unsigned char *cap_map, unsigned int width, unsigned int height);
 void conv_rgb24toyuv420p(unsigned char *map, unsigned char *cap_map, int width, int height);
-int conv_jpeg2yuv420(struct context *cnt, unsigned char *dst, netcam_buff * buff, int width, int height);
-int sonix_decompress(unsigned char *outp, unsigned char *inp,int width, int height);
+int sonix_decompress(unsigned char *outp, unsigned char *inp, int width, int height);
 void bayer2rgb24(unsigned char *dst, unsigned char *src, long int width, long int height);
 int vid_do_autobright(struct context *cnt, struct video_dev *viddev);
 int mjpegtoyuv420p(unsigned char *map, unsigned char *cap_map, int width, int height, unsigned int size);
 
 #ifndef WITHOUT_V4L
 /* video functions, video.c */
-int vid_startpipe(const char *dev_name, int width, int height, int);
-int vid_putpipe(int dev, unsigned char *image, int);
-unsigned char *v4l_start(struct context *cnt, struct video_dev *viddev, int width, int height,
+unsigned char *v4l_start(struct video_dev *viddev, int width, int height,
                          int input, int norm, unsigned long freq, int tuner_number);
-void v4l_set_input(struct context *cnt, struct video_dev *viddev, unsigned char *map, int width, 
-                   int height, int input, int norm, int skip, unsigned long freq, int tuner_number);
+void v4l_set_input(struct context *cnt, struct video_dev *viddev, unsigned char *map, int width, int height,
+                   struct config *conf);
 int v4l_next(struct video_dev *viddev, unsigned char *map, int width, int height);
 
 /* video2.c */
 unsigned char *v4l2_start(struct context *cnt, struct video_dev *viddev, int width, int height,
                           int input, int norm, unsigned long freq, int tuner_number);
-void v4l2_set_input(struct context *cnt, struct video_dev *viddev, unsigned char *map, int width, 
-                    int height, struct config *conf);
+void v4l2_set_input(struct context *cnt, struct video_dev *viddev, unsigned char *map, int width, int height,
+                    struct config *conf);
 int v4l2_next(struct context *cnt, struct video_dev *viddev, unsigned char *map, int width, int height);
 void v4l2_close(struct video_dev *viddev);
 void v4l2_cleanup(struct video_dev *viddev);
-
 #endif /* WITHOUT_V4L */
 
-#endif                /* _INCLUDE_VIDEO_H */
+#endif /* _INCLUDE_VIDEO_H */
--- motion-3.2.12.orig/video2.c
+++ motion-3.2.12/video2.c
@@ -3,35 +3,57 @@
  *
  *    V4L2 interface with basically JPEG decompression support and even more ...
  *    Copyright 2006 Krzysztof Blaszkowski (kb@sysmikro.com.pl)
- *              2007 Angel Carpintero (ack@telefonica.net)
- 
+ *              2007 Angel Carpintero (motiondevelop@gmail.com)
+
  * Supported features and TODO
- *  - preferred palette is JPEG which seems to be very popular for many 640x480 usb cams
- *  - other supported palettes (NOT TESTED)
- *      V4L2_PIX_FMT_SBGGR8    (sonix)    
- *      V4L2_PIX_FMT_SN9C10X   (sonix)
- *      V4L2_PIX_FMT_MJPEG,    (tested)
- *      V4L2_PIX_FMT_JPEG,     (tested)
-        V4L2_PIX_FMT_RGB24,
-        V4L2_PIX_FMT_UYVY,     (tested)
-        V4L2_PIX_FMT_YUV422P,
-        V4L2_PIX_FMT_YUV420,   (tested)
-        V4L2_PIX_FMT_YUYV      (tested)
- 
- *  - setting tuner - NOT TESTED 
+   - preferred palette is JPEG which seems to be very popular for many 640x480 usb cams
+   - other supported palettes (NOT TESTED)
+       V4L2_PIX_FMT_SN9C10X   (sonix)
+       V4L2_PIX_FMT_SBGGR16,
+       V4L2_PIX_FMT_SBGGR8,   (sonix)
+       V4L2_PIX_FMT_SPCA561,
+       V4L2_PIX_FMT_SGBRG8,
+       V4L2_PIX_FMT_SGRBG8,
+       V4L2_PIX_FMT_PAC207,
+       V4L2_PIX_FMT_PJPG,
+       V4L2_PIX_FMT_MJPEG,    (tested)
+       V4L2_PIX_FMT_JPEG,     (tested)
+       V4L2_PIX_FMT_RGB24,
+       V4L2_PIX_FMT_SPCA501,
+       V4L2_PIX_FMT_SPCA505,
+       V4L2_PIX_FMT_SPCA508,
+       V4L2_PIX_FMT_UYVY,     (tested)
+       V4L2_PIX_FMT_YUV422P,
+       V4L2_PIX_FMT_YUV420,   (tested)
+       V4L2_PIX_FMT_YUYV      (tested)
+
+ *  - setting tuner - NOT TESTED
  *  - access to V4L2 device controls is missing. Partially added but requires some improvements likely.
- *  - changing resolution at run-time may not work. 
- *  - ucvideo svn r75 or above to work with MJPEG ( i.ex Logitech 5000 pro )
- 
+ *  - changing resolution at run-time may not work.
+ *  - ucvideo svn r75 or above to work with MJPEG ( e.g. Logitech 5000 pro )
+
  * This work is inspired by fswebcam and current design of motion.
  * This interface has been tested with ZC0301 driver from kernel 2.6.17.3 and Labtec's usb camera (PAS202 sensor)
- 
- * I'm very pleased by achieved image quality and cpu usage comparing to junky v4l1 spca5xx driver with 
+
+ * I'm very pleased by achieved image quality and cpu usage comparing to junky v4l1 spca5xx driver with
  * it nonsensical kernel messy jpeg decompressor.
  * Default sensor settings used by ZC0301 driver are very reasonable choosen.
  * apparently brigthness should be controlled automatically by motion still for light compensation.
  * it can be done by adjusting ADC gain and also exposure time.
- 
+
+ * Kernel 2.6.27
+
+ V4L2_PIX_FMT_SPCA501 v4l2_fourcc('S', '5', '0', '1')  YUYV per line
+ V4L2_PIX_FMT_SPCA505 v4l2_fourcc('S', '5', '0', '5')  YYUV per line
+ V4L2_PIX_FMT_SPCA508 v4l2_fourcc('S', '5', '0', '8')  YUVY per line
+ V4L2_PIX_FMT_SGBRG8  v4l2_fourcc('G', 'B', 'R', 'G')   8  GBGB.. RGRG..
+ V4L2_PIX_FMT_SGRBG8  v4l2_fourcc('G', 'R', 'B', 'G')   8  GRGR.. BGBG..
+ V4L2_PIX_FMT_SBGGR16 v4l2_fourcc('B', 'Y', 'R', '2')  16  BGBG.. GRGR..
+ V4L2_PIX_FMT_SPCA561 v4l2_fourcc('S', '5', '6', '1')  compressed GBRG bayer
+ V4L2_PIX_FMT_PJPG    v4l2_fourcc('P', 'J', 'P', 'G')  Pixart 73xx JPEG
+ V4L2_PIX_FMT_PAC207  v4l2_fourcc('P', '2', '0', '7')  compressed BGGR bayer
+
+
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -46,11 +68,9 @@
  let's go :)
 */
 
-#ifndef WITHOUT_V4L
-#ifdef MOTION_V4L2
+#if !defined(WITHOUT_V4L) && defined(MOTION_V4L2)
 
 #include "motion.h"
-#include "netcam.h"
 #include "video.h"
 
 #ifdef MOTION_V4L2_OLD
@@ -64,24 +84,60 @@
 #define u32 unsigned int
 #define s32 signed int
 
-#define MMAP_BUFFERS        4
-#define MIN_MMAP_BUFFERS    2
+#define MMAP_BUFFERS 4
+#define MIN_MMAP_BUFFERS 2
 
 #ifndef V4L2_PIX_FMT_SBGGR8
 /* see http://www.siliconimaging.com/RGB%20Bayer.htm */
-#define V4L2_PIX_FMT_SBGGR8             v4l2_fourcc('B','A','8','1')    /*  8  BGBG.. GRGR.. */
+#define V4L2_PIX_FMT_SBGGR8  v4l2_fourcc('B','A','8','1')  /*  8  BGBG.. GRGR.. */
 #endif
 
 #ifndef V4L2_PIX_FMT_MJPEG
-#define V4L2_PIX_FMT_MJPEG              v4l2_fourcc('M','J','P','G')    /* Motion-JPEG   */
+#define V4L2_PIX_FMT_MJPEG   v4l2_fourcc('M','J','P','G')  /* Motion-JPEG   */
 #endif
 
 #ifndef V4L2_PIX_FMT_SN9C10X
-#define V4L2_PIX_FMT_SN9C10X            v4l2_fourcc('S','9','1','0')    /* SN9C10x compression */
+#define V4L2_PIX_FMT_SN9C10X v4l2_fourcc('S','9','1','0')  /* SN9C10x compression */
+#endif
+
+#ifndef V4L2_PIX_FMT_SGBRG8
+#define V4L2_PIX_FMT_SGBRG8  v4l2_fourcc('G', 'B', 'R', 'G') /*  8  GBGB.. RGRG.. */
+#endif
+
+#ifndef V4L2_PIX_FMT_SGRBG8
+#define V4L2_PIX_FMT_SGRBG8  v4l2_fourcc('G', 'R', 'B', 'G') /*  8  GRGR.. BGBG.. */
+#endif
+
+#ifndef V4L2_PIX_FMT_SBGGR16
+#define V4L2_PIX_FMT_SBGGR16 v4l2_fourcc('B', 'Y', 'R', '2') /* 16  BGBG.. GRGR.. */
 #endif
 
-#define ZC301_V4L2_CID_DAC_MAGN         V4L2_CID_PRIVATE_BASE
-#define ZC301_V4L2_CID_GREEN_BALANCE    (V4L2_CID_PRIVATE_BASE+1)
+#ifndef V4L2_PIX_FMT_SPCA561
+#define V4L2_PIX_FMT_SPCA561 v4l2_fourcc('S', '5', '6', '1') /* compressed GBRG bayer */
+#endif
+
+#ifndef V4L2_PIX_FMT_PJPG
+#define V4L2_PIX_FMT_PJPG    v4l2_fourcc('P', 'J', 'P', 'G') /* Pixart 73xx JPEG */
+#endif
+
+#ifndef V4L2_PIX_FMT_PAC207
+#define V4L2_PIX_FMT_PAC207  v4l2_fourcc('P', '2', '0', '7') /* compressed BGGR bayer */
+#endif
+
+#ifndef V4L2_PIX_FMT_SPCA501
+#define V4L2_PIX_FMT_SPCA501 v4l2_fourcc('S', '5', '0', '1') /*  YUYV per line */
+#endif
+
+#ifndef V4L2_PIX_FMT_SPCA505
+#define V4L2_PIX_FMT_SPCA505 v4l2_fourcc('S', '5', '0', '5') /* YYUV per line  */
+#endif
+
+#ifndef V4L2_PIX_FMT_SPCA508
+#define V4L2_PIX_FMT_SPCA508 v4l2_fourcc('S', '5', '0', '8') /* YUVY per line  */
+#endif
+
+#define ZC301_V4L2_CID_DAC_MAGN       V4L2_CID_PRIVATE_BASE
+#define ZC301_V4L2_CID_GREEN_BALANCE  (V4L2_CID_PRIVATE_BASE+1)
 
 static const u32 queried_ctrls[] = {
     V4L2_CID_BRIGHTNESS,
@@ -103,15 +159,15 @@ static const u32 queried_ctrls[] = {
 
 typedef struct {
     int fd;
-    char map;
     u32 fps;
 
     struct v4l2_capability cap;
-    struct v4l2_format fmt;
+    struct v4l2_format src_fmt;
+    struct v4l2_format dst_fmt;
     struct v4l2_requestbuffers req;
     struct v4l2_buffer buf;
 
-    netcam_buff *buffers;
+    video_buff *buffers;
 
     s32 pframe;
 
@@ -120,121 +176,130 @@ typedef struct {
 
 } src_v4l2_t;
 
+/**
+ * xioctl
+ */
 static int xioctl(int fd, int request, void *arg)
 {
-    int r;
+    int ret;
 
     do
-        r = ioctl(fd, request, arg);
-    while (-1 == r && EINTR == errno);
+        ret = ioctl(fd, request, arg);
+    while (-1 == ret && EINTR == errno);
 
-    return r;
+    return ret;
 }
 
-static int v4l2_get_capability(src_v4l2_t * s)
+/**
+ * v4l2_get_capability
+ */
+static int v4l2_get_capability(src_v4l2_t * vid_source)
 {
-    if (xioctl(s->fd, VIDIOC_QUERYCAP, &s->cap) < 0) {
-        motion_log(LOG_ERR, 0, "Not a V4L2 device?");
+    if (xioctl(vid_source->fd, VIDIOC_QUERYCAP, &vid_source->cap) < 0) {
+        MOTION_LOG(ERR, TYPE_VIDEO, NO_ERRNO, "%s: Not a V4L2 device?");
         return -1;
     }
 
-    motion_log(LOG_INFO, 0, "cap.driver: \"%s\"", s->cap.driver);
-    motion_log(LOG_INFO, 0, "cap.card: \"%s\"", s->cap.card);
-    motion_log(LOG_INFO, 0, "cap.bus_info: \"%s\"", s->cap.bus_info);
-    motion_log(LOG_INFO, 0, "cap.capabilities=0x%08X", s->cap.capabilities);
-
-    if (s->cap.capabilities & V4L2_CAP_VIDEO_CAPTURE)
-        motion_log(LOG_INFO, 0, "- VIDEO_CAPTURE");
-
-    if (s->cap.capabilities & V4L2_CAP_VIDEO_OUTPUT)
-        motion_log(LOG_INFO, 0, "- VIDEO_OUTPUT");
+    MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: \n------------------------\n"
+               "cap.driver: \"%s\"\n"
+               "cap.card: \"%s\"\n"
+               "cap.bus_info: \"%s\"\n"
+               "cap.capabilities=0x%08X\n------------------------",
+               vid_source->cap.driver, vid_source->cap.card, vid_source->cap.bus_info,
+               vid_source->cap.capabilities);
+
+    if (vid_source->cap.capabilities & V4L2_CAP_VIDEO_CAPTURE)
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: - VIDEO_CAPTURE");
+    if (vid_source->cap.capabilities & V4L2_CAP_VIDEO_OUTPUT)
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: - VIDEO_OUTPUT");
+    if (vid_source->cap.capabilities & V4L2_CAP_VIDEO_OVERLAY)
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: - VIDEO_OVERLAY");
+    if (vid_source->cap.capabilities & V4L2_CAP_VBI_CAPTURE)
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: - VBI_CAPTURE");
+    if (vid_source->cap.capabilities & V4L2_CAP_VBI_OUTPUT)
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: - VBI_OUTPUT");
+    if (vid_source->cap.capabilities & V4L2_CAP_RDS_CAPTURE)
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: - RDS_CAPTURE");
+    if (vid_source->cap.capabilities & V4L2_CAP_TUNER)
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: - TUNER");
+    if (vid_source->cap.capabilities & V4L2_CAP_AUDIO)
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: - AUDIO");
+    if (vid_source->cap.capabilities & V4L2_CAP_READWRITE)
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: - READWRITE");
+    if (vid_source->cap.capabilities & V4L2_CAP_ASYNCIO)
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: - ASYNCIO");
+    if (vid_source->cap.capabilities & V4L2_CAP_STREAMING)
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: - STREAMING");
+    if (vid_source->cap.capabilities & V4L2_CAP_TIMEPERFRAME)
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: - TIMEPERFRAME");
 
-    if (s->cap.capabilities & V4L2_CAP_VIDEO_OVERLAY)
-        motion_log(LOG_INFO, 0, "- VIDEO_OVERLAY");
-
-    if (s->cap.capabilities & V4L2_CAP_VBI_CAPTURE)
-        motion_log(LOG_INFO, 0, "- VBI_CAPTURE");
-
-    if (s->cap.capabilities & V4L2_CAP_VBI_OUTPUT)
-        motion_log(LOG_INFO, 0, "- VBI_OUTPUT");
-
-    if (s->cap.capabilities & V4L2_CAP_RDS_CAPTURE)
-        motion_log(LOG_INFO, 0, "- RDS_CAPTURE");
-
-    if (s->cap.capabilities & V4L2_CAP_TUNER)
-        motion_log(LOG_INFO, 0, "- TUNER");
-
-    if (s->cap.capabilities & V4L2_CAP_AUDIO)
-        motion_log(LOG_INFO, 0, "- AUDIO");
-
-    if (s->cap.capabilities & V4L2_CAP_READWRITE)
-        motion_log(LOG_INFO, 0, "- READWRITE");
-
-    if (s->cap.capabilities & V4L2_CAP_ASYNCIO)
-        motion_log(LOG_INFO, 0, "- ASYNCIO");
-
-    if (s->cap.capabilities & V4L2_CAP_STREAMING)
-        motion_log(LOG_INFO, 0, "- STREAMING");
-
-    if (s->cap.capabilities & V4L2_CAP_TIMEPERFRAME)
-        motion_log(LOG_INFO, 0, "- TIMEPERFRAME");
-
-    if (!(s->cap.capabilities & V4L2_CAP_VIDEO_CAPTURE)) {
-        motion_log(LOG_ERR, 0, "Device does not support capturing.");
+    if (!(vid_source->cap.capabilities & V4L2_CAP_VIDEO_CAPTURE)) {
+        MOTION_LOG(ERR, TYPE_VIDEO, NO_ERRNO, "%s: Device does not support capturing.");
         return -1;
     }
 
     return 0;
 }
 
-static int v4l2_select_input(src_v4l2_t * s, int in, int norm, unsigned long freq_, int tuner_number ATTRIBUTE_UNUSED)
+/**
+ * v4l2_select_input
+ */
+static int v4l2_select_input(struct config *conf, struct video_dev *viddev,
+                             src_v4l2_t * vid_source, int in, int norm,
+                             unsigned long freq_, int tuner_number ATTRIBUTE_UNUSED)
 {
     struct v4l2_input input;
     struct v4l2_standard standard;
     v4l2_std_id std_id;
 
-    if (in == 8)
-        in = 0;
-
     /* Set the input. */
-    memset (&input, 0, sizeof (input));
-    input.index = in;
-
-    if (xioctl(s->fd, VIDIOC_ENUMINPUT, &input) == -1) {
-        motion_log(LOG_ERR, 1, "Unable to query input %d VIDIOC_ENUMINPUT", in);
+    memset(&input, 0, sizeof (input));
+    if (in == IN_DEFAULT)
+        input.index = IN_TV;
+    else input.index = in;
+
+    if (xioctl(vid_source->fd, VIDIOC_ENUMINPUT, &input) == -1) {
+        MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: Unable to query input %d."
+                   " VIDIOC_ENUMINPUT, if you use a WEBCAM change input value in conf by -1", 
+                   input.index);
         return -1;
     }
 
-    if (debug_level > CAMERA_VIDEO)
-        motion_log(LOG_INFO, 0, "%s: name = \"%s\", type 0x%08X, status %08x", __FUNCTION__, input.name, 
-                   input.type, input.status);
+    MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: name = \"%s\", type 0x%08X,"
+               " status %08x", input.name, input.type, input.status);
 
-    if ((input.type & V4L2_INPUT_TYPE_TUNER) && (debug_level > CAMERA_VIDEO))
-        motion_log(LOG_INFO, 0, "- TUNER");
+    if (input.type & V4L2_INPUT_TYPE_TUNER)
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: - TUNER");
 
-    if ((input.type & V4L2_INPUT_TYPE_CAMERA) && (debug_level > CAMERA_VIDEO)) 
-        motion_log(LOG_INFO, 0, "- CAMERA");
+    if (input.type & V4L2_INPUT_TYPE_CAMERA)
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: - CAMERA");
 
-    if (xioctl(s->fd, VIDIOC_S_INPUT, &in) == -1) {
-        motion_log(LOG_ERR, 1, "Error selecting input %d VIDIOC_S_INPUT", in);
+    if (xioctl(vid_source->fd, VIDIOC_S_INPUT, &input.index) == -1) {
+        MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: Error selecting input %d"
+                   " VIDIOC_S_INPUT", input.index);
         return -1;
     }
 
-    /* Set video standard usually webcams doesn't support the ioctl or return V4L2_STD_UNKNOWN */
-    if (xioctl(s->fd, VIDIOC_G_STD, &std_id) == -1) {
-        if (debug_level > CAMERA_VIDEO)
-            motion_log(LOG_INFO, 0, "Device doesn't support VIDIOC_G_STD");
-        std_id = 0;    // V4L2_STD_UNKNOWN = 0
+    viddev->input = conf->input = in;
+
+    /*
+     * Set video standard usually webcams doesn't support the ioctl or
+     * return V4L2_STD_UNKNOWN
+     */
+    if (xioctl(vid_source->fd, VIDIOC_G_STD, &std_id) == -1) {
+        MOTION_LOG(WRN, TYPE_VIDEO, NO_ERRNO, "%s: Device doesn't support VIDIOC_G_STD");
+        norm = std_id = 0;    // V4L2_STD_UNKNOWN = 0
     }
 
     if (std_id) {
         memset(&standard, 0, sizeof(standard));
         standard.index = 0;
 
-        while (xioctl(s->fd, VIDIOC_ENUMSTD, &standard) == 0) {
-            if ((standard.id & std_id)  && (debug_level > CAMERA_VIDEO))
-                motion_log(LOG_INFO, 0, "- video standard %s", standard.name);
-            
+        while (xioctl(vid_source->fd, VIDIOC_ENUMSTD, &standard) == 0) {
+            if (standard.id & std_id)
+                MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: - video standard %s",
+                           standard.name);
+
             standard.index++;
         }
 
@@ -249,11 +314,16 @@ static int v4l2_select_input(src_v4l2_t
             std_id = V4L2_STD_PAL;
         }
 
-        if (xioctl(s->fd, VIDIOC_S_STD, &std_id) == -1)
-            motion_log(LOG_ERR, 1, "Error selecting standard method %d VIDIOC_S_STD", std_id);
-        
+        if (xioctl(vid_source->fd, VIDIOC_S_STD, &std_id) == -1)
+            MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: Error selecting standard"
+                       " method %d VIDIOC_S_STD", (int)std_id);
+
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: Set standard method %d",
+                   (int)std_id);
     }
 
+    viddev->norm = conf->norm = norm;
+
     /* If this input is attached to a tuner, set the frequency. */
     if (input.type & V4L2_INPUT_TYPE_TUNER) {
         struct v4l2_tuner tuner;
@@ -264,34 +334,47 @@ static int v4l2_select_input(src_v4l2_t
         memset(&tuner, 0, sizeof(struct v4l2_tuner));
         tuner.index = input.tuner;
 
-        if (xioctl(s->fd, VIDIOC_G_TUNER, &tuner) == -1) {
-            motion_log(LOG_ERR, 1, "tuner %d VIDIOC_G_TUNER", tuner.index);    
+        if (xioctl(vid_source->fd, VIDIOC_G_TUNER, &tuner) == -1) {
+            MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: tuner %d VIDIOC_G_TUNER",
+                       tuner.index);
             return 0;
         }
 
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: Set tuner %d",
+                   tuner.index);
+
         /* Set the frequency. */
         memset(&freq, 0, sizeof(struct v4l2_frequency));
         freq.tuner = input.tuner;
         freq.type = V4L2_TUNER_ANALOG_TV;
         freq.frequency = (freq_ / 1000) * 16;
 
-        if (xioctl(s->fd, VIDIOC_S_FREQUENCY, &freq) == -1) {
-            motion_log(LOG_ERR, 1, "freq %lu VIDIOC_S_FREQUENCY", freq.frequency);
+        if (xioctl(vid_source->fd, VIDIOC_S_FREQUENCY, &freq) == -1) {
+            MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: freq %ul VIDIOC_S_FREQUENCY",
+                       freq.frequency);
             return 0;
         }
+
+        viddev->freq = conf->frequency = freq_;
+
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: Set Frequency to %ul",
+                   freq.frequency);
+    } else {
+        viddev->freq = conf->frequency = 0;
     }
 
     return 0;
 }
 
+
 /* *
  * v4l2_do_set_pix_format
- * 
+ *
  *          This routine does the actual request to the driver
- * 
+ *
  * Returns:  0  Ok
  *          -1  Problems setting palette or not supported
- * 
+ *
  * Our algorithm for setting the picture format for the data which the
  * driver returns to us will be as follows:
  *
@@ -308,71 +391,95 @@ static int v4l2_select_input(src_v4l2_t
  * We then request the driver to set the format we have chosen.  That request
  * should never fail, so if it does we log the fact and give up.
  */
-static int v4l2_do_set_pix_format(u32 pixformat, src_v4l2_t * s,
-				  int *width, int *height)
+static int v4l2_do_set_pix_format(u32 pixformat, src_v4l2_t * vid_source,
+                                  int *width, int *height)
 {
-    memset(&s->fmt, 0, sizeof(struct v4l2_format));
-    s->fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    s->fmt.fmt.pix.width = *width;
-    s->fmt.fmt.pix.height = *height;
-    s->fmt.fmt.pix.pixelformat = pixformat;
-    s->fmt.fmt.pix.field = V4L2_FIELD_ANY;
-
-    if (xioctl(s->fd, VIDIOC_TRY_FMT, &s->fmt) != -1 &&
-	       s->fmt.fmt.pix.pixelformat == pixformat) {
-        motion_log(LOG_INFO, 0, "Test palette %c%c%c%c (%dx%d)",
-                pixformat >> 0, pixformat >> 8, pixformat >> 16,
-                pixformat >> 24, *width, *height);
-
-        if (s->fmt.fmt.pix.width != (unsigned int) *width ||
-	        s->fmt.fmt.pix.height != (unsigned int) *height) {
-            motion_log(LOG_INFO, 0, "Adjusting resolution from %ix%i to %ix%i.",
-                       *width, *height, s->fmt.fmt.pix.width,
-		               s->fmt.fmt.pix.height);
-            *width = s->fmt.fmt.pix.width;
-            *height = s->fmt.fmt.pix.height;
+    CLEAR(vid_source->dst_fmt);
+    vid_source->dst_fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    vid_source->dst_fmt.fmt.pix.width = *width;
+    vid_source->dst_fmt.fmt.pix.height = *height;
+    vid_source->dst_fmt.fmt.pix.pixelformat = pixformat;
+    vid_source->dst_fmt.fmt.pix.field = V4L2_FIELD_ANY;
+
+    if (xioctl(vid_source->fd, VIDIOC_TRY_FMT, &vid_source->dst_fmt) != -1 &&
+        vid_source->dst_fmt.fmt.pix.pixelformat == pixformat) {
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: Testing palette %c%c%c%c (%dx%d)",
+                   pixformat >> 0, pixformat >> 8,
+                   pixformat >> 16, pixformat >> 24, *width, *height);
+
+        if (vid_source->dst_fmt.fmt.pix.width != (unsigned int) *width ||
+            vid_source->dst_fmt.fmt.pix.height != (unsigned int) *height) {
+
+            MOTION_LOG(WRN, TYPE_VIDEO, NO_ERRNO, "%s: Adjusting resolution "
+                       "from %ix%i to %ix%i.",
+                       *width, *height, vid_source->dst_fmt.fmt.pix.width,
+                       vid_source->dst_fmt.fmt.pix.height);
+
+            *width = vid_source->dst_fmt.fmt.pix.width;
+            *height = vid_source->dst_fmt.fmt.pix.height;
         }
 
-        if (xioctl(s->fd, VIDIOC_S_FMT, &s->fmt) == -1) {
-            motion_log(LOG_ERR, 1, "Error setting pixel format VIDIOC_S_FMT");
+        if (xioctl(vid_source->fd, VIDIOC_S_FMT, &vid_source->dst_fmt) == -1) {
+            MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: Error setting pixel "
+                       "format.\nVIDIOC_S_FMT: ");
             return -1;
         }
 
-        motion_log(LOG_INFO, 0, "Using palette %c%c%c%c (%dx%d) bytesperlines "
-                   "%d sizeimage %d colorspace %08x", pixformat >> 0,
-                   pixformat >> 8, pixformat >> 16, pixformat >> 24,
-                   *width, *height, s->fmt.fmt.pix.bytesperline,
-                   s->fmt.fmt.pix.sizeimage, s->fmt.fmt.pix.colorspace);
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: Using palette %c%c%c%c (%dx%d)"
+                   " bytesperlines %d sizeimage %d colorspace %08x", pixformat >> 0,
+                   pixformat >> 8, pixformat >> 16, pixformat >> 24, *width,
+                   *height, vid_source->dst_fmt.fmt.pix.bytesperline,
+                   vid_source->dst_fmt.fmt.pix.sizeimage,
+                   vid_source->dst_fmt.fmt.pix.colorspace);
+
         return 0;
     }
+
     return -1;
 }
 
-/* This routine is called by the startup code to do the format setting */
-static int v4l2_set_pix_format(struct context *cnt, src_v4l2_t * s,
-			       int *width, int *height)
+/**
+ * v4l2_set_pix_format
+ *
+ * Returns:  0  Ok
+ *          -1  Problems setting palette or not supported
+ */
+static int v4l2_set_pix_format(struct context *cnt, src_v4l2_t * vid_source,
+                               int *width, int *height)
 {
-    struct v4l2_fmtdesc fmt;
-    short int v4l2_pal;
+    struct v4l2_fmtdesc fmtd;
+    int v4l2_pal;
 
-    /* 
+    /*
      * Note that this array MUST exactly match the config file list.
-     * A higher index means better chance to be used 
+     * A higher index means better chance to be used
      */
     static const u32 supported_formats[] = {
         V4L2_PIX_FMT_SN9C10X,
+        V4L2_PIX_FMT_SBGGR16,
         V4L2_PIX_FMT_SBGGR8,
+        V4L2_PIX_FMT_SPCA561,
+        V4L2_PIX_FMT_SGBRG8,
+        V4L2_PIX_FMT_SGRBG8,
+        V4L2_PIX_FMT_PAC207,
+        V4L2_PIX_FMT_PJPG,
         V4L2_PIX_FMT_MJPEG,
         V4L2_PIX_FMT_JPEG,
         V4L2_PIX_FMT_RGB24,
+        V4L2_PIX_FMT_SPCA501,
+        V4L2_PIX_FMT_SPCA505,
+        V4L2_PIX_FMT_SPCA508,
         V4L2_PIX_FMT_UYVY,
         V4L2_PIX_FMT_YUYV,
         V4L2_PIX_FMT_YUV422P,
-        V4L2_PIX_FMT_YUV420	/* most efficient for motion */
+        V4L2_PIX_FMT_YUV420 /* most efficient for motion */
     };
-    
+
     int array_size = sizeof(supported_formats) / sizeof(supported_formats[0]);
-    short int index_format = -1;	/* -1 says not yet chosen */
+    int index_format = -1; /* -1 says not yet chosen */
+    CLEAR(fmtd);
+    fmtd.index = v4l2_pal = 0;
+    fmtd.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
 
     /* First we try a shortcut of just setting the config file value */
     if (cnt->conf.v4l2_palette >= 0) {
@@ -380,38 +487,37 @@ static int v4l2_set_pix_format(struct co
                         supported_formats[cnt->conf.v4l2_palette] >>  8,
                         supported_formats[cnt->conf.v4l2_palette] >>  16,
                         supported_formats[cnt->conf.v4l2_palette] >>  24, 0};
-                        
+
         if (v4l2_do_set_pix_format(supported_formats[cnt->conf.v4l2_palette],
-            s, width, height) >= 0)
+                                   vid_source, width, height) >= 0)
             return 0;
-        
-        motion_log(LOG_INFO, 0, "Config palette index %d (%s) doesn't work.",
-		           cnt->conf.v4l2_palette, name);
-    }
-    /* Well, that didn't work, so we enumerate what the driver can offer */
-    	       
-    memset(&fmt, 0, sizeof(struct v4l2_fmtdesc));
-    fmt.index = v4l2_pal = 0;
-    fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-
-    motion_log(LOG_INFO, 0, "Supported palettes:");
-    
-    while (xioctl(s->fd, VIDIOC_ENUM_FMT, &fmt) != -1) {
-        short int i;
-
-        motion_log(LOG_INFO, 0, "%i: %c%c%c%c (%s)", v4l2_pal,
-                   fmt.pixelformat >> 0, fmt.pixelformat >> 8,
-                   fmt.pixelformat >> 16, fmt.pixelformat >> 24, 
-                   fmt.description);
 
-        /* adjust index_format if larger value found */
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: Config palette index %d (%s)"
+                   " doesn't work.", cnt->conf.v4l2_palette, name);
+    }
+
+    MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: Supported palettes:");
+
+    while (xioctl(vid_source->fd, VIDIOC_ENUM_FMT, &fmtd) != -1) {
+
+        int i;
+
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: (%i) %c%c%c%c (%s)",
+                   v4l2_pal, fmtd.pixelformat >> 0,
+                   fmtd.pixelformat >> 8, fmtd.pixelformat >> 16,
+                   fmtd.pixelformat >> 24, fmtd.description);
+
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: %d - %s (compressed : %d) (%#x)",
+                   fmtd.index, fmtd.description, fmtd.flags, fmtd.pixelformat);
+
+         /* Adjust index_format if larger value found */
         for (i = index_format + 1; i < array_size; i++)
-            if (supported_formats[i] == fmt.pixelformat)
+            if (supported_formats[i] == fmtd.pixelformat)
                 index_format = i;
 
-        memset(&fmt, 0, sizeof(struct v4l2_fmtdesc));
-        fmt.index = ++v4l2_pal;
-        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        CLEAR(fmtd);
+        fmtd.index = ++v4l2_pal;
+        fmtd.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
     }
 
     if (index_format >= 0) {
@@ -419,123 +525,140 @@ static int v4l2_set_pix_format(struct co
                         supported_formats[index_format] >>  8,
                         supported_formats[index_format] >>  16,
                         supported_formats[index_format] >>  24, 0};
-                
-        motion_log(LOG_INFO, 0, "Selected palette %s", name);
-        
+
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s Selected palette %s", name);
+
         if (v4l2_do_set_pix_format(supported_formats[index_format],
-            s, width, height) >= 0)
+                                   vid_source, width, height) >= 0)
             return 0;
-        motion_log(LOG_ERR, 1, "VIDIOC_TRY_FMT failed for format %s", name);      
+
+        MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "VIDIOC_TRY_FMT failed for "
+                   "format %s", name);
     }
 
-    motion_log(LOG_ERR, 0, "Unable to find a compatible palette format.");
+    MOTION_LOG(ERR, TYPE_VIDEO, NO_ERRNO, "%s: Unable to find a compatible"
+               " palette format.");
+
     return -1;
 }
 
 #if 0
-static void v4l2_set_fps(src_v4l2_t * s){
+static void v4l2_set_fps(src_v4l2_t * vid_source) {
     struct v4l2_streamparm* setfps;
 
-    setfps=(struct v4l2_streamparm *) calloc(1, sizeof(struct v4l2_streamparm));
+    setfps = (struct v4l2_streamparm *) calloc(1, sizeof(struct v4l2_streamparm));
     memset(setfps, 0, sizeof(struct v4l2_streamparm));
-    setfps->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    setfps->parm.capture.timeperframe.numerator=1;
-    setfps->parm.capture.timeperframe.denominator=s->fps;
+    setfpvid_source->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    setfpvid_source->parm.capture.timeperframe.numerator = 1;
+    setfpvid_source->parm.capture.timeperframe.denominator = vid_source->fps;
+
+    if (xioctl(vid_source->fd, VIDIOC_S_PARM, setfps) == -1)
+        MOTION_LOG(ERR, 1, "%s: v4l2_set_fps VIDIOC_S_PARM");
 
-    if (xioctl(s->fd, VIDIOC_S_PARM, setfps) == -1)
-        motion_log(LOG_ERR, 1, "v4l2_set_fps VIDIOC_S_PARM");
-    
 
 }
 #endif
 
-static int v4l2_set_mmap(src_v4l2_t * s)
+/**
+ * v4l2_set_mmap
+ */
+static int v4l2_set_mmap(src_v4l2_t * vid_source)
 {
     enum v4l2_buf_type type;
-    u32 b;
+    u32 buffer_index;
 
     /* Does the device support streaming? */
-    if (!(s->cap.capabilities & V4L2_CAP_STREAMING))
+    if (!(vid_source->cap.capabilities & V4L2_CAP_STREAMING))
         return -1;
 
-    memset(&s->req, 0, sizeof(struct v4l2_requestbuffers));
-
-    s->req.count = MMAP_BUFFERS;
-    s->req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    s->req.memory = V4L2_MEMORY_MMAP;
+    memset(&vid_source->req, 0, sizeof(struct v4l2_requestbuffers));
 
-    if (xioctl(s->fd, VIDIOC_REQBUFS, &s->req) == -1) {
-        motion_log(LOG_ERR, 1, "Error requesting buffers %d for memory map. VIDIOC_REQBUFS", s->req.count);
+    vid_source->req.count = MMAP_BUFFERS;
+    vid_source->req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    vid_source->req.memory = V4L2_MEMORY_MMAP;
+
+    if (xioctl(vid_source->fd, VIDIOC_REQBUFS, &vid_source->req) == -1) {
+        MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: Error requesting buffers"
+                   " %d for memory map. VIDIOC_REQBUFS",
+                   vid_source->req.count);
         return -1;
     }
 
-    motion_log(LOG_DEBUG, 0, "mmap information:");
-    motion_log(LOG_DEBUG, 0, "frames=%d", s->req.count);
+    MOTION_LOG(DBG, TYPE_VIDEO, NO_ERRNO, "%s: mmap information: frames=%d",
+               vid_source->req.count);
 
-    if (s->req.count < MIN_MMAP_BUFFERS) {
-        motion_log(LOG_ERR, 0, "Insufficient buffer memory.");
+    if (vid_source->req.count < MIN_MMAP_BUFFERS) {
+        MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: Insufficient buffer memory"
+                   " %d < MIN_MMAP_BUFFERS.", vid_source->req.count);
         return -1;
     }
 
-    s->buffers = calloc(s->req.count, sizeof(netcam_buff));
-    if (!s->buffers) {
-        motion_log(LOG_ERR, 1, "%s: Out of memory.", __FUNCTION__);
+    vid_source->buffers = calloc(vid_source->req.count, sizeof(video_buff));
+
+    if (!vid_source->buffers) {
+        MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: Out of memory.");
         return -1;
     }
 
-    for (b = 0; b < s->req.count; b++) {
+    for (buffer_index = 0; buffer_index < vid_source->req.count; buffer_index++) {
         struct v4l2_buffer buf;
 
         memset(&buf, 0, sizeof(struct v4l2_buffer));
 
         buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
         buf.memory = V4L2_MEMORY_MMAP;
-        buf.index = b;
+        buf.index = buffer_index;
 
-        if (xioctl(s->fd, VIDIOC_QUERYBUF, &buf) == -1) {
-            motion_log(LOG_ERR, 0, "Error querying buffer %d VIDIOC_QUERYBUF", b);
-            free(s->buffers);
+        if (xioctl(vid_source->fd, VIDIOC_QUERYBUF, &buf) == -1) {
+            MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: Error querying buffer"
+                       " %i\nVIDIOC_QUERYBUF: ", buffer_index);
+            free(vid_source->buffers);
             return -1;
         }
 
-        s->buffers[b].size = buf.length;
-        s->buffers[b].ptr = mmap(NULL, buf.length, PROT_READ | PROT_WRITE, MAP_SHARED, s->fd, buf.m.offset);
-
-        if (s->buffers[b].ptr == MAP_FAILED) {
-            motion_log(LOG_ERR, 1, "Error mapping buffer %i mmap", b);
-            free(s->buffers);
+        vid_source->buffers[buffer_index].size = buf.length;
+        vid_source->buffers[buffer_index].ptr = mmap(NULL, buf.length, PROT_READ | PROT_WRITE,
+                                                     MAP_SHARED, vid_source->fd, buf.m.offset);
+
+        if (vid_source->buffers[buffer_index].ptr == MAP_FAILED) {
+            MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: Error mapping buffer %i mmap",
+                       buffer_index);
+            free(vid_source->buffers);
             return -1;
         }
 
-        motion_log(LOG_DEBUG, 0, "%i length=%d", b, buf.length);
+        MOTION_LOG(DBG, TYPE_VIDEO, NO_ERRNO, "%s: %i length=%d Address (%x)",
+                   buffer_index, buf.length, vid_source->buffers[buffer_index].ptr);
     }
 
-    s->map = -1;
+    for (buffer_index = 0; buffer_index < vid_source->req.count; buffer_index++) {
+        memset(&vid_source->buf, 0, sizeof(struct v4l2_buffer));
 
-    for (b = 0; b < s->req.count; b++) {
-        memset(&s->buf, 0, sizeof(struct v4l2_buffer));
+        vid_source->buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        vid_source->buf.memory = V4L2_MEMORY_MMAP;
+        vid_source->buf.index = buffer_index;
 
-        s->buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        s->buf.memory = V4L2_MEMORY_MMAP;
-        s->buf.index = b;
-
-        if (xioctl(s->fd, VIDIOC_QBUF, &s->buf) == -1) {
-            motion_log(LOG_ERR, 1, "buffer index %d VIDIOC_QBUF", s->buf.index);
+        if (xioctl(vid_source->fd, VIDIOC_QBUF, &vid_source->buf) == -1) {
+            MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: VIDIOC_QBUF");
             return -1;
         }
     }
 
     type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
 
-    if (xioctl(s->fd, VIDIOC_STREAMON, &type) == -1) {
-        motion_log(LOG_ERR, 1, "Error starting stream VIDIOC_STREAMON");
+    if (xioctl(vid_source->fd, VIDIOC_STREAMON, &type) == -1) {
+        MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: Error starting stream."
+                   " VIDIOC_STREAMON");
         return -1;
     }
 
     return 0;
 }
 
-static int v4l2_scan_controls(src_v4l2_t * s)
+/**
+ * v4l2_scan_controls
+ */
+static int v4l2_scan_controls(src_v4l2_t * vid_source)
 {
     int count, i;
     struct v4l2_queryctrl queryctrl;
@@ -544,40 +667,42 @@ static int v4l2_scan_controls(src_v4l2_t
 
     for (i = 0, count = 0; queried_ctrls[i]; i++) {
         queryctrl.id = queried_ctrls[i];
-        if (xioctl(s->fd, VIDIOC_QUERYCTRL, &queryctrl))
+        if (xioctl(vid_source->fd, VIDIOC_QUERYCTRL, &queryctrl))
             continue;
 
         count++;
-        s->ctrl_flags |= 1 << i;
+        vid_source->ctrl_flags |= 1 << i;
     }
 
     if (count) {
-        struct v4l2_queryctrl *ctrl = s->controls = calloc(count, sizeof(struct v4l2_queryctrl));
+        struct v4l2_queryctrl *ctrl = vid_source->controls
+                                    = calloc(count, sizeof(struct v4l2_queryctrl));
 
         if (!ctrl) {
-            motion_log(LOG_ERR, 1, "%s: Insufficient buffer memory.", __FUNCTION__);
+            MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: Insufficient buffer memory.");
             return -1;
         }
 
         for (i = 0; queried_ctrls[i]; i++) {
-            if (s->ctrl_flags & (1 << i)) {
+            if (vid_source->ctrl_flags & (1 << i)) {
                 struct v4l2_control control;
 
                 queryctrl.id = queried_ctrls[i];
-                if (xioctl(s->fd, VIDIOC_QUERYCTRL, &queryctrl))
+                if (xioctl(vid_source->fd, VIDIOC_QUERYCTRL, &queryctrl))
                     continue;
 
                 memcpy(ctrl, &queryctrl, sizeof(struct v4l2_queryctrl));
 
-                motion_log(LOG_INFO, 0, "found control 0x%08x, \"%s\", range %d,%d %s", ctrl->id,
-                           ctrl->name, ctrl->minimum, ctrl->maximum,
+                MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: found control 0x%08x, \"%s\","
+                           " range %d,%d %s",
+                           ctrl->id, ctrl->name, ctrl->minimum, ctrl->maximum,
                            ctrl->flags & V4L2_CTRL_FLAG_DISABLED ? "!DISABLED!" : "");
 
-                memset (&control, 0, sizeof (control));
+                memset(&control, 0, sizeof (control));
                 control.id = queried_ctrls[i];
-                xioctl(s->fd, VIDIOC_G_CTRL, &control);
-                motion_log(LOG_INFO, 0, "\t\"%s\", default %d, current %d", ctrl->name,
-                           ctrl->default_value, control.value);
+                xioctl(vid_source->fd, VIDIOC_G_CTRL, &control);
+                MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: \t\"%s\", default %d, current %d",
+                           ctrl->name, ctrl->default_value, control.value);
 
                 ctrl++;
             }
@@ -587,44 +712,46 @@ static int v4l2_scan_controls(src_v4l2_t
     return 0;
 }
 
-static int v4l2_set_control(src_v4l2_t * s, u32 cid, int value)
+/**
+ * v4l2_set_control
+ */
+static int v4l2_set_control(src_v4l2_t * vid_source, u32 cid, int value)
 {
     int i, count;
 
-    if (!s->controls)
+    if (!vid_source->controls)
         return -1;
 
     for (i = 0, count = 0; queried_ctrls[i]; i++) {
-        if (s->ctrl_flags & (1 << i)) {
+        if (vid_source->ctrl_flags & (1 << i)) {
             if (cid == queried_ctrls[i]) {
-                struct v4l2_queryctrl *ctrl = s->controls + count;
+                struct v4l2_queryctrl *ctrl = vid_source->controls + count;
                 struct v4l2_control control;
                 int ret;
 
-                memset (&control, 0, sizeof (control));
+                memset(&control, 0, sizeof (control));
                 control.id = queried_ctrls[i];
 
                 switch (ctrl->type) {
                 case V4L2_CTRL_TYPE_INTEGER:
                     value = control.value =
                             (value * (ctrl->maximum - ctrl->minimum) / 256) + ctrl->minimum;
-                    ret = xioctl(s->fd, VIDIOC_S_CTRL, &control);
+                    ret = xioctl(vid_source->fd, VIDIOC_S_CTRL, &control);
                     break;
 
                 case V4L2_CTRL_TYPE_BOOLEAN:
                     value = control.value = value ? 1 : 0;
-                    ret = xioctl(s->fd, VIDIOC_S_CTRL, &control);
+                    ret = xioctl(vid_source->fd, VIDIOC_S_CTRL, &control);
                     break;
 
                 default:
-                    motion_log(LOG_ERR, 0, "%s: control type not supported yet");
+                    MOTION_LOG(WRN, TYPE_VIDEO, NO_ERRNO, "%s: control type not supported yet");
                     return -1;
                 }
 
-                if (debug_level > CAMERA_VIDEO)
-                    motion_log(LOG_INFO, 0, "setting control \"%s\" to %d (ret %d %s) %s", ctrl->name,
-                               value, ret, ret ? strerror(errno) : "",
-                               ctrl->flags & V4L2_CTRL_FLAG_DISABLED ? "Control is DISABLED!" : "");
+                MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: setting control \"%s\" to %d"
+                           " (ret %d %s) %s", ctrl->name, value, ret, ret ? strerror(errno) : "",
+                           ctrl->flags & V4L2_CTRL_FLAG_DISABLED ? "Control is DISABLED!" : "");
 
                 return 0;
             }
@@ -635,76 +762,82 @@ static int v4l2_set_control(src_v4l2_t *
     return -1;
 }
 
+/**
+ * v4l2_picture_controls
+ */
 static void v4l2_picture_controls(struct context *cnt, struct video_dev *viddev)
 {
-    src_v4l2_t *s = (src_v4l2_t *) viddev->v4l2_private;
+    src_v4l2_t *vid_source = (src_v4l2_t *) viddev->v4l2_private;
 
     if (cnt->conf.contrast && cnt->conf.contrast != viddev->contrast) {
         viddev->contrast = cnt->conf.contrast;
-        v4l2_set_control(s, V4L2_CID_CONTRAST, viddev->contrast);
+        v4l2_set_control(vid_source, V4L2_CID_CONTRAST, viddev->contrast);
     }
 
     if (cnt->conf.saturation && cnt->conf.saturation != viddev->saturation) {
         viddev->saturation = cnt->conf.saturation;
-        v4l2_set_control(s, V4L2_CID_SATURATION, viddev->saturation);
+        v4l2_set_control(vid_source, V4L2_CID_SATURATION, viddev->saturation);
     }
 
     if (cnt->conf.hue && cnt->conf.hue != viddev->hue) {
         viddev->hue = cnt->conf.hue;
-        v4l2_set_control(s, V4L2_CID_HUE, viddev->hue);
+        v4l2_set_control(vid_source, V4L2_CID_HUE, viddev->hue);
     }
 
     if (cnt->conf.autobright) {
         if (vid_do_autobright(cnt, viddev)) {
-            if (v4l2_set_control(s, V4L2_CID_BRIGHTNESS, viddev->brightness))
-                v4l2_set_control(s, V4L2_CID_GAIN, viddev->brightness);
+            if (v4l2_set_control(vid_source, V4L2_CID_BRIGHTNESS, viddev->brightness))
+                v4l2_set_control(vid_source, V4L2_CID_GAIN, viddev->brightness);
         }
     } else {
         if (cnt->conf.brightness && cnt->conf.brightness != viddev->brightness) {
             viddev->brightness = cnt->conf.brightness;
-            if (v4l2_set_control(s, V4L2_CID_BRIGHTNESS, viddev->brightness))
-                v4l2_set_control(s, V4L2_CID_GAIN, viddev->brightness);
+            if (v4l2_set_control(vid_source, V4L2_CID_BRIGHTNESS, viddev->brightness))
+                v4l2_set_control(vid_source, V4L2_CID_GAIN, viddev->brightness);
         }
     }
 
 }
 
 /* public functions */
-
+/**
+ * v4l2_start
+ */
 unsigned char *v4l2_start(struct context *cnt, struct video_dev *viddev, int width, int height,
               int input, int norm, unsigned long freq, int tuner_number)
 {
-    src_v4l2_t *s;
+    src_v4l2_t *vid_source;
 
     /* Allocate memory for the state structure. */
-    if (!(s = calloc(sizeof(src_v4l2_t), 1))) {
-        motion_log(LOG_ERR, 1, "%s: Out of memory.", __FUNCTION__);
+    if (!(vid_source = calloc(sizeof(src_v4l2_t), 1))) {
+        MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: Out of memory.");
         goto err;
     }
 
-    viddev->v4l2_private = s;
-    s->fd = viddev->fd;
-    s->fps = cnt->conf.frame_limit;
-    s->pframe = -1;
+    viddev->v4l2_private = vid_source;
+    vid_source->fd = viddev->fd;
+    vid_source->fps = cnt->conf.frame_limit;
+    vid_source->pframe = -1;
+    struct config *conf = &cnt->conf;
 
-    if (v4l2_get_capability(s)) 
+    if (v4l2_get_capability(vid_source))
         goto err;
-    
-    if (v4l2_select_input(s, input, norm, freq, tuner_number))
+
+    if (v4l2_select_input(conf, viddev, vid_source, input, norm, freq, tuner_number))
         goto err;
-    
-    if (v4l2_set_pix_format(cnt ,s, &width, &height))
+
+    if (v4l2_set_pix_format(cnt, vid_source, &width, &height))
         goto err;
-  
-    if (v4l2_scan_controls(s))
+
+    if (v4l2_scan_controls(vid_source))
         goto err;
-   
+
 #if 0
-    v4l2_set_fps(s);
+    v4l2_set_fps(vid_source);
 #endif
-    if (v4l2_set_mmap(s)) 
+    if (v4l2_set_mmap(vid_source))
         goto err;
-    
+
     viddev->size_map = 0;
     viddev->v4l_buffers[0] = NULL;
     viddev->v4l_maxbuffer = 1;
@@ -721,86 +854,101 @@ unsigned char *v4l2_start(struct context
     return (void *) 1;
 
 err:
-    if (s)
-        free(s);
+    if (vid_source)
+        free(vid_source);
 
     viddev->v4l2_private = NULL;
     viddev->v4l2 = 0;
     return NULL;
 }
 
-void v4l2_set_input(struct context *cnt, struct video_dev *viddev, unsigned char *map, int width, int height,
-            struct config *conf)
+/**
+ * v4l2_set_input
+ */
+void v4l2_set_input(struct context *cnt, struct video_dev *viddev, unsigned char *map,
+                    int width, int height, struct config *conf)
 {
-    int i;
     int input = conf->input;
     int norm = conf->norm;
-    int skip = conf->roundrobin_skip;
     unsigned long freq = conf->frequency;
     int tuner_number = conf->tuner_number;
 
     if (input != viddev->input || width != viddev->width || height != viddev->height ||
-        freq != viddev->freq || tuner_number != viddev->tuner_number) {
+        freq != viddev->freq || tuner_number != viddev->tuner_number || norm != viddev->norm) {
 
+        unsigned int i;
         struct timeval switchTime;
+        unsigned int skip = conf->roundrobin_skip;
 
-        v4l2_select_input((src_v4l2_t *) viddev->v4l2_private, input, norm, freq, tuner_number);
+        if (conf->roundrobin_skip < 0)
+            skip = 1;
+
+        v4l2_select_input(conf, viddev, (src_v4l2_t *) viddev->v4l2_private,
+                          input, norm, freq, tuner_number);
 
         gettimeofday(&switchTime, NULL);
 
         v4l2_picture_controls(cnt, viddev);
 
+        viddev->width = width;
+        viddev->height = height;
+
+        /*
         viddev->input = input;
+        viddev->norm = norm;
         viddev->width = width;
         viddev->height = height;
         viddev->freq = freq;
         viddev->tuner_number = tuner_number;
-
+        */
 
         /* Skip all frames captured before switchtime, capture 1 after switchtime */
         {
-            src_v4l2_t *s = (src_v4l2_t *) viddev->v4l2_private;
+            src_v4l2_t *vid_source = (src_v4l2_t *) viddev->v4l2_private;
             unsigned int counter = 0;
-            if (debug_level > CAMERA_VIDEO)
-                motion_log(LOG_DEBUG, 0, "set_input_skip_frame switch_time=%ld:%ld", 
-                           switchTime.tv_sec, switchTime.tv_usec);
+
+            MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: set_input_skip_frame "
+                       "switch_time=%ld:%ld", switchTime.tv_sec, switchTime.tv_usec);
 
             /* Avoid hang using the number of mmap buffers */
-            while(counter < s->req.count) {
+            while(counter < vid_source->req.count) {
                 counter++;
                 if (v4l2_next(cnt, viddev, map, width, height))
                     break;
-                
-                if (s->buf.timestamp.tv_sec > switchTime.tv_sec || 
-                   (s->buf.timestamp.tv_sec == switchTime.tv_sec && s->buf.timestamp.tv_usec > 
-                    switchTime.tv_usec))
+
+                if (vid_source->buf.timestamp.tv_sec > switchTime.tv_sec ||
+                   (vid_source->buf.timestamp.tv_sec == switchTime.tv_sec &&
+                    vid_source->buf.timestamp.tv_usec > switchTime.tv_usec))
                     break;
 
-                if (debug_level > CAMERA_VIDEO)
-                    motion_log(LOG_DEBUG, 0, "got frame before switch timestamp=%ld:%ld", 
-                               s->buf.timestamp.tv_sec, s->buf.timestamp.tv_usec);
+                MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: got frame before "
+                           " switch timestamp=%ld:%ld",
+                           vid_source->buf.timestamp.tv_sec,
+                           vid_source->buf.timestamp.tv_usec);
             }
         }
 
         /* skip a few frames if needed */
         for (i = 1; i < skip; i++)
             v4l2_next(cnt, viddev, map, width, height);
-
     } else {
         /* No round robin - we only adjust picture controls */
         v4l2_picture_controls(cnt, viddev);
     }
 }
 
-int v4l2_next(struct context *cnt, struct video_dev *viddev, unsigned char *map, int width, int height)
+/**
+ * v4l2_next
+ */
+int v4l2_next(struct context *cnt, struct video_dev *viddev, unsigned char *map,
+              int width, int height)
 {
     sigset_t set, old;
-    src_v4l2_t *s = (src_v4l2_t *) viddev->v4l2_private;
+    src_v4l2_t *vid_source = (src_v4l2_t *) viddev->v4l2_private;
 
     if (viddev->v4l_fmt != VIDEO_PALETTE_YUV420P)
         return V4L_FATAL_ERROR;
 
-
     /* Block signals during IOCTL */
     sigemptyset(&set);
     sigaddset(&set, SIGCHLD);
@@ -810,82 +958,109 @@ int v4l2_next(struct context *cnt, struc
     sigaddset(&set, SIGHUP);
     pthread_sigmask(SIG_BLOCK, &set, &old);
 
-    if (s->pframe >= 0) {
-        if (xioctl(s->fd, VIDIOC_QBUF, &s->buf) == -1) {
-            motion_log(LOG_ERR, 1, "%s: VIDIOC_QBUF", __FUNCTION__);
+    MOTION_LOG(DBG, TYPE_VIDEO, NO_ERRNO, "%s: 1) vid_source->pframe %i",
+               vid_source->pframe);
+
+    if (vid_source->pframe >= 0) {
+        if (xioctl(vid_source->fd, VIDIOC_QBUF, &vid_source->buf) == -1) {
+            MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: VIDIOC_QBUF");
+            pthread_sigmask(SIG_UNBLOCK, &old, NULL);
             return -1;
         }
     }
 
-    memset(&s->buf, 0, sizeof(struct v4l2_buffer));
+    memset(&vid_source->buf, 0, sizeof(struct v4l2_buffer));
 
-    s->buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    s->buf.memory = V4L2_MEMORY_MMAP;
+    vid_source->buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    vid_source->buf.memory = V4L2_MEMORY_MMAP;
 
-    if (xioctl(s->fd, VIDIOC_DQBUF, &s->buf) == -1) {
-
-        /* some drivers return EIO when there is no signal, 
-           driver might dequeue an (empty) buffer despite
-           returning an error, or even stop capturing.
-        */
+    if (xioctl(vid_source->fd, VIDIOC_DQBUF, &vid_source->buf) == -1) {
+        int ret;
+        /*
+         * Some drivers return EIO when there is no signal,
+         * driver might dequeue an (empty) buffer despite
+         * returning an error, or even stop capturing.
+         */
         if (errno == EIO) {
-            s->pframe++; 
-            if ((u32)s->pframe >= s->req.count) s->pframe = 0;
-            s->buf.index = s->pframe;
+            vid_source->pframe++;
 
-            motion_log(LOG_ERR, 1, "%s: VIDIOC_DQBUF: EIO (s->pframe %d)", __FUNCTION__, s->pframe);
+            if ((u32)vid_source->pframe >= vid_source->req.count)
+                vid_source->pframe = 0;
 
-            return 1;
+             vid_source->buf.index = vid_source->pframe;
+             MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: VIDIOC_DQBUF: EIO "
+                        "(vid_source->pframe %d)", vid_source->pframe);
+             ret = 1;
+        } else if (errno == EAGAIN) {
+            MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: VIDIOC_DQBUF: EAGAIN"
+                       " (vid_source->pframe %d)", vid_source->pframe);
+            ret = 1;
+        } else {
+            MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: VIDIOC_DQBUF");
+            ret = -1;
         }
 
-        motion_log(LOG_ERR, 1, "%s: VIDIOC_DQBUF", __FUNCTION__);
-
-        return -1;
+        pthread_sigmask(SIG_UNBLOCK, &old, NULL);
+        return ret;
     }
 
-    s->pframe = s->buf.index;
-    s->buffers[s->buf.index].used = s->buf.bytesused;
-    s->buffers[s->buf.index].content_length = s->buf.bytesused;
+    MOTION_LOG(DBG, TYPE_VIDEO, NO_ERRNO, "%s: 2) vid_source->pframe %i",
+               vid_source->pframe);
+
+    vid_source->pframe = vid_source->buf.index;
+    vid_source->buffers[vid_source->buf.index].used = vid_source->buf.bytesused;
+    vid_source->buffers[vid_source->buf.index].content_length = vid_source->buf.bytesused;
+
+    MOTION_LOG(DBG, TYPE_VIDEO, NO_ERRNO, "%s: 3) vid_source->pframe %i "
+               "vid_source->buf.index %i", vid_source->pframe, vid_source->buf.index);
+    MOTION_LOG(DBG, TYPE_VIDEO, NO_ERRNO, "%s: vid_source->buf.bytesused %i",
+               vid_source->buf.bytesused);
 
     pthread_sigmask(SIG_UNBLOCK, &old, NULL);    /*undo the signal blocking */
 
     {
-        netcam_buff *the_buffer = &s->buffers[s->buf.index];
+        video_buff *the_buffer = &vid_source->buffers[vid_source->buf.index];
 
-        switch (s->fmt.fmt.pix.pixelformat) {
+        MOTION_LOG(DBG, TYPE_VIDEO, NO_ERRNO, "%s: the_buffer index %d Address (%x)",
+                   vid_source->buf.index, the_buffer->ptr);
+
+        switch (vid_source->dst_fmt.fmt.pix.pixelformat) {
         case V4L2_PIX_FMT_RGB24:
-            conv_rgb24toyuv420p(map, (unsigned char *) the_buffer->ptr, width, height);
+            conv_rgb24toyuv420p(map, the_buffer->ptr, width, height);
             return 0;
 
         case V4L2_PIX_FMT_UYVY:
-            conv_uyvyto420p(map, (unsigned char *) the_buffer->ptr, (unsigned)width, (unsigned)height);
+            conv_uyvyto420p(map, the_buffer->ptr, (unsigned)width, (unsigned)height);
             return 0;
 
         case V4L2_PIX_FMT_YUYV:
         case V4L2_PIX_FMT_YUV422P:
-            conv_yuv422to420p(map, (unsigned char *) the_buffer->ptr, width, height);
+            conv_yuv422to420p(map, the_buffer->ptr, width, height);
             return 0;
 
         case V4L2_PIX_FMT_YUV420:
             memcpy(map, the_buffer->ptr, viddev->v4l_bufsize);
             return 0;
 
-        case V4L2_PIX_FMT_JPEG:            
-        case V4L2_PIX_FMT_MJPEG:
-            return mjpegtoyuv420p(map, (unsigned char *) the_buffer->ptr, width, height, 
-                                   s->buffers[s->buf.index].content_length);
-/*            
-            return 0;
+        case V4L2_PIX_FMT_PJPG:
         case V4L2_PIX_FMT_JPEG:
-            return conv_jpeg2yuv420(cnt, map, the_buffer, width, height);
-*/
+        case V4L2_PIX_FMT_MJPEG:
+            return mjpegtoyuv420p(map, the_buffer->ptr, width, height,
+                                  vid_source->buffers[vid_source->buf.index].content_length);
+
+        /* FIXME: quick hack to allow work all bayer formats */
+        case V4L2_PIX_FMT_SBGGR16:
+        case V4L2_PIX_FMT_SGBRG8:
+        case V4L2_PIX_FMT_SGRBG8:
+        /* case V4L2_PIX_FMT_SPCA561: */
         case V4L2_PIX_FMT_SBGGR8:    /* bayer */
-            bayer2rgb24(cnt->imgs.common_buffer, (unsigned char *) the_buffer->ptr, width, height);
+            bayer2rgb24(cnt->imgs.common_buffer, the_buffer->ptr, width, height);
             conv_rgb24toyuv420p(map, cnt->imgs.common_buffer, width, height);
             return 0;
 
+        case V4L2_PIX_FMT_SPCA561:
         case V4L2_PIX_FMT_SN9C10X:
-            sonix_decompress(map, (unsigned char *) the_buffer->ptr, width, height);
+            sonix_decompress(map, the_buffer->ptr, width, height);
             bayer2rgb24(cnt->imgs.common_buffer, map, width, height);
             conv_rgb24toyuv420p(map, cnt->imgs.common_buffer, width, height);
             return 0;
@@ -895,39 +1070,43 @@ int v4l2_next(struct context *cnt, struc
     return 1;
 }
 
+/**
+ * v4l2_close
+ */
 void v4l2_close(struct video_dev *viddev)
 {
-    src_v4l2_t *s = (src_v4l2_t *) viddev->v4l2_private;
+    src_v4l2_t *vid_source = (src_v4l2_t *) viddev->v4l2_private;
     enum v4l2_buf_type type;
 
     type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    xioctl(s->fd, VIDIOC_STREAMOFF, &type);
-    close(s->fd);
-    s->fd = -1;
+    xioctl(vid_source->fd, VIDIOC_STREAMOFF, &type);
+    close(vid_source->fd);
+    vid_source->fd = -1;
 }
 
+/**
+ * v4l2_cleanup
+ */
 void v4l2_cleanup(struct video_dev *viddev)
 {
-    src_v4l2_t *s = (src_v4l2_t *) viddev->v4l2_private;
+    src_v4l2_t *vid_source = (src_v4l2_t *) viddev->v4l2_private;
 
-    if (s->buffers) {
+    if (vid_source->buffers) {
         unsigned int i;
 
-        for (i = 0; i < s->req.count; i++)
-            munmap(s->buffers[i].ptr, s->buffers[i].size);
+        for (i = 0; i < vid_source->req.count; i++)
+            munmap(vid_source->buffers[i].ptr, vid_source->buffers[i].size);
 
-        free(s->buffers);
-        s->buffers = NULL;
+        free(vid_source->buffers);
+        vid_source->buffers = NULL;
     }
 
-    if (s->controls) {
-        free(s->controls);
-        s->controls = NULL;
+    if (vid_source->controls) {
+        free(vid_source->controls);
+        vid_source->controls = NULL;
     }
 
-    free(s);
+    free(vid_source);
     viddev->v4l2_private = NULL;
 }
-
-#endif
-#endif
+#endif /* !WITHOUT_V4L && MOTION_V4L2 */
--- motion-3.2.12.orig/video_common.c
+++ motion-3.2.12/video_common.c
@@ -2,19 +2,18 @@
  *
  *      Video stream functions for motion.
  *      Copyright 2000 by Jeroen Vreeken (pe1rxq@amsat.org)
- *                2006 by Krzysztof Blaszkowski (kb@sysmikro.com.pl)    
- *                2007 by Angel Carpinteo (ack@telefonica.net)
+ *                2006 by Krzysztof Blaszkowski (kb@sysmikro.com.pl)
+ *                2007 by Angel Carpintero (motiondevelop@gmail.com)
  *      This software is distributed under the GNU public license version 2
  *      See also the file 'COPYING'.
  *
  */
 
-/* for rotation */
-#include "rotate.h"    /* already includes motion.h */
+/* For rotation */
+#include "rotate.h"    /* Already includes motion.h */
 #include "video.h"
 #include "jpegutils.h"
 
-
 typedef unsigned char uint8_t;
 typedef unsigned short int uint16_t;
 typedef unsigned int uint32_t;
@@ -27,9 +26,8 @@ typedef struct {
     int val;
 } code_table_t;
 
-/*
- *   sonix_decompress_init
- *   =====================
+/**
+ * sonix_decompress_init
  *   pre-calculates a locally stored table for efficient huffman-decoding.
  *
  *   Each entry at index x in the table represents the codeword
@@ -89,10 +87,9 @@ static void sonix_decompress_init(code_t
     }
 }
 
-/*
- *   sonix_decompress
- *   ================
- *   decompresses an image encoded by a SN9C101 camera controller chip.
+/**
+ * sonix_decompress
+ *      Decompresses an image encoded by a SN9C101 camera controller chip.
  *
  *   IN    width
  *         height
@@ -111,14 +108,14 @@ int sonix_decompress(unsigned char *outp
     unsigned char code;
     unsigned char *addr;
 
-    /* local storage */
+    /* Local storage */
     static code_table_t table[256];
     static int init_done = 0;
 
     if (!init_done) {
         init_done = 1;
         sonix_decompress_init(table);
-        /* do sonix_decompress_init first! */
+        /* Do sonix_decompress_init first! */
         //return -1; // so it has been done and now fall through
     }
 
@@ -127,7 +124,7 @@ int sonix_decompress(unsigned char *outp
 
         col = 0;
 
-        /* first two pixels in first two rows are stored as raw 8-bit */
+        /* First two pixels in first two rows are stored as raw 8-bit. */
         if (row < 2) {
             addr = inp + (bitpos >> 3);
             code = (addr[0] << (bitpos & 7)) | (addr[1] >> (8 - (bitpos & 7)));
@@ -143,30 +140,30 @@ int sonix_decompress(unsigned char *outp
         }
 
         while (col < width) {
-            /* get bitcode from bitstream */
+            /* Get bitcode from bitstream. */
             addr = inp + (bitpos >> 3);
             code = (addr[0] << (bitpos & 7)) | (addr[1] >> (8 - (bitpos & 7)));
 
-            /* update bit position */
+            /* Update bit position. */
             bitpos += table[code].len;
 
-            /* calculate pixel value */
+            /* Calculate pixel value. */
             val = table[code].val;
             if (!table[code].is_abs) {
-                /* value is relative to top and left pixel */
+                /* Value is relative to top and left pixel. */
                 if (col < 2) {
-                    /* left column: relative to top pixel */
+                    /* Left column: relative to top pixel. */
                     val += outp[-2 * width];
                 } else if (row < 2) {
-                    /* top row: relative to left pixel */
+                    /* Top row: relative to left pixel. */
                     val += outp[-2];
                 } else {
-                    /* main area: average of left pixel and top pixel */
+                    /* Main area: average of left pixel and top pixel. */
                     val += (outp[-2] + outp[-2 * width]) / 2;
                 }
             }
 
-            /* store pixel */
+            /* Store pixel */
             *outp++ = CLAMP(val);
             col++;
         }
@@ -175,14 +172,14 @@ int sonix_decompress(unsigned char *outp
     return 0;
 }
 
-/*
+/**
+ * bayer2rgb24
  * BAYER2RGB24 ROUTINE TAKEN FROM:
  *
  * Sonix SN9C10x based webcam basic I/F routines
  * Takafumi Mizuno <taka-qce@ls-a.jp>
  *
  */
-
 void bayer2rgb24(unsigned char *dst, unsigned char *src, long int width, long int height)
 {
     long int i;
@@ -199,12 +196,12 @@ void bayer2rgb24(unsigned char *dst, uns
                 /* B */
                 if ((i > width) && ((i % width) > 0)) {
                     *scanpt++ = *rawpt;     /* B */
-                    *scanpt++ = (*(rawpt - 1) + *(rawpt + 1) + 
+                    *scanpt++ = (*(rawpt - 1) + *(rawpt + 1) +
                                 *(rawpt + width) + *(rawpt - width)) / 4;    /* G */
-                    *scanpt++ = (*(rawpt - width - 1) + *(rawpt - width + 1) + 
+                    *scanpt++ = (*(rawpt - width - 1) + *(rawpt - width + 1) +
                                 *(rawpt + width - 1) + *(rawpt + width + 1)) / 4;    /* R */
                 } else {
-                    /* first line or left column */
+                    /* First line or left column. */
                     *scanpt++ = *rawpt;     /* B */
                     *scanpt++ = (*(rawpt + 1) + *(rawpt + width)) / 2;    /* G */
                     *scanpt++ = *(rawpt + width + 1);       /* R */
@@ -216,7 +213,7 @@ void bayer2rgb24(unsigned char *dst, uns
                     *scanpt++ = *rawpt;    /* G */
                     *scanpt++ = (*(rawpt + width) + *(rawpt - width)) / 2;  /* R */
                 } else {
-                    /* first line or right column */
+                    /* First line or right column. */
                     *scanpt++ = *(rawpt - 1);       /* B */
                     *scanpt++ = *rawpt;    /* G */
                     *scanpt++ = *(rawpt + width);   /* R */
@@ -230,7 +227,7 @@ void bayer2rgb24(unsigned char *dst, uns
                     *scanpt++ = *rawpt;    /* G */
                     *scanpt++ = (*(rawpt - 1) + *(rawpt + 1)) / 2;  /* R */
                 } else {
-                    /* bottom line or left column */
+                    /* Bottom line or left column. */
                     *scanpt++ = *(rawpt - width);   /* B */
                     *scanpt++ = *rawpt;    /* G */
                     *scanpt++ = *(rawpt + 1);       /* R */
@@ -238,13 +235,13 @@ void bayer2rgb24(unsigned char *dst, uns
             } else {
                 /* R */
                 if (i < (width * (height - 1)) && ((i % width) < (width - 1))) {
-                    *scanpt++ = (*(rawpt - width - 1) + *(rawpt - width + 1) + 
+                    *scanpt++ = (*(rawpt - width - 1) + *(rawpt - width + 1) +
                                 *(rawpt + width - 1) + *(rawpt + width + 1)) / 4;    /* B */
-                    *scanpt++ = (*(rawpt - 1) + *(rawpt + 1) + *(rawpt - width) + 
-                                *(rawpt + width)) / 4;    /* G */
+                    *scanpt++ = (*(rawpt - 1) + *(rawpt + 1) +
+                                *(rawpt - width) + *(rawpt + width)) / 4;    /* G */
                     *scanpt++ = *rawpt;     /* R */
                 } else {
-                    /* bottom line or right column */
+                    /* Bottom line or right column. */
                     *scanpt++ = *(rawpt - width - 1);       /* B */
                     *scanpt++ = (*(rawpt - 1) + *(rawpt - width)) / 2;    /* G */
                     *scanpt++ = *rawpt;     /* R */
@@ -256,19 +253,24 @@ void bayer2rgb24(unsigned char *dst, uns
 
 }
 
+/**
+ * conv_yuv422to420p
+ *
+ *
+ */
 void conv_yuv422to420p(unsigned char *map, unsigned char *cap_map, int width, int height)
 {
     unsigned char *src, *dest, *src2, *dest2;
     int i, j;
 
-    /* Create the Y plane */
+    /* Create the Y plane. */
     src = cap_map;
     dest = map;
     for (i = width * height; i > 0; i--) {
         *dest++ = *src;
         src += 2;
     }
-    /* Create U and V planes */
+    /* Create U and V planes. */
     src = cap_map + 1;
     src2 = cap_map + width * 2 + 1;
     dest = map + width * height;
@@ -289,6 +291,11 @@ void conv_yuv422to420p(unsigned char *ma
     }
 }
 
+/**
+ * conv_uyvyto420p
+ *
+ *
+ */
 void conv_uyvyto420p(unsigned char *map, unsigned char *cap_map, unsigned int width, unsigned int height)
 {
     uint8_t *pY = map;
@@ -300,26 +307,35 @@ void conv_uyvyto420p(unsigned char *map,
     for (ix = 0; ix < height; ix++) {
         for (jx = 0; jx < width; jx += 2) {
             uint16_t calc;
+
             if ((ix&1) == 0) {
                 calc = *cap_map;
                 calc += *(cap_map + uv_offset);
                 calc /= 2;
                 *pU++ = (uint8_t) calc;
             }
+
             cap_map++;
             *pY++ = *cap_map++;
+
             if ((ix&1) == 0) {
                 calc = *cap_map;
                 calc += *(cap_map + uv_offset);
                 calc /= 2;
                 *pV++ = (uint8_t) calc;
             }
+
             cap_map++;
             *pY++ = *cap_map++;
         }
     }
 }
 
+/**
+ * conv_rgb24toyuv420p
+ *
+ *
+ */
 void conv_rgb24toyuv420p(unsigned char *map, unsigned char *cap_map, int width, int height)
 {
     unsigned char *y, *u, *v;
@@ -360,67 +376,33 @@ void conv_rgb24toyuv420p(unsigned char *
     }
 }
 
-int conv_jpeg2yuv420(struct context *cnt, unsigned char *dst, netcam_buff * buff, int width, int height)
-{
-    netcam_context netcam;
-
-    if (!buff || !dst)
-        return 3;
-
-    if (!buff->ptr)
-        return 2;    /* Error decoding MJPEG frame */
-
-    memset(&netcam, 0, sizeof(netcam));
-    netcam.imgcnt_last = 1;
-    netcam.latest = buff;
-    netcam.width = width;
-    netcam.height = height;
-    netcam.cnt = cnt;
-
-    pthread_mutex_init(&netcam.mutex, NULL);
-    pthread_cond_init(&netcam.cap_cond, NULL);
-    pthread_cond_init(&netcam.pic_ready, NULL);
-    pthread_cond_init(&netcam.exiting, NULL);
-
-    if (setjmp(netcam.setjmp_buffer)) 
-        return NETCAM_GENERAL_ERROR | NETCAM_JPEG_CONV_ERROR;
-    
-
-    return netcam_proc_jpeg(&netcam, dst);
-}
-
-
-
-/*
+/**
  * mjpegtoyuv420p
  *
  * Return values
  *  -1 on fatal error
  *  0  on success
- *  2  if jpeg lib threw a "corrupt jpeg data" warning.  
+ *  2  if jpeg lib threw a "corrupt jpeg data" warning.
  *     in this case, "a damaged output image is likely."
  */
-
 int mjpegtoyuv420p(unsigned char *map, unsigned char *cap_map, int width, int height, unsigned int size)
 {
     uint8_t *yuv[3];
     unsigned char *y, *u, *v;
     int loop, ret;
 
-    yuv[0] = malloc(width * height * sizeof(yuv[0][0]));
-    yuv[1] = malloc(width * height / 4 * sizeof(yuv[1][0]));
-    yuv[2] = malloc(width * height / 4 * sizeof(yuv[2][0]));
+    yuv[0] = mymalloc(width * height * sizeof(yuv[0][0]));
+    yuv[1] = mymalloc(width * height / 4 * sizeof(yuv[1][0]));
+    yuv[2] = mymalloc(width * height / 4 * sizeof(yuv[2][0]));
 
 
     ret = decode_jpeg_raw(cap_map, size, 0, 420, width, height, yuv[0], yuv[1], yuv[2]);
-    
+
     if (ret == 1) {
-        if (debug_level >= CAMERA_WARNINGS)
-            motion_log(LOG_ERR, 0, "%s: Corrupt image ... continue", __FUNCTION__);
+        MOTION_LOG(CRT, TYPE_VIDEO, NO_ERRNO, "%s: Corrupt image ... continue");
         ret = 2;
     }
 
-
     y = map;
     u = y + width * height;
     v = u + (width * height) / 4;
@@ -429,13 +411,13 @@ int mjpegtoyuv420p(unsigned char *map, u
     memset(v, 0, width * height / 4);
 
     for(loop = 0; loop < width * height; loop++)
-        *map++=yuv[0][loop];
+        *map++ = yuv[0][loop];
 
     for(loop = 0; loop < width * height / 4; loop++)
-        *map++=yuv[1][loop];
+        *map++ = yuv[1][loop];
 
     for(loop = 0; loop < width * height / 4; loop++)
-        *map++=yuv[2][loop];
+        *map++ = yuv[2][loop];
 
     free(yuv[0]);
     free(yuv[1]);
@@ -463,10 +445,13 @@ int mjpegtoyuv420p(unsigned char *map, u
  * the camera device.
  */
 #define AUTOBRIGHT_HYSTERESIS 10
-#define AUTOBRIGHT_DAMPER      5
-#define AUTOBRIGHT_MAX       255
-#define AUTOBRIGHT_MIN         0
+#define AUTOBRIGHT_DAMPER 5
+#define AUTOBRIGHT_MAX 255
+#define AUTOBRIGHT_MIN 0
 
+/**
+ * vid_do_autobright
+ */
 int vid_do_autobright(struct context *cnt, struct video_dev *viddev)
 {
 
@@ -492,16 +477,18 @@ int vid_do_autobright(struct context *cn
     }
     avg = avg / j;
 
-    /* average is above window - turn down brightness - go for the target */
+    /* Average is above window - turn down brightness - go for the target. */
     if (avg > brightness_window_high) {
         step = MIN2((avg - brightness_target) / AUTOBRIGHT_DAMPER + 1, viddev->brightness - AUTOBRIGHT_MIN);
+
         if (viddev->brightness > step + 1 - AUTOBRIGHT_MIN) {
             viddev->brightness -= step;
             make_change = 1;
         }
     } else if (avg < brightness_window_low) {
-        /* average is below window - turn up brightness - go for the target */
+        /* Average is below window - turn up brightness - go for the target. */
         step = MIN2((brightness_target - avg) / AUTOBRIGHT_DAMPER + 1, AUTOBRIGHT_MAX - viddev->brightness);
+
         if (viddev->brightness < AUTOBRIGHT_MAX - step) {
             viddev->brightness += step;
             make_change = 1;
@@ -516,12 +503,14 @@ int vid_do_autobright(struct context *cn
  *****************************************************************************/
 
 #ifndef WITHOUT_V4L
-/* big lock for vid_start to ensure exclusive access to viddevs while adding 
- * devices during initialization of each thread
+/*
+ * Big lock for vid_start to ensure exclusive access to viddevs while adding
+ * devices during initialization of each thread.
  */
 static pthread_mutex_t vid_mutex;
 
-/* Here we setup the viddevs structure which is used globally in the vid_*
+/*
+ * Here we setup the viddevs structure which is used globally in the vid_*
  * functions.
  */
 static struct video_dev *viddevs = NULL;
@@ -530,7 +519,7 @@ static struct video_dev *viddevs = NULL;
  * vid_init
  *
  * Called from motion.c at the very beginning before setting up the threads.
- * Function prepares the vid_mutex
+ * Function prepares the vid_mutex.
  */
 void vid_init(void)
 {
@@ -540,7 +529,7 @@ void vid_init(void)
 /**
  * vid_cleanup
  *
- * vid_cleanup is called from motion.c when Motion is stopped or restarted
+ * vid_cleanup is called from motion.c when Motion is stopped or restarted.
  */
 void vid_cleanup(void)
 {
@@ -552,18 +541,18 @@ void vid_cleanup(void)
 /**
  * vid_close
  *
- * vid_close is called from motion.c when a Motion thread is stopped or restarted
+ * vid_close is called from motion.c when a Motion thread is stopped or restarted.
  */
 void vid_close(struct context *cnt)
 {
 #ifndef WITHOUT_V4L
     struct video_dev *dev = viddevs;
     struct video_dev *prev = NULL;
-#endif /* WITHOUT_V4L */ 
+#endif /* WITHOUT_V4L */
 
     /* Cleanup the netcam part */
     if (cnt->netcam) {
-        motion_log(LOG_DEBUG, 0, "vid_close: calling netcam_cleanup");
+        MOTION_LOG(INF, TYPE_VIDEO, NO_ERRNO, "%s: calling netcam_cleanup");
         netcam_cleanup(cnt->netcam, 0);
         cnt->netcam = NULL;
         return;
@@ -581,16 +570,17 @@ void vid_close(struct context *cnt)
     }
     pthread_mutex_unlock(&vid_mutex);
 
-    /* Set it as closed in thread context */
+    /* Set it as closed in thread context. */
     cnt->video_dev = -1;
 
     if (dev == NULL) {
-        motion_log(LOG_ERR, 0, "vid_close: Unable to find video device");
+        MOTION_LOG(CRT, TYPE_VIDEO, NO_ERRNO, "%s: Unable to find video device");
         return;
     }
 
     if (--dev->usage_count == 0) {
-        motion_log(LOG_INFO, 0, "Closing video device %s", dev->video_device);
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: Closing video device %s",
+                   dev->video_device);
 #ifdef MOTION_V4L2
         if (dev->v4l2) {
             v4l2_close(dev);
@@ -604,23 +594,22 @@ void vid_close(struct context *cnt)
 #endif
         dev->fd = -1;
         pthread_mutex_lock(&vid_mutex);
-
         /* Remove from list */
         if (prev == NULL)
             viddevs = dev->next;
         else
             prev->next = dev->next;
-
         pthread_mutex_unlock(&vid_mutex);
 
         pthread_mutexattr_destroy(&dev->attr);
         pthread_mutex_destroy(&dev->mutex);
         free(dev);
     } else {
-        motion_log(LOG_INFO, 0, "Still %d users of video device %s, so we don't close it now", 
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: Still %d users of video device %s, so we don't close it now",
                    dev->usage_count, dev->video_device);
-        /* There is still at least one thread using this device 
-         * If we own it, release it
+        /*
+         * There is still at least one thread using this device
+         * If we own it, release it.
          */
         if (dev->owner == cnt->threadnr) {
             dev->frames = 0;
@@ -628,7 +617,7 @@ void vid_close(struct context *cnt)
             pthread_mutex_unlock(&dev->mutex);
         }
     }
-#endif /* WITHOUT_V4L */
+#endif /* !WITHOUT_V4L */
 }
 
 #ifndef WITHOUT_V4L
@@ -638,8 +627,8 @@ void vid_close(struct context *cnt)
  *
  * Called from vid_start setup the V4L/V4L2 capture device
  * The function does the following:
- *   
- * - Setup basic V4L/V4L2 properties incl palette incl setting 
+ *
+ * - Setup basic V4L/V4L2 properties incl palette incl setting
  * - Open the device
  * - Returns the device number.
  *
@@ -655,6 +644,7 @@ void vid_close(struct context *cnt)
  * Returns
  *     device number
  *     -1 if failed to open device.
+ *     -3 image dimensions are not modulo 8
  */
 static int vid_v4lx_start(struct context *cnt)
 {
@@ -665,20 +655,23 @@ static int vid_v4lx_start(struct context
     int width, height, input, norm, tuner_number;
     unsigned long frequency;
 
-    /* We use width and height from conf in this function. They will be assigned
-     * to width and height in imgs here, and cap_width and cap_height in 
+    /*
+     * We use width and height from conf in this function. They will be assigned
+     * to width and height in imgs here, and cap_width and cap_height in
      * rotate_data won't be set until in rotate_init.
-     * Motion requires that width and height is a multiple of 16 so we check
+     * Motion requires that width and height is a multiple of 8 so we check
      * for this first.
      */
-    if (conf->width % 16) {
-        motion_log(LOG_ERR, 0, "config image width (%d) is not modulo 16", conf->width);
-        return -1;
+    if (conf->width % 8) {
+        MOTION_LOG(ERR, TYPE_VIDEO, NO_ERRNO, "%s: config image width (%d) is not modulo 8",
+                   conf->width);
+        return -3;
     }
 
-    if (conf->height % 16) {
-        motion_log(LOG_ERR, 0, "config image height (%d) is not modulo 16", conf->height);
-        return -1;
+    if (conf->height % 8) {
+        MOTION_LOG(ERR, TYPE_VIDEO, NO_ERRNO, "%s: config image height (%d) is not modulo 8",
+                   conf->height);
+        return -3;
     }
 
     width = conf->width;
@@ -690,24 +683,25 @@ static int vid_v4lx_start(struct context
 
     pthread_mutex_lock(&vid_mutex);
 
-    /* Transfer width and height from conf to imgs. The imgs values are the ones
+    /*
+     * Transfer width and height from conf to imgs. The imgs values are the ones
      * that is used internally in Motion. That way, setting width and height via
      * http remote control won't screw things up.
      */
     cnt->imgs.width = width;
     cnt->imgs.height = height;
 
-    /* First we walk through the already discovered video devices to see
+    /*
+     * First we walk through the already discovered video devices to see
      * if we have already setup the same device before. If this is the case
      * the device is a Round Robin device and we set the basic settings
-     * and return the file descriptor
+     * and return the file descriptor.
      */
     dev = viddevs;
     while (dev) {
         if (!strcmp(conf->video_device, dev->video_device)) {
             dev->usage_count++;
             cnt->imgs.type = dev->v4l_fmt;
-
             switch (cnt->imgs.type) {
             case VIDEO_PALETTE_GREY:
                 cnt->imgs.motionsize = width * height;
@@ -728,6 +722,9 @@ static int vid_v4lx_start(struct context
         dev = dev->next;
     }
 
+    MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: Using videodevice %s and input %d",
+               conf->video_device, conf->input);
+
     dev = mymalloc(sizeof(struct video_dev));
     memset(dev, 0, sizeof(struct video_dev));
 
@@ -736,7 +733,8 @@ static int vid_v4lx_start(struct context
     fd = open(dev->video_device, O_RDWR);
 
     if (fd < 0) {
-        motion_log(LOG_ERR, 1, "Failed to open video device %s", conf->video_device);
+        MOTION_LOG(ALR, TYPE_VIDEO, SHOW_ERRNO, "%s: Failed to open video device %s",
+                   conf->video_device);
         free(dev);
         pthread_mutex_unlock(&vid_mutex);
         return -1;
@@ -748,12 +746,14 @@ static int vid_v4lx_start(struct context
     dev->usage_count = 1;
     dev->fd = fd;
     dev->input = input;
+    dev->norm = norm;
     dev->height = height;
     dev->width = width;
     dev->freq = frequency;
     dev->tuner_number = tuner_number;
 
-    /* We set brightness, contrast, saturation and hue = 0 so that they only get
+    /*
+     * We set brightness, contrast, saturation and hue = 0 so that they only get
      * set if the config is not zero.
      */
     dev->brightness = 0;
@@ -764,19 +764,21 @@ static int vid_v4lx_start(struct context
     dev->v4l_fmt = VIDEO_PALETTE_YUV420P;
     dev->fps = 0;
 #ifdef MOTION_V4L2
-    /* First lets try V4L2 and if it's not supported V4L1 */
+    /* First lets try V4L2 and if it's not supported V4L1. */
 
     dev->v4l2 = 1;
 
     if (!v4l2_start(cnt, dev, width, height, input, norm, frequency, tuner_number)) {
-        /* restore width & height before test with v4l
-         * because could be changed in v4l2_start ()
+        /*
+         * Restore width & height before test with v4l
+         * because could be changed in v4l2_start().
          */
         dev->width = width;
         dev->height = height;
 #endif
 
-        if (!v4l_start(cnt, dev, width, height, input, norm, frequency, tuner_number)) {
+#if defined(HAVE_LINUX_VIDEODEV_H) && (!defined(WITHOUT_V4L))      
+        if (!v4l_start(dev, width, height, input, norm, frequency, tuner_number)) {
             close(dev->fd);
             pthread_mutexattr_destroy(&dev->attr);
             pthread_mutex_destroy(&dev->mutex);
@@ -785,15 +787,17 @@ static int vid_v4lx_start(struct context
             pthread_mutex_unlock(&vid_mutex);
             return -1;
         }
+#endif
+
 #ifdef MOTION_V4L2
         dev->v4l2 = 0;
     }
 #endif
     if (dev->v4l2 == 0) {
-        motion_log(-1, 0, "Using V4L1");
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: Using V4L1");
     } else {
-        motion_log(-1, 0, "Using V4L2");
-        /* Update width & height because could be changed in v4l2_start () */
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: Using V4L2");
+        /* Update width & height because could be changed in v4l2_start(). */
         width = dev->width;
         height = dev->height;
         cnt->imgs.width = width;
@@ -817,17 +821,15 @@ static int vid_v4lx_start(struct context
         break;
     }
 
-    /* Insert into linked list */
+    /* Insert into linked list. */
     dev->next = viddevs;
     viddevs = dev;
 
     pthread_mutex_unlock(&vid_mutex);
 
-return fd;
+    return fd;
 }
-#endif                /*WITHOUT_V4L */
-
-
+#endif /* !WITHOUT_V4L */
 
 /**
  * vid_start
@@ -835,13 +837,13 @@ return fd;
  * vid_start setup the capture device. This will be either a V4L device or a netcam.
  * The function does the following:
  * - If the camera is a netcam - netcam_start is called and function returns
- * - Width and height are checked for valid value (multiple of 16)
+ * - Width and height are checked for valid value (multiple of 8)
  * - Copy the config height and width to the imgs struct. Note that height and width are
  *   only copied to the from the conf struct to the imgs struct during program startup
  *   The width and height can no later be changed via http remote control as this would
  *   require major re-memory allocations of all image buffers.
- *    
- * - if the camera is V4L/V4L2 vid_v4lx_start is called 
+ *
+ * - if the camera is V4L/V4L2 vid_v4lx_start is called
  *
  * Parameters:
  *     cnt        Pointer to the context for this thread
@@ -849,8 +851,8 @@ return fd;
  * Returns
  *     device number
  *     -1 if failed to open device.
+ *     -3 image dimensions are not modulo 8 
  */
-
 int vid_start(struct context *cnt)
 {
     struct config *conf = &cnt->conf;
@@ -864,8 +866,8 @@ int vid_start(struct context *cnt)
         }
     }
 #ifdef WITHOUT_V4L
-    else    
-        motion_log(LOG_ERR, 0,"You must setup netcam_url");
+    else
+        MOTION_LOG(CRT, TYPE_VIDEO, NO_ERRNO, "%s: You must setup netcam_url");
 #else
     else
         dev = vid_v4lx_start(cnt);
@@ -891,7 +893,7 @@ int vid_start(struct context *cnt)
  *    -1                        Fatal V4L error
  *    -2                        Fatal Netcam error
  *    Positive numbers...
- *    with bit 0 set            Non fatal V4L error (not implemented)
+ *    with bit 0 set            Non fatal V4L error (copy grey image and discard this image)
  *    with bit 1 set            Non fatal Netcam error
  */
 int vid_next(struct context *cnt, unsigned char *map)
@@ -906,8 +908,9 @@ int vid_next(struct context *cnt, unsign
         return netcam_next(cnt, map);
     }
 #ifndef WITHOUT_V4L
-    /* We start a new block so we can make declarations without breaking
-     * gcc 2.95 or older
+    /*
+     * We start a new block so we can make declarations without breaking
+     * gcc 2.95 or older.
      */
     {
         struct video_dev *dev;
@@ -940,10 +943,10 @@ int vid_next(struct context *cnt, unsign
             ret = v4l2_next(cnt, dev, map, width, height);
         } else {
 #endif
-            v4l_set_input(cnt, dev, map, width, height, conf->input, conf->norm,
-                          conf->roundrobin_skip, conf->frequency, conf->tuner_number);
-
+#if defined(HAVE_LINUX_VIDEODEV_H) && (!defined(WITHOUT_V4L))           
+            v4l_set_input(cnt, dev, map, width, height, conf);
             ret = v4l_next(dev, map, width, height);
+#endif            
 #ifdef MOTION_V4L2
         }
 #endif
@@ -953,11 +956,11 @@ int vid_next(struct context *cnt, unsign
             pthread_mutex_unlock(&dev->mutex);
         }
 
-        /* rotate the image as specified */
+        /* Rotate the image as specified. */
         if (cnt->rotate_data.degrees > 0)
             rotate_map(cnt, map);
-        
+
     }
-#endif                /*WITHOUT_V4L */
+#endif  /*WITHOUT_V4L */
     return ret;
 }
--- motion-3.2.12.orig/video_freebsd.c
+++ motion-3.2.12/video_freebsd.c
@@ -1,23 +1,22 @@
 /*    video_freebsd.c
  *
  *    BSD Video stream functions for motion.
- *    Copyright 2004 by Angel Carpintero (ack@telefonica.net)
+ *    Copyright 2004 by Angel Carpintero (motiondevelop@gmail.com)
  *    This software is distributed under the GNU public license version 2
  *    See also the file 'COPYING'.
  *
  */
 
-/* for rotation */
-#include "rotate.h"     /* already includes motion.h */
+/* For rotation */
+#include "rotate.h"     /* Already includes motion.h */
 #include "video_freebsd.h"
 
 #ifndef WITHOUT_V4L
 
-/* for the v4l stuff: */
+/* For the v4l stuff: */
 #include <sys/mman.h>
 
 /* Hack from xawtv 4.x */
-
 #define VIDEO_NONE           0
 #define VIDEO_RGB08          1  /* bt848 dithered */
 #define VIDEO_GRAY           2
@@ -40,7 +39,7 @@
 #define VIDEO_MPEG          19  /* MPEG1/2 */
 #define VIDEO_FMT_COUNT     20
 
-#define array_elem(x) (sizeof(x) / sizeof( (x)[0] ))
+#define array_elem(x) (sizeof(x) / sizeof((x)[0]))
 
 static const struct camparam_st {
   int min, max, range, drv_min, drv_range, def;
@@ -56,7 +55,7 @@ static const struct camparam_st {
     BT848_CONTRASTCENTER, },
   {
     BT848_CHROMAMIN, (BT848_CHROMAMIN + BT848_CHROMARANGE), BT848_CHROMARANGE,
-    BT848_CHROMAREGMIN, (BT848_CHROMAREGMAX - BT848_CHROMAREGMIN + 1 ),
+    BT848_CHROMAREGMIN, (BT848_CHROMAREGMAX - BT848_CHROMAREGMIN + 1),
     BT848_CHROMACENTER, },
 };
 
@@ -68,13 +67,11 @@ volatile sig_atomic_t bktr_frame_waiting
 
 //sigset_t sa_mask;
 
-
 static void catchsignal(int sig)
 {
     bktr_frame_waiting++;
 }
 
-
 /* Not tested yet */
 static void yuv422to420p(unsigned char *map, unsigned char *cap_map, int width, int height)
 {
@@ -110,8 +107,10 @@ static void yuv422to420p(unsigned char *
 
 }
 
-/* FIXME seems no work with METEOR_GEO_RGB24 , check BPP as well ? */
-
+/**
+ * rgb24toyuv420p
+ *   FIXME seems no work with METEOR_GEO_RGB24 , check BPP as well ?
+ */
 static void rgb24toyuv420p(unsigned char *map, unsigned char *cap_map, int width, int height)
 {
     unsigned char *y, *u, *v;
@@ -160,15 +159,15 @@ static void rgb24toyuv420p(unsigned char
 /* NOT TESTED YET FIXME */
 
 /*
-static int camparam_normalize(int param, int cfg_value, int *ioctl_val) 
+static int camparam_normalize(int param, int cfg_value, int *ioctl_val)
 {
     int val;
 
-    cfg_value = MIN(CamParams[ param ].max, MAX( CamParams[ param ].min, cfg_value)); 
-    val = (cfg_value - CamParams[ param ].min ) /
+    cfg_value = MIN(CamParams[ param ].max, MAX(CamParams[ param ].min, cfg_value));
+    val = (cfg_value - CamParams[ param ].min) /
           (CamParams[ param ].range + 0.01) * CamParams[param].drv_range + CamParams[param].drv_min;
-    val = MAX(CamParams[param].min,
-          MIN(CamParams[param].drv_min + CamParams[ param ].drv_range-1, val));
+    val = MAX(CamParams[ param ].min,
+          MIN(CamParams[ param ].drv_min + CamParams[ param ].drv_range-1, val));
     *ioctl_val = val;
     return cfg_value;
 }
@@ -179,12 +178,12 @@ static int set_hue(int viddev, int new_h
     signed char ioctlval = new_hue;
 
     if (ioctl(viddev, METEORSHUE, &ioctlval) < 0) {
-                motion_log(LOG_ERR, 1, "%s: METEORSHUE Error setting hue [%d]", __FUNCTION__, new_hue);
-                return -1;
-        }
+        MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: METEORSHUE Error setting hue [%d]",
+                   new_hue);
+        return -1;
+    }
 
-    if (debug_level >= CAMERA_VIDEO)
-        motion_log(-1, 0, "%s: to [%d]", __FUNCTION__, ioctlval);
+    MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: to [%d]", ioctlval);
 
     return ioctlval;
 }
@@ -194,29 +193,27 @@ static int get_hue(int viddev , int *hue
     signed char ioctlval;
 
     if (ioctl(viddev, METEORGHUE, &ioctlval) < 0) {
-        motion_log(LOG_ERR, 1, "%s: METEORGHUE Error getting hue", __FUNCTION__);
+        MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: METEORGHUE Error getting hue");
         return -1;
     }
 
-    if (debug_level >= CAMERA_VIDEO)
-        motion_log(-1, 0, "%s: to [%d]", __FUNCTION__, ioctlval);
-    
-    *hue = ioctlval; 
+    MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: to [%d]", ioctlval);
+
+    *hue = ioctlval;
     return ioctlval;
 }
 
-static int set_saturation(int viddev, int new_saturation) 
+static int set_saturation(int viddev, int new_saturation)
 {
     unsigned char ioctlval= new_saturation;
 
     if (ioctl(viddev, METEORSCSAT, &ioctlval) < 0) {
-        motion_log(LOG_ERR, 1, "%s: METEORSCSAT Error setting saturation [%d]", 
-                   __FUNCTION__, new_saturation);
+        MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: METEORSCSAT Error setting saturation [%d]",
+                   new_saturation);
         return -1;
     }
 
-    if (debug_level >= CAMERA_VIDEO)
-        motion_log(-1, 0, "%s: to [%d]", __FUNCTION__, ioctlval);
+    MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: to [%d]", ioctlval);
 
     return ioctlval;
 }
@@ -226,30 +223,27 @@ static int get_saturation(int viddev , i
     unsigned char ioctlval;
 
     if (ioctl(viddev, METEORGCSAT, &ioctlval) < 0) {
-
-        motion_log(LOG_ERR, 1, "%s: METEORGCSAT Error getting saturation", __FUNCTION__);
+        MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: METEORGCSAT Error getting saturation");
         return -1;
     }
 
-    if (debug_level >= CAMERA_VIDEO)
-        motion_log(-1, 0, "%s: to [%d]", __FUNCTION__, ioctlval);
-    
+    MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: to [%d]", ioctlval);
+
     *saturation = ioctlval;
     return ioctlval;
 }
 
-static int set_contrast(int viddev, int new_contrast) 
+static int set_contrast(int viddev, int new_contrast)
 {
     unsigned char ioctlval = new_contrast;
 
     if (ioctl(viddev, METEORSCONT, &ioctlval) < 0) {
-        motion_log(LOG_ERR, 1, "%s: METEORSCONT Error setting contrast [%d]", 
-                   __FUNCTION__, new_contrast);
+        MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: METEORSCONT Error setting contrast [%d]",
+                   new_contrast);
         return 0;
     }
 
-    if (debug_level >= CAMERA_VIDEO)
-        motion_log(-1, 0, "%s: to [%d]", __FUNCTION__, ioctlval);
+    MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: to [%d]", ioctlval);
 
     return ioctlval;
 }
@@ -258,15 +252,14 @@ static int get_contrast(int viddev, int
 {
     unsigned char ioctlval;
 
-    if (ioctl (viddev, METEORGCONT, &ioctlval ) < 0) {
-        motion_log(LOG_ERR, 1, "%s: METEORGCONT Error getting contrast", __FUNCTION__);
+    if (ioctl(viddev, METEORGCONT, &ioctlval) < 0) {
+        MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: METEORGCONT Error getting contrast");
         return -1;
     }
 
-    if (debug_level >= CAMERA_VIDEO)
-         motion_log(-1, 0, "%s: to [%d]", __FUNCTION__, ioctlval);
-    
-    *contrast = ioctlval; 
+    MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: to [%d]", ioctlval);
+
+    *contrast = ioctlval;
     return ioctlval;
 }
 
@@ -276,13 +269,13 @@ static int set_brightness(int viddev, in
     unsigned char ioctlval = new_bright;
 
     if (ioctl(viddev, METEORSBRIG, &ioctlval) < 0) {
-        motion_log(LOG_ERR, 1, "%s: METEORSBRIG  brightness [%d]", __FUNCTION__, new_bright);
+        MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: METEORSBRIG  brightness [%d]",
+                   new_bright);
         return -1;
     }
 
-    if (debug_level >= CAMERA_VIDEO)
-        motion_log(-1, 0, "%s: to [%d]", __FUNCTION__, ioctlval);
-    
+    MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: to [%d]", ioctlval);
+
     return ioctlval;
 }
 
@@ -292,57 +285,57 @@ static int get_brightness(int viddev, in
     unsigned char ioctlval;
 
     if (ioctl(viddev, METEORGBRIG, &ioctlval) < 0) {
-        motion_log(LOG_ERR, 1, "%s: METEORGBRIG  getting brightness", __FUNCTION__);
+        MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: METEORGBRIG  getting brightness");
         return -1;
     }
 
-    if (debug_level >= CAMERA_VIDEO)
-        motion_log(-1, 0, "%s: to [%d]", __FUNCTION__, ioctlval);
-    
+    MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: to [%d]", ioctlval);
+
     *brightness = ioctlval;
     return ioctlval;
 }
 
-// Set channel needed ? FIXME 
+// Set channel needed ? FIXME
 /*
-static int set_channel(struct video_dev *viddev, int new_channel) 
+static int set_channel(struct video_dev *viddev, int new_channel)
 {
     int ioctlval;
 
     ioctlval = new_channel;
     if (ioctl(viddev->fd_tuner, TVTUNER_SETCHNL, &ioctlval) < 0) {
-        motion_log(LOG_ERR, 1, "Error channel %d", ioctlval);
+        MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: Error channel %d", ioctlval);
         return -1;
     } else {
-        motion_log(LOG_DEBUG, 0, "channel set to %d", ioctlval);
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: channel set to %d", ioctlval);
     }
 
     viddev->channel = new_channel;
- 
+
     return 0;
 }
 */
 
-/* set frequency to tuner */
-
+/**
+ * set_freq
+ *  Sets frequency to tuner
+ */
 static int set_freq(struct video_dev *viddev, unsigned long freq)
 {
     int tuner_fd = viddev->fd_tuner;
     int old_audio;
 
-    motion_log(LOG_DEBUG, 0, "%s: Not implemented", __FUNCTION__);
-    
-    return 0; 
-    
-    /* HACK maybe not need it , but seems that is needed to mute before changing frequency */
+    MOTION_LOG(WRN, TYPE_VIDEO, NO_ERRNO, "%s: Not implemented");
+    return 0;
 
+    /* HACK maybe not need it , but seems that is needed to mute before changing frequency */
     if (ioctl(tuner_fd, BT848_GAUDIO, &old_audio) < 0) {
-        motion_log(LOG_ERR, 1, "%s: BT848_GAUDIO", __FUNCTION__);
+        MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: BT848_GAUDIO");
         return -1;
     }
-    
+
     if (ioctl(tuner_fd, TVTUNER_SETFREQ, &freq) < 0) {
-        motion_log(LOG_ERR, 1, "%s: Tuning (TVTUNER_SETFREQ) failed , freq [%lu]", __FUNCTION__, freq);
+        MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: Tuning (TVTUNER_SETFREQ) failed, ",
+                   "freq [%lu]", freq);
         return -1;
     }
 
@@ -350,55 +343,58 @@ static int set_freq(struct video_dev *vi
     if (old_audio) {
         old_audio = AUDIO_MUTE;
         if (ioctl(tuner_fd , BT848_SAUDIO, &old_audio) < 0) {
-            motion_log(LOG_ERR, 1, "%s: BT848_SAUDIO %i", __FUNCTION__, old_audio);
+            MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: BT848_SAUDIO %i",
+                       old_audio);
             return -1;
         }
     }
-    
+
     return 0;
 }
 
-/*
-  set the input to capture images , could be tuner (METEOR_INPUT_DEV1)
-  or any of others input :  
-    RCA/COMPOSITE1 (METEOR_INPUT_DEV0) 
-    COMPOSITE2/S-VIDEO (METEOR_INPUT_DEV2)
-    S-VIDEO (METEOR_INPUT_DEV3)
-    VBI ?! (METEOR_INPUT_DEV_SVIDEO)
-*/
-
-static int set_input(struct video_dev *viddev, unsigned short input)
+/**
+ * set_input
+ *      Sets the input to capture images , could be tuner (METEOR_INPUT_DEV1)
+ *      or any of others input :
+ *      RCA/COMPOSITE1 (METEOR_INPUT_DEV0)
+ *      COMPOSITE2/S-VIDEO (METEOR_INPUT_DEV2)
+ *      S-VIDEO (METEOR_INPUT_DEV3)
+ *      VBI ?! (METEOR_INPUT_DEV_SVIDEO)
+ */
+static int set_input(struct video_dev *viddev, unsigned input)
 {
     int actport;
     int portdata[] = { METEOR_INPUT_DEV0, METEOR_INPUT_DEV1,
                        METEOR_INPUT_DEV2, METEOR_INPUT_DEV3,
-                       METEOR_INPUT_DEV_SVIDEO};
+                       METEOR_INPUT_DEV_SVIDEO  };
 
     if (input >= array_elem(portdata)) {
-        motion_log(LOG_INFO, 0, "%s: Channel Port %d out of range (0-4)", __FUNCTION__, input);
+        MOTION_LOG(ERR, TYPE_VIDEO, NO_ERRNO, "%s: Channel Port %d out of range (0-4)",
+                   input);
         return -1;
     }
 
-    actport = portdata[input];
+    actport = portdata[ input ];
     if (ioctl(viddev->fd_bktr, METEORSINPUT, &actport) < 0) {
         if (input != IN_DEFAULT) {
-            motion_log(LOG_INFO, 1, "%s: METEORSINPUT %d invalid - Trying default %d", 
-                       __FUNCTION__, input, IN_DEFAULT);
+            MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: METEORSINPUT %d invalid -"
+                       "Trying default %d", input, IN_DEFAULT);
             input = IN_DEFAULT;
-            actport = portdata[input];
+            actport = portdata[ input ];
             if (ioctl(viddev->fd_bktr, METEORSINPUT, &actport) < 0) {
-                motion_log(LOG_ERR, 1, "%s: METEORSINPUT %d init", __FUNCTION__, input);
+                MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: METEORSINPUT %d init",
+                           input);
                 return -1;
             }
         } else {
-            motion_log(LOG_ERR, 1, "%s: METEORSINPUT %d init", __FUNCTION__, input);
+            MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: METEORSINPUT %d init",
+                       input);
             return -1;
         }
     }
 
-    if (debug_level >= CAMERA_VIDEO)
-        motion_log(-1, 0, "%s: to [%d]", __FUNCTION__, input);
-    
+    MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: to [%d]", input);
+
     return input;
 }
 
@@ -409,72 +405,70 @@ static int set_geometry(struct video_dev
 
     geom.columns = width;
     geom.rows = height;
-
     geom.oformat = METEOR_GEO_YUV_422 | METEOR_GEO_YUV_12;
 
-
     switch (viddev->norm) {
-    case PAL:   
-        h_max = PAL_HEIGHT;  
+    case PAL:
+        h_max = PAL_HEIGHT;
         break;
-    case NTSC:  
-        h_max = NTSC_HEIGHT; 
+    case NTSC:
+        h_max = NTSC_HEIGHT;
         break;
-    case SECAM: 
+    case SECAM:
         h_max = SECAM_HEIGHT;
         break;
-    default:    
+    default:
         h_max = PAL_HEIGHT;
     }
 
-    if (height <= h_max / 2) 
+    if (height <= h_max / 2)
         geom.oformat |= METEOR_GEO_EVEN_ONLY;
 
     geom.frames = 1;
 
     if (ioctl(viddev->fd_bktr, METEORSETGEO, &geom) < 0) {
-        motion_log(LOG_ERR, 1, "%s: Couldn't set the geometry", __FUNCTION__);
+        MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: Couldn't set the geometry");
         return -1;
     }
 
-    if (debug_level >= CAMERA_VIDEO)
-        motion_log(-1, 0, "%s: to [%d/%d] Norm %d", __FUNCTION__, width, height, viddev->norm);        
-    
+    MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: to [%d/%d] Norm %d",
+               width, height, viddev->norm);
+
     return 0;
 }
 
-/*
-   set input format ( PAL, NTSC, SECAM, etc ... )
-*/
-
-static int set_input_format(struct video_dev *viddev, unsigned short newformat) 
+/**
+ * set_input_format
+ *      Sets input format ( PAL, NTSC, SECAM, etc ... )
+ */
+static int set_input_format(struct video_dev *viddev, unsigned newformat)
 {
     int input_format[] = { NORM_PAL_NEW, NORM_NTSC_NEW, NORM_SECAM_NEW, NORM_DEFAULT_NEW};
     int format;
- 
-    if (newformat >= array_elem( input_format )) {
-        motion_log(LOG_WARNING, 0, "%s: Input format %d out of range (0-2)", __FUNCTION__, newformat);
+
+    if (newformat >= array_elem(input_format)) {
+        MOTION_LOG(WRN, TYPE_VIDEO, NO_ERRNO, "%s: Input format %d out of range (0-2)",
+                   newformat);
         return -1;
-    } 
+    }
 
-    format = input_format[newformat]; 
+    format = input_format[newformat];
 
-    if (ioctl( viddev->fd_bktr, BT848SFMT, &format) < 0) {
-        motion_log(LOG_ERR, 1, "%s: BT848SFMT, Couldn't set the input format , try again with default",
-                   __FUNCTION__);
+    if (ioctl(viddev->fd_bktr, BT848SFMT, &format) < 0) {
+        MOTION_LOG(WRN, TYPE_VIDEO, SHOW_ERRNO, "%s: BT848SFMT, Couldn't set the input format, "
+                   "try again with default");
         format = NORM_DEFAULT_NEW;
         newformat = 3;
-        
+
         if (ioctl(viddev->fd_bktr, BT848SFMT, &format) < 0) {
-            motion_log(LOG_ERR, 1, "%s: BT848SFMT, Couldn't set the input format either default", 
-                       __FUNCTION__);
+            MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: BT848SFMT, Couldn't set the input format "
+                       "either default");
             return -1;
         }
     }
 
-    if (debug_level >= CAMERA_VIDEO)
-        motion_log(-1, 0, "%s: to %d", __FUNCTION__, newformat);
-        
+    MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: to %d", newformat);
+
     return newformat;
 }
 
@@ -485,73 +479,75 @@ statict int setup_pixelformat(int bktr)
     struct meteor_pixfmt p;
     int format=-1;
 
-    for(i = 0; ; i++){
+    for (i = 0; ; i++) {
         p.index = i;
-        if (ioctl(bktr, METEORGSUPPIXFMT, &p ) < 0) {
+        if (ioctl(bktr, METEORGSUPPIXFMT, &p) < 0) {
             if (errno == EINVAL)
                 break;
-            motion_log(LOG_ERR, 1, "METEORGSUPPIXFMT getting pixformat %d", i);    
+            MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: METEORGSUPPIXFMT getting pixformat %d", i);
             return -1;
         }
 
 
-    // Hack from xawtv 4.x 
+    // Hack from xawtv 4.x
 
-    switch ( p.type ) {
+    switch (p.type) {
         case METEOR_PIXTYPE_RGB:
-            motion_log(-1, 0, "setup_pixelformat METEOR_PIXTYPE_RGB");
-            switch(p.masks[0]) {
-            case 31744: // 15 bpp 
-                format = p.swap_bytes ? VIDEO_RGB15_LE : VIDEO_RGB15_BE;
-                motion_log(-1, 0, "setup_pixelformat METEOR_PIXTYPE_RGB VIDEO_RGB15");
-                break;
-            case 63488: // 16 bpp 
-                format = p.swap_bytes ? VIDEO_RGB16_LE : VIDEO_RGB16_BE;
-                motion_log(-1, 0, "setup_pixelformat METEOR_PIXTYPE_RGB VIDEO_RGB16");
+            MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: setup_pixelformat METEOR_PIXTYPE_RGB");
+            switch (p.masks[0]) {
+                case 31744: // 15 bpp
+                    format = p.swap_bytes ? VIDEO_RGB15_LE : VIDEO_RGB15_BE;
+                    MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: setup_pixelformat METEOR_PIXTYPE_RGB VIDEO_RGB15");
                 break;
-            case 16711680: // 24/32 bpp 
-                if (p.Bpp == 3 && p.swap_bytes == 1) {
-                    format = VIDEO_BGR24;
-                    motion_log(-1, 0, "setup_pixelformat METEOR_PIXTYPE_RGB VIDEO_BGR24");
-                } else if (p.Bpp == 4 && p.swap_bytes == 1 && p.swap_shorts == 1) {
-                    format = VIDEO_BGR32;
-                    motion_log(-1, 0, "setup_pixelformat METEOR_PIXTYPE_RGB VIDEO_BGR32");
-                } else if (p.Bpp == 4 && p.swap_bytes == 0 && p.swap_shorts == 0) {
-                    format = VIDEO_RGB32;
-                    motion_log(-1, 0, "setup_pixelformat METEOR_PIXTYPE_RGB VIDEO_RGB32");
-                }
+                case 63488: // 16 bpp
+                    format = p.swap_bytes ? VIDEO_RGB16_LE : VIDEO_RGB16_BE;
+                    MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: setup_pixelformat METEOR_PIXTYPE_RGB VIDEO_RGB16");
                 break;
-            case METEOR_PIXTYPE_YUV:
-                format = VIDEO_YUV422P;
-                motion_log(-1, 0, "setup_pixelformat METEOR_PIXTYPE_YUV");
+                case 16711680: // 24/32 bpp
+                    if (p.Bpp == 3 && p.swap_bytes == 1) {
+                        format = VIDEO_BGR24;
+                        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: setup_pixelformat METEOR_PIXTYPE_RGB VIDEO_BGR24");
+                    } else if (p.Bpp == 4 && p.swap_bytes == 1 && p.swap_shorts == 1) {
+                        format = VIDEO_BGR32;
+                        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: setup_pixelformat METEOR_PIXTYPE_RGB VIDEO_BGR32");
+                        } else if (p.Bpp == 4 && p.swap_bytes == 0 && p.swap_shorts == 0) {
+                            format = VIDEO_RGB32;
+                            MOTION_LOG(EMG, TYPE_VIDEO, NO_ERRNO, "%s: setup_pixelformat METEOR_PIXTYPE_RGB VIDEO_RGB32");
+                        }
+                    }
                 break;
-            case METEOR_PIXTYPE_YUV_12:
-                format = VIDEO_YUV422P;
-                motion_log(-1, 0, "setup_pixelformat METEOR_PIXTYPE_YUV_12");
+                case METEOR_PIXTYPE_YUV:
+                    format = VIDEO_YUV422P;
+                    MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: setup_pixelformat METEOR_PIXTYPE_YUV");
                 break;
-            case METEOR_PIXTYPE_YUV_PACKED:
-                format = VIDEO_YUV422P;
-                motion_log(-1, 0, "setup_pixelformat METEOR_PIXTYPE_YUV_PACKED");
+                case METEOR_PIXTYPE_YUV_12:
+                    format = VIDEO_YUV422P;
+                    MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: setup_pixelformat METEOR_PIXTYPE_YUV_12");
+                    break;
+                case METEOR_PIXTYPE_YUV_PACKED:
+                    format = VIDEO_YUV422P;
+                    MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: setup_pixelformat METEOR_PIXTYPE_YUV_PACKED");
                 break;
+
             }
 
-            if (p.type == METEOR_PIXTYPE_RGB && p.Bpp == 3){
-                // Found a good pixeltype -- set it up 
-                if (ioctl(bktr, METEORSACTPIXFMT, &i) < 0){
-                    motion_log(LOG_WARNING, 1, "METEORSACTPIXFMT etting pixformat METEOR_PIXTYPE_RGB Bpp == 3");
-                // Not immediately fatal 
+            if (p.type == METEOR_PIXTYPE_RGB && p.Bpp == 3) {
+                // Found a good pixeltype -- set it up
+                if (ioctl(bktr, METEORSACTPIXFMT, &i) < 0) {
+                    MOTION_LOG(WRN, TYPE_VIDEO, SHOW_ERRNO, "%s: METEORSACTPIXFMT etting pixformat METEOR_PIXTYPE_RGB Bpp == 3");
+                // Not immediately fatal
                 }
-                motion_log(LOG_DEBUG, 0, "input format METEOR_PIXTYPE_RGB %i", i);
+                MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: input format METEOR_PIXTYPE_RGB %i", i);
                 format = i;
             }
 
             if (p.type == METEOR_PIXTYPE_YUV_PACKED) {
                 // Found a good pixeltype -- set it up
-                if (ioctl(bktr, METEORSACTPIXFMT, &i ) < 0){
-                    motion_log(LOG_WARNING, 1, "METEORSACTPIXFMT setting pixformat METEOR_PIXTYPE_YUV_PACKED");
+                if (ioctl(bktr, METEORSACTPIXFMT, &i) < 0) {
+                    MOTION_LOG(WRN, TYPE_VIDEO, SHOW_ERRNO, "%s: METEORSACTPIXFMT setting pixformat METEOR_PIXTYPE_YUV_PACKED");
                 // Not immediately fatal
-                } 
-                motion_log(LOG_DEBUG, 0, "input format METEOR_PIXTYPE_YUV_PACKED %i", i);
+                }
+                MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: input format METEOR_PIXTYPE_YUV_PACKED %i", i);
                 format = i;
             }
 
@@ -566,23 +562,23 @@ static void v4l_picture_controls(struct
 {
     int dev = viddev->fd_bktr;
 
-    if ((cnt->conf.contrast) && (cnt->conf.contrast != viddev->contrast)) { 
+    if ((cnt->conf.contrast) && (cnt->conf.contrast != viddev->contrast)) {
         set_contrast(dev, cnt->conf.contrast);
-        viddev->contrast = cnt->conf.contrast;    
+        viddev->contrast = cnt->conf.contrast;
     }
 
     if ((cnt->conf.hue) && (cnt->conf.hue != viddev->hue)) {
         set_hue(dev, cnt->conf.hue);
-        viddev->hue = cnt->conf.hue;    
+        viddev->hue = cnt->conf.hue;
     }
 
-    if ((cnt->conf.brightness) && 
+    if ((cnt->conf.brightness) &&
         (cnt->conf.brightness != viddev->brightness)) {
         set_brightness(dev, cnt->conf.brightness);
-        viddev->brightness = cnt->conf.brightness; 
+        viddev->brightness = cnt->conf.brightness;
     }
 
-    if ((cnt->conf.saturation) && 
+    if ((cnt->conf.saturation) &&
         (cnt->conf.saturation != viddev->saturation)) {
         set_saturation(dev, cnt->conf.saturation);
         viddev->saturation = cnt->conf.saturation;
@@ -597,7 +593,7 @@ static void v4l_picture_controls(struct
  - setup_pixelformat
  - set_geometry
 
- - set_brightness 
+ - set_brightness
  - set_chroma
  - set_contrast
  - set_channelset
@@ -605,97 +601,97 @@ static void v4l_picture_controls(struct
  - set_capture_mode
 
 */
-static unsigned char *v4l_start(struct video_dev *viddev, int width, int height, 
-                                unsigned short input, unsigned short norm, unsigned long freq)
+static unsigned char *v4l_start(struct video_dev *viddev, int width, int height,
+                                unsigned input, unsigned norm, unsigned long freq)
 {
     int dev_bktr = viddev->fd_bktr;
     struct sigaction act, old;
     //int dev_tunner = viddev->fd_tuner;
-    /* to ensure that all device will be support the capture mode 
+    /* to ensure that all device will be support the capture mode
       _TODO_ : Autodected the best capture mode .
     */
     int dummy = 1;
-//    int pixelformat = BSD_VIDFMT_I420;
+    //    int pixelformat = BSD_VIDFMT_I420;
 
     void *map;
 
-    /* if we have choose the tuner is needed to setup the frequency */
+    /* If we have choose the tuner is needed to setup the frequency. */
     if ((viddev->tuner_device != NULL) && (input == IN_TV)) {
         if (!freq) {
-            motion_log(LOG_ERR, 0, "%s: Not valid Frequency [%lu] for Source input [%i]",
-                       __FUNCTION__, freq, input);
+            MOTION_LOG(WRN, TYPE_VIDEO, NO_ERRNO, "%s: Not valid Frequency [%lu] for "
+                       "Source input [%i]", freq, input);
             return NULL;
         } else if (set_freq(viddev, freq) == -1) {
-            motion_log(LOG_ERR, 0, "%s: Frequency [%lu] Source input [%i]", 
-                       __FUNCTION__, freq, input);
+            MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: Frequency [%lu] Source input [%i]",
+                       freq, input);
             return NULL;
         }
     }
-    
-    /* FIXME if we set as input tuner , we need to set option for tuner not for bktr */
 
+    /* FIXME if we set as input tuner , we need to set option for tuner not for bktr */
     if ((dummy = set_input(viddev, input)) == -1) {
-        motion_log(LOG_ERR, 0, "%s: set input [%d]", __FUNCTION__, input);
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: set input [%d]", input);
         return NULL;
     }
 
     viddev->input = dummy;
 
     if ((dummy = set_input_format(viddev, norm)) == -1) {
-        motion_log(LOG_ERR, 0, "%s: set input format [%d]", __FUNCTION__, norm);
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: set input format [%d]",
+                   norm);
         return NULL;
     }
 
     viddev->norm = dummy;
 
     if (set_geometry(viddev, width, height) == -1) {
-        motion_log(LOG_ERR, 0, "%s: set geometry [%d]x[%d]", __FUNCTION__, width, height);
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: set geometry [%d]x[%d]",
+                   width, height);
         return NULL;
     }
-/*
+
+    /*
     if (ioctl(dev_bktr, METEORSACTPIXFMT, &pixelformat) < 0) {
-        motion_log(LOG_ERR, 1, "set encoding method BSD_VIDFMT_I420"); 
+        MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: set encoding method BSD_VIDFMT_I420");
         return NULL;
     }
 
-
-    NEEDED !? FIXME 
+    NEEDED !? FIXME
 
     if (setup_pixelformat(viddev) == -1)
         return NULL;
-*/
+    */
 
     if (freq) {
-        if (debug_level >= CAMERA_DEBUG)    
-            motion_log(-1, 0, "%s: Frequency set (no implemented yet", __FUNCTION__);
+        MOTION_LOG(WRN, TYPE_VIDEO, NO_ERRNO, "%s: Frequency set (no implemented yet");
     /*
      TODO missing implementation
         set_channelset(viddev);
         set_channel(viddev);
-        if (set_freq (viddev, freq) == -1) {
+        if (set_freq (viddev, freq) == -1)
             return NULL;
-        }
     */
-    }
-
 
-    /* set capture mode and capture buffers */
-
-    /* That is the buffer size for capture images ,
-     so is dependent of color space of input format / FIXME */
+    }
 
+    /*
+     * Set capture mode and capture buffers
+     * That is the buffer size for capture images ,
+     * so is dependent of color space of input format / FIXME
+     */
     viddev->v4l_bufsize = (((width * height * 3 / 2)) * sizeof(unsigned char));
     viddev->v4l_fmt = VIDEO_PALETTE_YUV420P;
-    
 
-    map = mmap((caddr_t)0, viddev->v4l_bufsize, PROT_READ|PROT_WRITE, MAP_SHARED, dev_bktr, (off_t)0);
 
-    if (map == MAP_FAILED){
-        motion_log(LOG_ERR, 1, "%s: mmap failed", __FUNCTION__);
+    map = mmap((caddr_t)0, viddev->v4l_bufsize, PROT_READ|PROT_WRITE, MAP_SHARED,
+               dev_bktr, (off_t)0);
+
+    if (map == MAP_FAILED) {
+        MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: mmap failed");
         return NULL;
     }
 
-    /* FIXME double buffer */ 
+    /* FIXME double buffer */
     if (0) {
         viddev->v4l_maxbuffer = 2;
         viddev->v4l_buffers[0] = map;
@@ -709,55 +705,54 @@ static unsigned char *v4l_start(struct v
     viddev->v4l_curbuffer = 0;
 
     /* Clear the buffer */
-
     if (ioctl(dev_bktr, BT848SCBUF, &dummy) < 0) {
-        motion_log(LOG_ERR, 1, "%s: BT848SCBUF", __FUNCTION__);
+        MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: BT848SCBUF");
         return NULL;
     }
 
-    /* signal handler to know when data is ready to be read() */
-         
+    /* Signal handler to know when data is ready to be read() */
     memset(&act, 0, sizeof(act));
     sigemptyset(&act.sa_mask);
     act.sa_handler = catchsignal;
     sigaction(SIGUSR2, &act, &old);
-     
+
     dummy = SIGUSR2;
 
     //viddev->capture_method = METEOR_CAP_CONTINOUS;
     //viddev->capture_method = METEOR_CAP_SINGLE;
-    
-    if ((viddev->capture_method == METEOR_CAP_CONTINOUS) && (ioctl(dev_bktr, METEORSSIGNAL, &dummy) < 0)) {
-        motion_log(LOG_ERR, 1, "%s: METEORSSIGNAL", __FUNCTION__);
-        motion_log(LOG_INFO, 0 , "%s: METEORSSIGNAL", __FUNCTION__);
+
+    if ((viddev->capture_method == METEOR_CAP_CONTINOUS) &&
+        (ioctl(dev_bktr, METEORSSIGNAL, &dummy) < 0)) {
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: METEORSSIGNAL");
+
         viddev->capture_method = METEOR_CAP_SINGLE;
+
         if (ioctl(dev_bktr, METEORCAPTUR, &viddev->capture_method) < 0) {
-            motion_log(LOG_ERR, 1, "%s: METEORCAPTUR using single method "
-                       "Error capturing", __FUNCTION__);
-            motion_log(LOG_INFO, 0, "%s: METEORCAPTUR using single method "
-                       "Error capturing", __FUNCTION__);
-        }    
+            MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: METEORCAPTUR using single method "
+                       "Error capturing");
+            MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: METEORCAPTUR using single method "
+                       "Error capturing");
+        }
     } else {
         if (ioctl(dev_bktr, METEORCAPTUR, &viddev->capture_method) < 0) {
             viddev->capture_method = METEOR_CAP_SINGLE;
+
             if (ioctl(dev_bktr, METEORCAPTUR, &viddev->capture_method) < 0) {
-                motion_log(LOG_ERR, 1, "%s: METEORCAPTUR using single method "
-                           "Error capturing", __FUNCTION__);
-                motion_log(LOG_INFO, 0, "%s: METEORCAPTUR using single method "
-                           "Error capturing", __FUNCTION__);
-            }    
-        }    
-    }            
-        
+                MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: METEORCAPTUR using single method "
+                           "Error capturing");
+            }
+        }
+    }
+
     if (viddev->capture_method == METEOR_CAP_CONTINOUS)
-        motion_log(LOG_INFO, 0, "%s: METEORCAPTUR METEOR_CAP_CONTINOUS", __FUNCTION__);    
-    else        
-        motion_log(LOG_INFO, 0, "%s: METEORCAPTUR METEOR_CAP_SINGLE", __FUNCTION__);
-    
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: METEORCAPTUR METEOR_CAP_CONTINOUS");
+    else
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: METEORCAPTUR METEOR_CAP_SINGLE");
+
     // settle , sleep(1) replaced
     SLEEP(1, 0);
 
-    /* FIXME*/
+    /* FIXME */
     switch (viddev->v4l_fmt) {
     case VIDEO_PALETTE_YUV420P:
         viddev->v4l_bufsize = (width * height * 3) / 2;
@@ -772,12 +767,16 @@ static unsigned char *v4l_start(struct v
         viddev->v4l_bufsize = width * height;
         break;
     }
-    
-    motion_log(LOG_INFO, 0, "HUE [%d]", get_hue(dev_bktr, &dummy));
-    motion_log(LOG_INFO, 0, "SATURATION [%d]", get_saturation(dev_bktr, &dummy));
-    motion_log(LOG_INFO, 0, "BRIGHTNESS [%d]", get_brightness(dev_bktr, &dummy));
-    motion_log(LOG_INFO, 0, "CONTRAST [%d]", get_contrast(dev_bktr, &dummy));
-    
+
+    MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: HUE [%d]",
+               get_hue(dev_bktr, &dummy));
+    MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: SATURATION [%d]",
+               get_saturation(dev_bktr, &dummy));
+    MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: BRIGHTNESS [%d]",
+               get_brightness(dev_bktr, &dummy));
+    MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: CONTRAST [%d]",
+               get_contrast(dev_bktr, &dummy));
+
     return map;
 }
 
@@ -805,8 +804,10 @@ static int v4l_next(struct video_dev *vi
 
     /* ONLY MMAP method is used to Capture */
 
-    /* Allocate a new mmap buffer */
-    /* Block signals during IOCTL */
+    /*
+     * Allocates a new mmap buffer
+     * Block signals during IOCTL
+     */
     sigemptyset (&set);
     sigaddset (&set, SIGCHLD);
     sigaddset (&set, SIGALRM);
@@ -820,21 +821,21 @@ static int v4l_next(struct video_dev *vi
     if (viddev->v4l_curbuffer >= viddev->v4l_maxbuffer)
         viddev->v4l_curbuffer = 0;
 
-    /* capture */
-    
+    /* Capture */
+
     if (viddev->capture_method == METEOR_CAP_CONTINOUS) {
-        if (bktr_frame_waiting) 
-            bktr_frame_waiting = 0;    
-            
+        if (bktr_frame_waiting)
+            bktr_frame_waiting = 0;
+
     } else if (ioctl(dev_bktr, METEORCAPTUR, &single) < 0) {
-        motion_log(LOG_ERR, 1, "%s: Error capturing using single method", __FUNCTION__);
+        MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: Error capturing using single method");
         sigprocmask(SIG_UNBLOCK, &old, NULL);
         return -1;
     }
 
-    /*undo the signal blocking*/
+    /* Undo the signal blocking */
     pthread_sigmask(SIG_UNBLOCK, &old, NULL);
-    
+
     switch (viddev->v4l_fmt) {
     case VIDEO_PALETTE_RGB24:
         rgb24toyuv420p(map, cap_map, width, height);
@@ -845,33 +846,35 @@ static int v4l_next(struct video_dev *vi
     default:
         memcpy(map, cap_map, viddev->v4l_bufsize);
     }
-    
+
     return 0;
 }
 
 
-/* set input & freq if needed FIXME not allowed use Tuner yet */
-
-static void v4l_set_input(struct context *cnt, struct video_dev *viddev, unsigned char *map, int width, int height,
-                          unsigned short input, unsigned short norm, int skip, unsigned long freq)
+/**
+ * v4l_set_input
+ *      Sets input & freq if needed FIXME not allowed use Tuner yet.
+ */
+static void v4l_set_input(struct context *cnt, struct video_dev *viddev, unsigned char *map, int width,
+                          int height, unsigned input, unsigned norm, int skip, unsigned long freq)
 {
-
     if (input != viddev->input || norm != viddev->norm || freq != viddev->freq) {
         int dummy;
         unsigned long frequnits = freq;
 
-        
+
         if ((dummy = set_input(viddev, input)) == -1)
             return;
 
         viddev->input = dummy;
-        
+
         if ((dummy = set_input_format(viddev, norm)) == -1)
             return;
-        
+
         viddev->norm = dummy;
-        
-        if ((viddev->tuner_device != NULL) && (viddev->input == IN_TV) && (frequnits > 0)) {
+
+        if ((viddev->tuner_device != NULL) && (viddev->input == IN_TV) &&
+            (frequnits > 0)) {
             if (set_freq(viddev, freq) == -1)
                 return;
         }
@@ -879,16 +882,14 @@ static void v4l_set_input(struct context
         // FIXME
         /*
         if (setup_pixelformat(viddev) == -1) {
-            motion_log(LOG_ERR, 1, "ioctl (VIDIOCSFREQ)");
+            MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: ioctl (VIDIOCSFREQ)");
             return
         }
-        */
 
-        /*
         if (set_geometry(viddev, width, height) == -1)
             return;
-        */     
-            
+        */
+
         v4l_picture_controls(cnt, viddev);
 
         viddev->freq = freq;
@@ -896,7 +897,6 @@ static void v4l_set_input(struct context
         /* skip a few frames if needed */
         for (dummy = 0; dummy < skip; dummy++)
             v4l_next(viddev, map, width, height);
-
     } else {
         /* No round robin - we only adjust picture controls */
         v4l_picture_controls(cnt, viddev);
@@ -911,39 +911,39 @@ static void v4l_set_input(struct context
 
 vid_init - Initi vid_mutex.
 vid_start - Setup Device parameters ( device , channel , freq , contrast , hue , saturation , brightness ) and open it.
-vid_next - Capture a frame and set input , contrast , hue , saturation and brightness if necessary. 
-vid_close - close devices. 
+vid_next - Capture a frame and set input , contrast , hue , saturation and brightness if necessary.
+vid_close - close devices.
 vid_cleanup - Destroy vid_mutex.
 
 */
 
-/* big lock for vid_start to ensure exclusive access to viddevs while adding
- * devices during initialization of each thread
+/*
+ * Big lock for vid_start to ensure exclusive access to viddevs while adding
+ * devices during initialization of each thread.
  */
 static pthread_mutex_t vid_mutex;
 
-
-/* Here we setup the viddevs structure which is used globally in the vid_*
+/*
+ * Here we setup the viddevs structure which is used globally in the vid_*
  * functions.
- */      
+ */
 static struct video_dev *viddevs = NULL;
 
-
-/*
+/**
  * vid_init
  *
  * Called from motion.c at the very beginning before setting up the threads.
- * Function prepares the vid_mutex
+ * Function prepares the vid_mutex.
  */
 void vid_init(void)
 {
     pthread_mutex_init(&vid_mutex, NULL);
 }
-                
+
 /**
  * vid_cleanup
  *
- * vid_cleanup is called from motion.c when Motion is stopped or restarted
+ * vid_cleanup is called from motion.c when Motion is stopped or restarted.
  */
 void vid_cleanup(void)
 {
@@ -952,13 +952,12 @@ void vid_cleanup(void)
 
 #endif /*WITHOUT_V4L*/
 
-
 /**
  * vid_close
  *
- * vid_close is called from motion.c when a Motion thread is stopped or restarted
+ * vid_close is called from motion.c when a Motion thread is stopped or restarted.
  */
-void vid_close(struct context *cnt)   
+void vid_close(struct context *cnt)
 {
 #ifndef WITHOUT_V4L
     struct video_dev *dev = viddevs;
@@ -970,79 +969,86 @@ void vid_close(struct context *cnt)
         netcam_cleanup(cnt->netcam, 0);
         cnt->netcam = NULL;
         return;
-    } 
+    }
 
 #ifndef WITHOUT_V4L
 
     /* Cleanup the v4l part */
     pthread_mutex_lock(&vid_mutex);
+
     while (dev) {
         if (dev->fd_bktr == cnt->video_dev)
             break;
-            prev = dev;
-            dev = dev->next;
-        }
-        pthread_mutex_unlock(&vid_mutex);
- 
-        /* Set it as closed in thread context */
-        cnt->video_dev = -1;
- 
-        if (dev == NULL) {
-            motion_log(LOG_ERR, 0, "%s: Unable to find video device", __FUNCTION__);   
-            return;
-        }
+        prev = dev;
+        dev = dev->next;
+    }
 
-        if (--dev->usage_count == 0) {
-            motion_log(LOG_INFO, 0, "%s: Closing video device %s", 
-                       __FUNCTION__, dev->video_device);
-
-            if (dev->fd_tuner > 0)
-                close(dev->fd_tuner);
-    
-            if (dev->fd_bktr > 0) { 
-                if (dev->capture_method == METEOR_CAP_CONTINOUS) {
-                    dev->fd_tuner = METEOR_CAP_STOP_CONT;
-                    ioctl(dev->fd_bktr, METEORCAPTUR, &dev->fd_tuner);
-                }
-                close(dev->fd_bktr);
-                dev->fd_tuner = -1;
+    pthread_mutex_unlock(&vid_mutex);
+
+    /* Set it as closed in thread context. */
+    cnt->video_dev = -1;
+
+    if (dev == NULL) {
+        MOTION_LOG(CRT, TYPE_VIDEO, NO_ERRNO, "%s: Unable to find video device");
+        return;
+    }
+
+    if (--dev->usage_count == 0) {
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: Closing video device %s",
+                   dev->video_device);
+
+        if (dev->fd_tuner > 0)
+            close(dev->fd_tuner);
+
+        if (dev->fd_bktr > 0) {
+            if (dev->capture_method == METEOR_CAP_CONTINOUS) {
+                dev->fd_tuner = METEOR_CAP_STOP_CONT;
+                ioctl(dev->fd_bktr, METEORCAPTUR, &dev->fd_tuner);
             }
+            close(dev->fd_bktr);
+            dev->fd_tuner = -1;
+        }
 
 
-            munmap(viddevs->v4l_buffers[0], viddevs->v4l_bufsize);
-            viddevs->v4l_buffers[0] = MAP_FAILED;
+        munmap(viddevs->v4l_buffers[0], viddevs->v4l_bufsize);
+        viddevs->v4l_buffers[0] = MAP_FAILED;
 
-            dev->fd_bktr = -1;
-            pthread_mutex_lock(&vid_mutex);
-            
-            /* Remove from list */
-            if (prev == NULL)
-                viddevs = dev->next;
-            else
-                prev->next = dev->next;
-             
-            pthread_mutex_unlock(&vid_mutex);
+        dev->fd_bktr = -1;
+        pthread_mutex_lock(&vid_mutex);
 
-            pthread_mutexattr_destroy(&dev->attr);
-            pthread_mutex_destroy(&dev->mutex);
-            free(dev);
-        } else {
-            motion_log(LOG_INFO, 0, "%s: Still %d users of video device %s, so we don't close it now", 
-                       __FUNCTION__, dev->usage_count, dev->video_device);
-            /* There is still at least one thread using this device
-             * If we own it, release it
-             */
-            if (dev->owner == cnt->threadnr) {
+        /* Remove from list */
+        if (prev == NULL)
+            viddevs = dev->next;
+        else
+            prev->next = dev->next;
+
+        pthread_mutex_unlock(&vid_mutex);
+
+        pthread_mutexattr_destroy(&dev->attr);
+        pthread_mutex_destroy(&dev->mutex);
+        free(dev);
+    } else {
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: Still %d users of video device %s, "
+                   "so we don't close it now", dev->usage_count,
+                   dev->video_device);
+        /*
+         * There is still at least one thread using this device
+         * If we own it, release it.
+         */
+        if (dev->owner == cnt->threadnr) {
                 dev->frames = 0;
                 dev->owner = -1;
                 pthread_mutex_unlock(&dev->mutex);
-            }
         }
-#endif /* WITHOUT_V4L */
+    }
+#endif /* !WITHOUT_V4L */
 }
 
 
-
+/**
+ * vid_start
+ *
+ */
 int vid_start(struct context *cnt)
 {
     struct config *conf = &cnt->conf;
@@ -1054,36 +1060,39 @@ int vid_start(struct context *cnt)
             netcam_cleanup(cnt->netcam, 1);
             cnt->netcam = NULL;
         }
-    }    
+    }
 #ifdef WITHOUT_V4L
-    else 
-        motion_log(LOG_ERR, 0, "%s: You must setup netcam_url", __FUNCTION__);    
+    else
+        MOTION_LOG(CRT, TYPE_VIDEO, NO_ERRNO, "%s: You must setup netcam_url");
 #else
     else {
         struct video_dev *dev;
         int fd_tuner = -1;
         int width, height, capture_method;
-        unsigned short input, norm;
+        unsigned input, norm;
         unsigned long frequency;
 
 
-        motion_log(-1, 0, "%s: [%s]", __FUNCTION__, conf->video_device);
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: [%s]",
+                   conf->video_device);
 
-        /* We use width and height from conf in this function. They will be assigned
-         * to width and height in imgs here, and cap_width and cap_height in 
+        /*
+         * We use width and height from conf in this function. They will be assigned
+         * to width and height in imgs here, and cap_width and cap_height in
          * rotate_data won't be set until in rotate_init.
-         * Motion requires that width and height are multiples of 16 so we check for this
+         * Motion requires that width and height are multiples of 8 so we check for this.
          */
-        if (conf->width % 16) {
-            motion_log(LOG_ERR, 0,
-                       "%s: config image width (%d) is not modulo 16",
-                       __FUNCTION__, conf->width);
+        if (conf->width % 8) {
+            MOTION_LOG(CRT, TYPE_VIDEO, NO_ERRNO,
+                       "%s: config image width (%d) is not modulo 8",
+                        conf->width);
             return -1;
         }
-        if (conf->height % 16) {
-            motion_log(LOG_ERR, 0,
-                       "%s: config image height (%d) is not modulo 16",
-                       __FUNCTION__, conf->height);
+
+        if (conf->height % 8) {
+            MOTION_LOG(CRT, TYPE_VIDEO, NO_ERRNO,
+                       "%s: config image height (%d) is not modulo 8",
+                        conf->height);
             return -1;
         }
 
@@ -1093,39 +1102,41 @@ int vid_start(struct context *cnt)
         norm = conf->norm;
         frequency = conf->frequency;
         capture_method = METEOR_CAP_CONTINOUS;
-        
+
         pthread_mutex_lock(&vid_mutex);
 
-        /* Transfer width and height from conf to imgs. The imgs values are the ones
+        /*
+         * Transfer width and height from conf to imgs. The imgs values are the ones
          * that is used internally in Motion. That way, setting width and height via
          * http remote control won't screw things up.
          */
         cnt->imgs.width = width;
         cnt->imgs.height = height;
 
-        /* First we walk through the already discovered video devices to see
+        /*
+         * First we walk through the already discovered video devices to see
          * if we have already setup the same device before. If this is the case
          * the device is a Round Robin device and we set the basic settings
-         * and return the file descriptor
+         * and return the file descriptor.
          */
         dev = viddevs;
-        while (dev) { 
+        while (dev) {
             if (!strcmp(conf->video_device, dev->video_device)) {
                 int dummy = METEOR_CAP_STOP_CONT;
                 dev->usage_count++;
                 cnt->imgs.type = dev->v4l_fmt;
 
                 if (ioctl(dev->fd_bktr, METEORCAPTUR, &dummy) < 0) {
-                    motion_log(LOG_ERR, 1, "%s Stopping capture", __FUNCTION__);
-                    return -1;    
-                }    
-                
-                motion_log(-1, 0, "%s Reusing [%s] inputs [%d,%d] Change capture method "
-                           "METEOR_CAP_SINGLE",  __FUNCTION__, dev->video_device, 
+                    MOTION_LOG(CRT, TYPE_VIDEO, SHOW_ERRNO, "%s Stopping capture");
+                    return -1;
+                }
+
+                MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s Reusing [%s] inputs [%d,%d] Change "
+                           "capture method METEOR_CAP_SINGLE", dev->video_device,
                            dev->input, conf->input);
 
                 dev->capture_method = METEOR_CAP_SINGLE;
-                
+
                 switch (cnt->imgs.type) {
                 case VIDEO_PALETTE_GREY:
                     cnt->imgs.motionsize = width * height;
@@ -1135,13 +1146,13 @@ int vid_start(struct context *cnt)
                 case VIDEO_PALETTE_YUV422:
                     cnt->imgs.type = VIDEO_PALETTE_YUV420P;
                 case VIDEO_PALETTE_YUV420P:
-                    motion_log(-1, 0,
-                               "%s VIDEO_PALETTE_YUV420P setting imgs.size "
-                               "and imgs.motionsize", __FUNCTION__);
+                    MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s VIDEO_PALETTE_YUV420P setting"
+                               " imgs.size and imgs.motionsize");
                     cnt->imgs.motionsize = width * height;
                     cnt->imgs.size = (width * height * 3) / 2;
                     break;
                 }
+
                 pthread_mutex_unlock(&vid_mutex);
                 return dev->fd_bktr; // FIXME return fd_tuner ?!
             }
@@ -1154,20 +1165,21 @@ int vid_start(struct context *cnt)
 
         fd_bktr = open(conf->video_device, O_RDWR);
 
-        if (fd_bktr < 0) { 
-            motion_log(LOG_ERR, 1, "%s: open video device %s", __FUNCTION__, conf->video_device);
+        if (fd_bktr < 0) {
+            MOTION_LOG(CRT, TYPE_VIDEO, SHOW_ERRNO, "%s: open video device %s",
+                       conf->video_device);
             free(dev);
             pthread_mutex_unlock(&vid_mutex);
             return -1;
         }
 
 
-        /* Only open tuner if conf->tuner_device has set , freq and input is 1 */
+        /* Only open tuner if conf->tuner_device has set , freq and input is 1. */
         if ((conf->tuner_device != NULL) && (frequency > 0) && (input == IN_TV)) {
             fd_tuner = open(conf->tuner_device, O_RDWR);
-            if (fd_tuner < 0) { 
-                motion_log(LOG_ERR, 1, "%s: open tuner device %s", 
-                           __FUNCTION__, conf->tuner_device);
+            if (fd_tuner < 0) {
+                MOTION_LOG(CRT, TYPE_VIDEO, SHOW_ERRNO, "%s: open tuner device %s",
+                           conf->tuner_device);
                 free(dev);
                 pthread_mutex_unlock(&vid_mutex);
                 return -1;
@@ -1188,23 +1200,24 @@ int vid_start(struct context *cnt)
         dev->freq = frequency;
         dev->owner = -1;
         dev->capture_method = capture_method;
-        
-        /* We set brightness, contrast, saturation and hue = 0 so that they only get
+
+        /*
+         * We set brightness, contrast, saturation and hue = 0 so that they only get
          * set if the config is not zero.
          */
-        
+
         dev->brightness = 0;
         dev->contrast = 0;
         dev->saturation = 0;
         dev->hue = 0;
         dev->owner = -1;
 
-        /* default palette */ 
+        /* Default palette */
         dev->v4l_fmt = VIDEO_PALETTE_YUV420P;
         dev->v4l_curbuffer = 0;
         dev->v4l_maxbuffer = 1;
 
-        if (!v4l_start(dev, width, height, input, norm, frequency)) { 
+        if (!v4l_start(dev, width, height, input, norm, frequency)) {
             close(dev->fd_bktr);
             pthread_mutexattr_destroy(&dev->attr);
             pthread_mutex_destroy(&dev->mutex);
@@ -1213,10 +1226,10 @@ int vid_start(struct context *cnt)
             pthread_mutex_unlock(&vid_mutex);
             return -1;
         }
-    
+
         cnt->imgs.type = dev->v4l_fmt;
-    
-        switch (cnt->imgs.type) { 
+
+        switch (cnt->imgs.type) {
         case VIDEO_PALETTE_GREY:
             cnt->imgs.size = width * height;
             cnt->imgs.motionsize = width * height;
@@ -1225,19 +1238,19 @@ int vid_start(struct context *cnt)
         case VIDEO_PALETTE_YUV422:
             cnt->imgs.type = VIDEO_PALETTE_YUV420P;
         case VIDEO_PALETTE_YUV420P:
-            motion_log(-1, 0, "%s: VIDEO_PALETTE_YUV420P imgs.type", __FUNCTION__);
+            MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: VIDEO_PALETTE_YUV420P imgs.type");
             cnt->imgs.size = (width * height * 3) / 2;
             cnt->imgs.motionsize = width * height;
-        break;
+            break;
         }
 
         /* Insert into linked list */
         dev->next = viddevs;
         viddevs = dev;
-    
+
         pthread_mutex_unlock(&vid_mutex);
     }
-#endif /* WITHOUT_V4L */
+#endif /* !WITHOUT_V4L */
 
     /* FIXME needed tuner device ?! */
     return fd_bktr;
@@ -1272,29 +1285,29 @@ int vid_next(struct context *cnt, unsign
 
 #ifndef WITHOUT_V4L
 
-    struct video_dev *dev;    
+    struct video_dev *dev;
     int width, height;
     int dev_bktr = cnt->video_dev;
 
     /* NOTE: Since this is a capture, we need to use capture dimensions. */
     width = cnt->rotate_data.cap_width;
     height = cnt->rotate_data.cap_height;
-    
+
     pthread_mutex_lock(&vid_mutex);
-    dev = viddevs;    
+    dev = viddevs;
+
     while (dev) {
         if (dev->fd_bktr == dev_bktr)
             break;
         dev = dev->next;
     }
-    
+
     pthread_mutex_unlock(&vid_mutex);
 
     if (dev == NULL)
         return V4L_FATAL_ERROR;
-        //return -1;
 
-    if (dev->owner != cnt->threadnr) { 
+    if (dev->owner != cnt->threadnr) {
         pthread_mutex_lock(&dev->mutex);
         dev->owner = cnt->threadnr;
         dev->frames = conf->roundrobin_frames;
@@ -1303,19 +1316,20 @@ int vid_next(struct context *cnt, unsign
 
     v4l_set_input(cnt, dev, map, width, height, conf->input, conf->norm,
                   conf->roundrobin_skip, conf->frequency);
-    
+
     ret = v4l_next(dev, map, width, height);
 
-    if (--dev->frames <= 0) { 
+    if (--dev->frames <= 0) {
         dev->owner = -1;
         dev->frames = 0;
         pthread_mutex_unlock(&dev->mutex);
     }
-    
-    /* rotate the image as specified */
-    if (cnt->rotate_data.degrees > 0)  
+
+    /* Rotate the image as specified */
+    if (cnt->rotate_data.degrees > 0)
         rotate_map(cnt, map);
-         
-#endif /*WITHOUT_V4L*/
+
+
+#endif /* !WITHOUT_V4L */
     return ret;
 }
--- motion-3.2.12.orig/video_freebsd.h
+++ motion-3.2.12/video_freebsd.h
@@ -1,9 +1,10 @@
-/*    video_freebsd.h
+/*
+ * video_freebsd.h
  *
  *    Include file for video_freebsd.c
- *      Copyright 2004 by Angel Carpintero (ack@telefonica.net)
- *      This software is distributed under the GNU public license version 2
- *      See also the file 'COPYING'.
+ *    Copyright 2004 by Angel Carpintero (motiondevelop@gmail.com)
+ *    This software is distributed under the GNU public license version 2
+ *    See also the file 'COPYING'.
  *
  */
 
@@ -24,13 +25,13 @@
 #include <dev/bktr/ioctl_bt848.h>
 #endif
 
-#endif
+#endif /* !WITHOUT_V4L */
 
 /* bktr (video4linux) stuff FIXME more modes not only these */
 
 /* not used yet FIXME ! only needed for tuner use */
 /*
-#define TV_INPUT_NTSCM    BT848_IFORM_F_NTSCM 
+#define TV_INPUT_NTSCM    BT848_IFORM_F_NTSCM
 #define TV_INPUT_NTSCJ    BT848_IFORM_F_NTSCJ
 #define TV_INPUT_PALBDGHI BT848_IFORM_F_PALBDGHI
 #define TV_INPUT_PALM     BT848_IFORM_F_PALM
@@ -40,26 +41,26 @@
 */
 
 /* video4linux error codes */
-#define V4L_GENERAL_ERROR    0x01  /* binary 000001 */
-#define V4L_BTTVLOST_ERROR   0x05  /* binary 000101 */
+#define V4L_GENERAL_ERROR  0x01   /* binary 000001 */
+#define V4L_BTTVLOST_ERROR 0x05   /* binary 000101 */
 #define V4L_FATAL_ERROR      -1
 
-#define NORM_DEFAULT      0x00800  /* METEOR_FMT_AUTOMODE */
-#define NORM_PAL          0x00200  /* METEOR_FMT_PAL      */
-#define NORM_NTSC         0x00100  /* METEOR_FMT_NTSC     */
-#define NORM_SECAM        0x00400  /* METEOR_FMT_SECAM    */
-#define NORM_PAL_NC       0x00200  /* METEOR_FMT_PAL      */
+#define NORM_DEFAULT    0x00800 // METEOR_FMT_AUTOMODE
+#define NORM_PAL        0x00200 // METEOR_FMT_PAL
+#define NORM_NTSC       0x00100 // METEOR_FMT_NTSC
+#define NORM_SECAM      0x00400 // METEOR_FMT_SECAM
+#define NORM_PAL_NC     0x00200 // METEOR_FMT_PAL /* Greyscale howto ?! FIXME */
 
-#define NORM_DEFAULT_NEW      BT848_IFORM_F_AUTO 
-#define NORM_PAL_NEW          BT848_IFORM_F_PALBDGHI    
+#define NORM_DEFAULT_NEW      BT848_IFORM_F_AUTO
+#define NORM_PAL_NEW          BT848_IFORM_F_PALBDGHI
 #define NORM_NTSC_NEW         BT848_IFORM_F_NTSCM
-#define NORM_SECAM_NEW        BT848_IFORM_F_SECAM                 
-#define NORM_PAL_NC_NEW       BT848_IFORM_F_AUTO /* FIXME */    
+#define NORM_SECAM_NEW        BT848_IFORM_F_SECAM
+#define NORM_PAL_NC_NEW       BT848_IFORM_F_AUTO /* FIXME */
 
 #define PAL                   0
 #define NTSC                  1
 #define SECAM                 2
-#define PAL_NC                3    
+#define PAL_NC                3
 
 #define PAL_HEIGHT          576
 #define SECAM_HEIGHT        576
@@ -76,7 +77,7 @@
 #define BSD_VIDFMT_LAST       8
 
 
-#define IN_DEFAULT            0 
+#define IN_DEFAULT            0
 #define IN_COMPOSITE          0
 #define IN_TV                 1
 #define IN_COMPOSITE2         2
@@ -95,8 +96,8 @@ struct video_dev {
     int fd_tuner;
     const char *video_device;
     const char *tuner_device;
-    unsigned short input;
-    unsigned short norm;
+    unsigned input;
+    unsigned norm;
     int width;
     int height;
     int contrast;
@@ -111,10 +112,10 @@ struct video_dev {
     pthread_mutexattr_t attr;
     int owner;
     int frames;
-    
+
     /* Device type specific stuff: */
-#ifndef WITHOUT_V4L    
-     int capture_method;    
+#ifndef WITHOUT_V4L
+     int capture_method;
     int v4l_fmt;
     unsigned char *v4l_buffers[2];
     int v4l_curbuffer;
--- /dev/null
+++ motion-3.2.12/vloopback_motion.c
@@ -0,0 +1,256 @@
+/*
+ *    vloopback_motion.c
+ *
+ *    Video loopback functions for motion.
+ *    Copyright 2000 by Jeroen Vreeken (pe1rxq@amsat.org)
+ *    Copyright 2008 by Angel Carpintero (motiondevelop@gmail.com)
+ *    This software is distributed under the GNU public license version 2
+ *    See also the file 'COPYING'.
+ *
+ */
+#include "vloopback_motion.h"
+#if defined(HAVE_LINUX_VIDEODEV_H) && (!defined(WITHOUT_V4L)) && (!defined(BSD))
+#include <sys/utsname.h>
+#include <dirent.h>
+
+/**
+ * v4l_open_vidpipe
+ *
+ */
+static int v4l_open_vidpipe(void)
+{
+    int pipe_fd = -1;
+    char pipepath[255];
+    char buffer[255];
+    char *major;
+    char *minor;
+    struct utsname uts;
+
+    if (uname(&uts) < 0) {
+        MOTION_LOG(CRT, TYPE_VIDEO, SHOW_ERRNO, "%s: Unable to execute uname");
+        return -1;
+    }
+
+    major = strtok(uts.release, ".");
+    minor = strtok(NULL, ".");
+
+    if ((major == NULL) || (minor == NULL) || (strcmp(major, "2"))) {
+        MOTION_LOG(CRT, TYPE_VIDEO, SHOW_ERRNO, "%s: Unable to decipher OS version");
+        return -1;
+    }
+
+    if (strcmp(minor, "5") < 0) {
+        FILE *vloopbacks;
+        char *loop;
+        char *input;
+        char *istatus;
+        char *output;
+        char *ostatus;
+
+        vloopbacks = fopen("/proc/video/vloopback/vloopbacks", "r");
+
+        if (!vloopbacks) {
+            MOTION_LOG(CRT, TYPE_VIDEO, SHOW_ERRNO, "%s: Failed to open "
+                       "'/proc/video/vloopback/vloopbacks'");
+            return -1;
+        }
+
+        /* Read vloopback version*/
+        if (!fgets(buffer, sizeof(buffer), vloopbacks)) {
+            MOTION_LOG(CRT, TYPE_VIDEO, SHOW_ERRNO, "%s: Unable to read vloopback version");
+            myfclose(vloopbacks);
+            return -1;
+        }
+
+        fprintf(stderr, "\t%s", buffer);
+
+        /* Read explanation line */
+
+        if (!fgets(buffer, sizeof(buffer), vloopbacks)) {
+            MOTION_LOG(CRT, TYPE_VIDEO, SHOW_ERRNO, "%s: Unable to read vloopback"
+                       " explanation line");
+            myfclose(vloopbacks);
+            return -1;
+        }
+
+        while (fgets(buffer, sizeof(buffer), vloopbacks)) {
+            if (strlen(buffer) > 1) {
+                buffer[strlen(buffer)-1] = 0;
+                loop = strtok(buffer, "\t");
+                input = strtok(NULL, "\t");
+                istatus = strtok(NULL, "\t");
+                output = strtok(NULL, "\t");
+                ostatus = strtok(NULL, "\t");
+
+                if (istatus[0] == '-') {
+                    snprintf(pipepath, sizeof(pipepath), "/dev/%s", input);
+                    pipe_fd = open(pipepath, O_RDWR);
+
+                    if (pipe_fd >= 0) {
+                        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: \tInput:  /dev/%s "
+                                   "\tOutput: /dev/%s",  input, output);
+                        break;
+                    }
+                }
+            }
+        }
+
+        myfclose(vloopbacks);
+    } else {
+        DIR *dir;
+        struct dirent *dirp;
+        const char prefix[] = "/sys/class/video4linux/";
+        char *ptr, *io;
+        int fd;
+        int low = 9999;
+        int tfd;
+        int tnum;
+
+        if ((dir = opendir(prefix)) == NULL) {
+            MOTION_LOG(CRT, TYPE_VIDEO, SHOW_ERRNO, "%s: Failed to open '%s'",
+                       prefix);
+            return -1;
+        }
+
+        while ((dirp = readdir(dir)) != NULL) {
+            if (!strncmp(dirp->d_name, "video", 5)) {
+                strncpy(buffer, prefix, sizeof(buffer));
+                strncat(buffer, dirp->d_name, sizeof(buffer) - strlen(buffer));
+                strncat(buffer, "/name", sizeof(buffer) - strlen(buffer));
+
+                if ((fd = open(buffer, O_RDONLY)) >= 0) {
+                    if ((read(fd, buffer, sizeof(buffer)-1)) < 0) {
+                        close(fd);
+                        continue;
+                    }
+
+                    ptr = strtok(buffer, " ");
+
+                    if (strcmp(ptr, "Video")) {
+                        close(fd);
+                        continue;
+                    }
+
+                    major = strtok(NULL, " ");
+                    minor = strtok(NULL, " ");
+                    io  = strtok(NULL, " \n");
+
+                    if (strcmp(major, "loopback") || strcmp(io, "input")) {
+                        close(fd);
+                        continue;
+                    }
+
+                    if ((ptr = strtok(buffer, " ")) == NULL) {
+                        close(fd);
+                        continue;
+                    }
+
+                    tnum = atoi(minor);
+
+                    if (tnum < low) {
+                        mystrcpy(buffer, "/dev/");
+                        strncat(buffer, dirp->d_name, sizeof(buffer) - strlen(buffer));
+                        if ((tfd = open(buffer, O_RDWR)) >= 0) {
+                            strncpy(pipepath, buffer, sizeof(pipepath));
+
+                            if (pipe_fd >= 0)
+                                close(pipe_fd);
+
+                            pipe_fd = tfd;
+                            low = tnum;
+                        }
+                    }
+                    close(fd);
+                }
+            }
+        }
+
+        closedir(dir);
+
+        if (pipe_fd >= 0)
+            MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: Opened %s as input",
+                       pipepath);
+    }
+
+    return pipe_fd;
+}
+
+/**
+ * v4l_startpipe
+ *
+ */
+static int v4l_startpipe(const char *dev_name, int width, int height, int type)
+{
+    int dev;
+    struct video_picture vid_pic;
+    struct video_window vid_win;
+
+    if (!strcmp(dev_name, "-")) {
+        dev = v4l_open_vidpipe();
+    } else {
+        dev = open(dev_name, O_RDWR);
+        MOTION_LOG(NTC, TYPE_VIDEO, NO_ERRNO, "%s: Opened %s as input",
+                   dev_name);
+    }
+
+    if (dev < 0) {
+        MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: Opening %s as input failed",
+                   dev_name);
+        return -1;
+    }
+
+    if (ioctl(dev, VIDIOCGPICT, &vid_pic) == -1) {
+        MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: ioctl (VIDIOCGPICT)");
+        return -1;
+    }
+
+    vid_pic.palette = type;
+
+    if (ioctl(dev, VIDIOCSPICT, &vid_pic) == -1) {
+        MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: ioctl (VIDIOCSPICT)");
+        return -1;
+    }
+
+    if (ioctl(dev, VIDIOCGWIN, &vid_win) == -1) {
+        MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: ioctl (VIDIOCGWIN)");
+        return -1;
+    }
+
+    vid_win.height = height;
+    vid_win.width = width;
+
+    if (ioctl(dev, VIDIOCSWIN, &vid_win) == -1) {
+        MOTION_LOG(ERR, TYPE_VIDEO, SHOW_ERRNO, "%s: ioctl (VIDIOCSWIN)");
+        return -1;
+    }
+
+    return dev;
+}
+
+/**
+ * v4l_putpipe
+ *
+ */
+static int v4l_putpipe(int dev, unsigned char *image, int size)
+{
+    return write(dev, image, size);
+}
+
+/**
+ * vid_startpipe
+ *
+ */
+int vid_startpipe(const char *dev_name, int width, int height, int type)
+{
+    return v4l_startpipe(dev_name, width, height, type);
+}
+
+/**
+ * vid_putpipe
+ *
+ */
+int vid_putpipe (int dev, unsigned char *image, int size)
+{
+    return v4l_putpipe(dev, image, size);
+}
+#endif /* !WITHOUT_V4L && !BSD */
--- /dev/null
+++ motion-3.2.12/vloopback_motion.h
@@ -0,0 +1,17 @@
+/*  vloopback_motion.h
+ *
+ *  Include file for vloopback_motion.c
+ *      Copyright 2000 by Jeroen Vreeken (pe1rxq@amsat.org)
+ *      Copyright 2008 by Angel Carpintero (motiondevelop@gmail.com)
+ *      This software is distributed under the GNU public license version 2
+ *      See also the file 'COPYING'.
+ *
+ */
+#ifndef _INCLUDE_VLOOPBACK_MOTION_H
+#define _INCLUDE_VLOOPBACK_MOTION_H
+
+#include "motion.h"
+
+int vid_startpipe(const char *dev_name, int width, int height, int);
+int vid_putpipe(int dev, unsigned char *image, int);
+#endif
--- motion-3.2.12.orig/webhttpd.c
+++ motion-3.2.12/webhttpd.c
@@ -3,9 +3,9 @@
  *
  *      HTTP Control interface for motion.
  *
- *      Specs : http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionHttpAPI
+ *      Specs : http://www.lavrsen.dk/twiki/bin/view/Motion/MotionHttpAPI
  *
- *      Copyright 2004-2005 by Angel Carpintero  (ack@telefonica.net)
+ *      Copyright 2004-2005 by Angel Carpintero  (motiondevelop@gmail.com)
  *      This software is distributed under the GNU Public License Version 2
  *      See also the file 'COPYING'.
  *
@@ -18,25 +18,26 @@
 
 pthread_mutex_t httpd_mutex;
 
-int warningkill; // This is a dummy variable use to kill warnings when not checking sscanf and similar functions
+// This is a dummy variable use to kill warnings when not checking sscanf and similar functions
+int warningkill;
 
-static const char* ini_template =
+static const char *ini_template =
     "<html><head><title>Motion "VERSION"</title></head>\n"
     "<body>\n";
 
 static const char *set_template =
     "<html><head><script language='javascript'>"
-    "function show(){top.location.href="
+    "function show() {top.location.href="
     "'set?'+document.n.onames.options[document.n.onames.selectedIndex].value"
     "+'='+document.s.valor.value;"
     "}</script>\n<title>Motion "VERSION"</title>\n"
     "</head><body>\n";
 
-static const char* end_template =
+static const char *end_template =
     "</body>\n"
     "</html>\n";
 
-static const char* ok_response =
+static const char *ok_response =
     "HTTP/1.1 200 OK\r\n"
     "Server: Motion-httpd/"VERSION"\r\n"
     "Connection: close\r\n"
@@ -47,7 +48,7 @@ static const char* ok_response =
     "Pragma: no-cache\r\n"
     "Content-type: text/html\r\n\r\n";
 
-static const char* ok_response_raw =
+static const char *ok_response_raw =
     "HTTP/1.1 200 OK\r\n"
     "Server: Motion-httpd/"VERSION"\r\n"
     "Connection: close\r\n"
@@ -58,8 +59,7 @@ static const char* ok_response_raw =
     "Pragma: no-cache\r\n"
     "Content-type: text/plain\r\n\r\n";
 
-
-static const char* bad_request_response =
+static const char *bad_request_response =
     "HTTP/1.0 400 Bad Request\r\n"
     "Content-type: text/html\r\n\r\n"
     "<html>\n"
@@ -69,12 +69,12 @@ static const char* bad_request_response
     "</body>\n"
     "</html>\n";
 
-static const char* bad_request_response_raw =
+static const char *bad_request_response_raw =
     "HTTP/1.0 400 Bad Request\r\n"
     "Content-type: text/plain\r\n\r\n"
     "Bad Request";
 
-static const char* not_found_response_template =
+static const char *not_found_response_template =
     "HTTP/1.0 404 Not Found\r\n"
     "Content-type: text/html\r\n\r\n"
     "<html>\n"
@@ -84,12 +84,12 @@ static const char* not_found_response_te
     "</body>\n"
     "</html>\n";
 
-static const char* not_found_response_template_raw =
+static const char *not_found_response_template_raw =
     "HTTP/1.0 404 Not Found\r\n"
     "Content-type: text/plain\r\n\r\n"
     "Not Found";
 
-static const char* not_found_response_valid =
+static const char *not_found_response_valid =
     "HTTP/1.0 404 Not Valid\r\n"
     "Content-type: text/html\r\n\r\n"
     "<html>\n"
@@ -99,12 +99,12 @@ static const char* not_found_response_va
     "</body>\n"
     "</html>\n";
 
-static const char* not_found_response_valid_raw =
+static const char *not_found_response_valid_raw =
     "HTTP/1.0 404 Not Valid\r\n"
     "Content-type: text/plain\r\n\r\n"
     "The requested URL is not valid.";
 
-static const char* not_valid_syntax =
+static const char *not_valid_syntax =
     "HTTP/1.0 404 Not Valid Syntax\r\n"
     "Content-type: text/html\r\n\r\n"
     "<html>\n"
@@ -113,48 +113,48 @@ static const char* not_valid_syntax =
     "</body>\n"
     "</html>\n";
 
-static const char* not_valid_syntax_raw =
+static const char *not_valid_syntax_raw =
     "HTTP/1.0 404 Not Valid Syntax\r\n"
     "Content-type: text/plain\r\n\r\n"
     "Not Valid Syntax\n";
 
-static const char* not_track =
+static const char *not_track =
     "HTTP/1.0 200 OK\r\n"
     "Content-type: text/html\r\n\r\n"
     "<html>\n"
     "<body>\n"
     "<h1>Tracking Not Enabled</h1>\n";
 
-static const char* not_track_raw =
+static const char *not_track_raw =
     "HTTP/1.0 200 OK\r\n"
     "Content-type: text/plain\r\n\r\n"
     "Tracking Not Enabled";
 
-static const char* track_error =
+static const char *track_error =
     "HTTP/1.0 200 OK\r\n"
     "Content-type: text/html\r\n\r\n"
     "<html>\n"
     "<body>\n"
     "<h1>Track Error</h1>\n";
 
-static const char* track_error_raw =
+static const char *track_error_raw =
     "HTTP/1.0 200 OK\r\n"
     "Content-type: text/plain\r\n\r\n"
     "Track Error";
 
-static const char* error_value =
+static const char *error_value =
     "HTTP/1.0 200 OK\r\n"
     "Content-type: text/html\r\n\r\n"
     "<html>\n"
     "<body>\n"
     "<h1>Value Error</h1>\n";
 
-static const char* error_value_raw =
+static const char *error_value_raw =
     "HTTP/1.0 200 OK\r\n"
     "Content-type: text/plain\r\n\r\n"
     "Value Error";
-    
-static const char* not_found_response_valid_command =
+
+static const char *not_found_response_valid_command =
     "HTTP/1.0 404 Not Valid Command\r\n"
     "Content-type: text/html\r\n\r\n"
     "<html>\n"
@@ -164,12 +164,12 @@ static const char* not_found_response_va
     "</body>\n"
     "</html>\n";
 
-static const char* not_found_response_valid_command_raw =
+static const char *not_found_response_valid_command_raw =
     "HTTP/1.0 404 Not Valid Command\r\n"
     "Content-type: text/plain\n\n"
     "Not Valid Command\n";
 
-static const char* bad_method_response_template =
+static const char *bad_method_response_template =
     "HTTP/1.0 501 Method Not Implemented\r\n"
     "Content-type: text/html\r\n\r\n"
     "<html>\n"
@@ -179,7 +179,7 @@ static const char* bad_method_response_t
     "</body>\n"
     "</html>\n";
 
-static const char* bad_method_response_template_raw =
+static const char *bad_method_response_template_raw =
     "HTTP/1.0 501 Method Not Implemented\r\n"
     "Content-type: text/plain\r\n\r\n"
     "Method Not Implemented\n";
@@ -188,54 +188,134 @@ static const char *request_auth_response
     "HTTP/1.0 401 Authorization Required\r\n"
     "WWW-Authenticate: Basic realm=\"Motion Security Access\"\r\n";
 
-static void send_template_ini_client(int client_socket, const char* template)
+/**
+ * write_nonblock
+ */
+static ssize_t write_nonblock(int fd, const void *buf, size_t size)
+{
+    ssize_t nwrite = -1;
+    struct timeval tm;
+    fd_set fds;
+
+    tm.tv_sec = 1; /* Timeout in seconds */
+    tm.tv_usec = 0;
+    FD_ZERO(&fds);
+    FD_SET(fd, &fds);
+
+    if (select(fd + 1, NULL, &fds, NULL, &tm) > 0) {
+        if (FD_ISSET(fd, &fds)) {
+            if ((nwrite = write(fd , buf, size)) < 0) {
+                if (errno != EWOULDBLOCK)
+                    return -1;
+            }
+        }
+    }
+
+    return nwrite;
+}
+
+/**
+ * read_nonblock
+ */
+static ssize_t read_nonblock(int fd ,void *buf, ssize_t size)
+{
+    ssize_t nread = -1;
+    struct timeval tm;
+    fd_set fds;
+
+    tm.tv_sec = 1; /* Timeout in seconds */
+    tm.tv_usec = 0;
+    FD_ZERO(&fds);
+    FD_SET(fd, &fds);
+
+    if (select(fd + 1, &fds, NULL, NULL, &tm) > 0) {
+        if (FD_ISSET(fd, &fds)) {
+            if ((nread = read(fd , buf, size)) < 0) {
+                if (errno != EWOULDBLOCK)
+                    return -1;
+            }
+        }
+    }
+
+    return nread;
+}
+
+/**
+ * send_template_ini_client
+ */
+static void send_template_ini_client(int client_socket, const char *template)
 {
     ssize_t nwrite = 0;
-    nwrite = write(client_socket, ok_response, strlen (ok_response));
-    nwrite += write(client_socket, template, strlen(template));
+    nwrite = write_nonblock(client_socket, ok_response, strlen(ok_response));
+    nwrite += write_nonblock(client_socket, template, strlen(template));
     if (nwrite != (ssize_t)(strlen(ok_response) + strlen(template)))
-        motion_log(LOG_ERR, 1, "httpd send_template_ini_client");
+        MOTION_LOG(ERR, TYPE_STREAM, SHOW_ERRNO, "%s: failure write");
 }
 
+/**
+ * send_template_ini_client_raw
+ */
 static void send_template_ini_client_raw(int client_socket)
 {
     ssize_t nwrite = 0;
-    nwrite = write(client_socket, ok_response_raw, strlen (ok_response_raw));
+    nwrite = write_nonblock(client_socket, ok_response_raw, strlen(ok_response_raw));
     if (nwrite != (ssize_t)strlen(ok_response_raw))
-        motion_log(LOG_ERR, 1, "httpd send_template_ini_client_raw");
+        MOTION_LOG(ERR, TYPE_STREAM, SHOW_ERRNO, "%s: failure write");
 }
 
+/**
+ * send_template
+ */
 static void send_template(int client_socket, char *res)
 {
     ssize_t nwrite = 0;
-    nwrite = write(client_socket, res, strlen(res));
+    nwrite = write_nonblock(client_socket, res, strlen(res));
     if (nwrite != (ssize_t)strlen(res))
-        motion_log(LOG_ERR, 1, "httpd send_template failure write");
+        MOTION_LOG(ERR, TYPE_STREAM, SHOW_ERRNO, "%s: failure write");
 }
 
+/**
+ * send_template_raw
+ */
 static void send_template_raw(int client_socket, char *res)
 {
     ssize_t nwrite = 0;
-    nwrite = write(client_socket, res, strlen(res));
+    nwrite = write_nonblock(client_socket, res, strlen(res));
+    if (nwrite < 0)
+        MOTION_LOG(DBG, TYPE_STREAM, SHOW_ERRNO, "%s: write_nonblock returned value less than zero.");
 }
 
+/**
+ * send_template_end_client
+ */
 static void send_template_end_client(int client_socket)
 {
     ssize_t nwrite = 0;
-    nwrite = write(client_socket, end_template, strlen(end_template));
+    nwrite = write_nonblock(client_socket, end_template, strlen(end_template));
+    if (nwrite < 0)
+        MOTION_LOG(DBG, TYPE_STREAM, SHOW_ERRNO, "%s: write_nonblock returned value less than zero.");
+
 }
 
-static void response_client(int client_socket, const char* template, char *back)
+/**
+ * response_client
+ */
+static void response_client(int client_socket, const char *template, char *back)
 {
     ssize_t nwrite = 0;
-    nwrite = write(client_socket, template, strlen(template));
+    nwrite = write_nonblock(client_socket, template, strlen(template));
     if (back != NULL) {
         send_template(client_socket, back);
         send_template_end_client(client_socket);
     }
-}
+    if (nwrite < 0)
+        MOTION_LOG(DBG, TYPE_STREAM, SHOW_ERRNO, "%s: write_nonblock returned value less than zero.");
 
+}
 
+/**
+ * replace
+ */
 static char *replace(const char *str, const char *old, const char *new)
 {
     char *ret, *r;
@@ -248,11 +328,10 @@ static char *replace(const char *str, co
             count++;
         /* this is undefined if p - str > PTRDIFF_MAX */
         retlen = p - str + strlen(p) + count * (newlen - oldlen);
-    } else {
+    } else
         retlen = strlen(str);
-    }
 
-    ret = malloc(retlen + 1);
+    ret = mymalloc(retlen + 1);
 
     for (r = ret, p = str; (q = strstr(p, old)) != NULL; p = q + oldlen) {
         /* this is undefined if q - p > PTRDIFF_MAX */
@@ -265,16 +344,18 @@ static char *replace(const char *str, co
     strcpy(r, p);
 
     return ret;
-} 
-
-/*
-   This function decode the values from GET request following the http RFC.
-*/
+}
 
+/**
+ * url_decode
+ *      This function decode the values from GET request following the http RFC.
+ *
+ * Returns nothing.
+ */
 static void url_decode(char *urlencoded, size_t length)
 {
-    char *data=urlencoded;
-    char *urldecoded=urlencoded;
+    char *data = urlencoded;
+    char *urldecoded = urlencoded;
 
     while (length > 0) {
         if (*data == '%') {
@@ -286,19 +367,23 @@ static void url_decode(char *urlencoded,
             length--;
             c[1] = *data;
             c[2] = 0;
+
             warningkill = sscanf(c, "%x", &i);
-            if (i < 128)
+
+            if (i < 128) {
                 *urldecoded++ = (char)i;
-            else {
+            } else {
                 *urldecoded++ = '%';
                 *urldecoded++ = c[0];
                 *urldecoded++ = c[1];
             }
-        } else if (*data=='+') {
-            *urldecoded++=' ';
+
+	} else if (*data == '<' || *data == '+' || *data == '>') {
+	  *urldecoded++ = ' ';
         } else {
-            *urldecoded++=*data;
+            *urldecoded++ = *data;
         }
+
         data++;
         length--;
     }
@@ -306,61 +391,62 @@ static void url_decode(char *urlencoded,
 }
 
 
-/*
-    This function manages/parses the config action for motion ( set , get , write , list ).
-
-    return 1 to exit from function.
-*/
-
-static unsigned short int config(char *pointer, char *res, unsigned short int length_uri, 
-                unsigned short int thread, int client_socket, void *userdata)
+/**
+ * config
+ *      Manages/parses the config action for motion ( set , get , write , list ).
+ *
+ *   Returns 1 to exit from function.
+ */
+static unsigned int config(char *pointer, char *res, unsigned int length_uri,
+                                 unsigned int thread, int client_socket, void *userdata)
 {
-    char question = '\0';
+    char question='\0';
     char command[256] = {'\0'};
-    unsigned short int i;
+    unsigned int i;
     struct context **cnt = userdata;
 
-    warningkill = sscanf (pointer, "%255[a-z]%c", command , &question);
-    if (!strcmp(command,"list")) {
+    warningkill = sscanf(pointer, "%255[a-z]%c", command , &question);
+    if (!strcmp(command, "list")) {
         pointer = pointer + 4;
         length_uri = length_uri - 4;
         if (length_uri == 0) {
             const char *value = NULL;
             char *retval = NULL;
             /*call list*/
-            if (cnt[0]->conf.control_html_output) {
+            if (cnt[0]->conf.webcontrol_html_output) {
                 send_template_ini_client(client_socket, ini_template);
-                sprintf(res, "<a href=/%hu/config>&lt;&ndash; back</a><br><br>\n<b>Thread %hu</b>\n<ul>", thread, thread);
+                sprintf(res, "<a href=/%hu/config>&lt;&ndash; back</a><br><br>\n<b>Thread %hu</b>\n<ul>",
+                        thread, thread);
                 send_template(client_socket, res);
 
-                for (i = 0; config_params[i].param_name != NULL; i++) {
+                for (i=0; config_params[i].param_name != NULL; i++) {
 
-                    if ((thread != 0) && (config_params[i].main_thread)) 
+                    if ((thread != 0) && (config_params[i].main_thread))
                         continue;
 
                     value = config_params[i].print(cnt, NULL, i, thread);
 
                     if (value == NULL) {
-                        retval=NULL;
-                    
-                        /* Only get the thread value for main thread */ 
+                        retval = NULL;
+
+                        /* Only get the thread value for main thread */
                         if (thread == 0)
                             config_params[i].print(cnt, &retval, i, thread);
-                    
+
                         /* thread value*/
-                        
+
                         if (retval) {
-                            
+
                             if (!strcmp(retval,"")) {
                                 free(retval);
-                                retval = strdup("No threads");
+                                retval = mystrdup("No threads");
                             } else {
-                                char *temp=retval;
+                                char *temp = retval;
                                 size_t retval_miss = 0;
                                 size_t retval_len = strlen(retval);
-                                unsigned short int ind=0;
-                                char thread_strings[1024]={'\0'};
-                                
+                                unsigned int ind = 0;
+                                char thread_strings[1024] = {'\0'};
+
                                 while (retval_miss != retval_len) {
                                     while (*temp != '\n') {
                                         thread_strings[ind++] = *temp;
@@ -376,16 +462,16 @@ static unsigned short int config(char *p
                                 }
                                 free(retval);
                                 retval = NULL;
-                                retval = strdup(thread_strings);
+                                retval = mystrdup(thread_strings);
                             }
-                            
+
                             sprintf(res, "<li><a href=/%hu/config/set?%s>%s</a> = %s</li>\n", thread,
                                     config_params[i].param_name, config_params[i].param_name, retval);
                             free(retval);
                         } else if (thread != 0) {
                             /* get the value from main thread for the rest of threads */
                             value = config_params[i].print(cnt, NULL, i, 0);
-                            
+
                             sprintf(res, "<li><a href=/%hu/config/set?%s>%s</a> = %s</li>\n", thread,
                                     config_params[i].param_name, config_params[i].param_name,
                                     value ? value : "(not defined)");
@@ -394,35 +480,35 @@ static unsigned short int config(char *p
                                     config_params[i].param_name, config_params[i].param_name,
                                     "(not defined)");
                         }
-                        
+
                     } else {
-                        sprintf(res, "<li><a href=/%hu/config/set?%s>%s</a> = %s</li>\n",thread,
+                        sprintf(res, "<li><a href=/%hu/config/set?%s>%s</a> = %s</li>\n", thread,
                                 config_params[i].param_name, config_params[i].param_name, value);
                     }
                     send_template(client_socket, res);
                 }
 
-                sprintf(res, "</ul><a href=/%hu/config>&lt;&ndash; back</a>",thread);
+                sprintf(res, "</ul><a href=/%hu/config>&lt;&ndash; back</a>", thread);
                 send_template(client_socket, res);
                 send_template_end_client(client_socket);
             } else {
                 send_template_ini_client_raw(client_socket);
                 for (i=0; config_params[i].param_name != NULL; i++) {
-                    value=config_params[i].print(cnt, NULL, i, thread);
+                    value = config_params[i].print(cnt, NULL, i, thread);
                     if (value == NULL)
-                        value=config_params[i].print(cnt, NULL, i, 0);
+                        value = config_params[i].print(cnt, NULL, i, 0);
                     sprintf(res, "%s = %s\n", config_params[i].param_name, value);
                     send_template_raw(client_socket, res);
                 }
             }
         } else {
             /*error*/
-            if (cnt[0]->conf.control_html_output)
+            if (cnt[0]->conf.webcontrol_html_output)
                 response_client(client_socket, not_found_response_valid_command, NULL);
             else
                 response_client(client_socket, not_found_response_valid_command_raw, NULL);
         }
-    } else if (!strcmp(command,"set")) {
+    } else if (!strcmp(command, "set")) {
         /* set?param_name=value */
         pointer = pointer + 3;
         length_uri = length_uri - 3;
@@ -431,13 +517,13 @@ static unsigned short int config(char *p
             length_uri--;
             warningkill = sscanf(pointer,"%255[-0-9a-z_]%c", command, &question);
             /*check command , question == '='  length_uri too*/
-            if ((question == '=') && (command[0]!='\0')) {
+            if ((question == '=') && (command[0] != '\0')) {
                 length_uri = length_uri - strlen(command) - 1;
                 pointer = pointer + strlen(command) + 1;
                 /* check if command exists and type of command and not end of URI */
-                i = 0;
+                i=0;
                 while (config_params[i].param_name != NULL) {
-                    if ((thread != 0) && (config_params[i].main_thread)){
+                    if ((thread != 0) && (config_params[i].main_thread)) {
                         i++;
                         continue;
                     }
@@ -449,24 +535,24 @@ static unsigned short int config(char *p
 
                 if (config_params[i].param_name) {
                     if (length_uri > 0) {
-                        char Value[1024]={'\0'};
+                        char Value[1024] = {'\0'};
                         warningkill = sscanf(pointer,"%1023s", Value);
                         length_uri = length_uri - strlen(Value);
-                        if ((length_uri == 0) && (strlen(Value) > 0) ) {
+                        if ((length_uri == 0) && (strlen(Value) > 0)) {
                             /* FIXME need to assure that is a valid value */
-                            url_decode(Value,strlen(Value));
+                            url_decode(Value, strlen(Value));
                             conf_cmdparse(cnt + thread, config_params[i].param_name, Value);
-                            if (cnt[0]->conf.control_html_output) {
+                            if (cnt[0]->conf.webcontrol_html_output) {
                                 sprintf(res,
                                     "<a href=/%hu/config/list>&lt;&ndash; back</a>"
                                     "<br><br>\n<b>Thread %hu</b>\n"
                                     "<ul><li><a href=/%hu/config/set?%s>%s</a> = %s"
                                     "</li></ul><b>Done</b>",
-                                        thread, thread, thread,config_params[i].param_name,
+                                        thread, thread, thread, config_params[i].param_name,
                                         config_params[i].param_name, Value);
-                                
+
                                 send_template_ini_client(client_socket, ini_template);
-                                send_template(client_socket,res);
+                                send_template(client_socket, res);
                                 send_template_end_client(client_socket);
                             } else {
                                 send_template_ini_client_raw(client_socket);
@@ -475,50 +561,46 @@ static unsigned short int config(char *p
                             }
                         } else {
                             /*error*/
-                            if (cnt[0]->conf.control_html_output)
+                            if (cnt[0]->conf.webcontrol_html_output)
                                 response_client(client_socket, not_valid_syntax, NULL);
                             else
                                 response_client(client_socket, not_valid_syntax_raw, NULL);
                         }
                     } else {
                         char *type = NULL;
-                        type = strdup(config_type(&config_params[i]));
+                        type = mystrdup(config_type(&config_params[i]));
 
-                        if (!strcmp(type,"string")) {
+                        if (!strcmp(type, "string")) {
                             char *value = NULL;
                             conf_cmdparse(cnt+thread, config_params[i].param_name, value);
                             free(type);
-                            type = strdup("(null)");
-                        } else if (!strcmp(type,"int")) {
-                            free(type);
-                            type = strdup("0");
-                            conf_cmdparse(cnt+thread, config_params[i].param_name, type);
-                        } else if (!strcmp(type,"short")) {
+                            type = mystrdup("(null)");
+                        } else if (!strcmp(type, "int")) {
                             free(type);
-                            type = strdup("0");
+                            type = mystrdup("0");
                             conf_cmdparse(cnt+thread, config_params[i].param_name, type);
-                        } else if (!strcmp(type,"bool")) {
+                        } else if (!strcmp(type, "bool")) {
                             free(type);
-                            type = strdup("off");
+                            type = mystrdup("off");
                             conf_cmdparse(cnt+thread, config_params[i].param_name, type);
                         } else {
                             free(type);
-                            type = strdup("unknown");
+                            type = mystrdup("unknown");
                         }
 
-                        if (cnt[0]->conf.control_html_output) {
+                        if (cnt[0]->conf.webcontrol_html_output) {
                             sprintf(res,
                                 "<a href=/%hu/config/list>&lt;&ndash; back</a><br><br>\n"
-                                    "<b>Thread %hu</b>\n<ul><li><a href=/%hu/config/set?%s>%s</a>" 
-                                    "= %s</li></ul><br><b>Done</b>", thread, thread, thread, 
+                                    "<b>Thread %hu</b>\n<ul><li><a href=/%hu/config/set?%s>%s</a>"
+                                    "= %s</li></ul><br><b>Done</b>", thread, thread, thread,
                                     config_params[i].param_name, config_params[i].param_name, type);
-                            
+
                             send_template_ini_client(client_socket, ini_template);
                             send_template(client_socket, res);
                             send_template_end_client(client_socket);
                         } else {
                             send_template_ini_client_raw(client_socket);
-                            sprintf(res, "%s = %s\nDone\n", config_params[i].param_name,type);
+                            sprintf(res, "%s = %s\nDone\n", config_params[i].param_name, type);
                             send_template_raw(client_socket, res);
                         }
                         free(type);
@@ -526,18 +608,18 @@ static unsigned short int config(char *p
                     }
                 } else {
                     /*error*/
-                    if (cnt[0]->conf.control_html_output)
+                    if (cnt[0]->conf.webcontrol_html_output)
                         response_client(client_socket, not_found_response_valid_command, NULL);
                     else
                         response_client(client_socket, not_found_response_valid_command_raw, NULL);
                 }
             } else {
                 /* Show param_name dialogue only for html output */
-                if ((cnt[0]->conf.control_html_output) && (command[0]!='\0') &&
-                     (((length_uri = length_uri - strlen(command)) == 0 )) ) {
-                    i = 0;
+                if ((cnt[0]->conf.webcontrol_html_output) && (command[0] != '\0') &&
+                    (((length_uri = length_uri - strlen(command)) == 0))) {
+                    i=0;
                     while (config_params[i].param_name != NULL) {
-                        if ((thread != 0) && (config_params[i].main_thread)){
+                        if ((thread != 0) && (config_params[i].main_thread)) {
                             i++;
                             continue;
                         }
@@ -548,10 +630,10 @@ static unsigned short int config(char *p
                     }
                     /* param_name exists */
                     if (config_params[i].param_name) {
-                        const char *value = NULL;                            
+                        const char *value = NULL;
                         char *text_help = NULL;
                         char *sharp = NULL;
-                        
+
                         value = config_params[i].print(cnt, NULL, i, thread);
 
                         sharp = strstr(config_params[i].param_help, "#\n\n#");
@@ -560,21 +642,21 @@ static unsigned short int config(char *p
                         sharp++;
 
                         text_help = replace(sharp, "\n#", "<br>");
-                        
+
                         send_template_ini_client(client_socket, ini_template);
-                        if (!strcmp ("bool",config_type(&config_params[i])) ){
+                        if (!strcmp ("bool", config_type(&config_params[i]))) {
                             char option[80] = {'\0'};
-                    
+
                             if ((value == NULL) && (thread != 0))
                                 value = config_params[i].print(cnt, NULL, i, 0);
-                            
+
                             if (!strcmp ("on", value))
                                 sprintf(option, "<option value='on' selected>on</option>\n"
                                                 "<option value='off'>off</option>\n");
                             else
                                 sprintf(option, "<option value='on'>on</option>\n"
                                                 "<option value='off' selected>off</option>\n");
-                            
+
                             sprintf(res, "<a href=/%hu/config/list>&lt;&ndash; back</a><br><br>\n"
                                          "<b>Thread %hu</b>\n"
                                          "<form action=set?>\n"
@@ -585,50 +667,50 @@ static unsigned short int config(char *p
                                          "<a href='%s#%s' target=_blank>[help]</a>"
                                          "</form>\n<hr><i>%s</i>", thread, thread,
                                          config_params[i].param_name, config_params[i].param_name,
-                                         option, FOSWIKI_URL,config_params[i].param_name, text_help);
+                                         option, TWIKI_URL, config_params[i].param_name, text_help);
                         } else {
-        
-                            if (value == NULL){
+
+                            if (value == NULL) {
                                 if (thread != 0)
                                     /* get the value from main thread for the rest of threads */
-                                                                value = config_params[i].print(cnt, NULL, i, 0); 
+                                                                value = config_params[i].print(cnt, NULL, i, 0);
                                 if (value == NULL) value = "";
                             }
                             sprintf(res, "<a href=/%hu/config/list>&lt;&ndash; back</a><br><br>\n"
                                          "<b>Thread %hu</b>\n<form action=set?>\n"
-                                         "<b>%s</b>&nbsp;<input type=text name='%s' value='%s' size=50>\n"
+                                         "<b>%s</b>&nbsp;<input type=text name='%s' value='%s' size=80>\n"
                                          "<input type='submit' value='set'>\n"
                                          "&nbsp;&nbsp;&nbsp;&nbsp;"
                                          "<a href='%s#%s' target=_blank>[help]</a>"
                                          "</form>\n<hr><i>%s</i>", thread, thread,
                                          config_params[i].param_name, config_params[i].param_name,
-                                         value, FOSWIKI_URL, config_params[i].param_name, text_help);
+                                         value, TWIKI_URL, config_params[i].param_name, text_help);
                         }
 
                         send_template(client_socket, res);
                         send_template_end_client(client_socket);
                         free(text_help);
                     } else {
-                        if (cnt[0]->conf.control_html_output)
+                        if (cnt[0]->conf.webcontrol_html_output)
                             response_client(client_socket, not_found_response_valid_command, NULL);
                         else
                             response_client(client_socket, not_found_response_valid_command_raw, NULL);
                     }
                 } else {
-                    if (cnt[0]->conf.control_html_output)
+                    if (cnt[0]->conf.webcontrol_html_output)
                         response_client(client_socket, not_found_response_valid_command, NULL);
                     else
                         response_client(client_socket, not_found_response_valid_command_raw, NULL);
                 }
             }
         } else if (length_uri == 0) {
-            if (cnt[0]->conf.control_html_output) {
+            if (cnt[0]->conf.webcontrol_html_output) {
                 send_template_ini_client(client_socket, set_template);
                 sprintf(res, "<a href=/%hu/config>&lt;&ndash; back</a><br><br>\n<b>Thread %hu</b>\n"
-                             "<form name='n'>\n<select name='onames'>\n", thread, thread );
+                             "<form name='n'>\n<select name='onames'>\n", thread, thread);
 
                 send_template(client_socket, res);
-                for (i = 0; config_params[i].param_name != NULL; i++) {
+                for (i=0; config_params[i].param_name != NULL; i++) {
                     if ((thread != 0) && (config_params[i].main_thread))
                         continue;
                     sprintf(res, "<option value='%s'>%s</option>\n",
@@ -650,12 +732,12 @@ static unsigned short int config(char *p
             }
         } else {
             /*error*/
-            if (cnt[0]->conf.control_html_output)
+            if (cnt[0]->conf.webcontrol_html_output)
                 response_client(client_socket, not_found_response_valid_command, NULL);
             else
                 response_client(client_socket, not_found_response_valid_command_raw, NULL);
         }
-    } else if (!strcmp(command,"get")) {
+    } else if (!strcmp(command, "get")) {
         /* get?query=param_name */
         pointer = pointer + 3;
         length_uri = length_uri - 3;
@@ -666,18 +748,18 @@ static unsigned short int config(char *p
             length_uri--;
             warningkill = sscanf(pointer,"%255[-0-9a-z]%c", command, &question);
 
-            if ((question == '=') && (!strcmp(command,"query")) ) {
+            if ((question == '=') && (!strcmp(command, "query"))) {
                 pointer = pointer + 6;
                 length_uri = length_uri - 6;
                 warningkill = sscanf(pointer, "%255[-0-9a-z_]", command);
                 /*check if command exist, length_uri too*/
-                length_uri = length_uri-strlen(command);
+                length_uri = length_uri - strlen(command);
 
                 if (length_uri == 0) {
                     const char *value = NULL;
                     i = 0;
                     while (config_params[i].param_name != NULL) {
-                        if ((thread != 0) && (config_params[i].main_thread)){
+                        if ((thread != 0) && (config_params[i].main_thread)) {
                             i++;
                             continue;
                         }
@@ -686,15 +768,16 @@ static unsigned short int config(char *p
                             break;
                         i++;
                     }
-                    /* FIXME bool values or commented values maybe that should be
-                    solved with config_type */
-
+                    /*
+                     * FIXME bool values or commented values maybe that should be
+                     * solved with config_type
+                     */
                     if (config_params[i].param_name) {
-                        const char *type=NULL;
+                        const char *type = NULL;
                         type = config_type(&config_params[i]);
-                        if (!strcmp(type,"unknown")) {
-                            /*error doesn't exists this param_name */
-                            if (cnt[0]->conf.control_html_output)
+                        if (!strcmp(type, "unknown")) {
+                            /* error doesn't exists this param_name */
+                            if (cnt[0]->conf.webcontrol_html_output)
                                 response_client(client_socket, not_found_response_valid_command, NULL);
                             else
                                 response_client(client_socket, not_found_response_valid_command_raw, NULL);
@@ -713,16 +796,15 @@ static unsigned short int config(char *p
                             text_help = replace(sharp, "\n#", "<br>");
 
                             if (value == NULL)
-                                value=config_params[i].print(cnt, NULL, i, 0);
-
-                            if (cnt[0]->conf.control_html_output) {
-                                send_template_ini_client(client_socket,ini_template);
+                                value = config_params[i].print(cnt, NULL, i, 0);
+                            if (cnt[0]->conf.webcontrol_html_output) {
+                                send_template_ini_client(client_socket, ini_template);
                                 sprintf(res, "<a href=/%hu/config/get>&lt;&ndash; back</a><br><br>\n"
                                              "<b>Thread %hu</b><br>\n<ul><li>%s = %s &nbsp;&nbsp;"
                                              "&nbsp;&nbsp;<a href='%s#%s' target=_blank>"
-                                             "[help]</a></li></ul><hr><i>%s</i>", 
-                                             thread, thread, config_params[i].param_name, value, 
-                                             FOSWIKI_URL, config_params[i].param_name, text_help);
+                                             "[help]</a></li></ul><hr><i>%s</i>",
+                                             thread, thread, config_params[i].param_name, value,
+                                             TWIKI_URL, config_params[i].param_name, text_help);
 
                                 send_template(client_socket, res);
                                 send_template_end_client(client_socket);
@@ -730,41 +812,39 @@ static unsigned short int config(char *p
                                 free(text_help);
                             } else {
                                 send_template_ini_client_raw(client_socket);
-                                sprintf(res, "%s = %s\nDone\n", config_params[i].param_name,value);
+                                sprintf(res, "%s = %s\nDone\n", config_params[i].param_name, value);
                                 send_template_raw(client_socket, res);
                             }
                         }
                     } else {
-                        /*error*/
-                        if (cnt[0]->conf.control_html_output)
+                        /* error */
+                        if (cnt[0]->conf.webcontrol_html_output)
                             response_client(client_socket, not_found_response_valid_command, NULL);
                         else
                             response_client(client_socket, not_found_response_valid_command_raw, NULL);
                     }
                 } else {
-                    /*error*/
-                    if (cnt[0]->conf.control_html_output)
+                    /* error */
+                    if (cnt[0]->conf.webcontrol_html_output)
                         response_client(client_socket, not_found_response_valid_command, NULL);
                     else
                         response_client(client_socket, not_found_response_valid_command_raw, NULL);
                 }
             }
         } else if (length_uri == 0) {
-            if (cnt[0]->conf.control_html_output) {
+            if (cnt[0]->conf.webcontrol_html_output) {
                 send_template_ini_client(client_socket, ini_template);
-                sprintf(res, "<a href=/%hu/config>&lt;&ndash; back</a><br><br>\n<b>Thread %hu</b><br>\n"    
+                sprintf(res, "<a href=/%hu/config>&lt;&ndash; back</a><br><br>\n<b>Thread %hu</b><br>\n"
                              "<form action=get>\n"
                              "<select name='query'>\n", thread, thread);
                 send_template(client_socket, res);
-                
-                for (i = 0; config_params[i].param_name != NULL; i++) {
+                for (i=0; config_params[i].param_name != NULL; i++) {
                     if ((thread != 0) && (config_params[i].main_thread))
                         continue;
                     sprintf(res, "<option value='%s'>%s</option>\n",
                             config_params[i].param_name, config_params[i].param_name);
                     send_template(client_socket, res);
                 }
-
                 sprintf(res, "</select>\n"
                              "<input type='submit' value='get'>\n"
                              "</form>\n");
@@ -776,17 +856,17 @@ static unsigned short int config(char *p
                 send_template_raw(client_socket, res);
             }
         } else {
-            /*error*/
-            if (cnt[0]->conf.control_html_output)
+            /* error */
+            if (cnt[0]->conf.webcontrol_html_output)
                 response_client(client_socket, not_valid_syntax, NULL);
             else
                 response_client(client_socket, not_valid_syntax_raw, NULL);
         }
-    } else if (!strcmp(command,"write")) {
+    } else if (!strcmp(command, "write")) {
             pointer = pointer + 5;
             length_uri = length_uri - 5;
             if (length_uri == 0) {
-                if (cnt[0]->conf.control_html_output) {
+                if (cnt[0]->conf.webcontrol_html_output) {
                     send_template_ini_client(client_socket, ini_template);
                     sprintf(res, "<a href=/%hu/config>&lt;&ndash; back</a><br><br>"
                                  "Are you sure? <a href=/%hu/config/writeyes>Yes</a>\n", thread, thread);
@@ -799,8 +879,8 @@ static unsigned short int config(char *p
                     send_template_raw(client_socket, res);
                 }
             } else {
-                /*error*/
-                if (cnt[0]->conf.control_html_output)
+                /* error */
+                if (cnt[0]->conf.webcontrol_html_output)
                     response_client(client_socket, not_found_response_valid_command, NULL);
                 else
                     response_client(client_socket, not_found_response_valid_command_raw, NULL);
@@ -811,7 +891,7 @@ static unsigned short int config(char *p
         length_uri = length_uri - 8;
         if (length_uri == 0) {
             conf_print(cnt);
-            if (cnt[0]->conf.control_html_output) {
+            if (cnt[0]->conf.webcontrol_html_output) {
                 send_template_ini_client(client_socket, ini_template);
                 sprintf(res, "<a href=/%hu/config>&lt;&ndash; back</a><br><br>\n<b>Thread %hu</b>  write done !\n",
                              thread, thread);
@@ -823,16 +903,16 @@ static unsigned short int config(char *p
                 send_template_raw(client_socket, res);
             }
         } else {
-            /*error*/
-            if (cnt[0]->conf.control_html_output) {
+            /* error */
+            if (cnt[0]->conf.webcontrol_html_output) {
                 response_client(client_socket, not_found_response_valid_command, NULL);
-            } else {
+            }
+            else
                 response_client(client_socket, not_found_response_valid_command_raw, NULL);
-            }    
         }
     } else {
-        /*error*/
-        if (cnt[0]->conf.control_html_output)
+        /* error */
+        if (cnt[0]->conf.webcontrol_html_output)
             response_client(client_socket, not_found_response_valid_command, NULL);
         else
             response_client(client_socket, not_found_response_valid_command_raw, NULL);
@@ -842,27 +922,28 @@ static unsigned short int config(char *p
 }
 
 
-/*
-    This function manages/parses the actions for motion ( makemovie , snapshot , restart , quit ).
-
-    return 0 for restart & quit
-    return 1 for makemovie & snaphost
-*/
-
-static unsigned short int action(char *pointer, char *res, unsigned short int length_uri, 
-                unsigned short int thread, int client_socket, void *userdata)
+/**
+ * action
+ *      manages/parses the actions for motion ( makemovie , snapshot , restart , quit ).
+ *
+ * Returns
+ *      0 for restart & quit
+ *      1 for makemovie & snaphost
+ */
+static unsigned int action(char *pointer, char *res, unsigned int length_uri,
+                                 unsigned int thread, int client_socket, void *userdata)
 {
     /* parse action commands */
     char command[256] = {'\0'};
     struct context **cnt = userdata;
-    unsigned short int i = 0;
+    unsigned int i = 0;
 
-    warningkill = sscanf (pointer, "%255[a-z]" , command);
-    if (!strcmp(command,"makemovie")) {
+    warningkill = sscanf(pointer, "%255[a-z]" , command);
+    if (!strcmp(command, "makemovie")) {
         pointer = pointer + 9;
         length_uri = length_uri - 9;
         if (length_uri == 0) {
-            /*call makemovie*/
+            /* call makemovie */
 
             if (thread == 0) {
                 while (cnt[++i])
@@ -871,7 +952,7 @@ static unsigned short int action(char *p
                 cnt[thread]->makemovie = 1;
             }
 
-            if (cnt[0]->conf.control_html_output) {
+            if (cnt[0]->conf.webcontrol_html_output) {
                 send_template_ini_client(client_socket, ini_template);
                 sprintf(res, "<a href=/%hu/action>&lt;&ndash; back</a><br><br>\n"
                              "makemovie for thread %hu done<br>\n", thread, thread);
@@ -883,27 +964,27 @@ static unsigned short int action(char *p
                 send_template_raw(client_socket, res);
             }
         } else {
-            /*error*/
-            if (cnt[0]->conf.control_html_output)
-                response_client(client_socket,not_found_response_valid_command,NULL);
+            /* error */
+            if (cnt[0]->conf.webcontrol_html_output)
+                response_client(client_socket, not_found_response_valid_command, NULL);
             else
-                response_client(client_socket,not_found_response_valid_command_raw,NULL);
+                response_client(client_socket, not_found_response_valid_command_raw, NULL);
         }
-    } else if (!strcmp(command,"snapshot")) {
+    } else if (!strcmp(command, "snapshot")) {
         pointer = pointer + 8;
         length_uri = length_uri - 8;
         if (length_uri == 0) {
-            /*call snapshot*/
+            /* call snapshot */
 
             if (thread == 0) {
                 while (cnt[++i])
-                    cnt[i]->snapshot=1;
+                    cnt[i]->snapshot = 1;
             } else {
-                cnt[thread]->snapshot=1;
+                cnt[thread]->snapshot = 1;
             }
 
             cnt[thread]->snapshot = 1;
-            if (cnt[0]->conf.control_html_output) {
+            if (cnt[0]->conf.webcontrol_html_output) {
                 send_template_ini_client(client_socket, ini_template);
                 sprintf(res, "<a href=/%hu/action>&lt;&ndash; back</a><br><br>\n"
                              "snapshot for thread %hu done<br>\n", thread, thread);
@@ -915,8 +996,8 @@ static unsigned short int action(char *p
                 send_template_raw(client_socket, res);
             }
         } else {
-            /*error*/
-            if (cnt[0]->conf.control_html_output)
+            /* error */
+            if (cnt[0]->conf.webcontrol_html_output)
                 response_client(client_socket, not_found_response_valid_command, NULL);
             else
                 response_client(client_socket, not_found_response_valid_command_raw, NULL);
@@ -925,12 +1006,12 @@ static unsigned short int action(char *p
         pointer = pointer + 7;
         length_uri = length_uri - 7;
         if (length_uri == 0) {
-            /*call restart*/
+            /* call restart */
 
             if (thread == 0) {
-                motion_log(LOG_DEBUG, 0, "httpd restart");
+                MOTION_LOG(NTC, TYPE_STREAM, NO_ERRNO, "%s: httpd is going to restart");
                 kill(getpid(),SIGHUP);
-                if (cnt[0]->conf.control_html_output) {
+                if (cnt[0]->conf.webcontrol_html_output) {
                     send_template_ini_client(client_socket, ini_template);
                     sprintf(res, "restart in progress ... bye<br>\n<a href='/'>Home</a>");
                     send_template(client_socket, res);
@@ -942,13 +1023,14 @@ static unsigned short int action(char *p
                 }
                 return 0; // to restart
             } else {
-                motion_log(LOG_DEBUG, 0, "httpd restart thread %d", thread);
+                MOTION_LOG(NTC, TYPE_STREAM, NO_ERRNO, "%s: httpd is going to restart thread %d",
+                           thread);
                 if (cnt[thread]->running) {
-                    cnt[thread]->makemovie=1;
-                    cnt[thread]->finish=1;
+                    cnt[thread]->makemovie = 1;
+                    cnt[thread]->finish = 1;
                 }
-                cnt[thread]->restart=1;
-                if (cnt[0]->conf.control_html_output) {
+                cnt[thread]->restart = 1;
+                if (cnt[0]->conf.webcontrol_html_output) {
                     send_template_ini_client(client_socket, ini_template);
                     sprintf(res, "<a href=/%hu/action>&lt;&ndash; back</a><br><br>\n"
                                  "restart for thread %hu done<br>\n", thread, thread);
@@ -961,21 +1043,21 @@ static unsigned short int action(char *p
                 }
             }
         } else {
-            if (cnt[0]->conf.control_html_output)
-                response_client(client_socket,not_found_response_valid_command,NULL);
+            if (cnt[0]->conf.webcontrol_html_output)
+                response_client(client_socket, not_found_response_valid_command, NULL);
             else
-                response_client(client_socket,not_found_response_valid_command_raw,NULL);
+                response_client(client_socket, not_found_response_valid_command_raw, NULL);
         }
-    } else if (!strcmp(command,"quit")) {
+    } else if (!strcmp(command, "quit")) {
         pointer = pointer + 4;
         length_uri = length_uri - 4;
         if (length_uri == 0) {
-            /*call quit*/
+            /* call quit */
 
             if (thread == 0) {
-                motion_log(LOG_DEBUG, 0, "httpd quit");
+                MOTION_LOG(NTC, TYPE_STREAM, NO_ERRNO, "%s: httpd quits");
                 kill(getpid(),SIGQUIT);
-                if (cnt[0]->conf.control_html_output) {
+                if (cnt[0]->conf.webcontrol_html_output) {
                     send_template_ini_client(client_socket, ini_template);
                     sprintf(res, "quit in progress ... bye");
                     send_template(client_socket, res);
@@ -986,14 +1068,14 @@ static unsigned short int action(char *p
                     send_template_raw(client_socket, res);
                 }
                 return 0; // to quit
-
             } else {
-                motion_log(LOG_DEBUG, 0, "httpd quit thread %d", thread);
-                cnt[thread]->restart=0;
-                cnt[thread]->makemovie=1;
-                cnt[thread]->finish=1;
-                cnt[thread]->watchdog=WATCHDOG_OFF;
-                if (cnt[0]->conf.control_html_output) {
+                MOTION_LOG(NTC, TYPE_STREAM, NO_ERRNO, "%s: httpd quits thread %d",
+                           thread);
+                cnt[thread]->restart = 0;
+                cnt[thread]->makemovie = 1;
+                cnt[thread]->finish = 1;
+                cnt[thread]->watchdog = WATCHDOG_OFF;
+                if (cnt[0]->conf.webcontrol_html_output) {
                     send_template_ini_client(client_socket, ini_template);
                     sprintf(res, "<a href=/%hu/action>&lt;&ndash; back</a><br><br>\n"
                                  "quit for thread %hu done<br>\n", thread, thread);
@@ -1006,14 +1088,14 @@ static unsigned short int action(char *p
                 }
             }
         } else {
-            /*error*/
-            if (cnt[0]->conf.control_html_output)
+            /* error */
+            if (cnt[0]->conf.webcontrol_html_output)
                 response_client(client_socket, not_found_response_valid_command, NULL);
             else
                 response_client(client_socket, not_found_response_valid_command_raw, NULL);
         }
     } else {
-        if (cnt[0]->conf.control_html_output)
+        if (cnt[0]->conf.webcontrol_html_output)
             response_client(client_socket, not_found_response_valid_command, NULL);
         else
             response_client(client_socket, not_found_response_valid_command_raw, NULL);
@@ -1022,42 +1104,44 @@ static unsigned short int action(char *p
     return 1;
 }
 
-/*
-   This function manages/parses the detection actions for motion ( status , start , pause ).
-
-   return 1 to exit from function.
-*/
+/**
+ * detection
+ *      manages/parses the detection actions for motion ( status , start , pause ).
+ *
+ * Returns
+ *      1 to exit from function.
+ */
 
-static unsigned short int detection(char *pointer, char *res, unsigned short int length_uri, unsigned short int thread, 
-            int client_socket, void *userdata)
+static unsigned int detection(char *pointer, char *res, unsigned int length_uri,
+                                    unsigned int thread, int client_socket, void *userdata)
 {
-    char command[256]={'\0'};
+    char command[256] = {'\0'};
     struct context **cnt = userdata;
-    unsigned short int i = 0;
+    unsigned int i = 0;
 
-    warningkill = sscanf (pointer, "%255[a-z]" , command);
-    if (!strcmp(command,"status")) {
+    warningkill = sscanf(pointer, "%255[a-z]" , command);
+    if (!strcmp(command, "status")) {
         pointer = pointer + 6;
         length_uri = length_uri - 6;
         if (length_uri == 0) {
-            /*call status*/
-            
-            if (cnt[0]->conf.control_html_output) {
+            /* call status */
+
+            if (cnt[0]->conf.webcontrol_html_output) {
                 send_template_ini_client(client_socket, ini_template);
-                sprintf(res, "<a href=/%hu/detection>&lt;&ndash; back</a><br><br><b>Thread %hu</b>" 
-                             " Detection status %s\n", thread, thread, 
+                sprintf(res, "<a href=/%hu/detection>&lt;&ndash; back</a><br><br><b>Thread %hu</b>"
+                             " Detection status %s\n", thread, thread,
                              (!cnt[thread]->running)? "NOT RUNNING": (cnt[thread]->pause)? "PAUSE":"ACTIVE");
                 send_template(client_socket, res);
                 send_template_end_client(client_socket);
             } else {
-                sprintf(res, "Thread %hu Detection status %s\n",thread, 
+                sprintf(res, "Thread %hu Detection status %s\n", thread,
                              (!cnt[thread]->running)? "NOT RUNNING": (cnt[thread]->pause)? "PAUSE":"ACTIVE");
                 send_template_ini_client_raw(client_socket);
                 send_template_raw(client_socket, res);
             }
         } else {
-            /*error*/
-            if (cnt[0]->conf.control_html_output)
+            /* error */
+            if (cnt[0]->conf.webcontrol_html_output)
                 response_client(client_socket, not_found_response_valid_command, NULL);
             else
                 response_client(client_socket, not_found_response_valid_command_raw, NULL);
@@ -1066,7 +1150,7 @@ static unsigned short int detection(char
         pointer = pointer + 5;
         length_uri = length_uri - 5;
         if (length_uri == 0) {
-            /*call start*/
+            /* call start */
 
             if (thread == 0) {
                 do {
@@ -1076,9 +1160,9 @@ static unsigned short int detection(char
                 cnt[thread]->pause = 0;
             }
 
-            if (cnt[0]->conf.control_html_output) {
-                send_template_ini_client(client_socket,ini_template);
-                sprintf(res, "<a href=/%hu/detection>&lt;&ndash; back</a><br><br>\n<b>Thread %hu</b>" 
+            if (cnt[0]->conf.webcontrol_html_output) {
+                send_template_ini_client(client_socket, ini_template);
+                sprintf(res, "<a href=/%hu/detection>&lt;&ndash; back</a><br><br>\n<b>Thread %hu</b>"
                              " Detection resumed\n", thread, thread);
                 send_template(client_socket, res);
                 send_template_end_client(client_socket);
@@ -1088,17 +1172,17 @@ static unsigned short int detection(char
                 send_template_raw(client_socket, res);
             }
         } else {
-            /*error*/
-            if (cnt[0]->conf.control_html_output)
+            /* error */
+            if (cnt[0]->conf.webcontrol_html_output)
                 response_client(client_socket, not_found_response_valid_command, NULL);
             else
                 response_client(client_socket, not_found_response_valid_command_raw, NULL);
         }
-    } else if (!strcmp(command,"pause")){
+    } else if (!strcmp(command, "pause")) {
         pointer = pointer + 5;
         length_uri = length_uri - 5;
         if (length_uri == 0) {
-            /*call pause*/
+            /* call pause */
 
             if (thread == 0) {
                 do {
@@ -1107,12 +1191,12 @@ static unsigned short int detection(char
             } else {
                 cnt[thread]->pause = 1;
             }
-            
-            if (cnt[0]->conf.control_html_output) {
+
+            if (cnt[0]->conf.webcontrol_html_output) {
                 send_template_ini_client(client_socket, ini_template);
-                sprintf(res, "<a href=/%hu/detection>&lt;&ndash; back</a><br><br>\n<b>Thread %hu</b>" 
+                sprintf(res, "<a href=/%hu/detection>&lt;&ndash; back</a><br><br>\n<b>Thread %hu</b>"
                              " Detection paused\n", thread, thread);
-                send_template(client_socket,res);
+                send_template(client_socket, res);
                 send_template_end_client(client_socket);
             } else {
                 send_template_ini_client_raw(client_socket);
@@ -1120,62 +1204,62 @@ static unsigned short int detection(char
                 send_template_raw(client_socket, res);
             }
         } else {
-            /*error*/
-            if (cnt[0]->conf.control_html_output)
+            /* error */
+            if (cnt[0]->conf.webcontrol_html_output)
                 response_client(client_socket, not_found_response_valid_command, NULL);
             else
                 response_client(client_socket, not_found_response_valid_command_raw, NULL);
         }
-    } else if (!strcmp(command,"connection")){
+    } else if (!strcmp(command, "connection")) {
         pointer = pointer + 10;
         length_uri = length_uri - 10;
+
         if (length_uri == 0) {
-            
-            /*call connection*/    
-            if (cnt[0]->conf.control_html_output) {
+            /* call connection */
+            if (cnt[0]->conf.webcontrol_html_output) {
                 send_template_ini_client(client_socket, ini_template);
                 sprintf(res, "<a href=/%hu/detection>&lt;&ndash; back</a><br><br>\n", thread);
-                send_template(client_socket,res);
+                send_template(client_socket, res);
                 if (thread == 0) {
-                    do {
-                        sprintf(res, "<b>Thread %hu</b> %s<br>\n",i, 
-                                     (!cnt[i]->running)? "NOT RUNNING" : 
+                    do{
+                        sprintf(res, "<b>Thread %hu</b> %s<br>\n", i,
+                                     (!cnt[i]->running)? "NOT RUNNING" :
                                      (cnt[i]->lost_connection)?CONNECTION_KO:CONNECTION_OK);
-                        send_template(client_socket,res);
+                        send_template(client_socket, res);
                     } while (cnt[++i]);
                 } else {
                     sprintf(res, "<b>Thread %hu</b> %s\n", thread,
-                                 (!cnt[thread]->running)? "NOT RUNNING" : 
+                                 (!cnt[thread]->running)? "NOT RUNNING" :
                                  (cnt[thread]->lost_connection)? CONNECTION_KO: CONNECTION_OK);
-                    send_template(client_socket,res);
-                }    
+                    send_template(client_socket, res);
+                }
                 send_template_end_client(client_socket);
             } else {
                 send_template_ini_client_raw(client_socket);
-                if (thread == 0){
+                if (thread == 0) {
                     do {
                         sprintf(res, "Thread %hu %s\n", i,
-                                     (!cnt[i]->running)? "NOT RUNNING" : 
+                                     (!cnt[i]->running)? "NOT RUNNING" :
                                                              (cnt[i]->lost_connection)? CONNECTION_KO: CONNECTION_OK);
                         send_template_raw(client_socket, res);
                     } while (cnt[++i]);
-                } else {        
+                } else {
                     sprintf(res, "Thread %hu %s\n", thread,
-                                 (!cnt[thread]->running)? "NOT RUNNING" : 
+                                 (!cnt[thread]->running)? "NOT RUNNING" :
                                  (cnt[thread]->lost_connection)? CONNECTION_KO: CONNECTION_OK);
                     send_template_raw(client_socket, res);
-                }    
-                
-            }    
+                }
+
+            }
         } else {
-            /*error*/
-             if (cnt[0]->conf.control_html_output)
+            /* error */
+             if (cnt[0]->conf.webcontrol_html_output)
                  response_client(client_socket, not_found_response_valid_command, NULL);
              else
                  response_client(client_socket, not_found_response_valid_command_raw, NULL);
-        }    
+        }
     } else {
-        if (cnt[0]->conf.control_html_output)
+        if (cnt[0]->conf.webcontrol_html_output)
             response_client(client_socket, not_found_response_valid_command, NULL);
         else
             response_client(client_socket, not_found_response_valid_command_raw, NULL);
@@ -1185,25 +1269,29 @@ static unsigned short int detection(char
 }
 
 
-/*
-   This function manages/parses the track action for motion ( set , pan , tilt , auto ).
-
-   return 1 to exit from function.
-*/
-
-static unsigned short int track(char *pointer, char *res, unsigned short int length_uri, unsigned short int thread, 
-            int client_socket, void *userdata)
+/**
+ * track
+ *      manages/parses the track action for motion ( set , pan , tilt , auto ).
+ *
+ * Returns
+ *      1 to exit from function.
+ */
+static unsigned int track(char *pointer, char *res, unsigned int length_uri,
+                                unsigned int thread, int client_socket, void *userdata)
 {
-    char question = '\0';
+    char question='\0';
     char command[256] = {'\0'};
     struct context **cnt = userdata;
 
     warningkill = sscanf(pointer, "%255[a-z]%c", command, &question);
     if (!strcmp(command, "set")) {
-        pointer=pointer+3;length_uri=length_uri-3;
-        /* FIXME need to check each value */
-        /* Relative movement set?pan=0&tilt=0 | set?pan=0 | set?tilt=0*/
-        /* Absolute movement set?x=0&y=0 | set?x=0 | set?y=0 */
+        pointer = pointer+3;
+        length_uri = length_uri-3;
+        /*
+         * FIXME need to check each value
+         * Relative movement set?pan=0&tilt=0 | set?pan=0 | set?tilt=0
+         * Absolute movement set?x=0&y=0 | set?x=0 | set?y=0
+         */
 
         if ((question == '?') && (length_uri > 2)) {
             char panvalue[12] = {'\0'}, tiltvalue[12] = {'\0'};
@@ -1213,16 +1301,18 @@ static unsigned short int track(char *po
 
             pointer++;
             length_uri--;
-            /* set?pan=value&tilt=value */
-            /* set?x=value&y=value */
-            /* pan= or x= | tilt= or y= */
+            /*
+             * set?pan=value&tilt=value
+             * set?x=value&y=value
+             * pan= or x= | tilt= or y=
+             */
 
-            warningkill = sscanf (pointer, "%255[a-z]%c" , command, &question);
+            warningkill = sscanf(pointer, "%255[a-z]%c" , command, &question);
 
-            if (( question != '=' ) || (command[0] == '\0')) {
+            if ((question != '=') || (command[0] == '\0')) {
                 /* no valid syntax */
-                motion_log(LOG_WARNING, 0, "httpd debug race 1");
-                if (cnt[0]->conf.control_html_output)
+                MOTION_LOG(INF, TYPE_STREAM, NO_ERRNO, "%s: httpd debug race 1");
+                if (cnt[0]->conf.webcontrol_html_output)
                     response_client(client_socket, not_valid_syntax, NULL);
                 else
                     response_client(client_socket, not_valid_syntax_raw, NULL);
@@ -1238,7 +1328,7 @@ static unsigned short int track(char *po
                 pointer = pointer + 3;
                 length_uri = length_uri - 3;
                 pan = 1;
-                if ((warningkill = sscanf(pointer, "%10[-0-9]", panvalue))){
+                if ((warningkill = sscanf(pointer, "%10[-0-9]", panvalue))) {
                     pointer = pointer + strlen(panvalue);
                     length_uri = length_uri - strlen(panvalue);
                 }
@@ -1247,7 +1337,7 @@ static unsigned short int track(char *po
                 pointer = pointer + 4;
                 length_uri = length_uri - 4;
                 tilt = 1;
-                if ((warningkill = sscanf(pointer, "%10[-0-9]", tiltvalue))){
+                if ((warningkill = sscanf(pointer, "%10[-0-9]", tiltvalue))) {
                     pointer = pointer + strlen(tiltvalue);
                     length_uri = length_uri - strlen(tiltvalue);
                 }
@@ -1256,7 +1346,7 @@ static unsigned short int track(char *po
                 pointer++;
                 length_uri--;
                 X = 1;
-                if ((warningkill = sscanf(pointer, "%10[-0-9]", x_value))){
+                if ((warningkill = sscanf(pointer, "%10[-0-9]", x_value))) {
                     pointer = pointer + strlen(x_value);
                     length_uri = length_uri - strlen(x_value);
                 }
@@ -1265,36 +1355,32 @@ static unsigned short int track(char *po
                 pointer++;
                 length_uri--;
                 Y = 1;
-                if ((warningkill = sscanf (pointer, "%10[-0-9]" , y_value))){
+                if ((warningkill = sscanf(pointer, "%10[-0-9]" , y_value))) {
                     pointer = pointer + strlen(y_value);
                     length_uri = length_uri - strlen(y_value);
                 }
             } else {
                 /* no valid syntax */
-                motion_log(LOG_WARNING, 0, "httpd debug race 2");
-                if (cnt[0]->conf.control_html_output)
+                MOTION_LOG(INF, TYPE_STREAM, NO_ERRNO, "%s: httpd debug race 2");
+                if (cnt[0]->conf.webcontrol_html_output)
                     response_client(client_socket, not_valid_syntax, NULL);
                 else
                     response_client(client_socket, not_valid_syntax_raw, NULL);
                 return 1;
             }
 
-
             /* first value check for error */
 
-            
             if (!warningkill) {
-                motion_log(LOG_WARNING, 0, "httpd debug race 3");
+                MOTION_LOG(INF, TYPE_STREAM, NO_ERRNO, "%s: httpd debug race 3");
                 /* error value */
-                if (cnt[0]->conf.control_html_output)
+                if (cnt[0]->conf.webcontrol_html_output)
                     response_client(client_socket, error_value, NULL);
                 else
                     response_client(client_socket, error_value_raw, NULL);
                 return 1;
             }
 
-            
-
             /* Only one parameter (pan= ,tilt= ,x= ,y= ) */
             if (length_uri == 0) {
                 if (pan) {
@@ -1311,11 +1397,11 @@ static unsigned short int track(char *po
                     // Add the number of frame to skip for motion detection
                     cnt[thread]->moved = track_move(pancnt, pancnt->video_dev, &cent, &pancnt->imgs, 1);
                     if (cnt[thread]->moved) {
-                        if (cnt[0]->conf.control_html_output) {
+                        if (cnt[0]->conf.webcontrol_html_output) {
                             send_template_ini_client(client_socket, ini_template);
                             sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br>"
                                          "<b>Thread %hu</b><br>\n"
-                                         "track set relative pan=%s<br>\n", 
+                                         "track set relative pan=%s<br>\n",
                                          thread, thread, panvalue);
                             send_template(client_socket, res);
                             send_template_end_client(client_socket);
@@ -1325,14 +1411,14 @@ static unsigned short int track(char *po
                             send_template_raw(client_socket, res);
                         }
                     } else {
-                    /*error in track action*/
-                        if (cnt[0]->conf.control_html_output) {
+                    /* error in track action */
+                        if (cnt[0]->conf.webcontrol_html_output) {
                             sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br>"
                                          "<b>Thread %hu</b>\n", thread, thread);
                             response_client(client_socket, track_error, res);
-                        }
-                        else
+                        } else {
                             response_client(client_socket, track_error_raw, NULL);
+                        }
                     }
                 } else if (tilt) {
                     struct coord cent;
@@ -1346,9 +1432,9 @@ static unsigned short int track(char *po
                     cent.x = 0;
                     cent.y = atoi(tiltvalue);
                     // Add the number of frame to skip for motion detection
-                    cnt[thread]->moved=track_move(tiltcnt, tiltcnt->video_dev, &cent, &tiltcnt->imgs, 1);
-                    if (cnt[thread]->moved){    
-                        if (cnt[0]->conf.control_html_output) {
+                    cnt[thread]->moved = track_move(tiltcnt, tiltcnt->video_dev, &cent, &tiltcnt->imgs, 1);
+                    if (cnt[thread]->moved) {
+                        if (cnt[0]->conf.webcontrol_html_output) {
                             send_template_ini_client(client_socket, ini_template);
                             sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br>"
                                          "<b>Thread %hu</b><br>\n"
@@ -1358,18 +1444,18 @@ static unsigned short int track(char *po
                             send_template_end_client(client_socket);
                         } else {
                             send_template_ini_client_raw(client_socket);
-                            sprintf(res, "track set relative tilt=%s\nDone\n",tiltvalue);
+                            sprintf(res, "track set relative tilt=%s\nDone\n", tiltvalue);
                             send_template_raw(client_socket, res);
                         }
                     } else {
-                        /*error in track action*/
-                        if (cnt[0]->conf.control_html_output) {
+                        /* error in track action */
+                        if (cnt[0]->conf.webcontrol_html_output) {
                             sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br>"
                                          "<b>Thread %hu</b>\n", thread, thread);
                             response_client(client_socket, track_error, res);
-                        }
-                        else
+                        } else {
                             response_client(client_socket, track_error_raw, NULL);
+                        }
                     }
                 } else if (X) {
                     /* X */
@@ -1377,7 +1463,7 @@ static unsigned short int track(char *po
                     // 1000 is out of range for pwc
                     cnt[thread]->moved = track_center(setcnt, setcnt->video_dev, 1, atoi(x_value), 1000);
                     if (cnt[thread]->moved) {
-                        if (cnt[0]->conf.control_html_output) {
+                        if (cnt[0]->conf.webcontrol_html_output) {
                             send_template_ini_client(client_socket, ini_template);
                             sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br>"
                                          "<b>Thread %hu</b><br>\n"
@@ -1391,14 +1477,14 @@ static unsigned short int track(char *po
                             send_template_raw(client_socket, res);
                         }
                     } else {
-                        /*error in track action*/
-                        if (cnt[0]->conf.control_html_output) {
+                        /* error in track action */
+                        if (cnt[0]->conf.webcontrol_html_output) {
                             sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br>"
                                          "<b>Thread %hu</b>\n", thread, thread);
                             response_client(client_socket, track_error, res);
-                        }
-                        else
+                        } else {
                             response_client(client_socket, track_error_raw, NULL);
+                        }
                     }
 
                 } else {
@@ -1407,7 +1493,7 @@ static unsigned short int track(char *po
                     // 1000 is out of range for pwc
                     cnt[thread]->moved = track_center(setcnt, setcnt->video_dev, 1, 1000, atoi(y_value));
                     if (cnt[thread]->moved) {
-                        if (cnt[0]->conf.control_html_output) {
+                        if (cnt[0]->conf.webcontrol_html_output) {
                             send_template_ini_client(client_socket, ini_template);
                             sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br>"
                                          "<b>Thread %hu</b><br>\n"
@@ -1421,105 +1507,108 @@ static unsigned short int track(char *po
                             send_template_raw(client_socket, res);
                         }
                     } else {
-                        /*error in track action*/
-                        if (cnt[0]->conf.control_html_output) {
+                        /* error in track action */
+                        if (cnt[0]->conf.webcontrol_html_output) {
                             sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br>"
                                          "<b>Thread %hu</b>\n", thread, thread);
                             response_client(client_socket, track_error, res);
                         } else {
                             response_client(client_socket, track_error_raw, NULL);
-                        }    
+                        }
                     }
                 }
                 return 1;
             }
 
-
             /* Check Second parameter */
 
-            warningkill = sscanf (pointer, "%c%255[a-z]" ,&question, command);
-            if (( question != '&' ) || (command[0] == '\0') ){
-                motion_log(LOG_WARNING, 0, "httpd debug race 4");
-                if (strstr(pointer,"&")){
-                    if (cnt[0]->conf.control_html_output)
+            warningkill = sscanf(pointer, "%c%255[a-z]" , &question, command);
+            if ((question != '&') || (command[0] == '\0')) {
+                MOTION_LOG(INF, TYPE_STREAM, NO_ERRNO, "%s: httpd debug race 4");
+                if (strstr(pointer, "&")) {
+                    if (cnt[0]->conf.webcontrol_html_output)
                         response_client(client_socket, error_value, NULL);
                     else
                         response_client(client_socket, error_value_raw, NULL);
-                } else {    /* no valid syntax */
-                    if (cnt[0]->conf.control_html_output)
+
+                /* no valid syntax */
+                } else {
+                    if (cnt[0]->conf.webcontrol_html_output)
                         response_client(client_socket, not_valid_syntax, NULL);
                     else
                         response_client(client_socket, not_valid_syntax_raw, NULL);
-                }    
+                }
                 return 1;
             }
 
             pointer++;
             length_uri--;
 
-            if (!strcmp(command, "pan")){
+            if (!strcmp(command, "pan")) {
                 pointer = pointer + 3;
                 length_uri = length_uri - 3;
-                if (pan || !tilt || X || Y ) {
-                    motion_log(LOG_WARNING, 0, "httpd debug race 5");
+                if (pan || !tilt || X || Y) {
+                    MOTION_LOG(INF, TYPE_STREAM, NO_ERRNO, "%s: httpd debug race 5");
                     /* no valid syntax */
-                    if (cnt[0]->conf.control_html_output)
+                    if (cnt[0]->conf.webcontrol_html_output)
                         response_client(client_socket, not_valid_syntax, NULL);
                     else
                         response_client(client_socket, not_valid_syntax_raw, NULL);
                     return 1;
                 }
                 pan=2;
-                warningkill = sscanf (pointer, "%c%10[-0-9]" ,&question, panvalue);
-            }
-            else if (!strcmp(command, "tilt")) {
+                warningkill = sscanf(pointer, "%c%10[-0-9]" , &question, panvalue);
+
+            } else if (!strcmp(command, "tilt")) {
                 pointer = pointer + 4;
                 length_uri = length_uri - 4;
-
                 if (tilt || !pan || X || Y) {
                     /* no valid syntax */
-                    motion_log(LOG_WARNING, 0, "httpd debug race 6");
-                    if (cnt[0]->conf.control_html_output)
+                    MOTION_LOG(INF, TYPE_STREAM, NO_ERRNO, "%s: httpd debug race 6");
+                    if (cnt[0]->conf.webcontrol_html_output)
                         response_client(client_socket, not_valid_syntax, NULL);
                     else
                         response_client(client_socket, not_valid_syntax_raw, NULL);
                     return 1;
                 }
                 tilt = 2;
-                warningkill = sscanf (pointer, "%c%10[-0-9]" ,&question, tiltvalue);
+                warningkill = sscanf(pointer, "%c%10[-0-9]" , &question, tiltvalue);
+
             } else if (!strcmp(command, "x")) {
                 pointer++;
                 length_uri--;
                 if (X || !Y || pan || tilt) {
-                    motion_log(LOG_WARNING, 0, "httpd debug race 7");
-                    
+                    MOTION_LOG(INF, TYPE_STREAM, NO_ERRNO, "%s: httpd debug race 7");
+
                     /* no valid syntax */
-                    if (cnt[0]->conf.control_html_output)
+                    if (cnt[0]->conf.webcontrol_html_output)
                         response_client(client_socket, not_valid_syntax, NULL);
                     else
                         response_client(client_socket, not_valid_syntax_raw, NULL);
                     return 1;
                 }
                 X = 2;
-                warningkill = sscanf (pointer, "%c%10[-0-9]" ,&question, x_value);
+                warningkill = sscanf(pointer, "%c%10[-0-9]" , &question, x_value);
+
             } else if (!strcmp(command, "y")) {
                 pointer++;
                 length_uri--;
-                if (Y || !X || pan || tilt){
-                    motion_log(LOG_WARNING, 0, "httpd debug race 8");
+                if (Y || !X || pan || tilt) {
+                    MOTION_LOG(INF, TYPE_STREAM, NO_ERRNO, "%s: httpd debug race 8");
                     /* no valid syntax */
-                    if (cnt[0]->conf.control_html_output)
+                    if (cnt[0]->conf.webcontrol_html_output)
                         response_client(client_socket, not_valid_syntax, NULL);
                     else
                         response_client(client_socket, not_valid_syntax_raw, NULL);
                     return 1;
                 }
                 Y = 2;
-                warningkill = sscanf (pointer, "%c%10[-0-9]" ,&question, y_value);
+                warningkill = sscanf(pointer, "%c%10[-0-9]" , &question, y_value);
+
             } else {
-                motion_log(LOG_WARNING, 0, "httpd debug race 9");
+                MOTION_LOG(INF, TYPE_STREAM, NO_ERRNO, "%s: httpd debug race 9");
                 /* no valid syntax */
-                if (cnt[0]->conf.control_html_output)
+                if (cnt[0]->conf.webcontrol_html_output)
                     response_client(client_socket, not_valid_syntax, NULL);
                 else
                     response_client(client_socket, not_valid_syntax_raw, NULL);
@@ -1529,26 +1618,26 @@ static unsigned short int track(char *po
             /* Second value check */
 
             if ((warningkill < 2) && (question != '=')) {
-                motion_log(LOG_WARNING, 0, "httpd debug race 10");
+                MOTION_LOG(INF, TYPE_STREAM, NO_ERRNO, "%s: httpd debug race 10");
                 /* no valid syntax */
-                if (cnt[0]->conf.control_html_output)
+                if (cnt[0]->conf.webcontrol_html_output)
                     response_client(client_socket, not_valid_syntax, NULL);
                 else
                     response_client(client_socket, not_valid_syntax_raw, NULL);
                 return 1;
-            } else if (( question == '=') && ( warningkill == 1)) {
-                motion_log(LOG_WARNING, 0, "httpd debug race 11");
-                if (cnt[0]->conf.control_html_output)
+            } else if ((question == '=') && (warningkill == 1)) {
+                MOTION_LOG(INF, TYPE_STREAM, NO_ERRNO, "%s: httpd debug race 11");
+                if (cnt[0]->conf.webcontrol_html_output)
                     response_client(client_socket, error_value, NULL);
                 else
                     response_client(client_socket, error_value_raw, NULL);
                 return 1;
             }
-            
-            
+
+
             if (pan == 2) {
                 pointer = pointer + strlen(panvalue) + 1;
-                length_uri = length_uri - strlen(panvalue) - 1;    
+                length_uri = length_uri - strlen(panvalue) - 1;
             } else if (tilt == 2) {
                 pointer = pointer + strlen(tiltvalue) + 1;
                 length_uri = length_uri - strlen(tiltvalue) - 1;
@@ -1558,27 +1647,25 @@ static unsigned short int track(char *po
             } else {
                 pointer = pointer + strlen(y_value) + 1;
                 length_uri = length_uri - strlen(y_value) - 1;
-            }    
-            
-            
+            }
+
 
             if (length_uri != 0) {
-                motion_log(LOG_WARNING, 0, "httpd debug race 12");
-                if (cnt[0]->conf.control_html_output)
+                MOTION_LOG(INF, TYPE_STREAM, NO_ERRNO, "%s: httpd debug race 12");
+                if (cnt[0]->conf.webcontrol_html_output)
                     response_client(client_socket, error_value, NULL);
                 else
                     response_client(client_socket, error_value_raw, NULL);
                 return 1;
             }
 
-
             /* track set absolute ( x , y )*/
 
             if (X && Y) {
                 setcnt = cnt[thread];
                 cnt[thread]->moved = track_center(setcnt, setcnt->video_dev, 1, atoi(x_value), atoi(y_value));
                 if (cnt[thread]->moved) {
-                    if (cnt[0]->conf.control_html_output){
+                    if (cnt[0]->conf.webcontrol_html_output) {
                         send_template_ini_client(client_socket, ini_template);
                         sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br>"
                                      "<b>Thread %hu</b><br>\n"
@@ -1592,14 +1679,14 @@ static unsigned short int track(char *po
                         send_template_raw(client_socket, res);
                     }
                 } else {
-                    /*error in track action*/
-                    if (cnt[0]->conf.control_html_output) {
+                    /* error in track action */
+                    if (cnt[0]->conf.webcontrol_html_output) {
                         sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br>"
                                      "<b>Thread %hu</b>\n", thread, thread);
                         response_client(client_socket, track_error, res);
                     } else {
                         response_client(client_socket, track_error_raw, NULL);
-                    }    
+                    }
                 }
                 /* track set relative ( pan , tilt )*/
             } else {
@@ -1614,7 +1701,8 @@ static unsigned short int track(char *po
                 cent.y = 0;
                 cent.x = atoi(panvalue);
                 // Add the number of frame to skip for motion detection
-                cnt[thread]->moved = track_move(relativecnt, relativecnt->video_dev, &cent, &relativecnt->imgs, 1);
+                cnt[thread]->moved = track_move(relativecnt, relativecnt->video_dev,
+                                                &cent, &relativecnt->imgs, 1);
 
                 if (cnt[thread]->moved) {
                     /* move tilt */
@@ -1623,11 +1711,11 @@ static unsigned short int track(char *po
                     cent.height = relativecnt->imgs.height;
                     cent.x = 0;
                     cent.y = atoi(tiltvalue);
-                    SLEEP(1,0);
-                    cnt[thread]->moved = track_move(relativecnt, relativecnt->video_dev, &cent, &relativecnt->imgs, 1);
-
+                    // SLEEP(1,0);
+                    cnt[thread]->moved = track_move(relativecnt, relativecnt->video_dev,
+                                                    &cent, &relativecnt->imgs, 1);
                     if (cnt[thread]->moved) {
-                        if (cnt[0]->conf.control_html_output) {
+                        if (cnt[0]->conf.webcontrol_html_output) {
                             send_template_ini_client(client_socket, ini_template);
                             sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br>"
                                          "<b>Thread %hu</b><br>\n"
@@ -1641,28 +1729,30 @@ static unsigned short int track(char *po
                             send_template_raw(client_socket, res);
                         }
                         return 1;
+
                     } else {
-                        /*error in track tilt*/    
-                        if (cnt[0]->conf.control_html_output) {
+                        /* error in track tilt */
+                        if (cnt[0]->conf.webcontrol_html_output) {
                             sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br>"
                                          "<b>Thread %hu</b>\n", thread, thread);
                             response_client(client_socket, track_error, res);
                         } else {
                             response_client(client_socket, track_error_raw, NULL);
-                        }    
+                        }
                     }
                 }
 
-                /*error in track pan*/
-                if (cnt[0]->conf.control_html_output) {
-                    sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br><b>Thread %hu</b>\n", 
+                /* error in track pan */
+                if (cnt[0]->conf.webcontrol_html_output) {
+                    sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br><b>Thread %hu</b>\n",
                                  thread, thread);
                     response_client(client_socket, track_error, res);
-                } else
+                } else {
                     response_client(client_socket, track_error_raw, NULL);
+                }
             }
         } else if (length_uri == 0) {
-            if (cnt[0]->conf.control_html_output) {
+            if (cnt[0]->conf.webcontrol_html_output) {
                 send_template_ini_client(client_socket, ini_template);
                 sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br>\n<b>Thread %hu</b><br>\n"
                              "<form action='set'>\n"
@@ -1684,36 +1774,63 @@ static unsigned short int track(char *po
             }
         } else {
             /* error not valid command */
-            if (cnt[0]->conf.control_html_output)
+            if (cnt[0]->conf.webcontrol_html_output)
                 response_client(client_socket, not_found_response_valid_command, NULL);
             else
                 response_client(client_socket, not_found_response_valid_command_raw, NULL);
         }
-    } else if (!strcmp(command,"status")) {
+    } else if (!strcmp(command, "center")) {
         pointer = pointer+6;
         length_uri = length_uri-6;
         if (length_uri==0) {
-            if (cnt[0]->conf.control_html_output) {
+            struct context *setcnt;
+            setcnt = cnt[thread];
+            // 1000 is out of range for pwc
+            cnt[thread]->moved = track_center(setcnt, setcnt->video_dev, 1, 0, 0);
+
+            if (cnt[0]->conf.webcontrol_html_output) {
                 send_template_ini_client(client_socket, ini_template);
                 sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br>\n<b>Thread %hu</b>"
-                             "<br>track auto %s", thread, thread, 
+                              "<br>track set center", thread, thread);
+                send_template(client_socket, res);
+                send_template_end_client(client_socket);
+            } else {
+                sprintf(res, "Thread %hu\n track set center\nDone\n", thread);
+                send_template_ini_client_raw(client_socket);
+                send_template_raw(client_socket, res);
+            }
+        } else {
+            /* error not valid command */
+            if (cnt[0]->conf.webcontrol_html_output)
+                response_client(client_socket, not_found_response_valid_command, NULL);
+            else
+                response_client(client_socket, not_found_response_valid_command_raw, NULL);
+        }
+    } else if (!strcmp(command, "status")) {
+        pointer = pointer+6;
+        length_uri = length_uri-6;
+        if (length_uri==0) {
+            if (cnt[0]->conf.webcontrol_html_output) {
+                send_template_ini_client(client_socket, ini_template);
+                sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br>\n<b>Thread %hu</b>"
+                             "<br>track auto %s", thread, thread,
                              (cnt[thread]->track.active)? "enabled":"disabled");
                 send_template(client_socket, res);
                 send_template_end_client(client_socket);
             } else {
-                sprintf(res, "Thread %hu\n track auto %s\nDone\n",thread, 
+                sprintf(res, "Thread %hu\n track auto %s\nDone\n", thread,
                              (cnt[thread]->track.active)? "enabled":"disabled");
                 send_template_ini_client_raw(client_socket);
                 send_template_raw(client_socket, res);
             }
         } else {
             /* error not valid command */
-            if (cnt[0]->conf.control_html_output) 
+            if (cnt[0]->conf.webcontrol_html_output)
                 response_client(client_socket, not_found_response_valid_command, NULL);
             else
                 response_client(client_socket, not_found_response_valid_command_raw, NULL);
         }
-    } else if (!strcmp(command,"auto")) {
+    } else if (!strcmp(command, "auto")) {
         pointer = pointer + 4;
         length_uri = length_uri - 4;
         if ((question == '?') && (length_uri > 0)) {
@@ -1722,27 +1839,27 @@ static unsigned short int track(char *po
             length_uri--;
             /* value= */
 
-            warningkill = sscanf (pointer, "%255[a-z]%c",query,&question);
-            if ((question == '=') && (!strcmp(query,"value")) ) {
+            warningkill = sscanf(pointer, "%255[a-z]%c", query, &question);
+            if ((question == '=') && (!strcmp(query, "value"))) {
                 pointer = pointer + 6;
                 length_uri = length_uri - 6;
-                warningkill = sscanf (pointer, "%255[-0-9a-z]" , command);
-                if ((command!=NULL) && (strlen(command) > 0)) {
+                warningkill = sscanf(pointer, "%255[-0-9a-z]" , command);
+                if ((command != NULL) && (strlen(command) > 0)) {
                     struct context *autocnt;
 
-                    /* auto value=0|1|status*/
+                    /* auto value=0|1|status */
 
-                    if (!strcmp(command,"status")) {
-                        if (cnt[0]->conf.control_html_output) {
+                    if (!strcmp(command, "status")) {
+                        if (cnt[0]->conf.webcontrol_html_output) {
                             send_template_ini_client(client_socket, ini_template);
                             sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br>"
                                          "<b>Thread %hu</b><br>"
-                                     "track auto %s", thread, thread, 
+                                     "track auto %s", thread, thread,
                                     (cnt[thread]->track.active)? "enabled":"disabled");
                             send_template(client_socket, res);
                             send_template_end_client(client_socket);
                         } else {
-                            sprintf(res, "Thread %hu\n track auto %s\nDone\n", thread, 
+                            sprintf(res, "Thread %hu\n track auto %s\nDone\n", thread,
                                      (cnt[thread]->track.active)? "enabled":"disabled");
                             send_template_ini_client_raw(client_socket);
                             send_template_raw(client_socket, res);
@@ -1754,65 +1871,64 @@ static unsigned short int track(char *po
                         if (active > -1 && active < 2) {
                             autocnt = cnt[thread];
                             autocnt->track.active = active;
-                            if (cnt[0]->conf.control_html_output) {
+                            if (cnt[0]->conf.webcontrol_html_output) {
                                 send_template_ini_client(client_socket, ini_template);
                                 sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br>"
                                              "<b>Thread %hu</b>"
-                                              "<br>track auto %s<br>", thread, thread, 
+                                             "<br>track auto %s<br>", thread, thread,
                                              active ? "enabled":"disabled");
                                 send_template(client_socket, res);
                                 send_template_end_client(client_socket);
                             } else {
                                 send_template_ini_client_raw(client_socket);
-                                sprintf(res, "track auto %s\nDone\n",active ? "enabled":"disabled");
+                                sprintf(res, "track auto %s\nDone\n", active ? "enabled":"disabled");
                                 send_template_raw(client_socket, res);
                             }
                         } else {
-                            if (cnt[0]->conf.control_html_output)
+                            if (cnt[0]->conf.webcontrol_html_output)
                                 response_client(client_socket, not_found_response_valid_command, NULL);
                             else
                                 response_client(client_socket, not_found_response_valid_command_raw, NULL);
                         }
                     }
                 } else {
-                    if (cnt[0]->conf.control_html_output)
+                    if (cnt[0]->conf.webcontrol_html_output)
                         response_client(client_socket, not_found_response_valid_command, NULL);
                     else
                         response_client(client_socket, not_found_response_valid_command_raw, NULL);
                 }
             } else {
-                if (cnt[0]->conf.control_html_output)
+                if (cnt[0]->conf.webcontrol_html_output)
                     response_client(client_socket, not_found_response_valid_command, NULL);
                 else
                     response_client(client_socket, not_found_response_valid_command_raw, NULL);
             }
-        }
-        else if (length_uri == 0) {
+        } else if (length_uri == 0) {
 
-            if (cnt[0]->conf.control_html_output) {
+            if (cnt[0]->conf.webcontrol_html_output) {
                 send_template_ini_client(client_socket, ini_template);
                 sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br>\n<b>Thread %hu</b>\n"
                              "<form action='auto'><select name='value'>\n"
                              "<option value='0' %s>Disable</option><option value='1' %s>Enable</option>\n"
                              "<option value='status'>status</option>\n"
                              "</select><input type=submit value='set'>\n"
-                             "</form>\n",thread, thread, (cnt[thread]->track.active) ? "selected":"",
-                             (cnt[thread]->track.active) ? "selected":"" );
+                             "</form>\n", thread, thread, (cnt[thread]->track.active) ? "selected":"",
+                             (cnt[thread]->track.active) ? "selected":"");
                 send_template(client_socket, res);
                 send_template_end_client(client_socket);
             } else {
                 send_template_ini_client_raw(client_socket);
-                sprintf(res, "auto accepts only  0,1 or status as valid value\n");
+                sprintf(res, "auto accepts only 0,1 or status as valid value\n");
                 send_template_raw(client_socket, res);
             }
         } else {
-            if (cnt[0]->conf.control_html_output)
+            if (cnt[0]->conf.webcontrol_html_output)
                 response_client(client_socket, not_found_response_valid_command, NULL);
             else
                 response_client(client_socket, not_found_response_valid_command_raw, NULL);
         }
     } else {
-        if (cnt[0]->conf.control_html_output)
+        if (cnt[0]->conf.webcontrol_html_output)
             response_client(client_socket, not_found_response_valid_command, NULL);
         else
             response_client(client_socket, not_found_response_valid_command_raw, NULL);
@@ -1823,34 +1939,35 @@ static unsigned short int track(char *po
 
 
 
-/*
-    parses the action requested for motion ( config , action , detection , track ) and call
-    to action function if needed.
-
-    return 0 on action restart or quit 
-    return 1 on success    
-*/
-
-static unsigned short int handle_get(int client_socket, const char* url, void *userdata)
+/**
+ * handle_get
+ *      parses the action requested for motion ( config , action , detection , track )
+ *      and call to action function if needed.
+ *
+ * Returns
+ *      0 on action restart or quit
+ *      1 on success
+ */
+static unsigned int handle_get(int client_socket, const char *url, void *userdata)
 {
-    struct context **cnt=userdata;
+    struct context **cnt = userdata;
 
-    if (*url == '/' ) {
-        unsigned short int i = 0;
+    if (*url == '/') {
+        int i = 0;
         char *res=NULL;
-        res = malloc(2048);
+        res = mymalloc(2048);
 
         /* get the number of threads */
         while (cnt[++i]);
         /* ROOT_URI -> GET / */
-        if (! (strcmp (url, "/"))) {
-            unsigned short int y;
-            if (cnt[0]->conf.control_html_output) {
-                send_template_ini_client(client_socket,ini_template);
+        if (!strcmp(url, "/")) {
+            int y;
+            if (cnt[0]->conf.webcontrol_html_output) {
+                send_template_ini_client(client_socket, ini_template);
                 sprintf(res, "<b>Motion "VERSION" Running [%hu] Threads</b><br>\n"
                              "<a href='/0/'>All</a><br>\n", i);
                 send_template(client_socket, res);
-                for (y=1; y<i; y++) {
+                for (y = 1; y < i; y++) {
                     sprintf(res, "<a href='/%hu/'>Thread %hu</a><br>\n", y, y);
                     send_template(client_socket, res);
                 }
@@ -1859,16 +1976,15 @@ static unsigned short int handle_get(int
                 send_template_ini_client_raw(client_socket);
                 sprintf(res, "Motion "VERSION" Running [%hu] Threads\n0\n", i);
                 send_template_raw(client_socket, res);
-                for (y=1; y<i; y++) {
+                for (y = 1; y < i; y++) {
                     sprintf(res, "%hu\n", y);
                     send_template_raw(client_socket, res);
                 }
             }
-
         } else {
             char command[256] = {'\0'};
             char slash;
-            short int thread = -1;
+            int thread = -1;
             size_t length_uri = 0;
             char *pointer = (char *)url;
 
@@ -1876,7 +1992,7 @@ static unsigned short int handle_get(int
             /* Check for Thread number first -> GET /2 */
             pointer++;
             length_uri--;
-            warningkill = sscanf (pointer, "%hd%c", &thread, &slash);
+            warningkill = sscanf(pointer, "%d%c", &thread, &slash);
 
             if ((thread != -1) && (thread < i)) {
                 /* thread_number found */
@@ -1885,23 +2001,23 @@ static unsigned short int handle_get(int
                     length_uri = length_uri - 2;
                 } else {
                     pointer++;
-                    length_uri--;    
+                    length_uri--;
                 }
-                
+
                 if (slash == '/') {   /* slash found /2/ */
                     pointer++;
                     length_uri--;
-                } 
+                }
 
                 if (length_uri != 0) {
-                    warningkill = sscanf (pointer, "%255[a-z]%c" , command , &slash);
+                    warningkill = sscanf(pointer, "%255[a-z]%c" , command , &slash);
 
                     /* config */
-                    if (!strcmp(command,"config")) {
+                    if (!strcmp(command, "config")) {
                         pointer = pointer + 6;
                         length_uri = length_uri - 6;
                         if (length_uri == 0) {
-                            if (cnt[0]->conf.control_html_output) {
+                            if (cnt[0]->conf.webcontrol_html_output) {
                                 send_template_ini_client(client_socket, ini_template);
                                 sprintf(res, "<a href=/%hd/>&lt;&ndash; back</a><br><br>\n"
                                              "<b>Thread %hd</b><br>\n"
@@ -1918,24 +2034,23 @@ static unsigned short int handle_get(int
                                 send_template_raw(client_socket, res);
                             }
                         } else if ((slash == '/') && (length_uri >= 4)) {
-                            /*call config() */
+                            /* call config() */
                             pointer++;
                             length_uri--;
                             config(pointer, res, length_uri, thread, client_socket, cnt);
                         } else {
-                            if (cnt[0]->conf.control_html_output)
+                            if (cnt[0]->conf.webcontrol_html_output)
                                 response_client(client_socket, not_found_response_valid_command, NULL);
                             else
                                 response_client(client_socket, not_found_response_valid_command_raw, NULL);
                         }
-                    }
-                    /* action */
-                    else if (!strcmp(command,"action")) {
+
+                    } else if (!strcmp(command, "action")) { /* action */
                         pointer = pointer + 6;
                         length_uri = length_uri - 6;
                         /* call action() */
                         if (length_uri == 0) {
-                            if (cnt[0]->conf.control_html_output) {
+                            if (cnt[0]->conf.webcontrol_html_output) {
                                 send_template_ini_client(client_socket, ini_template);
                                 sprintf(res, "<a href=/%hd/>&lt;&ndash; back</a><br><br>\n"
                                              "<b>Thread %hd</b><br>\n"
@@ -1943,7 +2058,7 @@ static unsigned short int handle_get(int
                                              "<a href=/%hd/action/snapshot>snapshot</a><br>\n"
                                              "<a href=/%hd/action/restart>restart</a><br>\n"
                                              "<a href=/%hd/action/quit>quit</a><br>\n",
-                                             thread,thread,thread,thread,thread,thread);
+                                             thread, thread, thread, thread, thread, thread);
                                 send_template(client_socket, res);
                                 send_template_end_client(client_socket);
                             } else {
@@ -1952,7 +2067,7 @@ static unsigned short int handle_get(int
                                 send_template_raw(client_socket, res);
                             }
                         } else if ((slash == '/') && (length_uri > 4)) {
-                            unsigned short int ret = 1;
+                            unsigned int ret = 1;
                             pointer++;
                             length_uri--;
                             ret = action(pointer, res, length_uri, thread, client_socket, cnt);
@@ -1960,18 +2075,16 @@ static unsigned short int handle_get(int
                             return ret;
 
                         } else {
-                            if (cnt[0]->conf.control_html_output)
+                            if (cnt[0]->conf.webcontrol_html_output)
                                 response_client(client_socket, not_found_response_valid_command,NULL);
                             else
                                 response_client(client_socket, not_found_response_valid_command_raw,NULL);
                         }
-                    }
-                    /* detection */
-                    else if (!strcmp(command,"detection")) {
+                    } else if (!strcmp(command, "detection")) {  /* detection */
                         pointer = pointer + 9;
                         length_uri = length_uri - 9;
                         if (length_uri == 0) {
-                            if (cnt[0]->conf.control_html_output) {
+                            if (cnt[0]->conf.webcontrol_html_output) {
                                 send_template_ini_client(client_socket, ini_template);
                                 sprintf(res, "<a href=/%hd/>&lt;&ndash; back</a><br><br>\n"
                                              "<b>Thread %hd</b><br>\n"
@@ -1993,34 +2106,33 @@ static unsigned short int handle_get(int
                             /* call detection() */
                             detection(pointer, res, length_uri, thread, client_socket, cnt);
                         } else {
-                            if (cnt[0]->conf.control_html_output)
+                            if (cnt[0]->conf.webcontrol_html_output)
                                 response_client(client_socket, not_found_response_valid_command, NULL);
                             else
                                 response_client(client_socket, not_found_response_valid_command_raw, NULL);
                         }
-                    }
-                    /* track */
-                    else if (!strcmp(command,"track")) {
+                    } else if (!strcmp(command,"track")) { /* track */
                         pointer = pointer + 5;
                         length_uri = length_uri - 5;
                         if (length_uri == 0) {
-                            if (cnt[0]->conf.control_html_output) {
+                            if (cnt[0]->conf.webcontrol_html_output) {
                                 send_template_ini_client(client_socket, ini_template);
                                 sprintf(res, "<a href=/%hd/>&lt;&ndash; back</a><br><br>\n"
                                              "<b>Thread %hd</b><br>\n"
                                              "<a href=/%hd/track/set>track set pan/tilt</a><br>\n"
+                                             "<a href=/%hd/track/center>track center</a><br>\n"
                                              "<a href=/%hd/track/auto>track auto</a><br>\n"
                                              "<a href=/%hd/track/status>track status</a><br>\n",
-                                             thread, thread, thread, thread, thread);
+                                             thread, thread, thread, thread, thread, thread);
                                 send_template(client_socket, res);
                                 send_template_end_client(client_socket);
                             } else {
                                 send_template_ini_client_raw(client_socket);
-                                sprintf(res, "Thread %hd\nset pan/tilt\nauto\nstatus\n", thread);
+                                sprintf(res, "Thread %hd\nset pan/tilt\ncenter\nauto\nstatus\n", thread);
                                 send_template_raw(client_socket, res);
                             }
-                        }
-                        else if ((slash == '/') && (length_uri >= 4)) {
+
+                        } else if ((slash == '/') && (length_uri >= 4)) {
                             pointer++;
                             length_uri--;
                             /* call track() */
@@ -2028,33 +2140,33 @@ static unsigned short int handle_get(int
                                 track(pointer, res, length_uri, thread, client_socket, cnt);
                             } else {
                                 /* error track not enable */
-                                if (cnt[0]->conf.control_html_output) {
+                                if (cnt[0]->conf.webcontrol_html_output) {
                                     sprintf(res, "<a href=/%hd/>&lt;&ndash; back</a>\n", thread);
-                                    response_client(client_socket, not_track,res);
+                                    response_client(client_socket, not_track, res);
+                                } else {
+                                    response_client(client_socket, not_track_raw, NULL);
                                 }
-                                else
-                                    response_client(client_socket, not_track_raw,NULL);
                             }
                         } else {
-                            if (cnt[0]->conf.control_html_output) {
+                            if (cnt[0]->conf.webcontrol_html_output) {
                                 sprintf(res, "<a href=/%hd/>&lt;&ndash; back</a>\n", thread);
                                 response_client(client_socket, not_found_response_valid_command, res);
-                            }
-                            else
+                            } else {
                                 response_client(client_socket, not_found_response_valid_command_raw, NULL);
+                            }
                         }
                     } else {
-                        if (cnt[0]->conf.control_html_output) {
+                        if (cnt[0]->conf.webcontrol_html_output) {
                             sprintf(res, "<a href=/%hd/>&lt;&ndash; back</a>\n", thread);
                             response_client(client_socket, not_found_response_valid_command, res);
-                        }
-                        else
+                        } else {
                             response_client(client_socket, not_found_response_valid_command_raw, NULL);
+                        }
                     }
                 } else {
                     /* /thread_number/ requested */
-                    if (cnt[0]->conf.control_html_output) {
-                        send_template_ini_client(client_socket,ini_template);
+                    if (cnt[0]->conf.webcontrol_html_output) {
+                        send_template_ini_client(client_socket, ini_template);
                         sprintf(res, "<a href=/>&lt;&ndash; back</a><br><br>\n<b>Thread %hd</b><br>\n"
                                      "<a href='/%hd/config'>config</a><br>\n"
                                      "<a href='/%hd/action'>action</a><br>\n"
@@ -2070,7 +2182,7 @@ static unsigned short int handle_get(int
                     }
                 }
             } else {
-                if (cnt[0]->conf.control_html_output) {
+                if (cnt[0]->conf.webcontrol_html_output) {
                     sprintf(res, "<a href=/>&lt;&ndash; back</a>\n");
                     response_client(client_socket, not_found_response_valid, res);
                 } else {
@@ -2080,7 +2192,7 @@ static unsigned short int handle_get(int
         }
         free(res);
     } else {
-        if (cnt[0]->conf.control_html_output)
+        if (cnt[0]->conf.webcontrol_html_output)
             response_client(client_socket, not_found_response_template,NULL);
         else
             response_client(client_socket, not_found_response_template_raw,NULL);
@@ -2090,20 +2202,21 @@ static unsigned short int handle_get(int
 }
 
 
-/*
- -TODO-
- As usually web clients uses nonblocking connect/read
- read_client should handle nonblocking sockets.
- return 0 to quit or restart
- return 1 on success
-*/
-
-static unsigned short int read_client(int client_socket, void *userdata, char *auth)
+/**
+ * read_client
+ *      As usually web clients uses nonblocking connect/read
+ *      read_client should handle nonblocking sockets.
+ *
+ * Returns
+ *      0 to quit or restart
+ *      1 on success
+ */
+static unsigned int read_client(int client_socket, void *userdata, char *auth)
 {
-    unsigned short int alive = 1;
-    unsigned short int ret = 1;
+    unsigned int alive = 1;
+    unsigned int ret = 1;
     char buffer[1024] = {'\0'};
-    unsigned short int length = 1023;
+    ssize_t length = 1023;
     struct context **cnt = userdata;
 
     /* lock the mutex */
@@ -2112,10 +2225,10 @@ static unsigned short int read_client(in
     while (alive) {
         ssize_t nread = 0, readb = -1;
 
-        nread = read (client_socket, buffer, length);
+        nread = read_nonblock(client_socket, buffer, length);
 
         if (nread <= 0) {
-            motion_log(LOG_ERR, 1, "httpd First read");
+            MOTION_LOG(ERR, TYPE_STREAM, SHOW_ERRNO, "%s: motion-httpd First Read Error");
             pthread_mutex_unlock(&httpd_mutex);
             return 1;
         } else {
@@ -2126,89 +2239,107 @@ static unsigned short int read_client(in
 
             buffer[nread] = '\0';
 
-            warningkill = sscanf (buffer, "%9s %511s %9s", method, url, protocol);
+            warningkill = sscanf(buffer, "%9s %511s %9s", method, url, protocol);
+
+            if (warningkill != 3) {
+                if (cnt[0]->conf.webcontrol_html_output)
+                    warningkill = write_nonblock(client_socket, bad_request_response,
+                                  sizeof (bad_request_response));
+                else
+                    warningkill = write_nonblock(client_socket, bad_request_response_raw,
+                                  sizeof (bad_request_response_raw));
+                pthread_mutex_unlock(&httpd_mutex);
+                return 1;
+            }
 
-            while ((strstr (buffer, "\r\n\r\n") == NULL) && (readb != 0) && (nread < length)) {
-                readb = read (client_socket, buffer+nread, sizeof (buffer) - nread);
+            while ((strstr(buffer, "\r\n\r\n") == NULL) && (readb != 0) && (nread < length)) {
+                readb = read_nonblock(client_socket, buffer+nread, sizeof (buffer) - nread);
 
                 if (readb == -1) {
                     nread = -1;
                     break;
                 }
 
-                nread +=readb;
-                
+                nread += readb;
+
                 if (nread > length) {
-                    motion_log(LOG_ERR, 1, "httpd End buffer reached waiting for buffer ending");
+                    MOTION_LOG(WRN, TYPE_STREAM, SHOW_ERRNO, "%s: motion-httpd End buffer"
+                               " reached waiting for buffer ending");
                     break;
                 }
                 buffer[nread] = '\0';
             }
 
-            /* Make sure the last read didn't fail.  If it did, there's a
-            problem with the connection, so give up.  */
+            /*
+             * Make sure the last read didn't fail.  If it did, there's a
+             * problem with the connection, so give up.
+             */
             if (nread == -1) {
-                motion_log(LOG_ERR, 1, "httpd READ");
+                MOTION_LOG(ERR, TYPE_STREAM, SHOW_ERRNO, "%s: motion-httpd READ give up!");
                 pthread_mutex_unlock(&httpd_mutex);
                 return 1;
             }
             alive = 0;
 
             /* Check Protocol */
-            if (strcmp (protocol, "HTTP/1.0") && strcmp (protocol, "HTTP/1.1")) {
+            if (strcmp(protocol, "HTTP/1.0") && strcmp (protocol, "HTTP/1.1")) {
                 /* We don't understand this protocol.  Report a bad response.  */
-                if (cnt[0]->conf.control_html_output)
-                    warningkill = write (client_socket, bad_request_response, sizeof (bad_request_response));
+                if (cnt[0]->conf.webcontrol_html_output)
+                    warningkill = write_nonblock(client_socket, bad_request_response,
+                                  sizeof (bad_request_response));
                 else
-                    warningkill = write (client_socket, bad_request_response_raw, sizeof (bad_request_response_raw));
+                    warningkill = write_nonblock(client_socket, bad_request_response_raw,
+                                  sizeof (bad_request_response_raw));
 
                 pthread_mutex_unlock(&httpd_mutex);
                 return 1;
             }
 
             if (strcmp (method, "GET")) {
-                /* This server only implements the GET method.  If client
-                uses other method, report the failure.  */
+                /*
+                 * This server only implements the GET method.  If client
+                 * uses other method, report the failure.
+                 */
                 char response[1024];
-                if (cnt[0]->conf.control_html_output)
-                    snprintf (response, sizeof (response),bad_method_response_template, method);
+                if (cnt[0]->conf.webcontrol_html_output)
+                    snprintf(response, sizeof (response), bad_method_response_template, method);
                 else
-                    snprintf (response, sizeof (response),bad_method_response_template_raw, method);
-                warningkill = write (client_socket, response, strlen (response));
+                    snprintf(response, sizeof (response), bad_method_response_template_raw, method);
+                warningkill = write_nonblock(client_socket, response, strlen(response));
                 pthread_mutex_unlock(&httpd_mutex);
                 return 1;
             }
 
             if (auth != NULL) {
-                if ((authentication = strstr(buffer,"Basic")) ) {
+                if ((authentication = strstr(buffer,"Basic"))) {
                     char *end_auth = NULL;
                     authentication = authentication + 6;
 
-                    if ((end_auth  = strstr(authentication,"\r\n")) ) {
+                    if ((end_auth  = strstr(authentication,"\r\n"))) {
                         authentication[end_auth - authentication] = '\0';
                     } else {
                         char response[1024];
-                        snprintf (response, sizeof (response),request_auth_response_template, method);
-                        warningkill = write (client_socket, response, strlen (response));
+                        snprintf(response, sizeof (response), request_auth_response_template, method);
+                        warningkill = write_nonblock(client_socket, response, strlen(response));
                         pthread_mutex_unlock(&httpd_mutex);
                         return 1;
                     }
 
                     if (strcmp(auth, authentication)) {
-                        char response[1024]={'\0'};
+                        char response[1024] = {'\0'};
                         snprintf(response, sizeof (response), request_auth_response_template, method);
-                        warningkill = write (client_socket, response, strlen (response));
+                        warningkill = write_nonblock(client_socket, response, strlen(response));
                         pthread_mutex_unlock(&httpd_mutex);
                         return 1;
                     } else {
-                        ret = handle_get (client_socket, url, cnt);
+                        ret = handle_get(client_socket, url, cnt);
                         /* A valid auth request.  Process it.  */
                     }
                 } else {
                     // Request Authorization
-                    char response[1024]={'\0'};
-                    snprintf (response, sizeof (response),request_auth_response_template, method);
-                    warningkill = write (client_socket, response, strlen (response));
+                    char response[1024] = {'\0'};
+                    snprintf(response, sizeof (response), request_auth_response_template, method);
+                    warningkill = write_nonblock(client_socket, response, strlen(response));
                     pthread_mutex_unlock(&httpd_mutex);
                     return 1;
                 }
@@ -2224,126 +2355,171 @@ static unsigned short int read_client(in
 }
 
 
-/*
-   acceptnonblocking
-   
-   This function waits timeout seconds for listen socket.
-   Returns :
-       -1 if the timeout expires or on accept error.
-    curfd (client socket) on accept success.
-*/
-
+/**
+ * acceptnonblocking
+ *      waits timeout seconds for listen socket.
+ *
+ * Returns
+ *      -1 if the timeout expires or on accept error.
+ *      curfd (client socket) on accept success.
+ */
 static int acceptnonblocking(int serverfd, int timeout)
 {
     int curfd;
-    socklen_t namelen = sizeof(struct sockaddr_in);
-    struct sockaddr_in client;
+    struct sockaddr_storage client;
+    socklen_t namelen = sizeof(client);
+
     struct timeval tm;
     fd_set fds;
 
     tm.tv_sec = timeout; /* Timeout in seconds */
     tm.tv_usec = 0;
     FD_ZERO(&fds);
-    FD_SET(serverfd,&fds);
-    
-    if (select (serverfd + 1, &fds, NULL, NULL, &tm) > 0) {
-        if (FD_ISSET(serverfd, &fds)) { 
+    FD_SET(serverfd, &fds);
+
+    if (select(serverfd + 1, &fds, NULL, NULL, &tm) > 0) {
+        if (FD_ISSET(serverfd, &fds)) {
             if ((curfd = accept(serverfd, (struct sockaddr*)&client, &namelen)) > 0)
                 return curfd;
-        }    
+        }
     }
 
     return -1;
-} 
-
+}
 
-/*
-   Main function: Create the listening socket and waits client requests.
-*/
 
+/**
+ * httpd_run
+ *      Creates the listening socket and waits client requests.
+ */
 void httpd_run(struct context **cnt)
 {
-    int sd, client_socket_fd, val = 1;
-    unsigned short int client_sent_quit_message = 1, closehttpd = 0; 
-    struct sockaddr_in servAddr;
+    int sd = -1, client_socket_fd, val;
+    unsigned int client_sent_quit_message = 1, closehttpd = 0;
+    struct addrinfo hints, *res = NULL, *ressave = NULL;
     struct sigaction act;
     char *authentication = NULL;
+    char portnumber[10], hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];
 
     /* Initialize the mutex */
     pthread_mutex_init(&httpd_mutex, NULL);
 
-
     /* set signal handlers TO IGNORE */
-    memset(&act,0,sizeof(act));
+    memset(&act, 0, sizeof(act));
     sigemptyset(&act.sa_mask);
     act.sa_handler = SIG_IGN;
-    sigaction(SIGPIPE,&act,NULL);
-    sigaction(SIGCHLD,&act,NULL);
-
-    /* create socket */
-    sd = socket(AF_INET, SOCK_STREAM, 0);
+    sigaction(SIGPIPE, &act, NULL);
+    sigaction(SIGCHLD, &act, NULL);
 
-    if (sd < 0) {
-        motion_log(LOG_ERR, 1, "httpd socket");
+    memset(&hints, 0, sizeof(struct addrinfo));
+    /* AI_PASSIVE as we are going to listen */
+    hints.ai_flags = AI_PASSIVE;
+#if defined(BSD)
+    hints.ai_family = AF_INET;
+#else
+    if (!cnt[0]->conf.ipv6_enabled)
+        hints.ai_family = AF_INET;
+    else
+        hints.ai_family = AF_UNSPEC;
+#endif
+    hints.ai_socktype = SOCK_STREAM;
+
+    snprintf(portnumber, sizeof(portnumber), "%u", cnt[0]->conf.webcontrol_port);
+
+    val = getaddrinfo(cnt[0]->conf.webcontrol_localhost ? "localhost" : NULL, portnumber, &hints, &res);
+
+    /* check != 0 to allow FreeBSD compatibility */
+    if (val != 0) {
+        MOTION_LOG(CRT, TYPE_STREAM, SHOW_ERRNO, "%s: getaddrinfo() for httpd socket failed: %s",
+                   gai_strerror(val));
+        if (res)
+            freeaddrinfo(res);
         pthread_mutex_destroy(&httpd_mutex);
         return;
     }
 
-    /* bind server port */
-    servAddr.sin_family = AF_INET;
-    if (cnt[0]->conf.control_localhost)
-        servAddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
-    else
-        servAddr.sin_addr.s_addr = htonl(INADDR_ANY);
-    servAddr.sin_port = htons(cnt[0]->conf.control_port);
+    ressave = res;
 
-    /* Reuse Address */ 
-    
-    setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, &val, sizeof(int)) ;
+    while (res) {
+        /* create socket */
+        sd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
+
+        getnameinfo(res->ai_addr, res->ai_addrlen, hbuf,
+                    sizeof(hbuf), sbuf, sizeof(sbuf), NI_NUMERICHOST | NI_NUMERICSERV);
+
+        MOTION_LOG(NTC, TYPE_STREAM, NO_ERRNO, "%s: motion-httpd testing : %s addr: %s port: %s",
+                   res->ai_family == AF_INET ? "IPV4":"IPV6", hbuf, sbuf);
+
+        if (sd >= 0) {
+            val = 1;
+            /* Reuse Address */
+            setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, &val, sizeof(int));
+
+            if (bind(sd, res->ai_addr, res->ai_addrlen) == 0) {
+                MOTION_LOG(NTC, TYPE_STREAM, NO_ERRNO, "%s: motion-httpd Bound : %s addr: %s"
+                           " port: %s", res->ai_family == AF_INET ? "IPV4":"IPV6",
+                           hbuf, sbuf);
+                break;
+            }
+
+            MOTION_LOG(ERR, TYPE_STREAM, SHOW_ERRNO, "%s: motion-httpd failed bind() interface %s"
+                       " / port %s, retrying", hbuf, sbuf);
+            close(sd);
+            sd = -1;
+        }
+        MOTION_LOG(ERR, TYPE_STREAM, SHOW_ERRNO, "%s: motion-httpd socket failed interface %s"
+                   " / port %s, retrying", hbuf, sbuf);
+        res = res->ai_next;
+    }
 
-    if (bind(sd, (struct sockaddr *) &servAddr, sizeof(servAddr)) < 0) {
-        motion_log(LOG_ERR, 1, "httpd bind()");
-        close(sd);
+    freeaddrinfo(ressave);
+
+    if (sd < 0) {
+        MOTION_LOG(CRT, TYPE_STREAM, SHOW_ERRNO, "%s: motion-httpd ERROR bind()"
+                   " [interface %s port %s]", hbuf, sbuf);
         pthread_mutex_destroy(&httpd_mutex);
         return;
     }
 
-    if (listen(sd,5) == -1) {
-        motion_log(LOG_ERR, 1, "httpd listen()");
+    if (listen(sd, DEF_MAXWEBQUEUE) == -1) {
+        MOTION_LOG(CRT, TYPE_STREAM, SHOW_ERRNO, "%s: motion-httpd ERROR listen()"
+                   " [interface %s port %s]", hbuf, sbuf);
         close(sd);
         pthread_mutex_destroy(&httpd_mutex);
         return;
     }
 
-    motion_log(LOG_DEBUG, 0, "motion-httpd/"VERSION" running, accepting connections");
-    motion_log(LOG_DEBUG, 0, "motion-httpd: waiting for data on port TCP %d", cnt[0]->conf.control_port);
+    MOTION_LOG(NTC, TYPE_STREAM, NO_ERRNO, "%s: motion-httpd/"VERSION" running,"
+               " accepting connections");
+    MOTION_LOG(NTC, TYPE_STREAM, NO_ERRNO, "%s: motion-httpd: waiting for data"
+               " on %s port TCP %s", hbuf, sbuf);
 
-    if (cnt[0]->conf.control_authentication != NULL) {
+    if (cnt[0]->conf.webcontrol_authentication != NULL) {
         char *userpass = NULL;
-        size_t auth_size = strlen(cnt[0]->conf.control_authentication);
+        size_t auth_size = strlen(cnt[0]->conf.webcontrol_authentication);
 
         authentication = (char *) mymalloc(BASE64_LENGTH(auth_size) + 1);
         userpass = mymalloc(auth_size + 4);
         /* base64_encode can read 3 bytes after the end of the string, initialize it */
         memset(userpass, 0, auth_size + 4);
-        strcpy(userpass, cnt[0]->conf.control_authentication);
+        strcpy(userpass, cnt[0]->conf.webcontrol_authentication);
         base64_encode(userpass, authentication, auth_size);
         free(userpass);
     }
 
-    while ((client_sent_quit_message) && (!closehttpd)) { 
+    while ((client_sent_quit_message) && (!closehttpd)) {
 
         client_socket_fd = acceptnonblocking(sd, 1);
 
         if (client_socket_fd < 0) {
-            if ((!cnt[0]) || (cnt[0]->finish)){
-                motion_log(-1, 0, "httpd - Finishing");
+            if ((!cnt[0]) || (cnt[0]->finish)) {
+                MOTION_LOG(NTC, TYPE_STREAM, NO_ERRNO, "%s: motion-httpd - Finishing");
                 closehttpd = 1;
             }
         } else {
             /* Get the Client request */
-            client_sent_quit_message = read_client (client_socket_fd, cnt, authentication);
-            motion_log(-1, 0, "httpd - Read from client");
+            client_sent_quit_message = read_client(client_socket_fd, cnt, authentication);
+            MOTION_LOG(NTC, TYPE_STREAM, NO_ERRNO, "%s: motion-httpd - Read from client");
 
             /* Close Connection */
             if (client_socket_fd)
@@ -2352,17 +2528,21 @@ void httpd_run(struct context **cnt)
 
     }
 
-    if (authentication != NULL) 
+    if (authentication != NULL)
         free(authentication);
     close(sd);
-    motion_log(LOG_DEBUG, 0, "httpd Closing");
+    MOTION_LOG(NTC, TYPE_STREAM, NO_ERRNO, "%s: motion-httpd Closing");
     pthread_mutex_destroy(&httpd_mutex);
 }
 
+/**
+ * motion_web_control
+ *      Calls main function httpd_run
+ */
 void *motion_web_control(void *arg)
 {
-    struct context **cnt=arg;
+    struct context **cnt = arg;
     httpd_run(cnt);
-    motion_log(LOG_DEBUG, 0, "httpd thread exit");
+    MOTION_LOG(NTC, TYPE_STREAM, NO_ERRNO, "%s: motion-httpd thread exit");
     pthread_exit(NULL);
 }
--- motion-3.2.12.orig/webhttpd.h
+++ motion-3.2.12/webhttpd.h
@@ -1,11 +1,11 @@
 /*
  *      webhttpd.h
  *
- *      Include file for webhttpd.c 
+ *      Include file for webhttpd.c
  *
- *      Specs : http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionHttpAPI
+ *      Specs : http://www.lavrsen.dk/twiki/bin/view/Motion/MotionHttpAPI
  *
- *      Copyright 2004-2005 by Angel Carpintero  (ack@telefonica.net)
+ *      Copyright 2004-2005 by Angel Carpintero  (motiondevelop@gmail.com)
  *      This software is distributed under the GNU Public License Version 2
  *      See also the file 'COPYING'.
  *
@@ -15,9 +15,9 @@
 
 #include "motion.h"
 
-#define FOSWIKI_URL "http://www.lavrsen.dk/foswiki/bin/view/Motion/MotionGuideAlphabeticalOptionReferenceManual"
+#define TWIKI_URL "http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideAlphabeticalOptionReferenceManual"
 
-void * motion_web_control(void *arg); 
+void * motion_web_control(void *arg);
 void httpd_run(struct context **);
 
 #endif
